{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///D:/real-time-code-editor%20%282%29/node_modules/.pnpm/isomorphic-git%401.36.0/node_modules/isomorphic-git/index.cjs"],"sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nfunction _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }\n\nvar AsyncLock = _interopDefault(require('async-lock'));\nvar Hash = _interopDefault(require('sha.js/sha1.js'));\nvar crc32 = _interopDefault(require('crc-32'));\nvar pako = _interopDefault(require('pako'));\nvar pify = _interopDefault(require('pify'));\nvar ignore = _interopDefault(require('ignore'));\nvar cleanGitRef = _interopDefault(require('clean-git-ref'));\nvar diff3Merge = _interopDefault(require('diff3'));\n\n/**\n * @typedef {Object} GitProgressEvent\n * @property {string} phase\n * @property {number} loaded\n * @property {number} total\n */\n\n/**\n * @callback ProgressCallback\n * @param {GitProgressEvent} progress\n * @returns {void | Promise<void>}\n */\n\n/**\n * @typedef {Object} GitHttpRequest\n * @property {string} url - The URL to request\n * @property {string} [method='GET'] - The HTTP method to use\n * @property {Object<string, string>} [headers={}] - Headers to include in the HTTP request\n * @property {Object} [agent] - An HTTP or HTTPS agent that manages connections for the HTTP client (Node.js only)\n * @property {AsyncIterableIterator<Uint8Array>} [body] - An async iterator of Uint8Arrays that make up the body of POST requests\n * @property {ProgressCallback} [onProgress] - Reserved for future use (emitting `GitProgressEvent`s)\n * @property {object} [signal] - Reserved for future use (canceling a request)\n */\n\n/**\n * @typedef {Object} GitHttpResponse\n * @property {string} url - The final URL that was fetched after any redirects\n * @property {string} [method] - The HTTP method that was used\n * @property {Object<string, string>} [headers] - HTTP response headers\n * @property {AsyncIterableIterator<Uint8Array>} [body] - An async iterator of Uint8Arrays that make up the body of the response\n * @property {number} statusCode - The HTTP status code\n * @property {string} statusMessage - The HTTP status message\n */\n\n/**\n * @callback HttpFetch\n * @param {GitHttpRequest} request\n * @returns {Promise<GitHttpResponse>}\n */\n\n/**\n * @typedef {Object} HttpClient\n * @property {HttpFetch} request\n */\n\n/**\n * A git commit object.\n *\n * @typedef {Object} CommitObject\n * @property {string} message Commit message\n * @property {string} tree SHA-1 object id of corresponding file tree\n * @property {string[]} parent an array of zero or more SHA-1 object ids\n * @property {Object} author\n * @property {string} author.name The author's name\n * @property {string} author.email The author's email\n * @property {number} author.timestamp UTC Unix timestamp in seconds\n * @property {number} author.timezoneOffset Timezone difference from UTC in minutes\n * @property {Object} committer\n * @property {string} committer.name The committer's name\n * @property {string} committer.email The committer's email\n * @property {number} committer.timestamp UTC Unix timestamp in seconds\n * @property {number} committer.timezoneOffset Timezone difference from UTC in minutes\n * @property {string} [gpgsig] PGP signature (if present)\n */\n\n/**\n * An entry from a git tree object. Files are called 'blobs' and directories are called 'trees'.\n *\n * @typedef {Object} TreeEntry\n * @property {string} mode the 6 digit hexadecimal mode\n * @property {string} path the name of the file or directory\n * @property {string} oid the SHA-1 object id of the blob or tree\n * @property {'commit'|'blob'|'tree'} type the type of object\n */\n\n/**\n * A git tree object. Trees represent a directory snapshot.\n *\n * @typedef {TreeEntry[]} TreeObject\n */\n\n/**\n * A git annotated tag object.\n *\n * @typedef {Object} TagObject\n * @property {string} object SHA-1 object id of object being tagged\n * @property {'blob' | 'tree' | 'commit' | 'tag'} type the type of the object being tagged\n * @property {string} tag the tag name\n * @property {Object} tagger\n * @property {string} tagger.name the tagger's name\n * @property {string} tagger.email the tagger's email\n * @property {number} tagger.timestamp UTC Unix timestamp in seconds\n * @property {number} tagger.timezoneOffset timezone difference from UTC in minutes\n * @property {string} message tag message\n * @property {string} [gpgsig] PGP signature (if present)\n */\n\n/**\n * @typedef {Object} ReadCommitResult\n * @property {string} oid - SHA-1 object id of this commit\n * @property {CommitObject} commit - the parsed commit object\n * @property {string} payload - PGP signing payload\n */\n\n/**\n * @typedef {Object} ServerRef - This object has the following schema:\n * @property {string} ref - The name of the ref\n * @property {string} oid - The SHA-1 object id the ref points to\n * @property {string} [target] - The target ref pointed to by a symbolic ref\n * @property {string} [peeled] - If the oid is the SHA-1 object id of an annotated tag, this is the SHA-1 object id that the annotated tag points to\n */\n\n/**\n * @typedef Walker\n * @property {Symbol} Symbol('GitWalkerSymbol')\n */\n\n/**\n * Normalized subset of filesystem `stat` data:\n *\n * @typedef {Object} Stat\n * @property {number} ctimeSeconds\n * @property {number} ctimeNanoseconds\n * @property {number} mtimeSeconds\n * @property {number} mtimeNanoseconds\n * @property {number} dev\n * @property {number} ino\n * @property {number} mode\n * @property {number} uid\n * @property {number} gid\n * @property {number} size\n */\n\n/**\n * The `WalkerEntry` is an interface that abstracts computing many common tree / blob stats.\n *\n * @typedef {Object} WalkerEntry\n * @property {function(): Promise<'tree'|'blob'|'special'|'commit'>} type\n * @property {function(): Promise<number>} mode\n * @property {function(): Promise<string>} oid\n * @property {function(): Promise<Uint8Array|void>} content\n * @property {function(): Promise<Stat>} stat\n */\n\n/**\n * @typedef {Object} CallbackFsClient\n * @property {function} readFile - https://nodejs.org/api/fs.html#fs_fs_readfile_path_options_callback\n * @property {function} writeFile - https://nodejs.org/api/fs.html#fs_fs_writefile_file_data_options_callback\n * @property {function} unlink - https://nodejs.org/api/fs.html#fs_fs_unlink_path_callback\n * @property {function} readdir - https://nodejs.org/api/fs.html#fs_fs_readdir_path_options_callback\n * @property {function} mkdir - https://nodejs.org/api/fs.html#fs_fs_mkdir_path_mode_callback\n * @property {function} rmdir - https://nodejs.org/api/fs.html#fs_fs_rmdir_path_callback\n * @property {function} stat - https://nodejs.org/api/fs.html#fs_fs_stat_path_options_callback\n * @property {function} lstat - https://nodejs.org/api/fs.html#fs_fs_lstat_path_options_callback\n * @property {function} [readlink] - https://nodejs.org/api/fs.html#fs_fs_readlink_path_options_callback\n * @property {function} [symlink] - https://nodejs.org/api/fs.html#fs_fs_symlink_target_path_type_callback\n * @property {function} [chmod] - https://nodejs.org/api/fs.html#fs_fs_chmod_path_mode_callback\n */\n\n/**\n * @typedef {Object} PromiseFsClient\n * @property {Object} promises\n * @property {function} promises.readFile - https://nodejs.org/api/fs.html#fs_fspromises_readfile_path_options\n * @property {function} promises.writeFile - https://nodejs.org/api/fs.html#fs_fspromises_writefile_file_data_options\n * @property {function} promises.unlink - https://nodejs.org/api/fs.html#fs_fspromises_unlink_path\n * @property {function} promises.readdir - https://nodejs.org/api/fs.html#fs_fspromises_readdir_path_options\n * @property {function} promises.mkdir - https://nodejs.org/api/fs.html#fs_fspromises_mkdir_path_options\n * @property {function} promises.rmdir - https://nodejs.org/api/fs.html#fs_fspromises_rmdir_path\n * @property {function} promises.stat - https://nodejs.org/api/fs.html#fs_fspromises_stat_path_options\n * @property {function} promises.lstat - https://nodejs.org/api/fs.html#fs_fspromises_lstat_path_options\n * @property {function} [promises.readlink] - https://nodejs.org/api/fs.html#fs_fspromises_readlink_path_options\n * @property {function} [promises.symlink] - https://nodejs.org/api/fs.html#fs_fspromises_symlink_target_path_type\n * @property {function} [promises.chmod] - https://nodejs.org/api/fs.html#fs_fspromises_chmod_path_mode\n */\n\n/**\n * @typedef {CallbackFsClient | PromiseFsClient} FsClient\n */\n\n/**\n * @callback MessageCallback\n * @param {string} message\n * @returns {void | Promise<void>}\n */\n\n/**\n * @typedef {Object} GitAuth\n * @property {string} [username]\n * @property {string} [password]\n * @property {Object<string, string>} [headers]\n * @property {boolean} [cancel] Tells git to throw a `UserCanceledError` (instead of an `HttpError`).\n */\n\n/**\n * @callback AuthCallback\n * @param {string} url\n * @param {GitAuth} auth Might have some values if the URL itself originally contained a username or password.\n * @returns {GitAuth | void | Promise<GitAuth | void>}\n */\n\n/**\n * @callback AuthFailureCallback\n * @param {string} url\n * @param {GitAuth} auth The credentials that failed\n * @returns {GitAuth | void | Promise<GitAuth | void>}\n */\n\n/**\n * @callback AuthSuccessCallback\n * @param {string} url\n * @param {GitAuth} auth\n * @returns {void | Promise<void>}\n */\n\n/**\n * @typedef {Object} SignParams\n * @property {string} payload - a plaintext message\n * @property {string} secretKey - an 'ASCII armor' encoded PGP key (technically can actually contain _multiple_ keys)\n */\n\n/**\n * @callback SignCallback\n * @param {SignParams} args\n * @return {{signature: string} | Promise<{signature: string}>} - an 'ASCII armor' encoded \"detached\" signature\n */\n\n/**\n * @typedef {Object} MergeDriverParams\n * @property {Array<string>} branches\n * @property {Array<string>} contents\n * @property {string} path\n */\n\n/**\n * @callback MergeDriverCallback\n * @param {MergeDriverParams} args\n * @return {{cleanMerge: boolean, mergedText: string} | Promise<{cleanMerge: boolean, mergedText: string}>}\n */\n\n/**\n * @callback WalkerMap\n * @param {string} filename\n * @param {WalkerEntry[]} entries\n * @returns {Promise<any>}\n */\n\n/**\n * @callback WalkerReduce\n * @param {any} parent\n * @param {any[]} children\n * @returns {Promise<any>}\n */\n\n/**\n * @callback WalkerIterateCallback\n * @param {WalkerEntry[]} entries\n * @returns {Promise<any[]>}\n */\n\n/**\n * @callback WalkerIterate\n * @param {WalkerIterateCallback} walk\n * @param {IterableIterator<WalkerEntry[]>} children\n * @returns {Promise<any[]>}\n */\n\n/**\n * @typedef {Object} RefUpdateStatus\n * @property {boolean} ok\n * @property {string} error\n */\n\n/**\n * @typedef {Object} PushResult\n * @property {boolean} ok\n * @property {?string} error\n * @property {Object<string, RefUpdateStatus>} refs\n * @property {Object<string, string>} [headers]\n */\n\n/**\n * @typedef {0|1} HeadStatus\n */\n\n/**\n * @typedef {0|1|2} WorkdirStatus\n */\n\n/**\n * @typedef {0|1|2|3} StageStatus\n */\n\n/**\n * @typedef {[string, HeadStatus, WorkdirStatus, StageStatus]} StatusRow\n */\n\n/**\n * @typedef {'push' | 'pop' | 'apply' | 'drop' | 'list' | 'clear'} StashOp the type of stash ops\n */\n\n/**\n * @typedef {'equal' | 'modify' | 'add' | 'remove' | 'unknown'} StashChangeType - when compare WORDIR to HEAD, 'remove' could mean 'untracked'\n * @typedef {Object} ClientRef\n * @property {string} ref The name of the ref\n * @property {string} oid The SHA-1 object id the ref points to\n */\n\n/**\n * @typedef {Object} PrePushParams\n * @property {string} remote The expanded name of target remote\n * @property {string} url The URL address of target remote\n * @property {ClientRef} localRef The ref which the client wants to push to the remote\n * @property {ClientRef} remoteRef The ref which is known by the remote\n */\n\n/**\n * @callback PrePushCallback\n * @param {PrePushParams} args\n * @returns {boolean | Promise<boolean>} Returns false if push must be cancelled\n */\n\n/**\n * @typedef {Object} PostCheckoutParams\n * @property {string} previousHead The SHA-1 object id of HEAD before checkout\n * @property {string} newHead The SHA-1 object id of HEAD after checkout\n * @property {'branch' | 'file'} type flag determining whether a branch or a set of files was checked\n */\n\n/**\n * @callback PostCheckoutCallback\n * @param {PostCheckoutParams} args\n * @returns {void | Promise<void>}\n */\n\nclass BaseError extends Error {\n  constructor(message) {\n    super(message);\n    // Setting this here allows TS to infer that all git errors have a `caller` property and\n    // that its type is string.\n    this.caller = '';\n  }\n\n  toJSON() {\n    // Error objects aren't normally serializable. So we do something about that.\n    return {\n      code: this.code,\n      data: this.data,\n      caller: this.caller,\n      message: this.message,\n      stack: this.stack,\n    }\n  }\n\n  fromJSON(json) {\n    const e = new BaseError(json.message);\n    e.code = json.code;\n    e.data = json.data;\n    e.caller = json.caller;\n    e.stack = json.stack;\n    return e\n  }\n\n  get isIsomorphicGitError() {\n    return true\n  }\n}\n\nclass UnmergedPathsError extends BaseError {\n  /**\n   * @param {Array<string>} filepaths\n   */\n  constructor(filepaths) {\n    super(\n      `Modifying the index is not possible because you have unmerged files: ${filepaths.toString}. Fix them up in the work tree, and then use 'git add/rm as appropriate to mark resolution and make a commit.`\n    );\n    this.code = this.name = UnmergedPathsError.code;\n    this.data = { filepaths };\n  }\n}\n/** @type {'UnmergedPathsError'} */\nUnmergedPathsError.code = 'UnmergedPathsError';\n\nclass InternalError extends BaseError {\n  /**\n   * @param {string} message\n   */\n  constructor(message) {\n    super(\n      `An internal error caused this command to fail.\\n\\nIf you're not a developer, report the bug to the developers of the application you're using. If this is a bug in isomorphic-git then you should create a proper bug yourselves. The bug should include a minimal reproduction and details about the version and environment.\\n\\nPlease file a bug report at https://github.com/isomorphic-git/isomorphic-git/issues with this error message: ${message}`\n    );\n    this.code = this.name = InternalError.code;\n    this.data = { message };\n  }\n}\n/** @type {'InternalError'} */\nInternalError.code = 'InternalError';\n\nclass UnsafeFilepathError extends BaseError {\n  /**\n   * @param {string} filepath\n   */\n  constructor(filepath) {\n    super(`The filepath \"${filepath}\" contains unsafe character sequences`);\n    this.code = this.name = UnsafeFilepathError.code;\n    this.data = { filepath };\n  }\n}\n/** @type {'UnsafeFilepathError'} */\nUnsafeFilepathError.code = 'UnsafeFilepathError';\n\n// Modeled after https://github.com/tjfontaine/node-buffercursor\n// but with the goal of being much lighter weight.\nclass BufferCursor {\n  constructor(buffer) {\n    this.buffer = buffer;\n    this._start = 0;\n  }\n\n  eof() {\n    return this._start >= this.buffer.length\n  }\n\n  tell() {\n    return this._start\n  }\n\n  seek(n) {\n    this._start = n;\n  }\n\n  slice(n) {\n    const r = this.buffer.slice(this._start, this._start + n);\n    this._start += n;\n    return r\n  }\n\n  toString(enc, length) {\n    const r = this.buffer.toString(enc, this._start, this._start + length);\n    this._start += length;\n    return r\n  }\n\n  write(value, length, enc) {\n    const r = this.buffer.write(value, this._start, length, enc);\n    this._start += length;\n    return r\n  }\n\n  copy(source, start, end) {\n    const r = source.copy(this.buffer, this._start, start, end);\n    this._start += r;\n    return r\n  }\n\n  readUInt8() {\n    const r = this.buffer.readUInt8(this._start);\n    this._start += 1;\n    return r\n  }\n\n  writeUInt8(value) {\n    const r = this.buffer.writeUInt8(value, this._start);\n    this._start += 1;\n    return r\n  }\n\n  readUInt16BE() {\n    const r = this.buffer.readUInt16BE(this._start);\n    this._start += 2;\n    return r\n  }\n\n  writeUInt16BE(value) {\n    const r = this.buffer.writeUInt16BE(value, this._start);\n    this._start += 2;\n    return r\n  }\n\n  readUInt32BE() {\n    const r = this.buffer.readUInt32BE(this._start);\n    this._start += 4;\n    return r\n  }\n\n  writeUInt32BE(value) {\n    const r = this.buffer.writeUInt32BE(value, this._start);\n    this._start += 4;\n    return r\n  }\n}\n\nfunction compareStrings(a, b) {\n  // https://stackoverflow.com/a/40355107/2168416\n  return -(a < b) || +(a > b)\n}\n\nfunction comparePath(a, b) {\n  // https://stackoverflow.com/a/40355107/2168416\n  return compareStrings(a.path, b.path)\n}\n\n/**\n * From https://github.com/git/git/blob/master/Documentation/technical/index-format.txt\n *\n * 32-bit mode, split into (high to low bits)\n *\n *  4-bit object type\n *    valid values in binary are 1000 (regular file), 1010 (symbolic link)\n *    and 1110 (gitlink)\n *\n *  3-bit unused\n *\n *  9-bit unix permission. Only 0755 and 0644 are valid for regular files.\n *  Symbolic links and gitlinks have value 0 in this field.\n */\nfunction normalizeMode(mode) {\n  // Note: BrowserFS will use -1 for \"unknown\"\n  // I need to make it non-negative for these bitshifts to work.\n  let type = mode > 0 ? mode >> 12 : 0;\n  // If it isn't valid, assume it as a \"regular file\"\n  // 0100 = directory\n  // 1000 = regular file\n  // 1010 = symlink\n  // 1110 = gitlink\n  if (\n    type !== 0b0100 &&\n    type !== 0b1000 &&\n    type !== 0b1010 &&\n    type !== 0b1110\n  ) {\n    type = 0b1000;\n  }\n  let permissions = mode & 0o777;\n  // Is the file executable? then 755. Else 644.\n  if (permissions & 0b001001001) {\n    permissions = 0o755;\n  } else {\n    permissions = 0o644;\n  }\n  // If it's not a regular file, scrub all permissions\n  if (type !== 0b1000) permissions = 0;\n  return (type << 12) + permissions\n}\n\nconst MAX_UINT32 = 2 ** 32;\n\nfunction SecondsNanoseconds(\n  givenSeconds,\n  givenNanoseconds,\n  milliseconds,\n  date\n) {\n  if (givenSeconds !== undefined && givenNanoseconds !== undefined) {\n    return [givenSeconds, givenNanoseconds]\n  }\n  if (milliseconds === undefined) {\n    milliseconds = date.valueOf();\n  }\n  const seconds = Math.floor(milliseconds / 1000);\n  const nanoseconds = (milliseconds - seconds * 1000) * 1000000;\n  return [seconds, nanoseconds]\n}\n\nfunction normalizeStats(e) {\n  const [ctimeSeconds, ctimeNanoseconds] = SecondsNanoseconds(\n    e.ctimeSeconds,\n    e.ctimeNanoseconds,\n    e.ctimeMs,\n    e.ctime\n  );\n  const [mtimeSeconds, mtimeNanoseconds] = SecondsNanoseconds(\n    e.mtimeSeconds,\n    e.mtimeNanoseconds,\n    e.mtimeMs,\n    e.mtime\n  );\n\n  return {\n    ctimeSeconds: ctimeSeconds % MAX_UINT32,\n    ctimeNanoseconds: ctimeNanoseconds % MAX_UINT32,\n    mtimeSeconds: mtimeSeconds % MAX_UINT32,\n    mtimeNanoseconds: mtimeNanoseconds % MAX_UINT32,\n    dev: e.dev % MAX_UINT32,\n    ino: e.ino % MAX_UINT32,\n    mode: normalizeMode(e.mode % MAX_UINT32),\n    uid: e.uid % MAX_UINT32,\n    gid: e.gid % MAX_UINT32,\n    // size of -1 happens over a BrowserFS HTTP Backend that doesn't serve Content-Length headers\n    // (like the Karma webserver) because BrowserFS HTTP Backend uses HTTP HEAD requests to do fs.stat\n    size: e.size > -1 ? e.size % MAX_UINT32 : 0,\n  }\n}\n\nfunction toHex(buffer) {\n  let hex = '';\n  for (const byte of new Uint8Array(buffer)) {\n    if (byte < 16) hex += '0';\n    hex += byte.toString(16);\n  }\n  return hex\n}\n\n/* eslint-env node, browser */\n\nlet supportsSubtleSHA1 = null;\n\nasync function shasum(buffer) {\n  if (supportsSubtleSHA1 === null) {\n    supportsSubtleSHA1 = await testSubtleSHA1();\n  }\n  return supportsSubtleSHA1 ? subtleSHA1(buffer) : shasumSync(buffer)\n}\n\n// This is modeled after @dominictarr's \"shasum\" module,\n// but without the 'json-stable-stringify' dependency and\n// extra type-casting features.\nfunction shasumSync(buffer) {\n  return new Hash().update(buffer).digest('hex')\n}\n\nasync function subtleSHA1(buffer) {\n  const hash = await crypto.subtle.digest('SHA-1', buffer);\n  return toHex(hash)\n}\n\nasync function testSubtleSHA1() {\n  // I'm using a rather crude method of progressive enhancement, because\n  // some browsers that have crypto.subtle.digest don't actually implement SHA-1.\n  try {\n    const hash = await subtleSHA1(new Uint8Array([]));\n    return hash === 'da39a3ee5e6b4b0d3255bfef95601890afd80709'\n  } catch (_) {\n    // no bother\n  }\n  return false\n}\n\n// Extract 1-bit assume-valid, 1-bit extended flag, 2-bit merge state flag, 12-bit path length flag\nfunction parseCacheEntryFlags(bits) {\n  return {\n    assumeValid: Boolean(bits & 0b1000000000000000),\n    extended: Boolean(bits & 0b0100000000000000),\n    stage: (bits & 0b0011000000000000) >> 12,\n    nameLength: bits & 0b0000111111111111,\n  }\n}\n\nfunction renderCacheEntryFlags(entry) {\n  const flags = entry.flags;\n  // 1-bit extended flag (must be zero in version 2)\n  flags.extended = false;\n  // 12-bit name length if the length is less than 0xFFF; otherwise 0xFFF\n  // is stored in this field.\n  flags.nameLength = Math.min(Buffer.from(entry.path).length, 0xfff);\n  return (\n    (flags.assumeValid ? 0b1000000000000000 : 0) +\n    (flags.extended ? 0b0100000000000000 : 0) +\n    ((flags.stage & 0b11) << 12) +\n    (flags.nameLength & 0b111111111111)\n  )\n}\n\nclass GitIndex {\n  /*::\n   _entries: Map<string, CacheEntry>\n   _dirty: boolean // Used to determine if index needs to be saved to filesystem\n   */\n  constructor(entries, unmergedPaths) {\n    this._dirty = false;\n    this._unmergedPaths = unmergedPaths || new Set();\n    this._entries = entries || new Map();\n  }\n\n  _addEntry(entry) {\n    if (entry.flags.stage === 0) {\n      entry.stages = [entry];\n      this._entries.set(entry.path, entry);\n      this._unmergedPaths.delete(entry.path);\n    } else {\n      let existingEntry = this._entries.get(entry.path);\n      if (!existingEntry) {\n        this._entries.set(entry.path, entry);\n        existingEntry = entry;\n      }\n      existingEntry.stages[entry.flags.stage] = entry;\n      this._unmergedPaths.add(entry.path);\n    }\n  }\n\n  static async from(buffer) {\n    if (Buffer.isBuffer(buffer)) {\n      return GitIndex.fromBuffer(buffer)\n    } else if (buffer === null) {\n      return new GitIndex(null)\n    } else {\n      throw new InternalError('invalid type passed to GitIndex.from')\n    }\n  }\n\n  static async fromBuffer(buffer) {\n    if (buffer.length === 0) {\n      throw new InternalError('Index file is empty (.git/index)')\n    }\n\n    const index = new GitIndex();\n    const reader = new BufferCursor(buffer);\n    const magic = reader.toString('utf8', 4);\n    if (magic !== 'DIRC') {\n      throw new InternalError(`Invalid dircache magic file number: ${magic}`)\n    }\n\n    // Verify shasum after we ensured that the file has a magic number\n    const shaComputed = await shasum(buffer.slice(0, -20));\n    const shaClaimed = buffer.slice(-20).toString('hex');\n    if (shaClaimed !== shaComputed) {\n      throw new InternalError(\n        `Invalid checksum in GitIndex buffer: expected ${shaClaimed} but saw ${shaComputed}`\n      )\n    }\n\n    const version = reader.readUInt32BE();\n    if (version !== 2) {\n      throw new InternalError(`Unsupported dircache version: ${version}`)\n    }\n    const numEntries = reader.readUInt32BE();\n    let i = 0;\n    while (!reader.eof() && i < numEntries) {\n      const entry = {};\n      entry.ctimeSeconds = reader.readUInt32BE();\n      entry.ctimeNanoseconds = reader.readUInt32BE();\n      entry.mtimeSeconds = reader.readUInt32BE();\n      entry.mtimeNanoseconds = reader.readUInt32BE();\n      entry.dev = reader.readUInt32BE();\n      entry.ino = reader.readUInt32BE();\n      entry.mode = reader.readUInt32BE();\n      entry.uid = reader.readUInt32BE();\n      entry.gid = reader.readUInt32BE();\n      entry.size = reader.readUInt32BE();\n      entry.oid = reader.slice(20).toString('hex');\n      const flags = reader.readUInt16BE();\n      entry.flags = parseCacheEntryFlags(flags);\n      // TODO: handle if (version === 3 && entry.flags.extended)\n      const pathlength = buffer.indexOf(0, reader.tell() + 1) - reader.tell();\n      if (pathlength < 1) {\n        throw new InternalError(`Got a path length of: ${pathlength}`)\n      }\n      // TODO: handle pathnames larger than 12 bits\n      entry.path = reader.toString('utf8', pathlength);\n\n      // Prevent malicious paths like \"..\\foo\"\n      if (entry.path.includes('..\\\\') || entry.path.includes('../')) {\n        throw new UnsafeFilepathError(entry.path)\n      }\n\n      // The next bit is awkward. We expect 1 to 8 null characters\n      // such that the total size of the entry is a multiple of 8 bits.\n      // (Hence subtract 12 bytes for the header.)\n      let padding = 8 - ((reader.tell() - 12) % 8);\n      if (padding === 0) padding = 8;\n      while (padding--) {\n        const tmp = reader.readUInt8();\n        if (tmp !== 0) {\n          throw new InternalError(\n            `Expected 1-8 null characters but got '${tmp}' after ${entry.path}`\n          )\n        } else if (reader.eof()) {\n          throw new InternalError('Unexpected end of file')\n        }\n      }\n      // end of awkward part\n      entry.stages = [];\n\n      index._addEntry(entry);\n\n      i++;\n    }\n    return index\n  }\n\n  get unmergedPaths() {\n    return [...this._unmergedPaths]\n  }\n\n  get entries() {\n    return [...this._entries.values()].sort(comparePath)\n  }\n\n  get entriesMap() {\n    return this._entries\n  }\n\n  get entriesFlat() {\n    return [...this.entries].flatMap(entry => {\n      return entry.stages.length > 1 ? entry.stages.filter(x => x) : entry\n    })\n  }\n\n  *[Symbol.iterator]() {\n    for (const entry of this.entries) {\n      yield entry;\n    }\n  }\n\n  insert({ filepath, stats, oid, stage = 0 }) {\n    if (!stats) {\n      stats = {\n        ctimeSeconds: 0,\n        ctimeNanoseconds: 0,\n        mtimeSeconds: 0,\n        mtimeNanoseconds: 0,\n        dev: 0,\n        ino: 0,\n        mode: 0,\n        uid: 0,\n        gid: 0,\n        size: 0,\n      };\n    }\n    stats = normalizeStats(stats);\n    const bfilepath = Buffer.from(filepath);\n    const entry = {\n      ctimeSeconds: stats.ctimeSeconds,\n      ctimeNanoseconds: stats.ctimeNanoseconds,\n      mtimeSeconds: stats.mtimeSeconds,\n      mtimeNanoseconds: stats.mtimeNanoseconds,\n      dev: stats.dev,\n      ino: stats.ino,\n      // We provide a fallback value for `mode` here because not all fs\n      // implementations assign it, but we use it in GitTree.\n      // '100644' is for a \"regular non-executable file\"\n      mode: stats.mode || 0o100644,\n      uid: stats.uid,\n      gid: stats.gid,\n      size: stats.size,\n      path: filepath,\n      oid,\n      flags: {\n        assumeValid: false,\n        extended: false,\n        stage,\n        nameLength: bfilepath.length < 0xfff ? bfilepath.length : 0xfff,\n      },\n      stages: [],\n    };\n\n    this._addEntry(entry);\n\n    this._dirty = true;\n  }\n\n  delete({ filepath }) {\n    if (this._entries.has(filepath)) {\n      this._entries.delete(filepath);\n    } else {\n      for (const key of this._entries.keys()) {\n        if (key.startsWith(filepath + '/')) {\n          this._entries.delete(key);\n        }\n      }\n    }\n\n    if (this._unmergedPaths.has(filepath)) {\n      this._unmergedPaths.delete(filepath);\n    }\n    this._dirty = true;\n  }\n\n  clear() {\n    this._entries.clear();\n    this._dirty = true;\n  }\n\n  has({ filepath }) {\n    return this._entries.has(filepath)\n  }\n\n  render() {\n    return this.entries\n      .map(entry => `${entry.mode.toString(8)} ${entry.oid}    ${entry.path}`)\n      .join('\\n')\n  }\n\n  static async _entryToBuffer(entry) {\n    const bpath = Buffer.from(entry.path);\n    // the fixed length + the filename + at least one null char => align by 8\n    const length = Math.ceil((62 + bpath.length + 1) / 8) * 8;\n    const written = Buffer.alloc(length);\n    const writer = new BufferCursor(written);\n    const stat = normalizeStats(entry);\n    writer.writeUInt32BE(stat.ctimeSeconds);\n    writer.writeUInt32BE(stat.ctimeNanoseconds);\n    writer.writeUInt32BE(stat.mtimeSeconds);\n    writer.writeUInt32BE(stat.mtimeNanoseconds);\n    writer.writeUInt32BE(stat.dev);\n    writer.writeUInt32BE(stat.ino);\n    writer.writeUInt32BE(stat.mode);\n    writer.writeUInt32BE(stat.uid);\n    writer.writeUInt32BE(stat.gid);\n    writer.writeUInt32BE(stat.size);\n    writer.write(entry.oid, 20, 'hex');\n    writer.writeUInt16BE(renderCacheEntryFlags(entry));\n    writer.write(entry.path, bpath.length, 'utf8');\n    return written\n  }\n\n  async toObject() {\n    const header = Buffer.alloc(12);\n    const writer = new BufferCursor(header);\n    writer.write('DIRC', 4, 'utf8');\n    writer.writeUInt32BE(2);\n    writer.writeUInt32BE(this.entriesFlat.length);\n\n    let entryBuffers = [];\n    for (const entry of this.entries) {\n      entryBuffers.push(GitIndex._entryToBuffer(entry));\n      if (entry.stages.length > 1) {\n        for (const stage of entry.stages) {\n          if (stage && stage !== entry) {\n            entryBuffers.push(GitIndex._entryToBuffer(stage));\n          }\n        }\n      }\n    }\n    entryBuffers = await Promise.all(entryBuffers);\n\n    const body = Buffer.concat(entryBuffers);\n    const main = Buffer.concat([header, body]);\n    const sum = await shasum(main);\n    return Buffer.concat([main, Buffer.from(sum, 'hex')])\n  }\n}\n\nfunction compareStats(entry, stats, filemode = true, trustino = true) {\n  // Comparison based on the description in Paragraph 4 of\n  // https://www.kernel.org/pub/software/scm/git/docs/technical/racy-git.txt\n  const e = normalizeStats(entry);\n  const s = normalizeStats(stats);\n  const staleness =\n    (filemode && e.mode !== s.mode) ||\n    e.mtimeSeconds !== s.mtimeSeconds ||\n    e.ctimeSeconds !== s.ctimeSeconds ||\n    e.uid !== s.uid ||\n    e.gid !== s.gid ||\n    (trustino && e.ino !== s.ino) ||\n    e.size !== s.size;\n  return staleness\n}\n\n// import Lock from '../utils.js'\n\n// const lm = new LockManager()\nlet lock = null;\n\nconst IndexCache = Symbol('IndexCache');\n\n/**\n * Creates a cache object to store GitIndex and file stats.\n * @returns {object} A cache object with `map` and `stats` properties.\n */\nfunction createCache() {\n  return {\n    map: new Map(),\n    stats: new Map(),\n  }\n}\n\n/**\n * Updates the cached index file by reading the file system and parsing the Git index.\n * @param {FSClient} fs - A file system implementation.\n * @param {string} filepath - The path to the Git index file.\n * @param {object} cache - The cache object to update.\n * @returns {Promise<void>}\n */\nasync function updateCachedIndexFile(fs, filepath, cache) {\n  const [stat, rawIndexFile] = await Promise.all([\n    fs.lstat(filepath),\n    fs.read(filepath),\n  ]);\n\n  const index = await GitIndex.from(rawIndexFile);\n  // cache the GitIndex object so we don't need to re-read it every time.\n  cache.map.set(filepath, index);\n  // Save the stat data for the index so we know whether the cached file is stale (modified by an outside process).\n  cache.stats.set(filepath, stat);\n}\n\n/**\n * Determines whether the cached index file is stale by comparing file stats.\n * @param {FSClient} fs - A file system implementation.\n * @param {string} filepath - The path to the Git index file.\n * @param {object} cache - The cache object containing file stats.\n * @returns {Promise<boolean>} `true` if the index file is stale, otherwise `false`.\n */\nasync function isIndexStale(fs, filepath, cache) {\n  const savedStats = cache.stats.get(filepath);\n  if (savedStats === undefined) return true\n  if (savedStats === null) return false\n\n  const currStats = await fs.lstat(filepath);\n  if (currStats === null) return false\n  return compareStats(savedStats, currStats)\n}\n\nclass GitIndexManager {\n  /**\n   * Manages access to the Git index file, ensuring thread-safe operations and caching.\n   *\n   * @param {object} opts - Options for acquiring the Git index.\n   * @param {FSClient} opts.fs - A file system implementation.\n   * @param {string} opts.gitdir - The path to the `.git` directory.\n   * @param {object} opts.cache - A shared cache object for storing index data.\n   * @param {boolean} [opts.allowUnmerged=true] - Whether to allow unmerged paths in the index.\n   * @param {function(GitIndex): any} closure - A function to execute with the Git index.\n   * @returns {Promise<any>} The result of the closure function.\n   * @throws {UnmergedPathsError} If unmerged paths exist and `allowUnmerged` is `false`.\n   */\n  static async acquire({ fs, gitdir, cache, allowUnmerged = true }, closure) {\n    if (!cache[IndexCache]) {\n      cache[IndexCache] = createCache();\n    }\n\n    const filepath = `${gitdir}/index`;\n    if (lock === null) lock = new AsyncLock({ maxPending: Infinity });\n    let result;\n    let unmergedPaths = [];\n    await lock.acquire(filepath, async () => {\n      // Acquire a file lock while we're reading the index\n      // to make sure other processes aren't writing to it\n      // simultaneously, which could result in a corrupted index.\n      // const fileLock = await Lock(filepath)\n      const theIndexCache = cache[IndexCache];\n      if (await isIndexStale(fs, filepath, theIndexCache)) {\n        await updateCachedIndexFile(fs, filepath, theIndexCache);\n      }\n      const index = theIndexCache.map.get(filepath);\n      unmergedPaths = index.unmergedPaths;\n\n      if (unmergedPaths.length && !allowUnmerged)\n        throw new UnmergedPathsError(unmergedPaths)\n\n      result = await closure(index);\n      if (index._dirty) {\n        // Acquire a file lock while we're writing the index file\n        // let fileLock = await Lock(filepath)\n        const buffer = await index.toObject();\n        await fs.write(filepath, buffer);\n        // Update cached stat value\n        theIndexCache.stats.set(filepath, await fs.lstat(filepath));\n        index._dirty = false;\n      }\n    });\n\n    return result\n  }\n}\n\nfunction basename(path) {\n  const last = Math.max(path.lastIndexOf('/'), path.lastIndexOf('\\\\'));\n  if (last > -1) {\n    path = path.slice(last + 1);\n  }\n  return path\n}\n\nfunction dirname(path) {\n  const last = Math.max(path.lastIndexOf('/'), path.lastIndexOf('\\\\'));\n  if (last === -1) return '.'\n  if (last === 0) return '/'\n  return path.slice(0, last)\n}\n\n/*::\ntype Node = {\n  type: string,\n  fullpath: string,\n  basename: string,\n  metadata: Object, // mode, oid\n  parent?: Node,\n  children: Array<Node>\n}\n*/\n\nfunction flatFileListToDirectoryStructure(files) {\n  const inodes = new Map();\n  const mkdir = function (name) {\n    if (!inodes.has(name)) {\n      const dir = {\n        type: 'tree',\n        fullpath: name,\n        basename: basename(name),\n        metadata: {},\n        children: [],\n      };\n      inodes.set(name, dir);\n      // This recursively generates any missing parent folders.\n      // We do it after we've added the inode to the set so that\n      // we don't recurse infinitely trying to create the root '.' dirname.\n      dir.parent = mkdir(dirname(name));\n      if (dir.parent && dir.parent !== dir) dir.parent.children.push(dir);\n    }\n    return inodes.get(name)\n  };\n\n  const mkfile = function (name, metadata) {\n    if (!inodes.has(name)) {\n      const file = {\n        type: 'blob',\n        fullpath: name,\n        basename: basename(name),\n        metadata,\n        // This recursively generates any missing parent folders.\n        parent: mkdir(dirname(name)),\n        children: [],\n      };\n      if (file.parent) file.parent.children.push(file);\n      inodes.set(name, file);\n    }\n    return inodes.get(name)\n  };\n\n  mkdir('.');\n  for (const file of files) {\n    mkfile(file.path, file);\n  }\n  return inodes\n}\n\n/**\n *\n * @param {number} mode\n */\nfunction mode2type(mode) {\n  // prettier-ignore\n  switch (mode) {\n    case 0o040000: return 'tree'\n    case 0o100644: return 'blob'\n    case 0o100755: return 'blob'\n    case 0o120000: return 'blob'\n    case 0o160000: return 'commit'\n  }\n  throw new InternalError(`Unexpected GitTree entry mode: ${mode.toString(8)}`)\n}\n\nclass GitWalkerIndex {\n  constructor({ fs, gitdir, cache }) {\n    this.treePromise = GitIndexManager.acquire(\n      { fs, gitdir, cache },\n      async function (index) {\n        return flatFileListToDirectoryStructure(index.entries)\n      }\n    );\n    const walker = this;\n    this.ConstructEntry = class StageEntry {\n      constructor(fullpath) {\n        this._fullpath = fullpath;\n        this._type = false;\n        this._mode = false;\n        this._stat = false;\n        this._oid = false;\n      }\n\n      async type() {\n        return walker.type(this)\n      }\n\n      async mode() {\n        return walker.mode(this)\n      }\n\n      async stat() {\n        return walker.stat(this)\n      }\n\n      async content() {\n        return walker.content(this)\n      }\n\n      async oid() {\n        return walker.oid(this)\n      }\n    };\n  }\n\n  async readdir(entry) {\n    const filepath = entry._fullpath;\n    const tree = await this.treePromise;\n    const inode = tree.get(filepath);\n    if (!inode) return null\n    if (inode.type === 'blob') return null\n    if (inode.type !== 'tree') {\n      throw new Error(`ENOTDIR: not a directory, scandir '${filepath}'`)\n    }\n    const names = inode.children.map(inode => inode.fullpath);\n    names.sort(compareStrings);\n    return names\n  }\n\n  async type(entry) {\n    if (entry._type === false) {\n      await entry.stat();\n    }\n    return entry._type\n  }\n\n  async mode(entry) {\n    if (entry._mode === false) {\n      await entry.stat();\n    }\n    return entry._mode\n  }\n\n  async stat(entry) {\n    if (entry._stat === false) {\n      const tree = await this.treePromise;\n      const inode = tree.get(entry._fullpath);\n      if (!inode) {\n        throw new Error(\n          `ENOENT: no such file or directory, lstat '${entry._fullpath}'`\n        )\n      }\n      const stats = inode.type === 'tree' ? {} : normalizeStats(inode.metadata);\n      entry._type = inode.type === 'tree' ? 'tree' : mode2type(stats.mode);\n      entry._mode = stats.mode;\n      if (inode.type === 'tree') {\n        entry._stat = undefined;\n      } else {\n        entry._stat = stats;\n      }\n    }\n    return entry._stat\n  }\n\n  async content(_entry) {\n    // Cannot get content for an index entry\n  }\n\n  async oid(entry) {\n    if (entry._oid === false) {\n      const tree = await this.treePromise;\n      const inode = tree.get(entry._fullpath);\n      entry._oid = inode.metadata.oid;\n    }\n    return entry._oid\n  }\n}\n\n// This is part of an elaborate system to facilitate code-splitting / tree-shaking.\n// commands/walk.js can depend on only this, and the actual Walker classes exported\n// can be opaque - only having a single property (this symbol) that is not enumerable,\n// and thus the constructor can be passed as an argument to walk while being \"unusable\"\n// outside of it.\nconst GitWalkSymbol = Symbol('GitWalkSymbol');\n\n// @ts-check\n\n/**\n * @returns {Walker}\n */\nfunction STAGE() {\n  const o = Object.create(null);\n  Object.defineProperty(o, GitWalkSymbol, {\n    value: function ({ fs, gitdir, cache }) {\n      return new GitWalkerIndex({ fs, gitdir, cache })\n    },\n  });\n  Object.freeze(o);\n  return o\n}\n\n// @ts-check\n\nclass NotFoundError extends BaseError {\n  /**\n   * @param {string} what\n   */\n  constructor(what) {\n    super(`Could not find ${what}.`);\n    this.code = this.name = NotFoundError.code;\n    this.data = { what };\n  }\n}\n/** @type {'NotFoundError'} */\nNotFoundError.code = 'NotFoundError';\n\nclass ObjectTypeError extends BaseError {\n  /**\n   * @param {string} oid\n   * @param {'blob'|'commit'|'tag'|'tree'} actual\n   * @param {'blob'|'commit'|'tag'|'tree'} expected\n   * @param {string} [filepath]\n   */\n  constructor(oid, actual, expected, filepath) {\n    super(\n      `Object ${oid} ${\n        filepath ? `at ${filepath}` : ''\n      }was anticipated to be a ${expected} but it is a ${actual}.`\n    );\n    this.code = this.name = ObjectTypeError.code;\n    this.data = { oid, actual, expected, filepath };\n  }\n}\n/** @type {'ObjectTypeError'} */\nObjectTypeError.code = 'ObjectTypeError';\n\nclass InvalidOidError extends BaseError {\n  /**\n   * @param {string} value\n   */\n  constructor(value) {\n    super(`Expected a 40-char hex object id but saw \"${value}\".`);\n    this.code = this.name = InvalidOidError.code;\n    this.data = { value };\n  }\n}\n/** @type {'InvalidOidError'} */\nInvalidOidError.code = 'InvalidOidError';\n\nclass NoRefspecError extends BaseError {\n  /**\n   * @param {string} remote\n   */\n  constructor(remote) {\n    super(`Could not find a fetch refspec for remote \"${remote}\". Make sure the config file has an entry like the following:\n[remote \"${remote}\"]\n\\tfetch = +refs/heads/*:refs/remotes/origin/*\n`);\n    this.code = this.name = NoRefspecError.code;\n    this.data = { remote };\n  }\n}\n/** @type {'NoRefspecError'} */\nNoRefspecError.code = 'NoRefspecError';\n\nclass GitPackedRefs {\n  constructor(text) {\n    this.refs = new Map();\n    this.parsedConfig = [];\n    if (text) {\n      let key = null;\n      this.parsedConfig = text\n        .trim()\n        .split('\\n')\n        .map(line => {\n          if (/^\\s*#/.test(line)) {\n            return { line, comment: true }\n          }\n          const i = line.indexOf(' ');\n          if (line.startsWith('^')) {\n            // This is a oid for the commit associated with the annotated tag immediately preceding this line.\n            // Trim off the '^'\n            const value = line.slice(1);\n            // The tagname^{} syntax is based on the output of `git show-ref --tags -d`\n            this.refs.set(key + '^{}', value);\n            return { line, ref: key, peeled: value }\n          } else {\n            // This is an oid followed by the ref name\n            const value = line.slice(0, i);\n            key = line.slice(i + 1);\n            this.refs.set(key, value);\n            return { line, ref: key, oid: value }\n          }\n        });\n    }\n    return this\n  }\n\n  static from(text) {\n    return new GitPackedRefs(text)\n  }\n\n  delete(ref) {\n    this.parsedConfig = this.parsedConfig.filter(entry => entry.ref !== ref);\n    this.refs.delete(ref);\n  }\n\n  toString() {\n    return this.parsedConfig.map(({ line }) => line).join('\\n') + '\\n'\n  }\n}\n\nclass GitRefSpec {\n  constructor({ remotePath, localPath, force, matchPrefix }) {\n    Object.assign(this, {\n      remotePath,\n      localPath,\n      force,\n      matchPrefix,\n    });\n  }\n\n  static from(refspec) {\n    const [forceMatch, remotePath, remoteGlobMatch, localPath, localGlobMatch] =\n      refspec.match(/^(\\+?)(.*?)(\\*?):(.*?)(\\*?)$/).slice(1);\n    const force = forceMatch === '+';\n    const remoteIsGlob = remoteGlobMatch === '*';\n    const localIsGlob = localGlobMatch === '*';\n    // validate\n    // TODO: Make this check more nuanced, and depend on whether this is a fetch refspec or a push refspec\n    if (remoteIsGlob !== localIsGlob) {\n      throw new InternalError('Invalid refspec')\n    }\n    return new GitRefSpec({\n      remotePath,\n      localPath,\n      force,\n      matchPrefix: remoteIsGlob,\n    })\n    // TODO: We need to run resolveRef on both paths to expand them to their full name.\n  }\n\n  translate(remoteBranch) {\n    if (this.matchPrefix) {\n      if (remoteBranch.startsWith(this.remotePath)) {\n        return this.localPath + remoteBranch.replace(this.remotePath, '')\n      }\n    } else {\n      if (remoteBranch === this.remotePath) return this.localPath\n    }\n    return null\n  }\n\n  reverseTranslate(localBranch) {\n    if (this.matchPrefix) {\n      if (localBranch.startsWith(this.localPath)) {\n        return this.remotePath + localBranch.replace(this.localPath, '')\n      }\n    } else {\n      if (localBranch === this.localPath) return this.remotePath\n    }\n    return null\n  }\n}\n\nclass GitRefSpecSet {\n  constructor(rules = []) {\n    this.rules = rules;\n  }\n\n  static from(refspecs) {\n    const rules = [];\n    for (const refspec of refspecs) {\n      rules.push(GitRefSpec.from(refspec)); // might throw\n    }\n    return new GitRefSpecSet(rules)\n  }\n\n  add(refspec) {\n    const rule = GitRefSpec.from(refspec); // might throw\n    this.rules.push(rule);\n  }\n\n  translate(remoteRefs) {\n    const result = [];\n    for (const rule of this.rules) {\n      for (const remoteRef of remoteRefs) {\n        const localRef = rule.translate(remoteRef);\n        if (localRef) {\n          result.push([remoteRef, localRef]);\n        }\n      }\n    }\n    return result\n  }\n\n  translateOne(remoteRef) {\n    let result = null;\n    for (const rule of this.rules) {\n      const localRef = rule.translate(remoteRef);\n      if (localRef) {\n        result = localRef;\n      }\n    }\n    return result\n  }\n\n  localNamespaces() {\n    return this.rules\n      .filter(rule => rule.matchPrefix)\n      .map(rule => rule.localPath.replace(/\\/$/, ''))\n  }\n}\n\nfunction compareRefNames(a, b) {\n  // https://stackoverflow.com/a/40355107/2168416\n  const _a = a.replace(/\\^\\{\\}$/, '');\n  const _b = b.replace(/\\^\\{\\}$/, '');\n  const tmp = -(_a < _b) || +(_a > _b);\n  if (tmp === 0) {\n    return a.endsWith('^{}') ? 1 : -1\n  }\n  return tmp\n}\n\n/*!\n * This code for `path.join` is directly copied from @zenfs/core/path for bundle size improvements.\n * SPDX-License-Identifier: LGPL-3.0-or-later\n * Copyright (c) James Prevett and other ZenFS contributors.\n */\n\nfunction normalizeString(path, aar) {\n  let res = '';\n  let lastSegmentLength = 0;\n  let lastSlash = -1;\n  let dots = 0;\n  let char = '\\x00';\n  for (let i = 0; i <= path.length; ++i) {\n    if (i < path.length) char = path[i];\n    else if (char === '/') break\n    else char = '/';\n\n    if (char === '/') {\n      if (lastSlash === i - 1 || dots === 1) {\n        // NOOP\n      } else if (dots === 2) {\n        if (\n          res.length < 2 ||\n          lastSegmentLength !== 2 ||\n          res.at(-1) !== '.' ||\n          res.at(-2) !== '.'\n        ) {\n          if (res.length > 2) {\n            const lastSlashIndex = res.lastIndexOf('/');\n            if (lastSlashIndex === -1) {\n              res = '';\n              lastSegmentLength = 0;\n            } else {\n              res = res.slice(0, lastSlashIndex);\n              lastSegmentLength = res.length - 1 - res.lastIndexOf('/');\n            }\n            lastSlash = i;\n            dots = 0;\n            continue\n          } else if (res.length !== 0) {\n            res = '';\n            lastSegmentLength = 0;\n            lastSlash = i;\n            dots = 0;\n            continue\n          }\n        }\n        if (aar) {\n          res += res.length > 0 ? '/..' : '..';\n          lastSegmentLength = 2;\n        }\n      } else {\n        if (res.length > 0) res += '/' + path.slice(lastSlash + 1, i);\n        else res = path.slice(lastSlash + 1, i);\n        lastSegmentLength = i - lastSlash - 1;\n      }\n      lastSlash = i;\n      dots = 0;\n    } else if (char === '.' && dots !== -1) {\n      ++dots;\n    } else {\n      dots = -1;\n    }\n  }\n  return res\n}\n\nfunction normalize(path) {\n  if (!path.length) return '.'\n\n  const isAbsolute = path[0] === '/';\n  const trailingSeparator = path.at(-1) === '/';\n\n  path = normalizeString(path, !isAbsolute);\n\n  if (!path.length) {\n    if (isAbsolute) return '/'\n    return trailingSeparator ? './' : '.'\n  }\n  if (trailingSeparator) path += '/';\n\n  return isAbsolute ? `/${path}` : path\n}\n\nfunction join(...args) {\n  if (args.length === 0) return '.'\n  let joined;\n  for (let i = 0; i < args.length; ++i) {\n    const arg = args[i];\n    if (arg.length > 0) {\n      if (joined === undefined) joined = arg;\n      else joined += '/' + arg;\n    }\n  }\n  if (joined === undefined) return '.'\n  return normalize(joined)\n}\n\n// This is straight from parse_unit_factor in config.c of canonical git\nconst num = val => {\n  if (typeof val === 'number') {\n    return val\n  }\n\n  val = val.toLowerCase();\n  let n = parseInt(val);\n  if (val.endsWith('k')) n *= 1024;\n  if (val.endsWith('m')) n *= 1024 * 1024;\n  if (val.endsWith('g')) n *= 1024 * 1024 * 1024;\n  return n\n};\n\n// This is straight from git_parse_maybe_bool_text in config.c of canonical git\nconst bool = val => {\n  if (typeof val === 'boolean') {\n    return val\n  }\n\n  val = val.trim().toLowerCase();\n  if (val === 'true' || val === 'yes' || val === 'on') return true\n  if (val === 'false' || val === 'no' || val === 'off') return false\n  throw Error(\n    `Expected 'true', 'false', 'yes', 'no', 'on', or 'off', but got ${val}`\n  )\n};\n\nconst schema = {\n  core: {\n    filemode: bool,\n    bare: bool,\n    logallrefupdates: bool,\n    symlinks: bool,\n    ignorecase: bool,\n    bigFileThreshold: num,\n  },\n};\n\n// https://git-scm.com/docs/git-config#_syntax\n\n// section starts with [ and ends with ]\n// section is alphanumeric (ASCII) with - and .\n// section is case insensitive\n// subsection is optional\n// subsection is specified after section and one or more spaces\n// subsection is specified between double quotes\nconst SECTION_LINE_REGEX = /^\\[([A-Za-z0-9-.]+)(?: \"(.*)\")?\\]$/;\nconst SECTION_REGEX = /^[A-Za-z0-9-.]+$/;\n\n// variable lines contain a name, and equal sign and then a value\n// variable lines can also only contain a name (the implicit value is a boolean true)\n// variable name is alphanumeric (ASCII) with -\n// variable name starts with an alphabetic character\n// variable name is case insensitive\nconst VARIABLE_LINE_REGEX = /^([A-Za-z][A-Za-z-]*)(?: *= *(.*))?$/;\nconst VARIABLE_NAME_REGEX = /^[A-Za-z][A-Za-z-]*$/;\n\n// Comments start with either # or ; and extend to the end of line\nconst VARIABLE_VALUE_COMMENT_REGEX = /^(.*?)( *[#;].*)$/;\n\nconst extractSectionLine = line => {\n  const matches = SECTION_LINE_REGEX.exec(line);\n  if (matches != null) {\n    const [section, subsection] = matches.slice(1);\n    return [section, subsection]\n  }\n  return null\n};\n\nconst extractVariableLine = line => {\n  const matches = VARIABLE_LINE_REGEX.exec(line);\n  if (matches != null) {\n    const [name, rawValue = 'true'] = matches.slice(1);\n    const valueWithoutComments = removeComments(rawValue);\n    const valueWithoutQuotes = removeQuotes(valueWithoutComments);\n    return [name, valueWithoutQuotes]\n  }\n  return null\n};\n\nconst removeComments = rawValue => {\n  const commentMatches = VARIABLE_VALUE_COMMENT_REGEX.exec(rawValue);\n  if (commentMatches == null) {\n    return rawValue\n  }\n  const [valueWithoutComment, comment] = commentMatches.slice(1);\n  // if odd number of quotes before and after comment => comment is escaped\n  if (\n    hasOddNumberOfQuotes(valueWithoutComment) &&\n    hasOddNumberOfQuotes(comment)\n  ) {\n    return `${valueWithoutComment}${comment}`\n  }\n  return valueWithoutComment\n};\n\nconst hasOddNumberOfQuotes = text => {\n  const numberOfQuotes = (text.match(/(?:^|[^\\\\])\"/g) || []).length;\n  return numberOfQuotes % 2 !== 0\n};\n\nconst removeQuotes = text => {\n  return text.split('').reduce((newText, c, idx, text) => {\n    const isQuote = c === '\"' && text[idx - 1] !== '\\\\';\n    const isEscapeForQuote = c === '\\\\' && text[idx + 1] === '\"';\n    if (isQuote || isEscapeForQuote) {\n      return newText\n    }\n    return newText + c\n  }, '')\n};\n\nconst lower = text => {\n  return text != null ? text.toLowerCase() : null\n};\n\nconst getPath = (section, subsection, name) => {\n  return [lower(section), subsection, lower(name)]\n    .filter(a => a != null)\n    .join('.')\n};\n\nconst normalizePath = path => {\n  const pathSegments = path.split('.');\n  const section = pathSegments.shift();\n  const name = pathSegments.pop();\n  const subsection = pathSegments.length ? pathSegments.join('.') : undefined;\n\n  return {\n    section,\n    subsection,\n    name,\n    path: getPath(section, subsection, name),\n    sectionPath: getPath(section, subsection, null),\n    isSection: !!section,\n  }\n};\n\nconst findLastIndex = (array, callback) => {\n  return array.reduce((lastIndex, item, index) => {\n    return callback(item) ? index : lastIndex\n  }, -1)\n};\n\n// Note: there are a LOT of edge cases that aren't covered (e.g. keys in sections that also\n// have subsections, [include] directives, etc.\nclass GitConfig {\n  constructor(text) {\n    let section = null;\n    let subsection = null;\n    this.parsedConfig = text\n      ? text.split('\\n').map(line => {\n          let name = null;\n          let value = null;\n\n          const trimmedLine = line.trim();\n          const extractedSection = extractSectionLine(trimmedLine);\n          const isSection = extractedSection != null;\n          if (isSection) {\n            ;[section, subsection] = extractedSection;\n          } else {\n            const extractedVariable = extractVariableLine(trimmedLine);\n            const isVariable = extractedVariable != null;\n            if (isVariable) {\n              ;[name, value] = extractedVariable;\n            }\n          }\n\n          const path = getPath(section, subsection, name);\n          return { line, isSection, section, subsection, name, value, path }\n        })\n      : [];\n  }\n\n  static from(text) {\n    return new GitConfig(text)\n  }\n\n  async get(path, getall = false) {\n    const normalizedPath = normalizePath(path).path;\n    const allValues = this.parsedConfig\n      .filter(config => config.path === normalizedPath)\n      .map(({ section, name, value }) => {\n        const fn = schema[section] && schema[section][name];\n        return fn ? fn(value) : value\n      });\n    return getall ? allValues : allValues.pop()\n  }\n\n  async getall(path) {\n    return this.get(path, true)\n  }\n\n  async getSubsections(section) {\n    return this.parsedConfig\n      .filter(config => config.isSection && config.section === section)\n      .map(config => config.subsection)\n  }\n\n  async deleteSection(section, subsection) {\n    this.parsedConfig = this.parsedConfig.filter(\n      config =>\n        !(config.section === section && config.subsection === subsection)\n    );\n  }\n\n  async append(path, value) {\n    return this.set(path, value, true)\n  }\n\n  async set(path, value, append = false) {\n    const {\n      section,\n      subsection,\n      name,\n      path: normalizedPath,\n      sectionPath,\n      isSection,\n    } = normalizePath(path);\n\n    const configIndex = findLastIndex(\n      this.parsedConfig,\n      config => config.path === normalizedPath\n    );\n    if (value == null) {\n      if (configIndex !== -1) {\n        this.parsedConfig.splice(configIndex, 1);\n      }\n    } else {\n      if (configIndex !== -1) {\n        const config = this.parsedConfig[configIndex];\n        // Name should be overwritten in case the casing changed\n        const modifiedConfig = Object.assign({}, config, {\n          name,\n          value,\n          modified: true,\n        });\n        if (append) {\n          this.parsedConfig.splice(configIndex + 1, 0, modifiedConfig);\n        } else {\n          this.parsedConfig[configIndex] = modifiedConfig;\n        }\n      } else {\n        const sectionIndex = this.parsedConfig.findIndex(\n          config => config.path === sectionPath\n        );\n        const newConfig = {\n          section,\n          subsection,\n          name,\n          value,\n          modified: true,\n          path: normalizedPath,\n        };\n        if (SECTION_REGEX.test(section) && VARIABLE_NAME_REGEX.test(name)) {\n          if (sectionIndex >= 0) {\n            // Reuse existing section\n            this.parsedConfig.splice(sectionIndex + 1, 0, newConfig);\n          } else {\n            // Add a new section\n            const newSection = {\n              isSection,\n              section,\n              subsection,\n              modified: true,\n              path: sectionPath,\n            };\n            this.parsedConfig.push(newSection, newConfig);\n          }\n        }\n      }\n    }\n  }\n\n  toString() {\n    return this.parsedConfig\n      .map(({ line, section, subsection, name, value, modified = false }) => {\n        if (!modified) {\n          return line\n        }\n        if (name != null && value != null) {\n          if (typeof value === 'string' && /[#;]/.test(value)) {\n            // A `#` or `;` symbol denotes a comment, so we have to wrap it in double quotes\n            return `\\t${name} = \"${value}\"`\n          }\n          return `\\t${name} = ${value}`\n        }\n        if (subsection != null) {\n          return `[${section} \"${subsection}\"]`\n        }\n        return `[${section}]`\n      })\n      .join('\\n')\n  }\n}\n\n/**\n * Manages access to the Git configuration file, providing methods to read and save configurations.\n */\nclass GitConfigManager {\n  /**\n   * Reads the Git configuration file from the specified `.git` directory.\n   *\n   * @param {object} opts - Options for reading the Git configuration.\n   * @param {FSClient} opts.fs - A file system implementation.\n   * @param {string} opts.gitdir - The path to the `.git` directory.\n   * @returns {Promise<GitConfig>} A `GitConfig` object representing the parsed configuration.\n   */\n  static async get({ fs, gitdir }) {\n    // We can improve efficiency later if needed.\n    // TODO: read from full list of git config files\n    const text = await fs.read(`${gitdir}/config`, { encoding: 'utf8' });\n    return GitConfig.from(text)\n  }\n\n  /**\n   * Saves the provided Git configuration to the specified `.git` directory.\n   *\n   * @param {object} opts - Options for saving the Git configuration.\n   * @param {FSClient} opts.fs - A file system implementation.\n   * @param {string} opts.gitdir - The path to the `.git` directory.\n   * @param {GitConfig} opts.config - The `GitConfig` object to save.\n   * @returns {Promise<void>} Resolves when the configuration has been successfully saved.\n   */\n  static async save({ fs, gitdir, config }) {\n    // We can improve efficiency later if needed.\n    // TODO: handle saving to the correct global/user/repo location\n    await fs.write(`${gitdir}/config`, config.toString(), {\n      encoding: 'utf8',\n    });\n  }\n}\n\n// @see https://git-scm.com/docs/git-rev-parse.html#_specifying_revisions\nconst refpaths = ref => [\n  `${ref}`,\n  `refs/${ref}`,\n  `refs/tags/${ref}`,\n  `refs/heads/${ref}`,\n  `refs/remotes/${ref}`,\n  `refs/remotes/${ref}/HEAD`,\n];\n\n// @see https://git-scm.com/docs/gitrepository-layout\nconst GIT_FILES = ['config', 'description', 'index', 'shallow', 'commondir'];\n\nlet lock$1;\n\nasync function acquireLock(ref, callback) {\n  if (lock$1 === undefined) lock$1 = new AsyncLock();\n  return lock$1.acquire(ref, callback)\n}\n\n/**\n * A class for managing Git references, including reading, writing, deleting, and resolving refs.\n */\nclass GitRefManager {\n  /**\n   * Updates remote refs based on the provided refspecs and options.\n   *\n   * @param {Object} args\n   * @param {FSClient} args.fs - A file system implementation.\n   * @param {string} [args.gitdir=join(dir, '.git')] - [required] The [git directory](dir-vs-gitdir.md) path\n   * @param {string} args.remote - The name of the remote.\n   * @param {Map<string, string>} args.refs - A map of refs to their object IDs.\n   * @param {Map<string, string>} args.symrefs - A map of symbolic refs.\n   * @param {boolean} args.tags - Whether to fetch tags.\n   * @param {string[]} [args.refspecs = undefined] - The refspecs to use.\n   * @param {boolean} [args.prune = false] - Whether to prune stale refs.\n   * @param {boolean} [args.pruneTags = false] - Whether to prune tags.\n   * @returns {Promise<Object>} - An object containing pruned refs.\n   */\n  static async updateRemoteRefs({\n    fs,\n    gitdir,\n    remote,\n    refs,\n    symrefs,\n    tags,\n    refspecs = undefined,\n    prune = false,\n    pruneTags = false,\n  }) {\n    // Validate input\n    for (const value of refs.values()) {\n      if (!value.match(/[0-9a-f]{40}/)) {\n        throw new InvalidOidError(value)\n      }\n    }\n    const config = await GitConfigManager.get({ fs, gitdir });\n    if (!refspecs) {\n      refspecs = await config.getall(`remote.${remote}.fetch`);\n      if (refspecs.length === 0) {\n        throw new NoRefspecError(remote)\n      }\n      // There's some interesting behavior with HEAD that doesn't follow the refspec.\n      refspecs.unshift(`+HEAD:refs/remotes/${remote}/HEAD`);\n    }\n    const refspec = GitRefSpecSet.from(refspecs);\n    const actualRefsToWrite = new Map();\n    // Delete all current tags if the pruneTags argument is true.\n    if (pruneTags) {\n      const tags = await GitRefManager.listRefs({\n        fs,\n        gitdir,\n        filepath: 'refs/tags',\n      });\n      await GitRefManager.deleteRefs({\n        fs,\n        gitdir,\n        refs: tags.map(tag => `refs/tags/${tag}`),\n      });\n    }\n    // Add all tags if the fetch tags argument is true.\n    if (tags) {\n      for (const serverRef of refs.keys()) {\n        if (serverRef.startsWith('refs/tags') && !serverRef.endsWith('^{}')) {\n          // Git's behavior is to only fetch tags that do not conflict with tags already present.\n          if (!(await GitRefManager.exists({ fs, gitdir, ref: serverRef }))) {\n            // Always use the object id of the tag itself, and not the peeled object id.\n            const oid = refs.get(serverRef);\n            actualRefsToWrite.set(serverRef, oid);\n          }\n        }\n      }\n    }\n    // Combine refs and symrefs giving symrefs priority\n    const refTranslations = refspec.translate([...refs.keys()]);\n    for (const [serverRef, translatedRef] of refTranslations) {\n      const value = refs.get(serverRef);\n      actualRefsToWrite.set(translatedRef, value);\n    }\n    const symrefTranslations = refspec.translate([...symrefs.keys()]);\n    for (const [serverRef, translatedRef] of symrefTranslations) {\n      const value = symrefs.get(serverRef);\n      const symtarget = refspec.translateOne(value);\n      if (symtarget) {\n        actualRefsToWrite.set(translatedRef, `ref: ${symtarget}`);\n      }\n    }\n    // If `prune` argument is true, clear out the existing local refspec roots\n    const pruned = [];\n    if (prune) {\n      for (const filepath of refspec.localNamespaces()) {\n        const refs = (\n          await GitRefManager.listRefs({\n            fs,\n            gitdir,\n            filepath,\n          })\n        ).map(file => `${filepath}/${file}`);\n        for (const ref of refs) {\n          if (!actualRefsToWrite.has(ref)) {\n            pruned.push(ref);\n          }\n        }\n      }\n      if (pruned.length > 0) {\n        await GitRefManager.deleteRefs({ fs, gitdir, refs: pruned });\n      }\n    }\n    // Update files\n    // TODO: For large repos with a history of thousands of pull requests\n    // (i.e. gitlab-ce) it would be vastly more efficient to write them\n    // to .git/packed-refs.\n    // The trick is to make sure we a) don't write a packed ref that is\n    // already shadowed by a loose ref and b) don't loose any refs already\n    // in packed-refs. Doing this efficiently may be difficult. A\n    // solution that might work is\n    // a) load the current packed-refs file\n    // b) add actualRefsToWrite, overriding the existing values if present\n    // c) enumerate all the loose refs currently in .git/refs/remotes/${remote}\n    // d) overwrite their value with the new value.\n    // Examples of refs we need to avoid writing in loose format for efficieny's sake\n    // are .git/refs/remotes/origin/refs/remotes/remote_mirror_3059\n    // and .git/refs/remotes/origin/refs/merge-requests\n    for (const [key, value] of actualRefsToWrite) {\n      await acquireLock(key, async () =>\n        fs.write(join(gitdir, key), `${value.trim()}\\n`, 'utf8')\n      );\n    }\n    return { pruned }\n  }\n\n  /**\n   * Writes a ref to the file system.\n   *\n   * @param {Object} args\n   * @param {FSClient} args.fs - A file system implementation.\n   * @param {string} [args.gitdir] - [required] The [git directory](dir-vs-gitdir.md) path\n   * @param {string} args.ref - The ref to write.\n   * @param {string} args.value - The object ID to write.\n   * @returns {Promise<void>}\n   */\n  // TODO: make this less crude?\n  static async writeRef({ fs, gitdir, ref, value }) {\n    // Validate input\n    if (!value.match(/[0-9a-f]{40}/)) {\n      throw new InvalidOidError(value)\n    }\n    await acquireLock(ref, async () =>\n      fs.write(join(gitdir, ref), `${value.trim()}\\n`, 'utf8')\n    );\n  }\n\n  /**\n   * Writes a symbolic ref to the file system.\n   *\n   * @param {Object} args\n   * @param {FSClient} args.fs - A file system implementation.\n   * @param {string} [args.gitdir] - [required] The [git directory](dir-vs-gitdir.md) path\n   * @param {string} args.ref - The ref to write.\n   * @param {string} args.value - The target ref.\n   * @returns {Promise<void>}\n   */\n  static async writeSymbolicRef({ fs, gitdir, ref, value }) {\n    await acquireLock(ref, async () =>\n      fs.write(join(gitdir, ref), 'ref: ' + `${value.trim()}\\n`, 'utf8')\n    );\n  }\n\n  /**\n   * Deletes a single ref.\n   *\n   * @param {Object} args\n   * @param {FSClient} args.fs - A file system implementation.\n   * @param {string} [args.gitdir] - [required] The [git directory](dir-vs-gitdir.md) path\n   * @param {string} args.ref - The ref to delete.\n   * @returns {Promise<void>}\n   */\n  static async deleteRef({ fs, gitdir, ref }) {\n    return GitRefManager.deleteRefs({ fs, gitdir, refs: [ref] })\n  }\n\n  /**\n   * Deletes multiple refs.\n   *\n   * @param {Object} args\n   * @param {FSClient} args.fs - A file system implementation.\n   * @param {string} [args.gitdir] - [required] The [git directory](dir-vs-gitdir.md) path\n   * @param {string[]} args.refs - The refs to delete.\n   * @returns {Promise<void>}\n   */\n  static async deleteRefs({ fs, gitdir, refs }) {\n    // Delete regular ref\n    await Promise.all(refs.map(ref => fs.rm(join(gitdir, ref))));\n    // Delete any packed ref\n    let text = await acquireLock('packed-refs', async () =>\n      fs.read(`${gitdir}/packed-refs`, { encoding: 'utf8' })\n    );\n    const packed = GitPackedRefs.from(text);\n    const beforeSize = packed.refs.size;\n    for (const ref of refs) {\n      if (packed.refs.has(ref)) {\n        packed.delete(ref);\n      }\n    }\n    if (packed.refs.size < beforeSize) {\n      text = packed.toString();\n      await acquireLock('packed-refs', async () =>\n        fs.write(`${gitdir}/packed-refs`, text, { encoding: 'utf8' })\n      );\n    }\n  }\n\n  /**\n   * Resolves a ref to its object ID.\n   *\n   * @param {Object} args\n   * @param {FSClient} args.fs - A file system implementation.\n   * @param {string} [args.gitdir] - [required] The [git directory](dir-vs-gitdir.md) path\n   * @param {string} args.ref - The ref to resolve.\n   * @param {number} [args.depth = undefined] - The maximum depth to resolve symbolic refs.\n   * @returns {Promise<string>} - The resolved object ID.\n   */\n  static async resolve({ fs, gitdir, ref, depth = undefined }) {\n    if (depth !== undefined) {\n      depth--;\n      if (depth === -1) {\n        return ref\n      }\n    }\n\n    // Is it a ref pointer?\n    if (ref.startsWith('ref: ')) {\n      ref = ref.slice('ref: '.length);\n      return GitRefManager.resolve({ fs, gitdir, ref, depth })\n    }\n    // Is it a complete and valid SHA?\n    if (ref.length === 40 && /[0-9a-f]{40}/.test(ref)) {\n      return ref\n    }\n    // We need to alternate between the file system and the packed-refs\n    const packedMap = await GitRefManager.packedRefs({ fs, gitdir });\n    // Look in all the proper paths, in this order\n    const allpaths = refpaths(ref).filter(p => !GIT_FILES.includes(p)); // exclude git system files (#709)\n\n    for (const ref of allpaths) {\n      const sha = await acquireLock(\n        ref,\n        async () =>\n          (await fs.read(`${gitdir}/${ref}`, { encoding: 'utf8' })) ||\n          packedMap.get(ref)\n      );\n      if (sha) {\n        return GitRefManager.resolve({ fs, gitdir, ref: sha.trim(), depth })\n      }\n    }\n    // Do we give up?\n    throw new NotFoundError(ref)\n  }\n\n  /**\n   * Checks if a ref exists.\n   *\n   * @param {Object} args\n   * @param {FSClient} args.fs - A file system implementation.\n   * @param {string} [args.gitdir=join(dir, '.git')] - [required] The [git directory](dir-vs-gitdir.md) path\n   * @param {string} args.ref - The ref to check.\n   * @returns {Promise<boolean>} - True if the ref exists, false otherwise.\n   */\n  static async exists({ fs, gitdir, ref }) {\n    try {\n      await GitRefManager.expand({ fs, gitdir, ref });\n      return true\n    } catch (err) {\n      return false\n    }\n  }\n\n  /**\n   * Expands a ref to its full name.\n   *\n   * @param {Object} args\n   * @param {FSClient} args.fs - A file system implementation.\n   * @param {string} [args.gitdir=join(dir, '.git')] - [required] The [git directory](dir-vs-gitdir.md) path\n   * @param {string} args.ref - The ref to expand.\n   * @returns {Promise<string>} - The full ref name.\n   */\n  static async expand({ fs, gitdir, ref }) {\n    // Is it a complete and valid SHA?\n    if (ref.length === 40 && /[0-9a-f]{40}/.test(ref)) {\n      return ref\n    }\n    // We need to alternate between the file system and the packed-refs\n    const packedMap = await GitRefManager.packedRefs({ fs, gitdir });\n    // Look in all the proper paths, in this order\n    const allpaths = refpaths(ref);\n    for (const ref of allpaths) {\n      const refExists = await acquireLock(ref, async () =>\n        fs.exists(`${gitdir}/${ref}`)\n      );\n      if (refExists) return ref\n      if (packedMap.has(ref)) return ref\n    }\n    // Do we give up?\n    throw new NotFoundError(ref)\n  }\n\n  /**\n   * Expands a ref against a provided map.\n   *\n   * @param {Object} args\n   * @param {string} args.ref - The ref to expand.\n   * @param {Map<string, string>} args.map - The map of refs.\n   * @returns {Promise<string>} - The expanded ref.\n   */\n  static async expandAgainstMap({ ref, map }) {\n    // Look in all the proper paths, in this order\n    const allpaths = refpaths(ref);\n    for (const ref of allpaths) {\n      if (await map.has(ref)) return ref\n    }\n    // Do we give up?\n    throw new NotFoundError(ref)\n  }\n\n  /**\n   * Resolves a ref against a provided map.\n   *\n   * @param {Object} args\n   * @param {string} args.ref - The ref to resolve.\n   * @param {string} [args.fullref = args.ref] - The full ref name.\n   * @param {number} [args.depth = undefined] - The maximum depth to resolve symbolic refs.\n   * @param {Map<string, string>} args.map - The map of refs.\n   * @returns {Object} - An object containing the full ref and its object ID.\n   */\n  static resolveAgainstMap({ ref, fullref = ref, depth = undefined, map }) {\n    if (depth !== undefined) {\n      depth--;\n      if (depth === -1) {\n        return { fullref, oid: ref }\n      }\n    }\n    // Is it a ref pointer?\n    if (ref.startsWith('ref: ')) {\n      ref = ref.slice('ref: '.length);\n      return GitRefManager.resolveAgainstMap({ ref, fullref, depth, map })\n    }\n    // Is it a complete and valid SHA?\n    if (ref.length === 40 && /[0-9a-f]{40}/.test(ref)) {\n      return { fullref, oid: ref }\n    }\n    // Look in all the proper paths, in this order\n    const allpaths = refpaths(ref);\n    for (const ref of allpaths) {\n      const sha = map.get(ref);\n      if (sha) {\n        return GitRefManager.resolveAgainstMap({\n          ref: sha.trim(),\n          fullref: ref,\n          depth,\n          map,\n        })\n      }\n    }\n    // Do we give up?\n    throw new NotFoundError(ref)\n  }\n\n  /**\n   * Reads the packed refs file and returns a map of refs.\n   *\n   * @param {Object} args\n   * @param {FSClient} args.fs - A file system implementation.\n   * @param {string} [args.gitdir=join(dir, '.git')] - [required] The [git directory](dir-vs-gitdir.md) path\n   * @returns {Promise<Map<string, string>>} - A map of packed refs.\n   */\n  static async packedRefs({ fs, gitdir }) {\n    const text = await acquireLock('packed-refs', async () =>\n      fs.read(`${gitdir}/packed-refs`, { encoding: 'utf8' })\n    );\n    const packed = GitPackedRefs.from(text);\n    return packed.refs\n  }\n\n  /**\n   * Lists all refs matching a given filepath prefix.\n   *\n   * @param {Object} args\n   * @param {FSClient} args.fs - A file system implementation.\n   * @param {string} [args.gitdir=join(dir, '.git')] - [required] The [git directory](dir-vs-gitdir.md) path\n   * @param {string} args.filepath - The filepath prefix to match.\n   * @returns {Promise<string[]>} - A sorted list of refs.\n   */\n  static async listRefs({ fs, gitdir, filepath }) {\n    const packedMap = GitRefManager.packedRefs({ fs, gitdir });\n    let files = null;\n    try {\n      files = await fs.readdirDeep(`${gitdir}/${filepath}`);\n      files = files.map(x => x.replace(`${gitdir}/${filepath}/`, ''));\n    } catch (err) {\n      files = [];\n    }\n\n    for (let key of (await packedMap).keys()) {\n      // filter by prefix\n      if (key.startsWith(filepath)) {\n        // remove prefix\n        key = key.replace(filepath + '/', '');\n        // Don't include duplicates; the loose files have precedence anyway\n        if (!files.includes(key)) {\n          files.push(key);\n        }\n      }\n    }\n    // since we just appended things onto an array, we need to sort them now\n    files.sort(compareRefNames);\n    return files\n  }\n\n  /**\n   * Lists all branches, optionally filtered by remote.\n   *\n   * @param {Object} args\n   * @param {FSClient} args.fs - A file system implementation.\n   * @param {string} [args.gitdir=join(dir, '.git')] - [required] The [git directory](dir-vs-gitdir.md) path\n   * @param {string} [args.remote] - The remote to filter branches by.\n   * @returns {Promise<string[]>} - A list of branch names.\n   */\n  static async listBranches({ fs, gitdir, remote }) {\n    if (remote) {\n      return GitRefManager.listRefs({\n        fs,\n        gitdir,\n        filepath: `refs/remotes/${remote}`,\n      })\n    } else {\n      return GitRefManager.listRefs({ fs, gitdir, filepath: `refs/heads` })\n    }\n  }\n\n  /**\n   * Lists all tags.\n   *\n   * @param {Object} args\n   * @param {FSClient} args.fs - A file system implementation.\n   * @param {string} [args.gitdir=join(dir, '.git')] - [required] The [git directory](dir-vs-gitdir.md) path\n   * @returns {Promise<string[]>} - A list of tag names.\n   */\n  static async listTags({ fs, gitdir }) {\n    const tags = await GitRefManager.listRefs({\n      fs,\n      gitdir,\n      filepath: `refs/tags`,\n    });\n    return tags.filter(x => !x.endsWith('^{}'))\n  }\n}\n\nfunction compareTreeEntryPath(a, b) {\n  // Git sorts tree entries as if there is a trailing slash on directory names.\n  return compareStrings(appendSlashIfDir(a), appendSlashIfDir(b))\n}\n\nfunction appendSlashIfDir(entry) {\n  return entry.mode === '040000' ? entry.path + '/' : entry.path\n}\n\n/**\n *\n * @typedef {Object} TreeEntry\n * @property {string} mode - the 6 digit hexadecimal mode\n * @property {string} path - the name of the file or directory\n * @property {string} oid - the SHA-1 object id of the blob or tree\n * @property {'commit'|'blob'|'tree'} type - the type of object\n */\n\nfunction mode2type$1(mode) {\n  // prettier-ignore\n  switch (mode) {\n    case '040000': return 'tree'\n    case '100644': return 'blob'\n    case '100755': return 'blob'\n    case '120000': return 'blob'\n    case '160000': return 'commit'\n  }\n  throw new InternalError(`Unexpected GitTree entry mode: ${mode}`)\n}\n\nfunction parseBuffer(buffer) {\n  const _entries = [];\n  let cursor = 0;\n  while (cursor < buffer.length) {\n    const space = buffer.indexOf(32, cursor);\n    if (space === -1) {\n      throw new InternalError(\n        `GitTree: Error parsing buffer at byte location ${cursor}: Could not find the next space character.`\n      )\n    }\n    const nullchar = buffer.indexOf(0, cursor);\n    if (nullchar === -1) {\n      throw new InternalError(\n        `GitTree: Error parsing buffer at byte location ${cursor}: Could not find the next null character.`\n      )\n    }\n    let mode = buffer.slice(cursor, space).toString('utf8');\n    if (mode === '40000') mode = '040000'; // makes it line up neater in printed output\n    const type = mode2type$1(mode);\n    const path = buffer.slice(space + 1, nullchar).toString('utf8');\n\n    // Prevent malicious git repos from writing to \"..\\foo\" on clone etc\n    if (path.includes('\\\\') || path.includes('/')) {\n      throw new UnsafeFilepathError(path)\n    }\n\n    const oid = buffer.slice(nullchar + 1, nullchar + 21).toString('hex');\n    cursor = nullchar + 21;\n    _entries.push({ mode, path, oid, type });\n  }\n  return _entries\n}\n\nfunction limitModeToAllowed(mode) {\n  if (typeof mode === 'number') {\n    mode = mode.toString(8);\n  }\n  // tree\n  if (mode.match(/^0?4.*/)) return '040000' // Directory\n  if (mode.match(/^1006.*/)) return '100644' // Regular non-executable file\n  if (mode.match(/^1007.*/)) return '100755' // Regular executable file\n  if (mode.match(/^120.*/)) return '120000' // Symbolic link\n  if (mode.match(/^160.*/)) return '160000' // Commit (git submodule reference)\n  throw new InternalError(`Could not understand file mode: ${mode}`)\n}\n\nfunction nudgeIntoShape(entry) {\n  if (!entry.oid && entry.sha) {\n    entry.oid = entry.sha; // Github\n  }\n  entry.mode = limitModeToAllowed(entry.mode); // index\n  if (!entry.type) {\n    entry.type = mode2type$1(entry.mode); // index\n  }\n  return entry\n}\n\nclass GitTree {\n  constructor(entries) {\n    if (Buffer.isBuffer(entries)) {\n      this._entries = parseBuffer(entries);\n    } else if (Array.isArray(entries)) {\n      this._entries = entries.map(nudgeIntoShape);\n    } else {\n      throw new InternalError('invalid type passed to GitTree constructor')\n    }\n    // Tree entries are not sorted alphabetically in the usual sense (see `compareTreeEntryPath`)\n    // but it is important later on that these be sorted in the same order as they would be returned from readdir.\n    this._entries.sort(comparePath);\n  }\n\n  static from(tree) {\n    return new GitTree(tree)\n  }\n\n  render() {\n    return this._entries\n      .map(entry => `${entry.mode} ${entry.type} ${entry.oid}    ${entry.path}`)\n      .join('\\n')\n  }\n\n  toObject() {\n    // Adjust the sort order to match git's\n    const entries = [...this._entries];\n    entries.sort(compareTreeEntryPath);\n    return Buffer.concat(\n      entries.map(entry => {\n        const mode = Buffer.from(entry.mode.replace(/^0/, ''));\n        const space = Buffer.from(' ');\n        const path = Buffer.from(entry.path, 'utf8');\n        const nullchar = Buffer.from([0]);\n        const oid = Buffer.from(entry.oid, 'hex');\n        return Buffer.concat([mode, space, path, nullchar, oid])\n      })\n    )\n  }\n\n  /**\n   * @returns {TreeEntry[]}\n   */\n  entries() {\n    return this._entries\n  }\n\n  *[Symbol.iterator]() {\n    for (const entry of this._entries) {\n      yield entry;\n    }\n  }\n}\n\n/**\n * Represents a Git object and provides methods to wrap and unwrap Git objects\n * according to the Git object format.\n */\nclass GitObject {\n  /**\n   * Wraps a raw object with a Git header.\n   *\n   * @param {Object} params - The parameters for wrapping.\n   * @param {string} params.type - The type of the Git object (e.g., 'blob', 'tree', 'commit').\n   * @param {Uint8Array} params.object - The raw object data to wrap.\n   * @returns {Uint8Array} The wrapped Git object as a single buffer.\n   */\n  static wrap({ type, object }) {\n    const header = `${type} ${object.length}\\x00`;\n    const headerLen = header.length;\n    const totalLength = headerLen + object.length;\n\n    // Allocate a single buffer for the header and object, rather than create multiple buffers\n    const wrappedObject = new Uint8Array(totalLength);\n    for (let i = 0; i < headerLen; i++) {\n      wrappedObject[i] = header.charCodeAt(i);\n    }\n    wrappedObject.set(object, headerLen);\n\n    return wrappedObject\n  }\n\n  /**\n   * Unwraps a Git object buffer into its type and raw object data.\n   *\n   * @param {Buffer|Uint8Array} buffer - The buffer containing the wrapped Git object.\n   * @returns {{ type: string, object: Buffer }} An object containing the type and the raw object data.\n   * @throws {InternalError} If the length specified in the header does not match the actual object length.\n   */\n  static unwrap(buffer) {\n    const s = buffer.indexOf(32); // first space\n    const i = buffer.indexOf(0); // first null value\n    const type = buffer.slice(0, s).toString('utf8'); // get type of object\n    const length = buffer.slice(s + 1, i).toString('utf8'); // get type of object\n    const actualLength = buffer.length - (i + 1);\n    // verify length\n    if (parseInt(length) !== actualLength) {\n      throw new InternalError(\n        `Length mismatch: expected ${length} bytes but got ${actualLength} instead.`\n      )\n    }\n    return {\n      type,\n      object: Buffer.from(buffer.slice(i + 1)),\n    }\n  }\n}\n\nasync function readObjectLoose({ fs, gitdir, oid }) {\n  const source = `objects/${oid.slice(0, 2)}/${oid.slice(2)}`;\n  const file = await fs.read(`${gitdir}/${source}`);\n  if (!file) {\n    return null\n  }\n  return { object: file, format: 'deflated', source }\n}\n\n/**\n * @param {Buffer} delta\n * @param {Buffer} source\n * @returns {Buffer}\n */\nfunction applyDelta(delta, source) {\n  const reader = new BufferCursor(delta);\n  const sourceSize = readVarIntLE(reader);\n\n  if (sourceSize !== source.byteLength) {\n    throw new InternalError(\n      `applyDelta expected source buffer to be ${sourceSize} bytes but the provided buffer was ${source.length} bytes`\n    )\n  }\n  const targetSize = readVarIntLE(reader);\n  let target;\n\n  const firstOp = readOp(reader, source);\n  // Speed optimization - return raw buffer if it's just single simple copy\n  if (firstOp.byteLength === targetSize) {\n    target = firstOp;\n  } else {\n    // Otherwise, allocate a fresh buffer and slices\n    target = Buffer.alloc(targetSize);\n    const writer = new BufferCursor(target);\n    writer.copy(firstOp);\n\n    while (!reader.eof()) {\n      writer.copy(readOp(reader, source));\n    }\n\n    const tell = writer.tell();\n    if (targetSize !== tell) {\n      throw new InternalError(\n        `applyDelta expected target buffer to be ${targetSize} bytes but the resulting buffer was ${tell} bytes`\n      )\n    }\n  }\n  return target\n}\n\nfunction readVarIntLE(reader) {\n  let result = 0;\n  let shift = 0;\n  let byte = null;\n  do {\n    byte = reader.readUInt8();\n    result |= (byte & 0b01111111) << shift;\n    shift += 7;\n  } while (byte & 0b10000000)\n  return result\n}\n\nfunction readCompactLE(reader, flags, size) {\n  let result = 0;\n  let shift = 0;\n  while (size--) {\n    if (flags & 0b00000001) {\n      result |= reader.readUInt8() << shift;\n    }\n    flags >>= 1;\n    shift += 8;\n  }\n  return result\n}\n\nfunction readOp(reader, source) {\n  /** @type {number} */\n  const byte = reader.readUInt8();\n  const COPY = 0b10000000;\n  const OFFS = 0b00001111;\n  const SIZE = 0b01110000;\n  if (byte & COPY) {\n    // copy consists of 4 byte offset, 3 byte size (in LE order)\n    const offset = readCompactLE(reader, byte & OFFS, 4);\n    let size = readCompactLE(reader, (byte & SIZE) >> 4, 3);\n    // Yup. They really did this optimization.\n    if (size === 0) size = 0x10000;\n    return source.slice(offset, offset + size)\n  } else {\n    // insert\n    return reader.slice(byte)\n  }\n}\n\n// Convert a value to an Async Iterator\n// This will be easier with async generator functions.\nfunction fromValue(value) {\n  let queue = [value];\n  return {\n    next() {\n      return Promise.resolve({ done: queue.length === 0, value: queue.pop() })\n    },\n    return() {\n      queue = [];\n      return {}\n    },\n    [Symbol.asyncIterator]() {\n      return this\n    },\n  }\n}\n\nfunction getIterator(iterable) {\n  if (iterable[Symbol.asyncIterator]) {\n    return iterable[Symbol.asyncIterator]()\n  }\n  if (iterable[Symbol.iterator]) {\n    return iterable[Symbol.iterator]()\n  }\n  if (iterable.next) {\n    return iterable\n  }\n  return fromValue(iterable)\n}\n\n// inspired by 'gartal' but lighter-weight and more battle-tested.\nclass StreamReader {\n  constructor(stream) {\n    // TODO: fix usage in bundlers before Buffer dependency is removed #1855\n    if (typeof Buffer === 'undefined') {\n      throw new Error('Missing Buffer dependency')\n    }\n    this.stream = getIterator(stream);\n    this.buffer = null;\n    this.cursor = 0;\n    this.undoCursor = 0;\n    this.started = false;\n    this._ended = false;\n    this._discardedBytes = 0;\n  }\n\n  eof() {\n    return this._ended && this.cursor === this.buffer.length\n  }\n\n  tell() {\n    return this._discardedBytes + this.cursor\n  }\n\n  async byte() {\n    if (this.eof()) return\n    if (!this.started) await this._init();\n    if (this.cursor === this.buffer.length) {\n      await this._loadnext();\n      if (this._ended) return\n    }\n    this._moveCursor(1);\n    return this.buffer[this.undoCursor]\n  }\n\n  async chunk() {\n    if (this.eof()) return\n    if (!this.started) await this._init();\n    if (this.cursor === this.buffer.length) {\n      await this._loadnext();\n      if (this._ended) return\n    }\n    this._moveCursor(this.buffer.length);\n    return this.buffer.slice(this.undoCursor, this.cursor)\n  }\n\n  async read(n) {\n    if (this.eof()) return\n    if (!this.started) await this._init();\n    if (this.cursor + n > this.buffer.length) {\n      this._trim();\n      await this._accumulate(n);\n    }\n    this._moveCursor(n);\n    return this.buffer.slice(this.undoCursor, this.cursor)\n  }\n\n  async skip(n) {\n    if (this.eof()) return\n    if (!this.started) await this._init();\n    if (this.cursor + n > this.buffer.length) {\n      this._trim();\n      await this._accumulate(n);\n    }\n    this._moveCursor(n);\n  }\n\n  async undo() {\n    this.cursor = this.undoCursor;\n  }\n\n  async _next() {\n    this.started = true;\n    let { done, value } = await this.stream.next();\n    if (done) {\n      this._ended = true;\n      if (!value) return Buffer.alloc(0)\n    }\n    if (value) {\n      value = Buffer.from(value);\n    }\n    return value\n  }\n\n  _trim() {\n    // Throw away parts of the buffer we don't need anymore\n    // assert(this.cursor <= this.buffer.length)\n    this.buffer = this.buffer.slice(this.undoCursor);\n    this.cursor -= this.undoCursor;\n    this._discardedBytes += this.undoCursor;\n    this.undoCursor = 0;\n  }\n\n  _moveCursor(n) {\n    this.undoCursor = this.cursor;\n    this.cursor += n;\n    if (this.cursor > this.buffer.length) {\n      this.cursor = this.buffer.length;\n    }\n  }\n\n  async _accumulate(n) {\n    if (this._ended) return\n    // Expand the buffer until we have N bytes of data\n    // or we've reached the end of the stream\n    const buffers = [this.buffer];\n    while (this.cursor + n > lengthBuffers(buffers)) {\n      const nextbuffer = await this._next();\n      if (this._ended) break\n      buffers.push(nextbuffer);\n    }\n    this.buffer = Buffer.concat(buffers);\n  }\n\n  async _loadnext() {\n    this._discardedBytes += this.buffer.length;\n    this.undoCursor = 0;\n    this.cursor = 0;\n    this.buffer = await this._next();\n  }\n\n  async _init() {\n    this.buffer = await this._next();\n  }\n}\n\n// This helper function helps us postpone concatenating buffers, which\n// would create intermediate buffer objects,\nfunction lengthBuffers(buffers) {\n  return buffers.reduce((acc, buffer) => acc + buffer.length, 0)\n}\n\n// My version of git-list-pack - roughly 15x faster than the original\n\nasync function listpack(stream, onData) {\n  const reader = new StreamReader(stream);\n  let PACK = await reader.read(4);\n  PACK = PACK.toString('utf8');\n  if (PACK !== 'PACK') {\n    throw new InternalError(`Invalid PACK header '${PACK}'`)\n  }\n\n  let version = await reader.read(4);\n  version = version.readUInt32BE(0);\n  if (version !== 2) {\n    throw new InternalError(`Invalid packfile version: ${version}`)\n  }\n\n  let numObjects = await reader.read(4);\n  numObjects = numObjects.readUInt32BE(0);\n  // If (for some godforsaken reason) this is an empty packfile, abort now.\n  if (numObjects < 1) return\n\n  while (!reader.eof() && numObjects--) {\n    const offset = reader.tell();\n    const { type, length, ofs, reference } = await parseHeader(reader);\n    const inflator = new pako.Inflate();\n    while (!inflator.result) {\n      const chunk = await reader.chunk();\n      if (!chunk) break\n      inflator.push(chunk, false);\n      if (inflator.err) {\n        throw new InternalError(`Pako error: ${inflator.msg}`)\n      }\n      if (inflator.result) {\n        if (inflator.result.length !== length) {\n          throw new InternalError(\n            `Inflated object size is different from that stated in packfile.`\n          )\n        }\n\n        // Backtrack parser to where deflated data ends\n        await reader.undo();\n        await reader.read(chunk.length - inflator.strm.avail_in);\n        const end = reader.tell();\n        await onData({\n          data: inflator.result,\n          type,\n          num: numObjects,\n          offset,\n          end,\n          reference,\n          ofs,\n        });\n      }\n    }\n  }\n}\n\nasync function parseHeader(reader) {\n  // Object type is encoded in bits 654\n  let byte = await reader.byte();\n  const type = (byte >> 4) & 0b111;\n  // The length encoding get complicated.\n  // Last four bits of length is encoded in bits 3210\n  let length = byte & 0b1111;\n  // Whether the next byte is part of the variable-length encoded number\n  // is encoded in bit 7\n  if (byte & 0b10000000) {\n    let shift = 4;\n    do {\n      byte = await reader.byte();\n      length |= (byte & 0b01111111) << shift;\n      shift += 7;\n    } while (byte & 0b10000000)\n  }\n  // Handle deltified objects\n  let ofs;\n  let reference;\n  if (type === 6) {\n    let shift = 0;\n    ofs = 0;\n    const bytes = [];\n    do {\n      byte = await reader.byte();\n      ofs |= (byte & 0b01111111) << shift;\n      shift += 7;\n      bytes.push(byte);\n    } while (byte & 0b10000000)\n    reference = Buffer.from(bytes);\n  }\n  if (type === 7) {\n    const buf = await reader.read(20);\n    reference = buf;\n  }\n  return { type, length, ofs, reference }\n}\n\n/* eslint-env node, browser */\n\nlet supportsDecompressionStream = false;\n\nasync function inflate(buffer) {\n  if (supportsDecompressionStream === null) {\n    supportsDecompressionStream = testDecompressionStream();\n  }\n  return supportsDecompressionStream\n    ? browserInflate(buffer)\n    : pako.inflate(buffer)\n}\n\nasync function browserInflate(buffer) {\n  const ds = new DecompressionStream('deflate');\n  const d = new Blob([buffer]).stream().pipeThrough(ds);\n  return new Uint8Array(await new Response(d).arrayBuffer())\n}\n\nfunction testDecompressionStream() {\n  try {\n    const ds = new DecompressionStream('deflate');\n    if (ds) return true\n  } catch (_) {\n    // no bother\n  }\n  return false\n}\n\nfunction decodeVarInt(reader) {\n  const bytes = [];\n  let byte = 0;\n  let multibyte = 0;\n  do {\n    byte = reader.readUInt8();\n    // We keep bits 6543210\n    const lastSeven = byte & 0b01111111;\n    bytes.push(lastSeven);\n    // Whether the next byte is part of the variable-length encoded number\n    // is encoded in bit 7\n    multibyte = byte & 0b10000000;\n  } while (multibyte)\n  // Now that all the bytes are in big-endian order,\n  // alternate shifting the bits left by 7 and OR-ing the next byte.\n  // And... do a weird increment-by-one thing that I don't quite understand.\n  return bytes.reduce((a, b) => ((a + 1) << 7) | b, -1)\n}\n\n// I'm pretty much copying this one from the git C source code,\n// because it makes no sense.\nfunction otherVarIntDecode(reader, startWith) {\n  let result = startWith;\n  let shift = 4;\n  let byte = null;\n  do {\n    byte = reader.readUInt8();\n    result |= (byte & 0b01111111) << shift;\n    shift += 7;\n  } while (byte & 0b10000000)\n  return result\n}\n\nclass GitPackIndex {\n  constructor(stuff) {\n    Object.assign(this, stuff);\n    this.offsetCache = {};\n  }\n\n  static async fromIdx({ idx, getExternalRefDelta }) {\n    const reader = new BufferCursor(idx);\n    const magic = reader.slice(4).toString('hex');\n    // Check for IDX v2 magic number\n    if (magic !== 'ff744f63') {\n      return // undefined\n    }\n    const version = reader.readUInt32BE();\n    if (version !== 2) {\n      throw new InternalError(\n        `Unable to read version ${version} packfile IDX. (Only version 2 supported)`\n      )\n    }\n    if (idx.byteLength > 2048 * 1024 * 1024) {\n      throw new InternalError(\n        `To keep implementation simple, I haven't implemented the layer 5 feature needed to support packfiles > 2GB in size.`\n      )\n    }\n    // Skip over fanout table\n    reader.seek(reader.tell() + 4 * 255);\n    // Get hashes\n    const size = reader.readUInt32BE();\n    const hashes = [];\n    for (let i = 0; i < size; i++) {\n      const hash = reader.slice(20).toString('hex');\n      hashes[i] = hash;\n    }\n    reader.seek(reader.tell() + 4 * size);\n    // Skip over CRCs\n    // Get offsets\n    const offsets = new Map();\n    for (let i = 0; i < size; i++) {\n      offsets.set(hashes[i], reader.readUInt32BE());\n    }\n    const packfileSha = reader.slice(20).toString('hex');\n    return new GitPackIndex({\n      hashes,\n      crcs: {},\n      offsets,\n      packfileSha,\n      getExternalRefDelta,\n    })\n  }\n\n  static async fromPack({ pack, getExternalRefDelta, onProgress }) {\n    const listpackTypes = {\n      1: 'commit',\n      2: 'tree',\n      3: 'blob',\n      4: 'tag',\n      6: 'ofs-delta',\n      7: 'ref-delta',\n    };\n    const offsetToObject = {};\n\n    // Older packfiles do NOT use the shasum of the pack itself,\n    // so it is recommended to just use whatever bytes are in the trailer.\n    // Source: https://github.com/git/git/commit/1190a1acf800acdcfd7569f87ac1560e2d077414\n    const packfileSha = pack.slice(-20).toString('hex');\n\n    const hashes = [];\n    const crcs = {};\n    const offsets = new Map();\n    let totalObjectCount = null;\n    let lastPercent = null;\n\n    await listpack([pack], async ({ data, type, reference, offset, num }) => {\n      if (totalObjectCount === null) totalObjectCount = num;\n      const percent = Math.floor(\n        ((totalObjectCount - num) * 100) / totalObjectCount\n      );\n      if (percent !== lastPercent) {\n        if (onProgress) {\n          await onProgress({\n            phase: 'Receiving objects',\n            loaded: totalObjectCount - num,\n            total: totalObjectCount,\n          });\n        }\n      }\n      lastPercent = percent;\n      // Change type from a number to a meaningful string\n      type = listpackTypes[type];\n\n      if (['commit', 'tree', 'blob', 'tag'].includes(type)) {\n        offsetToObject[offset] = {\n          type,\n          offset,\n        };\n      } else if (type === 'ofs-delta') {\n        offsetToObject[offset] = {\n          type,\n          offset,\n        };\n      } else if (type === 'ref-delta') {\n        offsetToObject[offset] = {\n          type,\n          offset,\n        };\n      }\n    });\n\n    // We need to know the lengths of the slices to compute the CRCs.\n    const offsetArray = Object.keys(offsetToObject).map(Number);\n    for (const [i, start] of offsetArray.entries()) {\n      const end =\n        i + 1 === offsetArray.length ? pack.byteLength - 20 : offsetArray[i + 1];\n      const o = offsetToObject[start];\n      const crc = crc32.buf(pack.slice(start, end)) >>> 0;\n      o.end = end;\n      o.crc = crc;\n    }\n\n    // We don't have the hashes yet. But we can generate them using the .readSlice function!\n    const p = new GitPackIndex({\n      pack: Promise.resolve(pack),\n      packfileSha,\n      crcs,\n      hashes,\n      offsets,\n      getExternalRefDelta,\n    });\n\n    // Resolve deltas and compute the oids\n    lastPercent = null;\n    let count = 0;\n    const objectsByDepth = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n    for (let offset in offsetToObject) {\n      offset = Number(offset);\n      const percent = Math.floor((count * 100) / totalObjectCount);\n      if (percent !== lastPercent) {\n        if (onProgress) {\n          await onProgress({\n            phase: 'Resolving deltas',\n            loaded: count,\n            total: totalObjectCount,\n          });\n        }\n      }\n      count++;\n      lastPercent = percent;\n\n      const o = offsetToObject[offset];\n      if (o.oid) continue\n      try {\n        p.readDepth = 0;\n        p.externalReadDepth = 0;\n        const { type, object } = await p.readSlice({ start: offset });\n        objectsByDepth[p.readDepth] += 1;\n        const oid = await shasum(GitObject.wrap({ type, object }));\n        o.oid = oid;\n        hashes.push(oid);\n        offsets.set(oid, offset);\n        crcs[oid] = o.crc;\n      } catch (err) {\n        continue\n      }\n    }\n\n    hashes.sort();\n    return p\n  }\n\n  async toBuffer() {\n    const buffers = [];\n    const write = (str, encoding) => {\n      buffers.push(Buffer.from(str, encoding));\n    };\n    // Write out IDX v2 magic number\n    write('ff744f63', 'hex');\n    // Write out version number 2\n    write('00000002', 'hex');\n    // Write fanout table\n    const fanoutBuffer = new BufferCursor(Buffer.alloc(256 * 4));\n    for (let i = 0; i < 256; i++) {\n      let count = 0;\n      for (const hash of this.hashes) {\n        if (parseInt(hash.slice(0, 2), 16) <= i) count++;\n      }\n      fanoutBuffer.writeUInt32BE(count);\n    }\n    buffers.push(fanoutBuffer.buffer);\n    // Write out hashes\n    for (const hash of this.hashes) {\n      write(hash, 'hex');\n    }\n    // Write out crcs\n    const crcsBuffer = new BufferCursor(Buffer.alloc(this.hashes.length * 4));\n    for (const hash of this.hashes) {\n      crcsBuffer.writeUInt32BE(this.crcs[hash]);\n    }\n    buffers.push(crcsBuffer.buffer);\n    // Write out offsets\n    const offsetsBuffer = new BufferCursor(Buffer.alloc(this.hashes.length * 4));\n    for (const hash of this.hashes) {\n      offsetsBuffer.writeUInt32BE(this.offsets.get(hash));\n    }\n    buffers.push(offsetsBuffer.buffer);\n    // Write out packfile checksum\n    write(this.packfileSha, 'hex');\n    // Write out shasum\n    const totalBuffer = Buffer.concat(buffers);\n    const sha = await shasum(totalBuffer);\n    const shaBuffer = Buffer.alloc(20);\n    shaBuffer.write(sha, 'hex');\n    return Buffer.concat([totalBuffer, shaBuffer])\n  }\n\n  async load({ pack }) {\n    this.pack = pack;\n  }\n\n  async unload() {\n    this.pack = null;\n  }\n\n  async read({ oid }) {\n    if (!this.offsets.get(oid)) {\n      if (this.getExternalRefDelta) {\n        this.externalReadDepth++;\n        return this.getExternalRefDelta(oid)\n      } else {\n        throw new InternalError(`Could not read object ${oid} from packfile`)\n      }\n    }\n    const start = this.offsets.get(oid);\n    return this.readSlice({ start })\n  }\n\n  async readSlice({ start }) {\n    if (this.offsetCache[start]) {\n      return Object.assign({}, this.offsetCache[start])\n    }\n    this.readDepth++;\n    const types = {\n      0b0010000: 'commit',\n      0b0100000: 'tree',\n      0b0110000: 'blob',\n      0b1000000: 'tag',\n      0b1100000: 'ofs_delta',\n      0b1110000: 'ref_delta',\n    };\n    if (!this.pack) {\n      throw new InternalError(\n        'Tried to read from a GitPackIndex with no packfile loaded into memory'\n      )\n    }\n    const raw = (await this.pack).slice(start);\n    const reader = new BufferCursor(raw);\n    const byte = reader.readUInt8();\n    // Object type is encoded in bits 654\n    const btype = byte & 0b1110000;\n    let type = types[btype];\n    if (type === undefined) {\n      throw new InternalError('Unrecognized type: 0b' + btype.toString(2))\n    }\n    // The length encoding get complicated.\n    // Last four bits of length is encoded in bits 3210\n    const lastFour = byte & 0b1111;\n    let length = lastFour;\n    // Whether the next byte is part of the variable-length encoded number\n    // is encoded in bit 7\n    const multibyte = byte & 0b10000000;\n    if (multibyte) {\n      length = otherVarIntDecode(reader, lastFour);\n    }\n    let base = null;\n    let object = null;\n    // Handle deltified objects\n    if (type === 'ofs_delta') {\n      const offset = decodeVarInt(reader);\n      const baseOffset = start - offset\n      ;({ object: base, type } = await this.readSlice({ start: baseOffset }));\n    }\n    if (type === 'ref_delta') {\n      const oid = reader.slice(20).toString('hex')\n      ;({ object: base, type } = await this.read({ oid }));\n    }\n    // Handle undeltified objects\n    const buffer = raw.slice(reader.tell());\n    object = Buffer.from(await inflate(buffer));\n    // Assert that the object length is as expected.\n    if (object.byteLength !== length) {\n      throw new InternalError(\n        `Packfile told us object would have length ${length} but it had length ${object.byteLength}`\n      )\n    }\n    if (base) {\n      object = Buffer.from(applyDelta(object, base));\n    }\n    // Cache the result based on depth.\n    if (this.readDepth > 3) {\n      // hand tuned for speed / memory usage tradeoff\n      this.offsetCache[start] = { type, object };\n    }\n    return { type, format: 'content', object }\n  }\n}\n\nconst PackfileCache = Symbol('PackfileCache');\n\nasync function loadPackIndex({\n  fs,\n  filename,\n  getExternalRefDelta,\n  emitter,\n  emitterPrefix,\n}) {\n  const idx = await fs.read(filename);\n  return GitPackIndex.fromIdx({ idx, getExternalRefDelta })\n}\n\nfunction readPackIndex({\n  fs,\n  cache,\n  filename,\n  getExternalRefDelta,\n  emitter,\n  emitterPrefix,\n}) {\n  // Try to get the packfile index from the in-memory cache\n  if (!cache[PackfileCache]) cache[PackfileCache] = new Map();\n  let p = cache[PackfileCache].get(filename);\n  if (!p) {\n    p = loadPackIndex({\n      fs,\n      filename,\n      getExternalRefDelta,\n      emitter,\n      emitterPrefix,\n    });\n    cache[PackfileCache].set(filename, p);\n  }\n  return p\n}\n\nasync function readObjectPacked({\n  fs,\n  cache,\n  gitdir,\n  oid,\n  format = 'content',\n  getExternalRefDelta,\n}) {\n  // Check to see if it's in a packfile.\n  // Iterate through all the .idx files\n  let list = await fs.readdir(join(gitdir, 'objects/pack'));\n  list = list.filter(x => x.endsWith('.idx'));\n  for (const filename of list) {\n    const indexFile = `${gitdir}/objects/pack/${filename}`;\n    const p = await readPackIndex({\n      fs,\n      cache,\n      filename: indexFile,\n      getExternalRefDelta,\n    });\n    if (p.error) throw new InternalError(p.error)\n    // If the packfile DOES have the oid we're looking for...\n    if (p.offsets.has(oid)) {\n      // Get the resolved git object from the packfile\n      if (!p.pack) {\n        const packFile = indexFile.replace(/idx$/, 'pack');\n        p.pack = fs.read(packFile);\n      }\n      const result = await p.read({ oid, getExternalRefDelta });\n      result.format = 'content';\n      result.source = `objects/pack/${filename.replace(/idx$/, 'pack')}`;\n      return result\n    }\n  }\n  // Failed to find it\n  return null\n}\n\n/**\n * @param {object} args\n * @param {import('../models/FileSystem.js').FileSystem} args.fs\n * @param {any} args.cache\n * @param {string} args.gitdir\n * @param {string} args.oid\n * @param {string} [args.format]\n */\nasync function _readObject({\n  fs,\n  cache,\n  gitdir,\n  oid,\n  format = 'content',\n}) {\n  // Curry the current read method so that the packfile un-deltification\n  // process can acquire external ref-deltas.\n  const getExternalRefDelta = oid => _readObject({ fs, cache, gitdir, oid });\n\n  let result;\n  // Empty tree - hard-coded so we can use it as a shorthand.\n  // Note: I think the canonical git implementation must do this too because\n  // `git cat-file -t 4b825dc642cb6eb9a060e54bf8d69288fbee4904` prints \"tree\" even in empty repos.\n  if (oid === '4b825dc642cb6eb9a060e54bf8d69288fbee4904') {\n    result = { format: 'wrapped', object: Buffer.from(`tree 0\\x00`) };\n  }\n  // Look for it in the loose object directory.\n  if (!result) {\n    result = await readObjectLoose({ fs, gitdir, oid });\n  }\n  // Check to see if it's in a packfile.\n  if (!result) {\n    result = await readObjectPacked({\n      fs,\n      cache,\n      gitdir,\n      oid,\n      getExternalRefDelta,\n    });\n\n    if (!result) {\n      throw new NotFoundError(oid)\n    }\n\n    // Directly return packed result, as specified: packed objects always return the 'content' format.\n    return result\n  }\n\n  // Loose objects are always deflated, return early\n  if (format === 'deflated') {\n    return result\n  }\n\n  // All loose objects are deflated but the hard-coded empty tree is `wrapped` so we have to check if we need to inflate the object.\n  if (result.format === 'deflated') {\n    result.object = Buffer.from(await inflate(result.object));\n    result.format = 'wrapped';\n  }\n\n  if (format === 'wrapped') {\n    return result\n  }\n\n  const sha = await shasum(result.object);\n  if (sha !== oid) {\n    throw new InternalError(\n      `SHA check failed! Expected ${oid}, computed ${sha}`\n    )\n  }\n  const { object, type } = GitObject.unwrap(result.object);\n  result.type = type;\n  result.object = object;\n  result.format = 'content';\n\n  if (format === 'content') {\n    return result\n  }\n\n  throw new InternalError(`invalid requested format \"${format}\"`)\n}\n\nclass AlreadyExistsError extends BaseError {\n  /**\n   * @param {'note'|'remote'|'tag'|'branch'} noun\n   * @param {string} where\n   * @param {boolean} canForce\n   */\n  constructor(noun, where, canForce = true) {\n    super(\n      `Failed to create ${noun} at ${where} because it already exists.${\n        canForce\n          ? ` (Hint: use 'force: true' parameter to overwrite existing ${noun}.)`\n          : ''\n      }`\n    );\n    this.code = this.name = AlreadyExistsError.code;\n    this.data = { noun, where, canForce };\n  }\n}\n/** @type {'AlreadyExistsError'} */\nAlreadyExistsError.code = 'AlreadyExistsError';\n\nclass AmbiguousError extends BaseError {\n  /**\n   * @param {'oids'|'refs'} nouns\n   * @param {string} short\n   * @param {string[]} matches\n   */\n  constructor(nouns, short, matches) {\n    super(\n      `Found multiple ${nouns} matching \"${short}\" (${matches.join(\n        ', '\n      )}). Use a longer abbreviation length to disambiguate them.`\n    );\n    this.code = this.name = AmbiguousError.code;\n    this.data = { nouns, short, matches };\n  }\n}\n/** @type {'AmbiguousError'} */\nAmbiguousError.code = 'AmbiguousError';\n\nclass CheckoutConflictError extends BaseError {\n  /**\n   * @param {string[]} filepaths\n   */\n  constructor(filepaths) {\n    super(\n      `Your local changes to the following files would be overwritten by checkout: ${filepaths.join(\n        ', '\n      )}`\n    );\n    this.code = this.name = CheckoutConflictError.code;\n    this.data = { filepaths };\n  }\n}\n/** @type {'CheckoutConflictError'} */\nCheckoutConflictError.code = 'CheckoutConflictError';\n\nclass CommitNotFetchedError extends BaseError {\n  /**\n   * @param {string} ref\n   * @param {string} oid\n   */\n  constructor(ref, oid) {\n    super(\n      `Failed to checkout \"${ref}\" because commit ${oid} is not available locally. Do a git fetch to make the branch available locally.`\n    );\n    this.code = this.name = CommitNotFetchedError.code;\n    this.data = { ref, oid };\n  }\n}\n/** @type {'CommitNotFetchedError'} */\nCommitNotFetchedError.code = 'CommitNotFetchedError';\n\nclass EmptyServerResponseError extends BaseError {\n  constructor() {\n    super(`Empty response from git server.`);\n    this.code = this.name = EmptyServerResponseError.code;\n    this.data = {};\n  }\n}\n/** @type {'EmptyServerResponseError'} */\nEmptyServerResponseError.code = 'EmptyServerResponseError';\n\nclass FastForwardError extends BaseError {\n  constructor() {\n    super(`A simple fast-forward merge was not possible.`);\n    this.code = this.name = FastForwardError.code;\n    this.data = {};\n  }\n}\n/** @type {'FastForwardError'} */\nFastForwardError.code = 'FastForwardError';\n\nclass GitPushError extends BaseError {\n  /**\n   * @param {string} prettyDetails\n   * @param {PushResult} result\n   */\n  constructor(prettyDetails, result) {\n    super(`One or more branches were not updated: ${prettyDetails}`);\n    this.code = this.name = GitPushError.code;\n    this.data = { prettyDetails, result };\n  }\n}\n/** @type {'GitPushError'} */\nGitPushError.code = 'GitPushError';\n\nclass HttpError extends BaseError {\n  /**\n   * @param {number} statusCode\n   * @param {string} statusMessage\n   * @param {string} response\n   */\n  constructor(statusCode, statusMessage, response) {\n    super(`HTTP Error: ${statusCode} ${statusMessage}`);\n    this.code = this.name = HttpError.code;\n    this.data = { statusCode, statusMessage, response };\n  }\n}\n/** @type {'HttpError'} */\nHttpError.code = 'HttpError';\n\nclass InvalidFilepathError extends BaseError {\n  /**\n   * @param {'leading-slash'|'trailing-slash'|'directory'} [reason]\n   */\n  constructor(reason) {\n    let message = 'invalid filepath';\n    if (reason === 'leading-slash' || reason === 'trailing-slash') {\n      message = `\"filepath\" parameter should not include leading or trailing directory separators because these can cause problems on some platforms.`;\n    } else if (reason === 'directory') {\n      message = `\"filepath\" should not be a directory.`;\n    }\n    super(message);\n    this.code = this.name = InvalidFilepathError.code;\n    this.data = { reason };\n  }\n}\n/** @type {'InvalidFilepathError'} */\nInvalidFilepathError.code = 'InvalidFilepathError';\n\nclass InvalidRefNameError extends BaseError {\n  /**\n   * @param {string} ref\n   * @param {string} suggestion\n   * @param {boolean} canForce\n   */\n  constructor(ref, suggestion) {\n    super(\n      `\"${ref}\" would be an invalid git reference. (Hint: a valid alternative would be \"${suggestion}\".)`\n    );\n    this.code = this.name = InvalidRefNameError.code;\n    this.data = { ref, suggestion };\n  }\n}\n/** @type {'InvalidRefNameError'} */\nInvalidRefNameError.code = 'InvalidRefNameError';\n\nclass MaxDepthError extends BaseError {\n  /**\n   * @param {number} depth\n   */\n  constructor(depth) {\n    super(`Maximum search depth of ${depth} exceeded.`);\n    this.code = this.name = MaxDepthError.code;\n    this.data = { depth };\n  }\n}\n/** @type {'MaxDepthError'} */\nMaxDepthError.code = 'MaxDepthError';\n\nclass MergeNotSupportedError extends BaseError {\n  constructor() {\n    super(`Merges with conflicts are not supported yet.`);\n    this.code = this.name = MergeNotSupportedError.code;\n    this.data = {};\n  }\n}\n/** @type {'MergeNotSupportedError'} */\nMergeNotSupportedError.code = 'MergeNotSupportedError';\n\nclass MergeConflictError extends BaseError {\n  /**\n   * @param {Array<string>} filepaths\n   * @param {Array<string>} bothModified\n   * @param {Array<string>} deleteByUs\n   * @param {Array<string>} deleteByTheirs\n   */\n  constructor(filepaths, bothModified, deleteByUs, deleteByTheirs) {\n    super(\n      `Automatic merge failed with one or more merge conflicts in the following files: ${filepaths.toString()}. Fix conflicts then commit the result.`\n    );\n    this.code = this.name = MergeConflictError.code;\n    this.data = { filepaths, bothModified, deleteByUs, deleteByTheirs };\n  }\n}\n/** @type {'MergeConflictError'} */\nMergeConflictError.code = 'MergeConflictError';\n\nclass MissingNameError extends BaseError {\n  /**\n   * @param {'author'|'committer'|'tagger'} role\n   */\n  constructor(role) {\n    super(\n      `No name was provided for ${role} in the argument or in the .git/config file.`\n    );\n    this.code = this.name = MissingNameError.code;\n    this.data = { role };\n  }\n}\n/** @type {'MissingNameError'} */\nMissingNameError.code = 'MissingNameError';\n\nclass MissingParameterError extends BaseError {\n  /**\n   * @param {string} parameter\n   */\n  constructor(parameter) {\n    super(\n      `The function requires a \"${parameter}\" parameter but none was provided.`\n    );\n    this.code = this.name = MissingParameterError.code;\n    this.data = { parameter };\n  }\n}\n/** @type {'MissingParameterError'} */\nMissingParameterError.code = 'MissingParameterError';\n\nclass MultipleGitError extends BaseError {\n  /**\n   * @param {Error[]} errors\n   * @param {string} message\n   */\n  constructor(errors) {\n    super(\n      `There are multiple errors that were thrown by the method. Please refer to the \"errors\" property to see more`\n    );\n    this.code = this.name = MultipleGitError.code;\n    this.data = { errors };\n    this.errors = errors;\n  }\n}\n/** @type {'MultipleGitError'} */\nMultipleGitError.code = 'MultipleGitError';\n\nclass ParseError extends BaseError {\n  /**\n   * @param {string} expected\n   * @param {string} actual\n   */\n  constructor(expected, actual) {\n    super(`Expected \"${expected}\" but received \"${actual}\".`);\n    this.code = this.name = ParseError.code;\n    this.data = { expected, actual };\n  }\n}\n/** @type {'ParseError'} */\nParseError.code = 'ParseError';\n\nclass PushRejectedError extends BaseError {\n  /**\n   * @param {'not-fast-forward'|'tag-exists'} reason\n   */\n  constructor(reason) {\n    let message = '';\n    if (reason === 'not-fast-forward') {\n      message = ' because it was not a simple fast-forward';\n    } else if (reason === 'tag-exists') {\n      message = ' because tag already exists';\n    }\n    super(`Push rejected${message}. Use \"force: true\" to override.`);\n    this.code = this.name = PushRejectedError.code;\n    this.data = { reason };\n  }\n}\n/** @type {'PushRejectedError'} */\nPushRejectedError.code = 'PushRejectedError';\n\nclass RemoteCapabilityError extends BaseError {\n  /**\n   * @param {'shallow'|'deepen-since'|'deepen-not'|'deepen-relative'} capability\n   * @param {'depth'|'since'|'exclude'|'relative'} parameter\n   */\n  constructor(capability, parameter) {\n    super(\n      `Remote does not support the \"${capability}\" so the \"${parameter}\" parameter cannot be used.`\n    );\n    this.code = this.name = RemoteCapabilityError.code;\n    this.data = { capability, parameter };\n  }\n}\n/** @type {'RemoteCapabilityError'} */\nRemoteCapabilityError.code = 'RemoteCapabilityError';\n\nclass SmartHttpError extends BaseError {\n  /**\n   * @param {string} preview\n   * @param {string} response\n   */\n  constructor(preview, response) {\n    super(\n      `Remote did not reply using the \"smart\" HTTP protocol. Expected \"001e# service=git-upload-pack\" but received: ${preview}`\n    );\n    this.code = this.name = SmartHttpError.code;\n    this.data = { preview, response };\n  }\n}\n/** @type {'SmartHttpError'} */\nSmartHttpError.code = 'SmartHttpError';\n\nclass UnknownTransportError extends BaseError {\n  /**\n   * @param {string} url\n   * @param {string} transport\n   * @param {string} [suggestion]\n   */\n  constructor(url, transport, suggestion) {\n    super(\n      `Git remote \"${url}\" uses an unrecognized transport protocol: \"${transport}\"`\n    );\n    this.code = this.name = UnknownTransportError.code;\n    this.data = { url, transport, suggestion };\n  }\n}\n/** @type {'UnknownTransportError'} */\nUnknownTransportError.code = 'UnknownTransportError';\n\nclass UrlParseError extends BaseError {\n  /**\n   * @param {string} url\n   */\n  constructor(url) {\n    super(`Cannot parse remote URL: \"${url}\"`);\n    this.code = this.name = UrlParseError.code;\n    this.data = { url };\n  }\n}\n/** @type {'UrlParseError'} */\nUrlParseError.code = 'UrlParseError';\n\nclass UserCanceledError extends BaseError {\n  constructor() {\n    super(`The operation was canceled.`);\n    this.code = this.name = UserCanceledError.code;\n    this.data = {};\n  }\n}\n/** @type {'UserCanceledError'} */\nUserCanceledError.code = 'UserCanceledError';\n\nclass IndexResetError extends BaseError {\n  /**\n   * @param {Array<string>} filepaths\n   */\n  constructor(filepath) {\n    super(\n      `Could not merge index: Entry for '${filepath}' is not up to date. Either reset the index entry to HEAD, or stage your unstaged changes.`\n    );\n    this.code = this.name = IndexResetError.code;\n    this.data = { filepath };\n  }\n}\n/** @type {'IndexResetError'} */\nIndexResetError.code = 'IndexResetError';\n\nclass NoCommitError extends BaseError {\n  /**\n   * @param {string} ref\n   */\n  constructor(ref) {\n    super(\n      `\"${ref}\" does not point to any commit. You're maybe working on a repository with no commits yet. `\n    );\n    this.code = this.name = NoCommitError.code;\n    this.data = { ref };\n  }\n}\n/** @type {'NoCommitError'} */\nNoCommitError.code = 'NoCommitError';\n\n\n\nvar Errors = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  AlreadyExistsError: AlreadyExistsError,\n  AmbiguousError: AmbiguousError,\n  CheckoutConflictError: CheckoutConflictError,\n  CommitNotFetchedError: CommitNotFetchedError,\n  EmptyServerResponseError: EmptyServerResponseError,\n  FastForwardError: FastForwardError,\n  GitPushError: GitPushError,\n  HttpError: HttpError,\n  InternalError: InternalError,\n  InvalidFilepathError: InvalidFilepathError,\n  InvalidOidError: InvalidOidError,\n  InvalidRefNameError: InvalidRefNameError,\n  MaxDepthError: MaxDepthError,\n  MergeNotSupportedError: MergeNotSupportedError,\n  MergeConflictError: MergeConflictError,\n  MissingNameError: MissingNameError,\n  MissingParameterError: MissingParameterError,\n  MultipleGitError: MultipleGitError,\n  NoRefspecError: NoRefspecError,\n  NotFoundError: NotFoundError,\n  ObjectTypeError: ObjectTypeError,\n  ParseError: ParseError,\n  PushRejectedError: PushRejectedError,\n  RemoteCapabilityError: RemoteCapabilityError,\n  SmartHttpError: SmartHttpError,\n  UnknownTransportError: UnknownTransportError,\n  UnsafeFilepathError: UnsafeFilepathError,\n  UrlParseError: UrlParseError,\n  UserCanceledError: UserCanceledError,\n  UnmergedPathsError: UnmergedPathsError,\n  IndexResetError: IndexResetError,\n  NoCommitError: NoCommitError\n});\n\nfunction formatAuthor({ name, email, timestamp, timezoneOffset }) {\n  timezoneOffset = formatTimezoneOffset(timezoneOffset);\n  return `${name} <${email}> ${timestamp} ${timezoneOffset}`\n}\n\n// The amount of effort that went into crafting these cases to handle\n// -0 (just so we don't lose that information when parsing and reconstructing)\n// but can also default to +0 was extraordinary.\n\nfunction formatTimezoneOffset(minutes) {\n  const sign = simpleSign(negateExceptForZero(minutes));\n  minutes = Math.abs(minutes);\n  const hours = Math.floor(minutes / 60);\n  minutes -= hours * 60;\n  let strHours = String(hours);\n  let strMinutes = String(minutes);\n  if (strHours.length < 2) strHours = '0' + strHours;\n  if (strMinutes.length < 2) strMinutes = '0' + strMinutes;\n  return (sign === -1 ? '-' : '+') + strHours + strMinutes\n}\n\nfunction simpleSign(n) {\n  return Math.sign(n) || (Object.is(n, -0) ? -1 : 1)\n}\n\nfunction negateExceptForZero(n) {\n  return n === 0 ? n : -n\n}\n\nfunction normalizeNewlines(str) {\n  // remove all <CR>\n  str = str.replace(/\\r/g, '');\n  // no extra newlines up front\n  str = str.replace(/^\\n+/, '');\n  // and a single newline at the end\n  str = str.replace(/\\n+$/, '') + '\\n';\n  return str\n}\n\nfunction parseAuthor(author) {\n  const [, name, email, timestamp, offset] = author.match(\n    /^(.*) <(.*)> (.*) (.*)$/\n  );\n  return {\n    name,\n    email,\n    timestamp: Number(timestamp),\n    timezoneOffset: parseTimezoneOffset(offset),\n  }\n}\n\n// The amount of effort that went into crafting these cases to handle\n// -0 (just so we don't lose that information when parsing and reconstructing)\n// but can also default to +0 was extraordinary.\n\nfunction parseTimezoneOffset(offset) {\n  let [, sign, hours, minutes] = offset.match(/(\\+|-)(\\d\\d)(\\d\\d)/);\n  minutes = (sign === '+' ? 1 : -1) * (Number(hours) * 60 + Number(minutes));\n  return negateExceptForZero$1(minutes)\n}\n\nfunction negateExceptForZero$1(n) {\n  return n === 0 ? n : -n\n}\n\nclass GitAnnotatedTag {\n  constructor(tag) {\n    if (typeof tag === 'string') {\n      this._tag = tag;\n    } else if (Buffer.isBuffer(tag)) {\n      this._tag = tag.toString('utf8');\n    } else if (typeof tag === 'object') {\n      this._tag = GitAnnotatedTag.render(tag);\n    } else {\n      throw new InternalError(\n        'invalid type passed to GitAnnotatedTag constructor'\n      )\n    }\n  }\n\n  static from(tag) {\n    return new GitAnnotatedTag(tag)\n  }\n\n  static render(obj) {\n    return `object ${obj.object}\ntype ${obj.type}\ntag ${obj.tag}\ntagger ${formatAuthor(obj.tagger)}\n\n${obj.message}\n${obj.gpgsig ? obj.gpgsig : ''}`\n  }\n\n  justHeaders() {\n    return this._tag.slice(0, this._tag.indexOf('\\n\\n'))\n  }\n\n  message() {\n    const tag = this.withoutSignature();\n    return tag.slice(tag.indexOf('\\n\\n') + 2)\n  }\n\n  parse() {\n    return Object.assign(this.headers(), {\n      message: this.message(),\n      gpgsig: this.gpgsig(),\n    })\n  }\n\n  render() {\n    return this._tag\n  }\n\n  headers() {\n    const headers = this.justHeaders().split('\\n');\n    const hs = [];\n    for (const h of headers) {\n      if (h[0] === ' ') {\n        // combine with previous header (without space indent)\n        hs[hs.length - 1] += '\\n' + h.slice(1);\n      } else {\n        hs.push(h);\n      }\n    }\n    const obj = {};\n    for (const h of hs) {\n      const key = h.slice(0, h.indexOf(' '));\n      const value = h.slice(h.indexOf(' ') + 1);\n      if (Array.isArray(obj[key])) {\n        obj[key].push(value);\n      } else {\n        obj[key] = value;\n      }\n    }\n    if (obj.tagger) {\n      obj.tagger = parseAuthor(obj.tagger);\n    }\n    if (obj.committer) {\n      obj.committer = parseAuthor(obj.committer);\n    }\n    return obj\n  }\n\n  withoutSignature() {\n    const tag = normalizeNewlines(this._tag);\n    if (tag.indexOf('\\n-----BEGIN PGP SIGNATURE-----') === -1) return tag\n    return tag.slice(0, tag.lastIndexOf('\\n-----BEGIN PGP SIGNATURE-----'))\n  }\n\n  gpgsig() {\n    if (this._tag.indexOf('\\n-----BEGIN PGP SIGNATURE-----') === -1) return\n    const signature = this._tag.slice(\n      this._tag.indexOf('-----BEGIN PGP SIGNATURE-----'),\n      this._tag.indexOf('-----END PGP SIGNATURE-----') +\n        '-----END PGP SIGNATURE-----'.length\n    );\n    return normalizeNewlines(signature)\n  }\n\n  payload() {\n    return this.withoutSignature() + '\\n'\n  }\n\n  toObject() {\n    return Buffer.from(this._tag, 'utf8')\n  }\n\n  static async sign(tag, sign, secretKey) {\n    const payload = tag.payload();\n    let { signature } = await sign({ payload, secretKey });\n    // renormalize the line endings to the one true line-ending\n    signature = normalizeNewlines(signature);\n    const signedTag = payload + signature;\n    // return a new tag object\n    return GitAnnotatedTag.from(signedTag)\n  }\n}\n\nfunction indent(str) {\n  return (\n    str\n      .trim()\n      .split('\\n')\n      .map(x => ' ' + x)\n      .join('\\n') + '\\n'\n  )\n}\n\nfunction outdent(str) {\n  return str\n    .split('\\n')\n    .map(x => x.replace(/^ /, ''))\n    .join('\\n')\n}\n\nclass GitCommit {\n  constructor(commit) {\n    if (typeof commit === 'string') {\n      this._commit = commit;\n    } else if (Buffer.isBuffer(commit)) {\n      this._commit = commit.toString('utf8');\n    } else if (typeof commit === 'object') {\n      this._commit = GitCommit.render(commit);\n    } else {\n      throw new InternalError('invalid type passed to GitCommit constructor')\n    }\n  }\n\n  static fromPayloadSignature({ payload, signature }) {\n    const headers = GitCommit.justHeaders(payload);\n    const message = GitCommit.justMessage(payload);\n    const commit = normalizeNewlines(\n      headers + '\\ngpgsig' + indent(signature) + '\\n' + message\n    );\n    return new GitCommit(commit)\n  }\n\n  static from(commit) {\n    return new GitCommit(commit)\n  }\n\n  toObject() {\n    return Buffer.from(this._commit, 'utf8')\n  }\n\n  // Todo: allow setting the headers and message\n  headers() {\n    return this.parseHeaders()\n  }\n\n  // Todo: allow setting the headers and message\n  message() {\n    return GitCommit.justMessage(this._commit)\n  }\n\n  parse() {\n    return Object.assign({ message: this.message() }, this.headers())\n  }\n\n  static justMessage(commit) {\n    return normalizeNewlines(commit.slice(commit.indexOf('\\n\\n') + 2))\n  }\n\n  static justHeaders(commit) {\n    return commit.slice(0, commit.indexOf('\\n\\n'))\n  }\n\n  parseHeaders() {\n    const headers = GitCommit.justHeaders(this._commit).split('\\n');\n    const hs = [];\n    for (const h of headers) {\n      if (h[0] === ' ') {\n        // combine with previous header (without space indent)\n        hs[hs.length - 1] += '\\n' + h.slice(1);\n      } else {\n        hs.push(h);\n      }\n    }\n    const obj = {\n      parent: [],\n    };\n    for (const h of hs) {\n      const key = h.slice(0, h.indexOf(' '));\n      const value = h.slice(h.indexOf(' ') + 1);\n      if (Array.isArray(obj[key])) {\n        obj[key].push(value);\n      } else {\n        obj[key] = value;\n      }\n    }\n    if (obj.author) {\n      obj.author = parseAuthor(obj.author);\n    }\n    if (obj.committer) {\n      obj.committer = parseAuthor(obj.committer);\n    }\n    return obj\n  }\n\n  static renderHeaders(obj) {\n    let headers = '';\n    if (obj.tree) {\n      headers += `tree ${obj.tree}\\n`;\n    } else {\n      headers += `tree 4b825dc642cb6eb9a060e54bf8d69288fbee4904\\n`; // the null tree\n    }\n    if (obj.parent) {\n      if (obj.parent.length === undefined) {\n        throw new InternalError(`commit 'parent' property should be an array`)\n      }\n      for (const p of obj.parent) {\n        headers += `parent ${p}\\n`;\n      }\n    }\n    const author = obj.author;\n    headers += `author ${formatAuthor(author)}\\n`;\n    const committer = obj.committer || obj.author;\n    headers += `committer ${formatAuthor(committer)}\\n`;\n    if (obj.gpgsig) {\n      headers += 'gpgsig' + indent(obj.gpgsig);\n    }\n    return headers\n  }\n\n  static render(obj) {\n    return GitCommit.renderHeaders(obj) + '\\n' + normalizeNewlines(obj.message)\n  }\n\n  render() {\n    return this._commit\n  }\n\n  withoutSignature() {\n    const commit = normalizeNewlines(this._commit);\n    if (commit.indexOf('\\ngpgsig') === -1) return commit\n    const headers = commit.slice(0, commit.indexOf('\\ngpgsig'));\n    const message = commit.slice(\n      commit.indexOf('-----END PGP SIGNATURE-----\\n') +\n        '-----END PGP SIGNATURE-----\\n'.length\n    );\n    return normalizeNewlines(headers + '\\n' + message)\n  }\n\n  isolateSignature() {\n    const signature = this._commit.slice(\n      this._commit.indexOf('-----BEGIN PGP SIGNATURE-----'),\n      this._commit.indexOf('-----END PGP SIGNATURE-----') +\n        '-----END PGP SIGNATURE-----'.length\n    );\n    return outdent(signature)\n  }\n\n  static async sign(commit, sign, secretKey) {\n    const payload = commit.withoutSignature();\n    const message = GitCommit.justMessage(commit._commit);\n    let { signature } = await sign({ payload, secretKey });\n    // renormalize the line endings to the one true line-ending\n    signature = normalizeNewlines(signature);\n    const headers = GitCommit.justHeaders(commit._commit);\n    const signedCommit =\n      headers + '\\n' + 'gpgsig' + indent(signature) + '\\n' + message;\n    // return a new commit object\n    return GitCommit.from(signedCommit)\n  }\n}\n\nasync function resolveTree({ fs, cache, gitdir, oid }) {\n  // Empty tree - bypass `readObject`\n  if (oid === '4b825dc642cb6eb9a060e54bf8d69288fbee4904') {\n    return { tree: GitTree.from([]), oid }\n  }\n  const { type, object } = await _readObject({ fs, cache, gitdir, oid });\n  // Resolve annotated tag objects to whatever\n  if (type === 'tag') {\n    oid = GitAnnotatedTag.from(object).parse().object;\n    return resolveTree({ fs, cache, gitdir, oid })\n  }\n  // Resolve commits to trees\n  if (type === 'commit') {\n    oid = GitCommit.from(object).parse().tree;\n    return resolveTree({ fs, cache, gitdir, oid })\n  }\n  if (type !== 'tree') {\n    throw new ObjectTypeError(oid, type, 'tree')\n  }\n  return { tree: GitTree.from(object), oid }\n}\n\nclass GitWalkerRepo {\n  constructor({ fs, gitdir, ref, cache }) {\n    this.fs = fs;\n    this.cache = cache;\n    this.gitdir = gitdir;\n    this.mapPromise = (async () => {\n      const map = new Map();\n      let oid;\n      try {\n        oid = await GitRefManager.resolve({ fs, gitdir, ref });\n      } catch (e) {\n        if (e instanceof NotFoundError) {\n          // Handle fresh branches with no commits\n          oid = '4b825dc642cb6eb9a060e54bf8d69288fbee4904';\n        }\n      }\n      const tree = await resolveTree({ fs, cache: this.cache, gitdir, oid });\n      tree.type = 'tree';\n      tree.mode = '40000';\n      map.set('.', tree);\n      return map\n    })();\n    const walker = this;\n    this.ConstructEntry = class TreeEntry {\n      constructor(fullpath) {\n        this._fullpath = fullpath;\n        this._type = false;\n        this._mode = false;\n        this._stat = false;\n        this._content = false;\n        this._oid = false;\n      }\n\n      async type() {\n        return walker.type(this)\n      }\n\n      async mode() {\n        return walker.mode(this)\n      }\n\n      async stat() {\n        return walker.stat(this)\n      }\n\n      async content() {\n        return walker.content(this)\n      }\n\n      async oid() {\n        return walker.oid(this)\n      }\n    };\n  }\n\n  async readdir(entry) {\n    const filepath = entry._fullpath;\n    const { fs, cache, gitdir } = this;\n    const map = await this.mapPromise;\n    const obj = map.get(filepath);\n    if (!obj) throw new Error(`No obj for ${filepath}`)\n    const oid = obj.oid;\n    if (!oid) throw new Error(`No oid for obj ${JSON.stringify(obj)}`)\n    if (obj.type !== 'tree') {\n      // TODO: support submodules (type === 'commit')\n      return null\n    }\n    const { type, object } = await _readObject({ fs, cache, gitdir, oid });\n    if (type !== obj.type) {\n      throw new ObjectTypeError(oid, type, obj.type)\n    }\n    const tree = GitTree.from(object);\n    // cache all entries\n    for (const entry of tree) {\n      map.set(join(filepath, entry.path), entry);\n    }\n    return tree.entries().map(entry => join(filepath, entry.path))\n  }\n\n  async type(entry) {\n    if (entry._type === false) {\n      const map = await this.mapPromise;\n      const { type } = map.get(entry._fullpath);\n      entry._type = type;\n    }\n    return entry._type\n  }\n\n  async mode(entry) {\n    if (entry._mode === false) {\n      const map = await this.mapPromise;\n      const { mode } = map.get(entry._fullpath);\n      entry._mode = normalizeMode(parseInt(mode, 8));\n    }\n    return entry._mode\n  }\n\n  async stat(_entry) {}\n\n  async content(entry) {\n    if (entry._content === false) {\n      const map = await this.mapPromise;\n      const { fs, cache, gitdir } = this;\n      const obj = map.get(entry._fullpath);\n      const oid = obj.oid;\n      const { type, object } = await _readObject({ fs, cache, gitdir, oid });\n      if (type !== 'blob') {\n        entry._content = undefined;\n      } else {\n        entry._content = new Uint8Array(object);\n      }\n    }\n    return entry._content\n  }\n\n  async oid(entry) {\n    if (entry._oid === false) {\n      const map = await this.mapPromise;\n      const obj = map.get(entry._fullpath);\n      entry._oid = obj.oid;\n    }\n    return entry._oid\n  }\n}\n\n// @ts-check\n\n/**\n * @param {object} args\n * @param {string} [args.ref='HEAD']\n * @returns {Walker}\n */\nfunction TREE({ ref = 'HEAD' } = {}) {\n  const o = Object.create(null);\n  Object.defineProperty(o, GitWalkSymbol, {\n    value: function ({ fs, gitdir, cache }) {\n      return new GitWalkerRepo({ fs, gitdir, ref, cache })\n    },\n  });\n  Object.freeze(o);\n  return o\n}\n\n// @ts-check\n\nclass GitWalkerFs {\n  constructor({ fs, dir, gitdir, cache }) {\n    this.fs = fs;\n    this.cache = cache;\n    this.dir = dir;\n    this.gitdir = gitdir;\n\n    this.config = null;\n    const walker = this;\n    this.ConstructEntry = class WorkdirEntry {\n      constructor(fullpath) {\n        this._fullpath = fullpath;\n        this._type = false;\n        this._mode = false;\n        this._stat = false;\n        this._content = false;\n        this._oid = false;\n      }\n\n      async type() {\n        return walker.type(this)\n      }\n\n      async mode() {\n        return walker.mode(this)\n      }\n\n      async stat() {\n        return walker.stat(this)\n      }\n\n      async content() {\n        return walker.content(this)\n      }\n\n      async oid() {\n        return walker.oid(this)\n      }\n    };\n  }\n\n  async readdir(entry) {\n    const filepath = entry._fullpath;\n    const { fs, dir } = this;\n    const names = await fs.readdir(join(dir, filepath));\n    if (names === null) return null\n    return names.map(name => join(filepath, name))\n  }\n\n  async type(entry) {\n    if (entry._type === false) {\n      await entry.stat();\n    }\n    return entry._type\n  }\n\n  async mode(entry) {\n    if (entry._mode === false) {\n      await entry.stat();\n    }\n    return entry._mode\n  }\n\n  async stat(entry) {\n    if (entry._stat === false) {\n      const { fs, dir } = this;\n      let stat = await fs.lstat(`${dir}/${entry._fullpath}`);\n      if (!stat) {\n        throw new Error(\n          `ENOENT: no such file or directory, lstat '${entry._fullpath}'`\n        )\n      }\n      let type = stat.isDirectory() ? 'tree' : 'blob';\n      if (type === 'blob' && !stat.isFile() && !stat.isSymbolicLink()) {\n        type = 'special';\n      }\n      entry._type = type;\n      stat = normalizeStats(stat);\n      entry._mode = stat.mode;\n      // workaround for a BrowserFS edge case\n      if (stat.size === -1 && entry._actualSize) {\n        stat.size = entry._actualSize;\n      }\n      entry._stat = stat;\n    }\n    return entry._stat\n  }\n\n  async content(entry) {\n    if (entry._content === false) {\n      const { fs, dir, gitdir } = this;\n      if ((await entry.type()) === 'tree') {\n        entry._content = undefined;\n      } else {\n        const config = await this._getGitConfig(fs, gitdir);\n        const autocrlf = await config.get('core.autocrlf');\n        const content = await fs.read(`${dir}/${entry._fullpath}`, { autocrlf });\n        // workaround for a BrowserFS edge case\n        entry._actualSize = content.length;\n        if (entry._stat && entry._stat.size === -1) {\n          entry._stat.size = entry._actualSize;\n        }\n        entry._content = new Uint8Array(content);\n      }\n    }\n    return entry._content\n  }\n\n  async oid(entry) {\n    if (entry._oid === false) {\n      const self = this;\n      const { fs, gitdir, cache } = this;\n      let oid;\n      // See if we can use the SHA1 hash in the index.\n      await GitIndexManager.acquire(\n        { fs, gitdir, cache },\n        async function (index) {\n          const stage = index.entriesMap.get(entry._fullpath);\n          const stats = await entry.stat();\n          const config = await self._getGitConfig(fs, gitdir);\n          const filemode = await config.get('core.filemode');\n          const trustino =\n            typeof process !== 'undefined'\n              ? !(process.platform === 'win32')\n              : true;\n          if (!stage || compareStats(stats, stage, filemode, trustino)) {\n            const content = await entry.content();\n            if (content === undefined) {\n              oid = undefined;\n            } else {\n              oid = await shasum(\n                GitObject.wrap({ type: 'blob', object: content })\n              );\n              // Update the stats in the index so we will get a \"cache hit\" next time\n              // 1) if we can (because the oid and mode are the same)\n              // 2) and only if we need to (because other stats differ)\n              if (\n                stage &&\n                oid === stage.oid &&\n                (!filemode || stats.mode === stage.mode) &&\n                compareStats(stats, stage, filemode, trustino)\n              ) {\n                index.insert({\n                  filepath: entry._fullpath,\n                  stats,\n                  oid,\n                });\n              }\n            }\n          } else {\n            // Use the index SHA1 rather than compute it\n            oid = stage.oid;\n          }\n        }\n      );\n      entry._oid = oid;\n    }\n    return entry._oid\n  }\n\n  async _getGitConfig(fs, gitdir) {\n    if (this.config) {\n      return this.config\n    }\n    this.config = await GitConfigManager.get({ fs, gitdir });\n    return this.config\n  }\n}\n\n// @ts-check\n\n/**\n * @returns {Walker}\n */\nfunction WORKDIR() {\n  const o = Object.create(null);\n  Object.defineProperty(o, GitWalkSymbol, {\n    value: function ({ fs, dir, gitdir, cache }) {\n      return new GitWalkerFs({ fs, dir, gitdir, cache })\n    },\n  });\n  Object.freeze(o);\n  return o\n}\n\n// @ts-check\n\n// https://dev.to/namirsab/comment/2050\nfunction arrayRange(start, end) {\n  const length = end - start;\n  return Array.from({ length }, (_, i) => start + i)\n}\n\n// TODO: Should I just polyfill Array.flat?\nconst flat =\n  typeof Array.prototype.flat === 'undefined'\n    ? entries => entries.reduce((acc, x) => acc.concat(x), [])\n    : entries => entries.flat();\n\n// This is convenient for computing unions/joins of sorted lists.\nclass RunningMinimum {\n  constructor() {\n    // Using a getter for 'value' would just bloat the code.\n    // You know better than to set it directly right?\n    this.value = null;\n  }\n\n  consider(value) {\n    if (value === null || value === undefined) return\n    if (this.value === null) {\n      this.value = value;\n    } else if (value < this.value) {\n      this.value = value;\n    }\n  }\n\n  reset() {\n    this.value = null;\n  }\n}\n\n// Take an array of length N of\n//   iterators of length Q_n\n//     of strings\n// and return an iterator of length max(Q_n) for all n\n//   of arrays of length N\n//     of string|null who all have the same string value\nfunction* unionOfIterators(sets) {\n  /* NOTE: We can assume all arrays are sorted.\n   * Indexes are sorted because they are defined that way:\n   *\n   * > Index entries are sorted in ascending order on the name field,\n   * > interpreted as a string of unsigned bytes (i.e. memcmp() order, no\n   * > localization, no special casing of directory separator '/'). Entries\n   * > with the same name are sorted by their stage field.\n   *\n   * Trees should be sorted because they are created directly from indexes.\n   * They definitely should be sorted, or else they wouldn't have a unique SHA1.\n   * So that would be very naughty on the part of the tree-creator.\n   *\n   * Lastly, the working dir entries are sorted because I choose to sort them\n   * in my FileSystem.readdir() implementation.\n   */\n\n  // Init\n  const min = new RunningMinimum();\n  let minimum;\n  const heads = [];\n  const numsets = sets.length;\n  for (let i = 0; i < numsets; i++) {\n    // Abuse the fact that iterators continue to return 'undefined' for value\n    // once they are done\n    heads[i] = sets[i].next().value;\n    if (heads[i] !== undefined) {\n      min.consider(heads[i]);\n    }\n  }\n  if (min.value === null) return\n  // Iterate\n  while (true) {\n    const result = [];\n    minimum = min.value;\n    min.reset();\n    for (let i = 0; i < numsets; i++) {\n      if (heads[i] !== undefined && heads[i] === minimum) {\n        result[i] = heads[i];\n        heads[i] = sets[i].next().value;\n      } else {\n        // A little hacky, but eh\n        result[i] = null;\n      }\n      if (heads[i] !== undefined) {\n        min.consider(heads[i]);\n      }\n    }\n    yield result;\n    if (min.value === null) return\n  }\n}\n\n// @ts-check\n\n/**\n * @param {object} args\n * @param {import('../models/FileSystem.js').FileSystem} args.fs\n * @param {object} args.cache\n * @param {string} [args.dir]\n * @param {string} [args.gitdir=join(dir,'.git')]\n * @param {Walker[]} args.trees\n * @param {WalkerMap} [args.map]\n * @param {WalkerReduce} [args.reduce]\n * @param {WalkerIterate} [args.iterate]\n *\n * @returns {Promise<any>} The finished tree-walking result\n *\n * @see {WalkerMap}\n *\n */\nasync function _walk({\n  fs,\n  cache,\n  dir,\n  gitdir,\n  trees,\n  // @ts-ignore\n  map = async (_, entry) => entry,\n  // The default reducer is a flatmap that filters out undefineds.\n  reduce = async (parent, children) => {\n    const flatten = flat(children);\n    if (parent !== undefined) flatten.unshift(parent);\n    return flatten\n  },\n  // The default iterate function walks all children concurrently\n  iterate = (walk, children) => Promise.all([...children].map(walk)),\n}) {\n  const walkers = trees.map(proxy =>\n    proxy[GitWalkSymbol]({ fs, dir, gitdir, cache })\n  );\n\n  const root = new Array(walkers.length).fill('.');\n  const range = arrayRange(0, walkers.length);\n  const unionWalkerFromReaddir = async entries => {\n    range.forEach(i => {\n      const entry = entries[i];\n      entries[i] = entry && new walkers[i].ConstructEntry(entry);\n    });\n    const subdirs = await Promise.all(\n      range.map(i => {\n        const entry = entries[i];\n        return entry ? walkers[i].readdir(entry) : []\n      })\n    );\n    // Now process child directories\n    const iterators = subdirs.map(array => {\n      return (array === null ? [] : array)[Symbol.iterator]()\n    });\n\n    return {\n      entries,\n      children: unionOfIterators(iterators),\n    }\n  };\n\n  const walk = async root => {\n    const { entries, children } = await unionWalkerFromReaddir(root);\n    const fullpath = entries.find(entry => entry && entry._fullpath)._fullpath;\n    const parent = await map(fullpath, entries);\n    if (parent !== null) {\n      let walkedChildren = await iterate(walk, children);\n      walkedChildren = walkedChildren.filter(x => x !== undefined);\n      return reduce(parent, walkedChildren)\n    }\n  };\n  return walk(root)\n}\n\n/**\n * Removes the directory at the specified filepath recursively. Used internally to replicate the behavior of\n * fs.promises.rm({ recursive: true, force: true }) from Node.js 14 and above when not available. If the provided\n * filepath resolves to a file, it will be removed.\n *\n * @param {import('../models/FileSystem.js').FileSystem} fs\n * @param {string} filepath - The file or directory to remove.\n */\nasync function rmRecursive(fs, filepath) {\n  const entries = await fs.readdir(filepath);\n  if (entries == null) {\n    await fs.rm(filepath);\n  } else if (entries.length) {\n    await Promise.all(\n      entries.map(entry => {\n        const subpath = join(filepath, entry);\n        return fs.lstat(subpath).then(stat => {\n          if (!stat) return\n          return stat.isDirectory() ? rmRecursive(fs, subpath) : fs.rm(subpath)\n        })\n      })\n    ).then(() => fs.rmdir(filepath));\n  } else {\n    await fs.rmdir(filepath);\n  }\n}\n\nfunction isPromiseLike(obj) {\n  return isObject(obj) && isFunction(obj.then) && isFunction(obj.catch)\n}\n\nfunction isObject(obj) {\n  return obj && typeof obj === 'object'\n}\n\nfunction isFunction(obj) {\n  return typeof obj === 'function'\n}\n\nfunction isPromiseFs(fs) {\n  const test = targetFs => {\n    try {\n      // If readFile returns a promise then we can probably assume the other\n      // commands do as well\n      return targetFs.readFile().catch(e => e)\n    } catch (e) {\n      return e\n    }\n  };\n  return isPromiseLike(test(fs))\n}\n\n// List of commands all filesystems are expected to provide. `rm` is not\n// included since it may not exist and must be handled as a special case\nconst commands = [\n  'cp',\n  'readFile',\n  'writeFile',\n  'mkdir',\n  'rmdir',\n  'unlink',\n  'stat',\n  'lstat',\n  'readdir',\n  'readlink',\n  'symlink',\n];\n\nfunction bindFs(target, fs) {\n  if (isPromiseFs(fs)) {\n    for (const command of commands) {\n      target[`_${command}`] = fs[command].bind(fs);\n    }\n  } else {\n    for (const command of commands) {\n      target[`_${command}`] = pify(fs[command].bind(fs));\n    }\n  }\n\n  // Handle the special case of `rm`\n  if (isPromiseFs(fs)) {\n    if (fs.rm) target._rm = fs.rm.bind(fs);\n    else if (fs.rmdir.length > 1) target._rm = fs.rmdir.bind(fs);\n    else target._rm = rmRecursive.bind(null, target);\n  } else {\n    if (fs.rm) target._rm = pify(fs.rm.bind(fs));\n    else if (fs.rmdir.length > 2) target._rm = pify(fs.rmdir.bind(fs));\n    else target._rm = rmRecursive.bind(null, target);\n  }\n}\n\n/**\n * A wrapper class for file system operations, providing a consistent API for both promise-based\n * and callback-based file systems. It includes utility methods for common file system tasks.\n */\nclass FileSystem {\n  /**\n   * Creates an instance of FileSystem.\n   *\n   * @param {Object} fs - A file system implementation to wrap.\n   */\n  constructor(fs) {\n    if (typeof fs._original_unwrapped_fs !== 'undefined') return fs\n\n    const promises = Object.getOwnPropertyDescriptor(fs, 'promises');\n    if (promises && promises.enumerable) {\n      bindFs(this, fs.promises);\n    } else {\n      bindFs(this, fs);\n    }\n    this._original_unwrapped_fs = fs;\n  }\n\n  /**\n   * Return true if a file exists, false if it doesn't exist.\n   * Rethrows errors that aren't related to file existence.\n   *\n   * @param {string} filepath - The path to the file.\n   * @param {Object} [options] - Additional options.\n   * @returns {Promise<boolean>} - `true` if the file exists, `false` otherwise.\n   */\n  async exists(filepath, options = {}) {\n    try {\n      await this._stat(filepath);\n      return true\n    } catch (err) {\n      if (\n        err.code === 'ENOENT' ||\n        err.code === 'ENOTDIR' ||\n        (err.code || '').includes('ENS')\n      ) {\n        return false\n      } else {\n        console.log('Unhandled error in \"FileSystem.exists()\" function', err);\n        throw err\n      }\n    }\n  }\n\n  /**\n   * Return the contents of a file if it exists, otherwise returns null.\n   *\n   * @param {string} filepath - The path to the file.\n   * @param {Object} [options] - Options for reading the file.\n   * @returns {Promise<Buffer|string|null>} - The file contents, or `null` if the file doesn't exist.\n   */\n  async read(filepath, options = {}) {\n    try {\n      let buffer = await this._readFile(filepath, options);\n      if (options.autocrlf === 'true') {\n        try {\n          buffer = new TextDecoder('utf8', { fatal: true }).decode(buffer);\n          buffer = buffer.replace(/\\r\\n/g, '\\n');\n          buffer = new TextEncoder().encode(buffer);\n        } catch (error) {\n          // non utf8 file\n        }\n      }\n      // Convert plain ArrayBuffers to Buffers\n      if (typeof buffer !== 'string') {\n        buffer = Buffer.from(buffer);\n      }\n      return buffer\n    } catch (err) {\n      return null\n    }\n  }\n\n  /**\n   * Write a file (creating missing directories if need be) without throwing errors.\n   *\n   * @param {string} filepath - The path to the file.\n   * @param {Buffer|Uint8Array|string} contents - The data to write.\n   * @param {Object|string} [options] - Options for writing the file.\n   * @returns {Promise<void>}\n   */\n  async write(filepath, contents, options = {}) {\n    try {\n      await this._writeFile(filepath, contents, options);\n    } catch (err) {\n      // Hmm. Let's try mkdirp and try again.\n      await this.mkdir(dirname(filepath));\n      await this._writeFile(filepath, contents, options);\n    }\n  }\n\n  /**\n   * Make a directory (or series of nested directories) without throwing an error if it already exists.\n   *\n   * @param {string} filepath - The path to the directory.\n   * @param {boolean} [_selfCall=false] - Internal flag to prevent infinite recursion.\n   * @returns {Promise<void>}\n   */\n  async mkdir(filepath, _selfCall = false) {\n    try {\n      await this._mkdir(filepath);\n    } catch (err) {\n      // If err is null then operation succeeded!\n      if (err === null) return\n      // If the directory already exists, that's OK!\n      if (err.code === 'EEXIST') return\n      // Avoid infinite loops of failure\n      if (_selfCall) throw err\n      // If we got a \"no such file or directory error\" backup and try again.\n      if (err.code === 'ENOENT') {\n        const parent = dirname(filepath);\n        // Check to see if we've gone too far\n        if (parent === '.' || parent === '/' || parent === filepath) throw err\n        // Infinite recursion, what could go wrong?\n        await this.mkdir(parent);\n        await this.mkdir(filepath, true);\n      }\n    }\n  }\n\n  /**\n   * Delete a file without throwing an error if it is already deleted.\n   *\n   * @param {string} filepath - The path to the file.\n   * @returns {Promise<void>}\n   */\n  async rm(filepath) {\n    try {\n      await this._unlink(filepath);\n    } catch (err) {\n      if (err.code !== 'ENOENT') throw err\n    }\n  }\n\n  /**\n   * Delete a directory without throwing an error if it is already deleted.\n   *\n   * @param {string} filepath - The path to the directory.\n   * @param {Object} [opts] - Options for deleting the directory.\n   * @returns {Promise<void>}\n   */\n  async rmdir(filepath, opts) {\n    try {\n      if (opts && opts.recursive) {\n        await this._rm(filepath, opts);\n      } else {\n        await this._rmdir(filepath);\n      }\n    } catch (err) {\n      if (err.code !== 'ENOENT') throw err\n    }\n  }\n\n  /**\n   * Read a directory without throwing an error is the directory doesn't exist\n   *\n   * @param {string} filepath - The path to the directory.\n   * @returns {Promise<string[]|null>} - An array of file names, or `null` if the path is not a directory.\n   */\n  async readdir(filepath) {\n    try {\n      const names = await this._readdir(filepath);\n      // Ordering is not guaranteed, and system specific (Windows vs Unix)\n      // so we must sort them ourselves.\n      names.sort(compareStrings);\n      return names\n    } catch (err) {\n      if (err.code === 'ENOTDIR') return null\n      return []\n    }\n  }\n\n  /**\n   * Return a flat list of all the files nested inside a directory\n   *\n   * Based on an elegant concurrent recursive solution from SO\n   * https://stackoverflow.com/a/45130990/2168416\n   *\n   * @param {string} dir - The directory to read.\n   * @returns {Promise<string[]>} - A flat list of all files in the directory.\n   */\n  async readdirDeep(dir) {\n    const subdirs = await this._readdir(dir);\n    const files = await Promise.all(\n      subdirs.map(async subdir => {\n        const res = dir + '/' + subdir;\n        return (await this._stat(res)).isDirectory()\n          ? this.readdirDeep(res)\n          : res\n      })\n    );\n    return files.reduce((a, f) => a.concat(f), [])\n  }\n\n  /**\n   * Return the Stats of a file/symlink if it exists, otherwise returns null.\n   * Rethrows errors that aren't related to file existence.\n   *\n   * @param {string} filename - The path to the file or symlink.\n   * @returns {Promise<Object|null>} - The stats object, or `null` if the file doesn't exist.\n   */\n  async lstat(filename) {\n    try {\n      const stats = await this._lstat(filename);\n      return stats\n    } catch (err) {\n      if (err.code === 'ENOENT' || (err.code || '').includes('ENS')) {\n        return null\n      }\n      throw err\n    }\n  }\n\n  /**\n   * Reads the contents of a symlink if it exists, otherwise returns null.\n   * Rethrows errors that aren't related to file existence.\n   *\n   * @param {string} filename - The path to the symlink.\n   * @param {Object} [opts={ encoding: 'buffer' }] - Options for reading the symlink.\n   * @returns {Promise<Buffer|null>} - The symlink target, or `null` if it doesn't exist.\n   */\n  async readlink(filename, opts = { encoding: 'buffer' }) {\n    // Note: FileSystem.readlink returns a buffer by default\n    // so we can dump it into GitObject.write just like any other file.\n    try {\n      const link = await this._readlink(filename, opts);\n      return Buffer.isBuffer(link) ? link : Buffer.from(link)\n    } catch (err) {\n      if (err.code === 'ENOENT' || (err.code || '').includes('ENS')) {\n        return null\n      }\n      throw err\n    }\n  }\n\n  /**\n   * Write the contents of buffer to a symlink.\n   *\n   * @param {string} filename - The path to the symlink.\n   * @param {Buffer} buffer - The symlink target.\n   * @returns {Promise<void>}\n   */\n  async writelink(filename, buffer) {\n    return this._symlink(buffer.toString('utf8'), filename)\n  }\n}\n\nfunction assertParameter(name, value) {\n  if (value === undefined) {\n    throw new MissingParameterError(name)\n  }\n}\n\n/**\n * discoverGitdir\n *\n * When processing git commands on a submodule determine\n * the actual git directory based on the contents of the .git file.\n *\n * Otherwise (if sent a directory) return that directory as-is.\n *\n * A decision has to be made \"in what layer will submodules be interpreted,\n * and then after that, where can the code can just stay exactly the same as before.\"\n * This implementation processes submodules in the front-end location of src/api/.\n * The backend of src/commands/ isn't modified. This keeps a clear division\n * of responsibilities and should be maintained.\n *\n * A consequence is that __tests__ must occasionally be informed\n * about submodules also, since those call src/commands/ directly.\n *\n *\n */\n\nasync function discoverGitdir({ fsp, dotgit }) {\n  assertParameter('fsp', fsp);\n  assertParameter('dotgit', dotgit);\n\n  const dotgitStat = await fsp\n    ._stat(dotgit)\n    .catch(() => ({ isFile: () => false, isDirectory: () => false }));\n  if (dotgitStat.isDirectory()) {\n    return dotgit\n  } else if (dotgitStat.isFile()) {\n    return fsp\n      ._readFile(dotgit, 'utf8')\n      .then(contents => contents.trimRight().substr(8))\n      .then(submoduleGitdir => {\n        const gitdir = join(dirname(dotgit), submoduleGitdir);\n        return gitdir\n      })\n  } else {\n    // Neither a file nor a directory. This correlates to a \"git init\" scenario where it's empty.\n    // This is the expected result for normal repos, and indeterminate for submodules, but\n    // would be unusual with submodules.\n    return dotgit\n  }\n}\n\n// @ts-check\n/**\n *\n * @param {WalkerEntry} entry\n * @param {WalkerEntry} base\n *\n */\nasync function modified(entry, base) {\n  if (!entry && !base) return false\n  if (entry && !base) return true\n  if (!entry && base) return true\n  if ((await entry.type()) === 'tree' && (await base.type()) === 'tree') {\n    return false\n  }\n  if (\n    (await entry.type()) === (await base.type()) &&\n    (await entry.mode()) === (await base.mode()) &&\n    (await entry.oid()) === (await base.oid())\n  ) {\n    return false\n  }\n  return true\n}\n\n// @ts-check\n\n/**\n * Abort a merge in progress.\n *\n * Based on the behavior of git reset --merge, i.e.  \"Resets the index and updates the files in the working tree that are different between <commit> and HEAD, but keeps those which are different between the index and working tree (i.e. which have changes which have not been added). If a file that is different between <commit> and the index has unstaged changes, reset is aborted.\"\n *\n * Essentially, abortMerge will reset any files affected by merge conflicts to their last known good version at HEAD.\n * Any unstaged changes are saved and any staged changes are reset as well.\n *\n * NOTE: The behavior of this command differs slightly from canonical git in that an error will be thrown if a file exists in the index and nowhere else.\n * Canonical git will reset the file and continue aborting the merge in this case.\n *\n * **WARNING:** Running git merge with non-trivial uncommitted changes is discouraged: while possible, it may leave you in a state that is hard to back out of in the case of a conflict.\n * If there were uncommitted changes when the merge started (and especially if those changes were further modified after the merge was started), `git.abortMerge` will in some cases be unable to reconstruct the original (pre-merge) changes.\n *\n * @param {object} args\n * @param {FsClient} args.fs - a file system implementation\n * @param {string} args.dir - The [working tree](dir-vs-gitdir.md) directory path\n * @param {string} [args.gitdir=join(dir, '.git')] - [required] The [git directory](dir-vs-gitdir.md) path\n * @param {string} [args.commit='HEAD'] - commit to reset the index and worktree to, defaults to HEAD\n * @param {object} [args.cache] - a [cache](cache.md) object\n *\n * @returns {Promise<void>} Resolves successfully once the git index has been updated\n *\n */\nasync function abortMerge({\n  fs: _fs,\n  dir,\n  gitdir = join(dir, '.git'),\n  commit = 'HEAD',\n  cache = {},\n}) {\n  try {\n    assertParameter('fs', _fs);\n    assertParameter('dir', dir);\n    assertParameter('gitdir', gitdir);\n\n    const fs = new FileSystem(_fs);\n    const trees = [TREE({ ref: commit }), WORKDIR(), STAGE()];\n    let unmergedPaths = [];\n\n    const updatedGitdir = await discoverGitdir({ fsp: fs, dotgit: gitdir });\n    await GitIndexManager.acquire(\n      { fs, gitdir: updatedGitdir, cache },\n      async function (index) {\n        unmergedPaths = index.unmergedPaths;\n      }\n    );\n\n    const results = await _walk({\n      fs,\n      cache,\n      dir,\n      gitdir: updatedGitdir,\n      trees,\n      map: async function (path, [head, workdir, index]) {\n        const staged = !(await modified(workdir, index));\n        const unmerged = unmergedPaths.includes(path);\n        const unmodified = !(await modified(index, head));\n\n        if (staged || unmerged) {\n          return head\n            ? {\n                path,\n                mode: await head.mode(),\n                oid: await head.oid(),\n                type: await head.type(),\n                content: await head.content(),\n              }\n            : undefined\n        }\n\n        if (unmodified) return false\n        else throw new IndexResetError(path)\n      },\n    });\n\n    await GitIndexManager.acquire(\n      { fs, gitdir: updatedGitdir, cache },\n      async function (index) {\n        // Reset paths in index and worktree, this can't be done in _walk because the\n        // STAGE walker acquires its own index lock.\n\n        for (const entry of results) {\n          if (entry === false) continue\n\n          // entry is not false, so from here we can assume index = workdir\n          if (!entry) {\n            await fs.rmdir(`${dir}/${entry.path}`, { recursive: true });\n            index.delete({ filepath: entry.path });\n            continue\n          }\n\n          if (entry.type === 'blob') {\n            const content = new TextDecoder().decode(entry.content);\n            await fs.write(`${dir}/${entry.path}`, content, {\n              mode: entry.mode,\n            });\n            index.insert({\n              filepath: entry.path,\n              oid: entry.oid,\n              stage: 0,\n            });\n          }\n        }\n      }\n    );\n  } catch (err) {\n    err.caller = 'git.abortMerge';\n    throw err\n  }\n}\n\n// I'm putting this in a Manager because I reckon it could benefit\n// from a LOT of caching.\nclass GitIgnoreManager {\n  /**\n   * Determines whether a given file is ignored based on `.gitignore` rules and exclusion files.\n   *\n   * @param {Object} args\n   * @param {FSClient} args.fs - A file system implementation.\n   * @param {string} args.dir - The working directory.\n   * @param {string} [args.gitdir=join(dir, '.git')] - [required] The [git directory](dir-vs-gitdir.md) path\n   * @param {string} args.filepath - The path of the file to check.\n   * @returns {Promise<boolean>} - `true` if the file is ignored, `false` otherwise.\n   */\n  static async isIgnored({ fs, dir, gitdir = join(dir, '.git'), filepath }) {\n    // ALWAYS ignore \".git\" folders.\n    if (basename(filepath) === '.git') return true\n    // '.' is not a valid gitignore entry, so '.' is never ignored\n    if (filepath === '.') return false\n    // Check and load exclusion rules from project exclude file (.git/info/exclude)\n    let excludes = '';\n    const excludesFile = join(gitdir, 'info', 'exclude');\n    if (await fs.exists(excludesFile)) {\n      excludes = await fs.read(excludesFile, 'utf8');\n    }\n    // Find all the .gitignore files that could affect this file\n    const pairs = [\n      {\n        gitignore: join(dir, '.gitignore'),\n        filepath,\n      },\n    ];\n    const pieces = filepath.split('/').filter(Boolean);\n    for (let i = 1; i < pieces.length; i++) {\n      const folder = pieces.slice(0, i).join('/');\n      const file = pieces.slice(i).join('/');\n      pairs.push({\n        gitignore: join(dir, folder, '.gitignore'),\n        filepath: file,\n      });\n    }\n    let ignoredStatus = false;\n    for (const p of pairs) {\n      let file;\n      try {\n        file = await fs.read(p.gitignore, 'utf8');\n      } catch (err) {\n        if (err.code === 'NOENT') continue\n      }\n      const ign = ignore().add(excludes);\n      ign.add(file);\n      // If the parent directory is excluded, we are done.\n      // \"It is not possible to re-include a file if a parent directory of that file is excluded. Git doesnt list excluded directories for performance reasons, so any patterns on contained files have no effect, no matter where they are defined.\"\n      // source: https://git-scm.com/docs/gitignore\n      const parentdir = dirname(p.filepath);\n      if (parentdir !== '.' && ign.ignores(parentdir)) return true\n      // If the file is currently ignored, test for UNignoring.\n      if (ignoredStatus) {\n        ignoredStatus = !ign.test(p.filepath).unignored;\n      } else {\n        ignoredStatus = ign.test(p.filepath).ignored;\n      }\n    }\n    return ignoredStatus\n  }\n}\n\nasync function writeObjectLoose({ fs, gitdir, object, format, oid }) {\n  if (format !== 'deflated') {\n    throw new InternalError(\n      'GitObjectStoreLoose expects objects to write to be in deflated format'\n    )\n  }\n  const source = `objects/${oid.slice(0, 2)}/${oid.slice(2)}`;\n  const filepath = `${gitdir}/${source}`;\n  // Don't overwrite existing git objects - this helps avoid EPERM errors.\n  // Although I don't know how we'd fix corrupted objects then. Perhaps delete them\n  // on read?\n  if (!(await fs.exists(filepath))) await fs.write(filepath, object);\n}\n\n/* eslint-env node, browser */\n\nlet supportsCompressionStream = null;\n\nasync function deflate(buffer) {\n  if (supportsCompressionStream === null) {\n    supportsCompressionStream = testCompressionStream();\n  }\n  return supportsCompressionStream\n    ? browserDeflate(buffer)\n    : pako.deflate(buffer)\n}\n\nasync function browserDeflate(buffer) {\n  const cs = new CompressionStream('deflate');\n  const c = new Blob([buffer]).stream().pipeThrough(cs);\n  return new Uint8Array(await new Response(c).arrayBuffer())\n}\n\nfunction testCompressionStream() {\n  try {\n    const cs = new CompressionStream('deflate');\n    cs.writable.close();\n    // Test if `Blob.stream` is present. React Native does not have the `stream` method\n    const stream = new Blob([]).stream();\n    stream.cancel();\n    return true\n  } catch (_) {\n    return false\n  }\n}\n\nasync function _writeObject({\n  fs,\n  gitdir,\n  type,\n  object,\n  format = 'content',\n  oid = undefined,\n  dryRun = false,\n}) {\n  if (format !== 'deflated') {\n    if (format !== 'wrapped') {\n      object = GitObject.wrap({ type, object });\n    }\n    oid = await shasum(object);\n    object = Buffer.from(await deflate(object));\n  }\n  if (!dryRun) {\n    await writeObjectLoose({ fs, gitdir, object, format: 'deflated', oid });\n  }\n  return oid\n}\n\nfunction posixifyPathBuffer(buffer) {\n  let idx;\n  while (~(idx = buffer.indexOf(92))) buffer[idx] = 47;\n  return buffer\n}\n\n// @ts-check\n\n/**\n * Add a file to the git index (aka staging area)\n *\n * @param {object} args\n * @param {FsClient} args.fs - a file system implementation\n * @param {string} args.dir - The [working tree](dir-vs-gitdir.md) directory path\n * @param {string} [args.gitdir=join(dir, '.git')] - [required] The [git directory](dir-vs-gitdir.md) path\n * @param {string|string[]} args.filepath - The path to the file to add to the index\n * @param {object} [args.cache] - a [cache](cache.md) object\n * @param {boolean} [args.force=false] - add to index even if matches gitignore. Think `git add --force`\n * @param {boolean} [args.parallel=false] - process each input file in parallel. Parallel processing will result in more memory consumption but less process time\n *\n * @returns {Promise<void>} Resolves successfully once the git index has been updated\n *\n * @example\n * await fs.promises.writeFile('/tutorial/README.md', `# TEST`)\n * await git.add({ fs, dir: '/tutorial', filepath: 'README.md' })\n * console.log('done')\n *\n */\nasync function add({\n  fs: _fs,\n  dir,\n  gitdir = join(dir, '.git'),\n  filepath,\n  cache = {},\n  force = false,\n  parallel = true,\n}) {\n  try {\n    assertParameter('fs', _fs);\n    assertParameter('dir', dir);\n    assertParameter('gitdir', gitdir);\n    assertParameter('filepath', filepath);\n\n    const fs = new FileSystem(_fs);\n    const updatedGitdir = await discoverGitdir({ fsp: fs, dotgit: gitdir });\n    await GitIndexManager.acquire(\n      { fs, gitdir: updatedGitdir, cache },\n      async index => {\n        const config = await GitConfigManager.get({ fs, gitdir: updatedGitdir });\n        const autocrlf = await config.get('core.autocrlf');\n        return addToIndex({\n          dir,\n          gitdir: updatedGitdir,\n          fs,\n          filepath,\n          index,\n          force,\n          parallel,\n          autocrlf,\n        })\n      }\n    );\n  } catch (err) {\n    err.caller = 'git.add';\n    throw err\n  }\n}\n\nasync function addToIndex({\n  dir,\n  gitdir,\n  fs,\n  filepath,\n  index,\n  force,\n  parallel,\n  autocrlf,\n}) {\n  // TODO: Should ignore UNLESS it's already in the index.\n  filepath = Array.isArray(filepath) ? filepath : [filepath];\n  const promises = filepath.map(async currentFilepath => {\n    if (!force) {\n      const ignored = await GitIgnoreManager.isIgnored({\n        fs,\n        dir,\n        gitdir,\n        filepath: currentFilepath,\n      });\n      if (ignored) return\n    }\n    const stats = await fs.lstat(join(dir, currentFilepath));\n    if (!stats) throw new NotFoundError(currentFilepath)\n\n    if (stats.isDirectory()) {\n      const children = await fs.readdir(join(dir, currentFilepath));\n      if (parallel) {\n        const promises = children.map(child =>\n          addToIndex({\n            dir,\n            gitdir,\n            fs,\n            filepath: [join(currentFilepath, child)],\n            index,\n            force,\n            parallel,\n            autocrlf,\n          })\n        );\n        await Promise.all(promises);\n      } else {\n        for (const child of children) {\n          await addToIndex({\n            dir,\n            gitdir,\n            fs,\n            filepath: [join(currentFilepath, child)],\n            index,\n            force,\n            parallel,\n            autocrlf,\n          });\n        }\n      }\n    } else {\n      const object = stats.isSymbolicLink()\n        ? await fs.readlink(join(dir, currentFilepath)).then(posixifyPathBuffer)\n        : await fs.read(join(dir, currentFilepath), { autocrlf });\n      if (object === null) throw new NotFoundError(currentFilepath)\n      const oid = await _writeObject({ fs, gitdir, type: 'blob', object });\n      index.insert({ filepath: currentFilepath, stats, oid });\n    }\n  });\n\n  const settledPromises = await Promise.allSettled(promises);\n  const rejectedPromises = settledPromises\n    .filter(settle => settle.status === 'rejected')\n    .map(settle => settle.reason);\n  if (rejectedPromises.length > 1) {\n    throw new MultipleGitError(rejectedPromises)\n  }\n  if (rejectedPromises.length === 1) {\n    throw rejectedPromises[0]\n  }\n\n  const fulfilledPromises = settledPromises\n    .filter(settle => settle.status === 'fulfilled' && settle.value)\n    .map(settle => settle.value);\n\n  return fulfilledPromises\n}\n\n// @ts-check\n\n/**\n * @param {Object} args\n * @param {import('../models/FileSystem.js').FileSystem} args.fs\n * @param {string} args.gitdir\n * @param {string} args.path\n *\n * @returns {Promise<any>} Resolves with the config value\n *\n * @example\n * // Read config value\n * let value = await git.getConfig({\n *   dir: '$input((/))',\n *   path: '$input((user.name))'\n * })\n * console.log(value)\n *\n */\nasync function _getConfig({ fs, gitdir, path }) {\n  const config = await GitConfigManager.get({ fs, gitdir });\n  return config.get(path)\n}\n\n// Like Object.assign but ignore properties with undefined values\n// ref: https://stackoverflow.com/q/39513815\nfunction assignDefined(target, ...sources) {\n  for (const source of sources) {\n    if (source) {\n      for (const key of Object.keys(source)) {\n        const val = source[key];\n        if (val !== undefined) {\n          target[key] = val;\n        }\n      }\n    }\n  }\n  return target\n}\n\n/**\n * Return author object by using properties following this priority:\n * (1) provided author object\n * -> (2) author of provided commit object\n * -> (3) Config and current date/time\n *\n * @param {Object} args\n * @param {FsClient} args.fs - a file system implementation\n * @param {string} [args.gitdir] - The [git directory](dir-vs-gitdir.md) path\n * @param {Object} [args.author] - The author object.\n * @param {CommitObject} [args.commit] - A commit object.\n *\n * @returns {Promise<void | {name: string, email: string, timestamp: number, timezoneOffset: number }>}\n */\nasync function normalizeAuthorObject({ fs, gitdir, author, commit }) {\n  const timestamp = Math.floor(Date.now() / 1000);\n\n  const defaultAuthor = {\n    name: await _getConfig({ fs, gitdir, path: 'user.name' }),\n    email: (await _getConfig({ fs, gitdir, path: 'user.email' })) || '', // author.email is allowed to be empty string\n    timestamp,\n    timezoneOffset: new Date(timestamp * 1000).getTimezoneOffset(),\n  };\n\n  // Populate author object by using properties with this priority:\n  // (1) provided author object\n  // -> (2) author of provided commit object\n  // -> (3) default author\n  const normalizedAuthor = assignDefined(\n    {},\n    defaultAuthor,\n    commit ? commit.author : undefined,\n    author\n  );\n\n  if (normalizedAuthor.name === undefined) {\n    return undefined\n  }\n\n  return normalizedAuthor\n}\n\n/**\n * Return committer object by using properties with this priority:\n * (1) provided committer object\n * -> (2) provided author object\n * -> (3) committer of provided commit object\n * -> (4) Config and current date/time\n *\n * @param {Object} args\n * @param {FsClient} args.fs - a file system implementation\n * @param {string} [args.gitdir] - The [git directory](dir-vs-gitdir.md) path\n * @param {Object} [args.author] - The author object.\n * @param {Object} [args.committer] - The committer object.\n * @param {CommitObject} [args.commit] - A commit object.\n *\n * @returns {Promise<void | {name: string, email: string, timestamp: number, timezoneOffset: number }>}\n */\nasync function normalizeCommitterObject({\n  fs,\n  gitdir,\n  author,\n  committer,\n  commit,\n}) {\n  const timestamp = Math.floor(Date.now() / 1000);\n\n  const defaultCommitter = {\n    name: await _getConfig({ fs, gitdir, path: 'user.name' }),\n    email: (await _getConfig({ fs, gitdir, path: 'user.email' })) || '', // committer.email is allowed to be empty string\n    timestamp,\n    timezoneOffset: new Date(timestamp * 1000).getTimezoneOffset(),\n  };\n\n  const normalizedCommitter = assignDefined(\n    {},\n    defaultCommitter,\n    commit ? commit.committer : undefined,\n    author,\n    committer\n  );\n\n  if (normalizedCommitter.name === undefined) {\n    return undefined\n  }\n  return normalizedCommitter\n}\n\nasync function resolveCommit({ fs, cache, gitdir, oid }) {\n  const { type, object } = await _readObject({ fs, cache, gitdir, oid });\n  // Resolve annotated tag objects to whatever\n  if (type === 'tag') {\n    oid = GitAnnotatedTag.from(object).parse().object;\n    return resolveCommit({ fs, cache, gitdir, oid })\n  }\n  if (type !== 'commit') {\n    throw new ObjectTypeError(oid, type, 'commit')\n  }\n  return { commit: GitCommit.from(object), oid }\n}\n\n// @ts-check\n\n/**\n * @param {object} args\n * @param {import('../models/FileSystem.js').FileSystem} args.fs\n * @param {any} args.cache\n * @param {string} args.gitdir\n * @param {string} args.oid\n *\n * @returns {Promise<ReadCommitResult>} Resolves successfully with a git commit object\n * @see ReadCommitResult\n * @see CommitObject\n *\n */\nasync function _readCommit({ fs, cache, gitdir, oid }) {\n  const { commit, oid: commitOid } = await resolveCommit({\n    fs,\n    cache,\n    gitdir,\n    oid,\n  });\n  const result = {\n    oid: commitOid,\n    commit: commit.parse(),\n    payload: commit.withoutSignature(),\n  };\n  // @ts-ignore\n  return result\n}\n\n// @ts-check\n\n/**\n *\n * @param {Object} args\n * @param {import('../models/FileSystem.js').FileSystem} args.fs\n * @param {object} args.cache\n * @param {SignCallback} [args.onSign]\n * @param {string} args.gitdir\n * @param {string} [args.message]\n * @param {Object} [args.author]\n * @param {string} [args.author.name]\n * @param {string} [args.author.email]\n * @param {number} [args.author.timestamp]\n * @param {number} [args.author.timezoneOffset]\n * @param {Object} [args.committer]\n * @param {string} [args.committer.name]\n * @param {string} [args.committer.email]\n * @param {number} [args.committer.timestamp]\n * @param {number} [args.committer.timezoneOffset]\n * @param {string} [args.signingKey]\n * @param {boolean} [args.amend = false]\n * @param {boolean} [args.dryRun = false]\n * @param {boolean} [args.noUpdateBranch = false]\n * @param {string} [args.ref]\n * @param {string[]} [args.parent]\n * @param {string} [args.tree]\n *\n * @returns {Promise<string>} Resolves successfully with the SHA-1 object id of the newly created commit.\n */\nasync function _commit({\n  fs,\n  cache,\n  onSign,\n  gitdir,\n  message,\n  author: _author,\n  committer: _committer,\n  signingKey,\n  amend = false,\n  dryRun = false,\n  noUpdateBranch = false,\n  ref,\n  parent,\n  tree,\n}) {\n  // Determine ref and the commit pointed to by ref, and if it is the initial commit\n  let initialCommit = false;\n  if (!ref) {\n    ref = await GitRefManager.resolve({\n      fs,\n      gitdir,\n      ref: 'HEAD',\n      depth: 2,\n    });\n  }\n\n  let refOid, refCommit;\n  try {\n    refOid = await GitRefManager.resolve({\n      fs,\n      gitdir,\n      ref,\n    });\n    refCommit = await _readCommit({ fs, gitdir, oid: refOid, cache: {} });\n  } catch {\n    // We assume that there's no commit and this is the initial commit\n    initialCommit = true;\n  }\n\n  if (amend && initialCommit) {\n    throw new NoCommitError(ref)\n  }\n\n  // Determine author and committer information\n  const author = !amend\n    ? await normalizeAuthorObject({ fs, gitdir, author: _author })\n    : await normalizeAuthorObject({\n        fs,\n        gitdir,\n        author: _author,\n        commit: refCommit.commit,\n      });\n  if (!author) throw new MissingNameError('author')\n\n  const committer = !amend\n    ? await normalizeCommitterObject({\n        fs,\n        gitdir,\n        author,\n        committer: _committer,\n      })\n    : await normalizeCommitterObject({\n        fs,\n        gitdir,\n        author,\n        committer: _committer,\n        commit: refCommit.commit,\n      });\n  if (!committer) throw new MissingNameError('committer')\n\n  return GitIndexManager.acquire(\n    { fs, gitdir, cache, allowUnmerged: false },\n    async function (index) {\n      const inodes = flatFileListToDirectoryStructure(index.entries);\n      const inode = inodes.get('.');\n      if (!tree) {\n        tree = await constructTree({ fs, gitdir, inode, dryRun });\n      }\n\n      // Determine parents of this commit\n      if (!parent) {\n        if (!amend) {\n          parent = refOid ? [refOid] : [];\n        } else {\n          parent = refCommit.commit.parent;\n        }\n      } else {\n        // ensure that the parents are oids, not refs\n        parent = await Promise.all(\n          parent.map(p => {\n            return GitRefManager.resolve({ fs, gitdir, ref: p })\n          })\n        );\n      }\n\n      // Determine message of this commit\n      if (!message) {\n        if (!amend) {\n          throw new MissingParameterError('message')\n        } else {\n          message = refCommit.commit.message;\n        }\n      }\n\n      // Create and write new Commit object\n      let comm = GitCommit.from({\n        tree,\n        parent,\n        author,\n        committer,\n        message,\n      });\n      if (signingKey) {\n        comm = await GitCommit.sign(comm, onSign, signingKey);\n      }\n      const oid = await _writeObject({\n        fs,\n        gitdir,\n        type: 'commit',\n        object: comm.toObject(),\n        dryRun,\n      });\n      if (!noUpdateBranch && !dryRun) {\n        // Update branch pointer\n        await GitRefManager.writeRef({\n          fs,\n          gitdir,\n          ref,\n          value: oid,\n        });\n      }\n      return oid\n    }\n  )\n}\n\nasync function constructTree({ fs, gitdir, inode, dryRun }) {\n  // use depth first traversal\n  const children = inode.children;\n  for (const inode of children) {\n    if (inode.type === 'tree') {\n      inode.metadata.mode = '040000';\n      inode.metadata.oid = await constructTree({ fs, gitdir, inode, dryRun });\n    }\n  }\n  const entries = children.map(inode => ({\n    mode: inode.metadata.mode,\n    path: inode.basename,\n    oid: inode.metadata.oid,\n    type: inode.type,\n  }));\n  const tree = GitTree.from(entries);\n  const oid = await _writeObject({\n    fs,\n    gitdir,\n    type: 'tree',\n    object: tree.toObject(),\n    dryRun,\n  });\n  return oid\n}\n\n// @ts-check\n\nasync function resolveFilepath({ fs, cache, gitdir, oid, filepath }) {\n  // Ensure there are no leading or trailing directory separators.\n  // I was going to do this automatically, but then found that the Git Terminal for Windows\n  // auto-expands --filepath=/src/utils to --filepath=C:/Users/Will/AppData/Local/Programs/Git/src/utils\n  // so I figured it would be wise to promote the behavior in the application layer not just the library layer.\n  if (filepath.startsWith('/')) {\n    throw new InvalidFilepathError('leading-slash')\n  } else if (filepath.endsWith('/')) {\n    throw new InvalidFilepathError('trailing-slash')\n  }\n  const _oid = oid;\n  const result = await resolveTree({ fs, cache, gitdir, oid });\n  const tree = result.tree;\n  if (filepath === '') {\n    oid = result.oid;\n  } else {\n    const pathArray = filepath.split('/');\n    oid = await _resolveFilepath({\n      fs,\n      cache,\n      gitdir,\n      tree,\n      pathArray,\n      oid: _oid,\n      filepath,\n    });\n  }\n  return oid\n}\n\nasync function _resolveFilepath({\n  fs,\n  cache,\n  gitdir,\n  tree,\n  pathArray,\n  oid,\n  filepath,\n}) {\n  const name = pathArray.shift();\n  for (const entry of tree) {\n    if (entry.path === name) {\n      if (pathArray.length === 0) {\n        return entry.oid\n      } else {\n        const { type, object } = await _readObject({\n          fs,\n          cache,\n          gitdir,\n          oid: entry.oid,\n        });\n        if (type !== 'tree') {\n          throw new ObjectTypeError(oid, type, 'tree', filepath)\n        }\n        tree = GitTree.from(object);\n        return _resolveFilepath({\n          fs,\n          cache,\n          gitdir,\n          tree,\n          pathArray,\n          oid,\n          filepath,\n        })\n      }\n    }\n  }\n  throw new NotFoundError(`file or directory found at \"${oid}:${filepath}\"`)\n}\n\n// @ts-check\n\n/**\n *\n * @typedef {Object} ReadTreeResult - The object returned has the following schema:\n * @property {string} oid - SHA-1 object id of this tree\n * @property {TreeObject} tree - the parsed tree object\n */\n\n/**\n * @param {object} args\n * @param {import('../models/FileSystem.js').FileSystem} args.fs\n * @param {any} args.cache\n * @param {string} args.gitdir\n * @param {string} args.oid\n * @param {string} [args.filepath]\n *\n * @returns {Promise<ReadTreeResult>}\n */\nasync function _readTree({\n  fs,\n  cache,\n  gitdir,\n  oid,\n  filepath = undefined,\n}) {\n  if (filepath !== undefined) {\n    oid = await resolveFilepath({ fs, cache, gitdir, oid, filepath });\n  }\n  const { tree, oid: treeOid } = await resolveTree({ fs, cache, gitdir, oid });\n  const result = {\n    oid: treeOid,\n    tree: tree.entries(),\n  };\n  return result\n}\n\n// @ts-check\n\n/**\n * @param {object} args\n * @param {import('../models/FileSystem.js').FileSystem} args.fs\n * @param {string} args.gitdir\n * @param {TreeObject} args.tree\n *\n * @returns {Promise<string>}\n */\nasync function _writeTree({ fs, gitdir, tree }) {\n  // Convert object to buffer\n  const object = GitTree.from(tree).toObject();\n  const oid = await _writeObject({\n    fs,\n    gitdir,\n    type: 'tree',\n    object,\n    format: 'content',\n  });\n  return oid\n}\n\n// @ts-check\n\n/**\n * @param {object} args\n * @param {import('../models/FileSystem.js').FileSystem} args.fs\n * @param {object} args.cache\n * @param {SignCallback} [args.onSign]\n * @param {string} args.gitdir\n * @param {string} args.ref\n * @param {string} args.oid\n * @param {string|Uint8Array} args.note\n * @param {boolean} [args.force]\n * @param {Object} args.author\n * @param {string} args.author.name\n * @param {string} args.author.email\n * @param {number} args.author.timestamp\n * @param {number} args.author.timezoneOffset\n * @param {Object} args.committer\n * @param {string} args.committer.name\n * @param {string} args.committer.email\n * @param {number} args.committer.timestamp\n * @param {number} args.committer.timezoneOffset\n * @param {string} [args.signingKey]\n *\n * @returns {Promise<string>}\n */\n\nasync function _addNote({\n  fs,\n  cache,\n  onSign,\n  gitdir,\n  ref,\n  oid,\n  note,\n  force,\n  author,\n  committer,\n  signingKey,\n}) {\n  // Get the current note commit\n  let parent;\n  try {\n    parent = await GitRefManager.resolve({ gitdir, fs, ref });\n  } catch (err) {\n    if (!(err instanceof NotFoundError)) {\n      throw err\n    }\n  }\n\n  // I'm using the \"empty tree\" magic number here for brevity\n  const result = await _readTree({\n    fs,\n    cache,\n    gitdir,\n    oid: parent || '4b825dc642cb6eb9a060e54bf8d69288fbee4904',\n  });\n  let tree = result.tree;\n\n  // Handle the case where a note already exists\n  if (force) {\n    tree = tree.filter(entry => entry.path !== oid);\n  } else {\n    for (const entry of tree) {\n      if (entry.path === oid) {\n        throw new AlreadyExistsError('note', oid)\n      }\n    }\n  }\n\n  // Create the note blob\n  if (typeof note === 'string') {\n    note = Buffer.from(note, 'utf8');\n  }\n  const noteOid = await _writeObject({\n    fs,\n    gitdir,\n    type: 'blob',\n    object: note,\n    format: 'content',\n  });\n\n  // Create the new note tree\n  tree.push({ mode: '100644', path: oid, oid: noteOid, type: 'blob' });\n  const treeOid = await _writeTree({\n    fs,\n    gitdir,\n    tree,\n  });\n\n  // Create the new note commit\n  const commitOid = await _commit({\n    fs,\n    cache,\n    onSign,\n    gitdir,\n    ref,\n    tree: treeOid,\n    parent: parent && [parent],\n    message: `Note added by 'isomorphic-git addNote'\\n`,\n    author,\n    committer,\n    signingKey,\n  });\n\n  return commitOid\n}\n\n// @ts-check\n\n/**\n * Add or update an object note\n *\n * @param {object} args\n * @param {FsClient} args.fs - a file system implementation\n * @param {SignCallback} [args.onSign] - a PGP signing implementation\n * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path\n * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path\n * @param {string} [args.ref] - The notes ref to look under\n * @param {string} args.oid - The SHA-1 object id of the object to add the note to.\n * @param {string|Uint8Array} args.note - The note to add\n * @param {boolean} [args.force] - Over-write note if it already exists.\n * @param {Object} [args.author] - The details about the author.\n * @param {string} [args.author.name] - Default is `user.name` config.\n * @param {string} [args.author.email] - Default is `user.email` config.\n * @param {number} [args.author.timestamp=Math.floor(Date.now()/1000)] - Set the author timestamp field. This is the integer number of seconds since the Unix epoch (1970-01-01 00:00:00).\n * @param {number} [args.author.timezoneOffset] - Set the author timezone offset field. This is the difference, in minutes, from the current timezone to UTC. Default is `(new Date()).getTimezoneOffset()`.\n * @param {Object} [args.committer = author] - The details about the note committer, in the same format as the author parameter. If not specified, the author details are used.\n * @param {string} [args.committer.name] - Default is `user.name` config.\n * @param {string} [args.committer.email] - Default is `user.email` config.\n * @param {number} [args.committer.timestamp=Math.floor(Date.now()/1000)] - Set the committer timestamp field. This is the integer number of seconds since the Unix epoch (1970-01-01 00:00:00).\n * @param {number} [args.committer.timezoneOffset] - Set the committer timezone offset field. This is the difference, in minutes, from the current timezone to UTC. Default is `(new Date()).getTimezoneOffset()`.\n * @param {string} [args.signingKey] - Sign the note commit using this private PGP key.\n * @param {object} [args.cache] - a [cache](cache.md) object\n *\n * @returns {Promise<string>} Resolves successfully with the SHA-1 object id of the commit object for the added note.\n */\n\nasync function addNote({\n  fs: _fs,\n  onSign,\n  dir,\n  gitdir = join(dir, '.git'),\n  ref = 'refs/notes/commits',\n  oid,\n  note,\n  force,\n  author: _author,\n  committer: _committer,\n  signingKey,\n  cache = {},\n}) {\n  try {\n    assertParameter('fs', _fs);\n    assertParameter('gitdir', gitdir);\n    assertParameter('oid', oid);\n    assertParameter('note', note);\n    if (signingKey) {\n      assertParameter('onSign', onSign);\n    }\n    const fs = new FileSystem(_fs);\n\n    const author = await normalizeAuthorObject({ fs, gitdir, author: _author });\n    if (!author) throw new MissingNameError('author')\n\n    const committer = await normalizeCommitterObject({\n      fs,\n      gitdir,\n      author,\n      committer: _committer,\n    });\n    if (!committer) throw new MissingNameError('committer')\n\n    const updatedGitdir = await discoverGitdir({ fsp: fs, dotgit: gitdir });\n    return await _addNote({\n      fs,\n      cache,\n      onSign,\n      gitdir: updatedGitdir,\n      ref,\n      oid,\n      note,\n      force,\n      author,\n      committer,\n      signingKey,\n    })\n  } catch (err) {\n    err.caller = 'git.addNote';\n    throw err\n  }\n}\n\n/*\nAdapted from is-git-ref-name-valid\nSPDX-License-Identifier: MIT\nCopyright  Vincent Weevers\n*/\n\n// eslint-disable-next-line no-control-regex\nconst bad = /(^|[/.])([/.]|$)|^@$|@{|[\\x00-\\x20\\x7f~^:?*[\\\\]|\\.lock(\\/|$)/;\n\nfunction isValidRef(name, onelevel) {\n  if (typeof name !== 'string')\n    throw new TypeError('Reference name must be a string')\n\n  return !bad.test(name) && (!!onelevel || name.includes('/'))\n}\n\n// @ts-check\n\n/**\n * @param {object} args\n * @param {import('../models/FileSystem.js').FileSystem} args.fs\n * @param {string} args.gitdir\n * @param {string} args.remote\n * @param {string} args.url\n * @param {boolean} args.force\n *\n * @returns {Promise<void>}\n *\n */\nasync function _addRemote({ fs, gitdir, remote, url, force }) {\n  if (!isValidRef(remote, true)) {\n    throw new InvalidRefNameError(remote, cleanGitRef.clean(remote))\n  }\n  const config = await GitConfigManager.get({ fs, gitdir });\n  if (!force) {\n    // Check that setting it wouldn't overwrite.\n    const remoteNames = await config.getSubsections('remote');\n    if (remoteNames.includes(remote)) {\n      // Throw an error if it would overwrite an existing remote,\n      // but not if it's simply setting the same value again.\n      if (url !== (await config.get(`remote.${remote}.url`))) {\n        throw new AlreadyExistsError('remote', remote)\n      }\n    }\n  }\n  await config.set(`remote.${remote}.url`, url);\n  await config.set(\n    `remote.${remote}.fetch`,\n    `+refs/heads/*:refs/remotes/${remote}/*`\n  );\n  await GitConfigManager.save({ fs, gitdir, config });\n}\n\n// @ts-check\n\n/**\n * Add or update a remote\n *\n * @param {object} args\n * @param {FsClient} args.fs - a file system implementation\n * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path\n * @param {string} [args.gitdir] - [required] The [git directory](dir-vs-gitdir.md) path\n * @param {string} args.remote - The name of the remote\n * @param {string} args.url - The URL of the remote\n * @param {boolean} [args.force = false] - Instead of throwing an error if a remote named `remote` already exists, overwrite the existing remote.\n *\n * @returns {Promise<void>} Resolves successfully when filesystem operations are complete\n *\n * @example\n * await git.addRemote({\n *   fs,\n *   dir: '/tutorial',\n *   remote: 'upstream',\n *   url: 'https://github.com/isomorphic-git/isomorphic-git'\n * })\n * console.log('done')\n *\n */\nasync function addRemote({\n  fs,\n  dir,\n  gitdir = join(dir, '.git'),\n  remote,\n  url,\n  force = false,\n}) {\n  try {\n    assertParameter('fs', fs);\n    assertParameter('gitdir', gitdir);\n    assertParameter('remote', remote);\n    assertParameter('url', url);\n    const fsp = new FileSystem(fs);\n    const updatedGitdir = await discoverGitdir({ fsp, dotgit: gitdir });\n    return await _addRemote({\n      fs: fsp,\n      gitdir: updatedGitdir,\n      remote,\n      url,\n      force,\n    })\n  } catch (err) {\n    err.caller = 'git.addRemote';\n    throw err\n  }\n}\n\n// @ts-check\n\n/**\n * Create an annotated tag.\n *\n * @param {object} args\n * @param {import('../models/FileSystem.js').FileSystem} args.fs\n * @param {any} args.cache\n * @param {SignCallback} [args.onSign]\n * @param {string} args.gitdir\n * @param {string} args.ref\n * @param {string} [args.message = ref]\n * @param {string} [args.object = 'HEAD']\n * @param {object} [args.tagger]\n * @param {string} args.tagger.name\n * @param {string} args.tagger.email\n * @param {number} args.tagger.timestamp\n * @param {number} args.tagger.timezoneOffset\n * @param {string} [args.gpgsig]\n * @param {string} [args.signingKey]\n * @param {boolean} [args.force = false]\n *\n * @returns {Promise<void>} Resolves successfully when filesystem operations are complete\n *\n * @example\n * await git.annotatedTag({\n *   dir: '$input((/))',\n *   ref: '$input((test-tag))',\n *   message: '$input((This commit is awesome))',\n *   tagger: {\n *     name: '$input((Mr. Test))',\n *     email: '$input((mrtest@example.com))'\n *   }\n * })\n * console.log('done')\n *\n */\nasync function _annotatedTag({\n  fs,\n  cache,\n  onSign,\n  gitdir,\n  ref,\n  tagger,\n  message = ref,\n  gpgsig,\n  object,\n  signingKey,\n  force = false,\n}) {\n  ref = ref.startsWith('refs/tags/') ? ref : `refs/tags/${ref}`;\n\n  if (!force && (await GitRefManager.exists({ fs, gitdir, ref }))) {\n    throw new AlreadyExistsError('tag', ref)\n  }\n\n  // Resolve passed value\n  const oid = await GitRefManager.resolve({\n    fs,\n    gitdir,\n    ref: object || 'HEAD',\n  });\n\n  const { type } = await _readObject({ fs, cache, gitdir, oid });\n  let tagObject = GitAnnotatedTag.from({\n    object: oid,\n    type,\n    tag: ref.replace('refs/tags/', ''),\n    tagger,\n    message,\n    gpgsig,\n  });\n  if (signingKey) {\n    tagObject = await GitAnnotatedTag.sign(tagObject, onSign, signingKey);\n  }\n  const value = await _writeObject({\n    fs,\n    gitdir,\n    type: 'tag',\n    object: tagObject.toObject(),\n  });\n\n  await GitRefManager.writeRef({ fs, gitdir, ref, value });\n}\n\n// @ts-check\n\n/**\n * Create an annotated tag.\n *\n * @param {object} args\n * @param {FsClient} args.fs - a file system implementation\n * @param {SignCallback} [args.onSign] - a PGP signing implementation\n * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path\n * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path\n * @param {string} args.ref - What to name the tag\n * @param {string} [args.message = ref] - The tag message to use.\n * @param {string} [args.object = 'HEAD'] - The SHA-1 object id the tag points to. (Will resolve to a SHA-1 object id if value is a ref.) By default, the commit object which is referred by the current `HEAD` is used.\n * @param {object} [args.tagger] - The details about the tagger.\n * @param {string} [args.tagger.name] - Default is `user.name` config.\n * @param {string} [args.tagger.email] - Default is `user.email` config.\n * @param {number} [args.tagger.timestamp=Math.floor(Date.now()/1000)] - Set the tagger timestamp field. This is the integer number of seconds since the Unix epoch (1970-01-01 00:00:00).\n * @param {number} [args.tagger.timezoneOffset] - Set the tagger timezone offset field. This is the difference, in minutes, from the current timezone to UTC. Default is `(new Date()).getTimezoneOffset()`.\n * @param {string} [args.gpgsig] - The gpgsig attached to the tag object. (Mutually exclusive with the `signingKey` option.)\n * @param {string} [args.signingKey] - Sign the tag object using this private PGP key. (Mutually exclusive with the `gpgsig` option.)\n * @param {boolean} [args.force = false] - Instead of throwing an error if a tag named `ref` already exists, overwrite the existing tag. Note that this option does not modify the original tag object itself.\n * @param {object} [args.cache] - a [cache](cache.md) object\n *\n * @returns {Promise<void>} Resolves successfully when filesystem operations are complete\n *\n * @example\n * await git.annotatedTag({\n *   fs,\n *   dir: '/tutorial',\n *   ref: 'test-tag',\n *   message: 'This commit is awesome',\n *   tagger: {\n *     name: 'Mr. Test',\n *     email: 'mrtest@example.com'\n *   }\n * })\n * console.log('done')\n *\n */\nasync function annotatedTag({\n  fs: _fs,\n  onSign,\n  dir,\n  gitdir = join(dir, '.git'),\n  ref,\n  tagger: _tagger,\n  message = ref,\n  gpgsig,\n  object,\n  signingKey,\n  force = false,\n  cache = {},\n}) {\n  try {\n    assertParameter('fs', _fs);\n    assertParameter('gitdir', gitdir);\n    assertParameter('ref', ref);\n    if (signingKey) {\n      assertParameter('onSign', onSign);\n    }\n    const fs = new FileSystem(_fs);\n    const updatedGitdir = await discoverGitdir({ fsp: fs, dotgit: gitdir });\n\n    // Fill in missing arguments with default values\n    const tagger = await normalizeAuthorObject({\n      fs,\n      gitdir: updatedGitdir,\n      author: _tagger,\n    });\n    if (!tagger) throw new MissingNameError('tagger')\n\n    return await _annotatedTag({\n      fs,\n      cache,\n      onSign,\n      gitdir: updatedGitdir,\n      ref,\n      tagger,\n      message,\n      gpgsig,\n      object,\n      signingKey,\n      force,\n    })\n  } catch (err) {\n    err.caller = 'git.annotatedTag';\n    throw err\n  }\n}\n\n// @ts-check\n\n/**\n * Create a branch\n *\n * @param {object} args\n * @param {import('../models/FileSystem.js').FileSystem} args.fs\n * @param {string} args.gitdir\n * @param {string} args.ref\n * @param {string} [args.object = 'HEAD']\n * @param {boolean} [args.checkout = false]\n * @param {boolean} [args.force = false]\n *\n * @returns {Promise<void>} Resolves successfully when filesystem operations are complete\n *\n * @example\n * await git.branch({ dir: '$input((/))', ref: '$input((develop))' })\n * console.log('done')\n *\n */\nasync function _branch({\n  fs,\n  gitdir,\n  ref,\n  object,\n  checkout = false,\n  force = false,\n}) {\n  if (!isValidRef(ref, true)) {\n    throw new InvalidRefNameError(ref, cleanGitRef.clean(ref))\n  }\n\n  const fullref = `refs/heads/${ref}`;\n\n  if (!force) {\n    const exist = await GitRefManager.exists({ fs, gitdir, ref: fullref });\n    if (exist) {\n      throw new AlreadyExistsError('branch', ref, false)\n    }\n  }\n\n  // Get current HEAD tree oid\n  let oid;\n  try {\n    oid = await GitRefManager.resolve({ fs, gitdir, ref: object || 'HEAD' });\n  } catch (e) {\n    // Probably an empty repo\n  }\n\n  // Create a new ref that points at the current commit\n  if (oid) {\n    await GitRefManager.writeRef({ fs, gitdir, ref: fullref, value: oid });\n  }\n\n  if (checkout) {\n    // Update HEAD\n    await GitRefManager.writeSymbolicRef({\n      fs,\n      gitdir,\n      ref: 'HEAD',\n      value: fullref,\n    });\n  }\n}\n\n// @ts-check\n\n/**\n * Create a branch\n *\n * @param {object} args\n * @param {FsClient} args.fs - a file system implementation\n * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path\n * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path\n * @param {string} args.ref - What to name the branch\n * @param {string} [args.object = 'HEAD'] - What oid to use as the start point. Accepts a symbolic ref.\n * @param {boolean} [args.checkout = false] - Update `HEAD` to point at the newly created branch\n * @param {boolean} [args.force = false] - Instead of throwing an error if a branched named `ref` already exists, overwrite the existing branch.\n *\n * @returns {Promise<void>} Resolves successfully when filesystem operations are complete\n *\n * @example\n * await git.branch({ fs, dir: '/tutorial', ref: 'develop' })\n * console.log('done')\n *\n */\nasync function branch({\n  fs,\n  dir,\n  gitdir = join(dir, '.git'),\n  ref,\n  object,\n  checkout = false,\n  force = false,\n}) {\n  try {\n    assertParameter('fs', fs);\n    assertParameter('gitdir', gitdir);\n    assertParameter('ref', ref);\n    const fsp = new FileSystem(fs);\n    const updatedGitdir = await discoverGitdir({ fsp, dotgit: gitdir });\n    return await _branch({\n      fs: fsp,\n      gitdir: updatedGitdir,\n      ref,\n      object,\n      checkout,\n      force,\n    })\n  } catch (err) {\n    err.caller = 'git.branch';\n    throw err\n  }\n}\n\nconst worthWalking = (filepath, root) => {\n  if (filepath === '.' || root == null || root.length === 0 || root === '.') {\n    return true\n  }\n  if (root.length >= filepath.length) {\n    return root.startsWith(filepath)\n  } else {\n    return filepath.startsWith(root)\n  }\n};\n\n// @ts-check\n\n/**\n * @param {object} args\n * @param {import('../models/FileSystem.js').FileSystem} args.fs\n * @param {any} args.cache\n * @param {ProgressCallback} [args.onProgress]\n * @param {PostCheckoutCallback} [args.onPostCheckout]\n * @param {string} args.dir\n * @param {string} args.gitdir\n * @param {string} args.ref\n * @param {string[]} [args.filepaths]\n * @param {string} args.remote\n * @param {boolean} args.noCheckout\n * @param {boolean} [args.noUpdateHead]\n * @param {boolean} [args.dryRun]\n * @param {boolean} [args.force]\n * @param {boolean} [args.track]\n * @param {boolean} [args.nonBlocking]\n * @param {number} [args.batchSize]\n *\n * @returns {Promise<void>} Resolves successfully when filesystem operations are complete\n *\n */\nasync function _checkout({\n  fs,\n  cache,\n  onProgress,\n  onPostCheckout,\n  dir,\n  gitdir,\n  remote,\n  ref,\n  filepaths,\n  noCheckout,\n  noUpdateHead,\n  dryRun,\n  force,\n  track = true,\n  nonBlocking = false,\n  batchSize = 100,\n}) {\n  // oldOid is defined only if onPostCheckout hook is attached\n  let oldOid;\n  if (onPostCheckout) {\n    try {\n      oldOid = await GitRefManager.resolve({ fs, gitdir, ref: 'HEAD' });\n    } catch (err) {\n      oldOid = '0000000000000000000000000000000000000000';\n    }\n  }\n\n  // Get tree oid\n  let oid;\n  try {\n    oid = await GitRefManager.resolve({ fs, gitdir, ref });\n    // TODO: Figure out what to do if both 'ref' and 'remote' are specified, ref already exists,\n    // and is configured to track a different remote.\n  } catch (err) {\n    if (ref === 'HEAD') throw err\n    // If `ref` doesn't exist, create a new remote tracking branch\n    // Figure out the commit to checkout\n    const remoteRef = `${remote}/${ref}`;\n    oid = await GitRefManager.resolve({\n      fs,\n      gitdir,\n      ref: remoteRef,\n    });\n    if (track) {\n      // Set up remote tracking branch\n      const config = await GitConfigManager.get({ fs, gitdir });\n      await config.set(`branch.${ref}.remote`, remote);\n      await config.set(`branch.${ref}.merge`, `refs/heads/${ref}`);\n      await GitConfigManager.save({ fs, gitdir, config });\n    }\n    // Create a new branch that points at that same commit\n    await GitRefManager.writeRef({\n      fs,\n      gitdir,\n      ref: `refs/heads/${ref}`,\n      value: oid,\n    });\n  }\n\n  // Update working dir\n  if (!noCheckout) {\n    let ops;\n    // First pass - just analyze files (not directories) and figure out what needs to be done\n    try {\n      ops = await analyze({\n        fs,\n        cache,\n        onProgress,\n        dir,\n        gitdir,\n        ref,\n        force,\n        filepaths,\n      });\n    } catch (err) {\n      // Throw a more helpful error message for this common mistake.\n      if (err instanceof NotFoundError && err.data.what === oid) {\n        throw new CommitNotFetchedError(ref, oid)\n      } else {\n        throw err\n      }\n    }\n\n    // Report conflicts\n    const conflicts = ops\n      .filter(([method]) => method === 'conflict')\n      .map(([method, fullpath]) => fullpath);\n    if (conflicts.length > 0) {\n      throw new CheckoutConflictError(conflicts)\n    }\n\n    // Collect errors\n    const errors = ops\n      .filter(([method]) => method === 'error')\n      .map(([method, fullpath]) => fullpath);\n    if (errors.length > 0) {\n      throw new InternalError(errors.join(', '))\n    }\n\n    if (dryRun) {\n      // Since the format of 'ops' is in flux, I really would rather folk besides myself not start relying on it\n      // return ops\n\n      if (onPostCheckout) {\n        await onPostCheckout({\n          previousHead: oldOid,\n          newHead: oid,\n          type: filepaths != null && filepaths.length > 0 ? 'file' : 'branch',\n        });\n      }\n      return\n    }\n\n    // Second pass - execute planned changes\n    // The cheapest semi-parallel solution without computing a full dependency graph will be\n    // to just do ops in 4 dumb phases: delete files, delete dirs, create dirs, write files\n\n    let count = 0;\n    const total = ops.length;\n    await GitIndexManager.acquire(\n      { fs, gitdir, cache },\n      async function (index) {\n        await Promise.all(\n          ops\n            .filter(\n              ([method]) => method === 'delete' || method === 'delete-index'\n            )\n            .map(async function ([method, fullpath]) {\n              const filepath = `${dir}/${fullpath}`;\n              if (method === 'delete') {\n                await fs.rm(filepath);\n              }\n              index.delete({ filepath: fullpath });\n              if (onProgress) {\n                await onProgress({\n                  phase: 'Updating workdir',\n                  loaded: ++count,\n                  total,\n                });\n              }\n            })\n        );\n      }\n    );\n\n    // Note: this is cannot be done naively in parallel\n    await GitIndexManager.acquire(\n      { fs, gitdir, cache },\n      async function (index) {\n        for (const [method, fullpath] of ops) {\n          if (method === 'rmdir' || method === 'rmdir-index') {\n            const filepath = `${dir}/${fullpath}`;\n            try {\n              if (method === 'rmdir') {\n                await fs.rmdir(filepath);\n              }\n              index.delete({ filepath: fullpath });\n              if (onProgress) {\n                await onProgress({\n                  phase: 'Updating workdir',\n                  loaded: ++count,\n                  total,\n                });\n              }\n            } catch (e) {\n              if (e.code === 'ENOTEMPTY') {\n                console.log(\n                  `Did not delete ${fullpath} because directory is not empty`\n                );\n              } else {\n                throw e\n              }\n            }\n          }\n        }\n      }\n    );\n\n    await Promise.all(\n      ops\n        .filter(([method]) => method === 'mkdir' || method === 'mkdir-index')\n        .map(async function ([_, fullpath]) {\n          const filepath = `${dir}/${fullpath}`;\n          await fs.mkdir(filepath);\n          if (onProgress) {\n            await onProgress({\n              phase: 'Updating workdir',\n              loaded: ++count,\n              total,\n            });\n          }\n        })\n    );\n\n    if (nonBlocking) {\n      // Filter eligible operations first\n      const eligibleOps = ops.filter(\n        ([method]) =>\n          method === 'create' ||\n          method === 'create-index' ||\n          method === 'update' ||\n          method === 'mkdir-index'\n      );\n\n      const updateWorkingDirResults = await batchAllSettled(\n        'Update Working Dir',\n        eligibleOps.map(\n          ([method, fullpath, oid, mode, chmod]) =>\n            () =>\n              updateWorkingDir({ fs, cache, gitdir, dir }, [\n                method,\n                fullpath,\n                oid,\n                mode,\n                chmod,\n              ])\n        ),\n        onProgress,\n        batchSize\n      );\n\n      await GitIndexManager.acquire(\n        { fs, gitdir, cache, allowUnmerged: true },\n        async function (index) {\n          await batchAllSettled(\n            'Update Index',\n            updateWorkingDirResults.map(\n              ([fullpath, oid, stats]) =>\n                () =>\n                  updateIndex({ index, fullpath, oid, stats })\n            ),\n            onProgress,\n            batchSize\n          );\n        }\n      );\n    } else {\n      await GitIndexManager.acquire(\n        { fs, gitdir, cache, allowUnmerged: true },\n        async function (index) {\n          await Promise.all(\n            ops\n              .filter(\n                ([method]) =>\n                  method === 'create' ||\n                  method === 'create-index' ||\n                  method === 'update' ||\n                  method === 'mkdir-index'\n              )\n              .map(async function ([method, fullpath, oid, mode, chmod]) {\n                const filepath = `${dir}/${fullpath}`;\n                try {\n                  if (method !== 'create-index' && method !== 'mkdir-index') {\n                    const { object } = await _readObject({\n                      fs,\n                      cache,\n                      gitdir,\n                      oid,\n                    });\n                    if (chmod) {\n                      // Note: the mode option of fs.write only works when creating files,\n                      // not updating them. Since the `fs` plugin doesn't expose `chmod` this\n                      // is our only option.\n                      await fs.rm(filepath);\n                    }\n                    if (mode === 0o100644) {\n                      // regular file\n                      await fs.write(filepath, object);\n                    } else if (mode === 0o100755) {\n                      // executable file\n                      await fs.write(filepath, object, { mode: 0o777 });\n                    } else if (mode === 0o120000) {\n                      // symlink\n                      await fs.writelink(filepath, object);\n                    } else {\n                      throw new InternalError(\n                        `Invalid mode 0o${mode.toString(\n                          8\n                        )} detected in blob ${oid}`\n                      )\n                    }\n                  }\n\n                  const stats = await fs.lstat(filepath);\n                  // We can't trust the executable bit returned by lstat on Windows,\n                  // so we need to preserve this value from the TREE.\n                  // TODO: Figure out how git handles this internally.\n                  if (mode === 0o100755) {\n                    stats.mode = 0o755;\n                  }\n                  // Submodules are present in the git index but use a unique mode different from trees\n                  if (method === 'mkdir-index') {\n                    stats.mode = 0o160000;\n                  }\n                  index.insert({\n                    filepath: fullpath,\n                    stats,\n                    oid,\n                  });\n                  if (onProgress) {\n                    await onProgress({\n                      phase: 'Updating workdir',\n                      loaded: ++count,\n                      total,\n                    });\n                  }\n                } catch (e) {\n                  console.log(e);\n                }\n              })\n          );\n        }\n      );\n    }\n\n    if (onPostCheckout) {\n      await onPostCheckout({\n        previousHead: oldOid,\n        newHead: oid,\n        type: filepaths != null && filepaths.length > 0 ? 'file' : 'branch',\n      });\n    }\n  }\n\n  // Update HEAD\n  if (!noUpdateHead) {\n    const fullRef = await GitRefManager.expand({ fs, gitdir, ref });\n    if (fullRef.startsWith('refs/heads')) {\n      await GitRefManager.writeSymbolicRef({\n        fs,\n        gitdir,\n        ref: 'HEAD',\n        value: fullRef,\n      });\n    } else {\n      // detached head\n      await GitRefManager.writeRef({ fs, gitdir, ref: 'HEAD', value: oid });\n    }\n  }\n}\n\nasync function analyze({\n  fs,\n  cache,\n  onProgress,\n  dir,\n  gitdir,\n  ref,\n  force,\n  filepaths,\n}) {\n  let count = 0;\n  return _walk({\n    fs,\n    cache,\n    dir,\n    gitdir,\n    trees: [TREE({ ref }), WORKDIR(), STAGE()],\n    map: async function (fullpath, [commit, workdir, stage]) {\n      if (fullpath === '.') return\n      // match against base paths\n      if (filepaths && !filepaths.some(base => worthWalking(fullpath, base))) {\n        return null\n      }\n      // Emit progress event\n      if (onProgress) {\n        await onProgress({ phase: 'Analyzing workdir', loaded: ++count });\n      }\n\n      // This is a kind of silly pattern but it worked so well for me in the past\n      // and it makes intuitively demonstrating exhaustiveness so *easy*.\n      // This checks for the presence and/or absence of each of the 3 entries,\n      // converts that to a 3-bit binary representation, and then handles\n      // every possible combination (2^3 or 8 cases) with a lookup table.\n      const key = [!!stage, !!commit, !!workdir].map(Number).join('');\n      switch (key) {\n        // Impossible case.\n        case '000':\n          return\n        // Ignore workdir files that are not tracked and not part of the new commit.\n        case '001':\n          // OK, make an exception for explicitly named files.\n          if (force && filepaths && filepaths.includes(fullpath)) {\n            return ['delete', fullpath]\n          }\n          return\n        // New entries\n        case '010': {\n          switch (await commit.type()) {\n            case 'tree': {\n              return ['mkdir', fullpath]\n            }\n            case 'blob': {\n              return [\n                'create',\n                fullpath,\n                await commit.oid(),\n                await commit.mode(),\n              ]\n            }\n            case 'commit': {\n              return [\n                'mkdir-index',\n                fullpath,\n                await commit.oid(),\n                await commit.mode(),\n              ]\n            }\n            default: {\n              return [\n                'error',\n                `new entry Unhandled type ${await commit.type()}`,\n              ]\n            }\n          }\n        }\n        // New entries but there is already something in the workdir there.\n        case '011': {\n          switch (`${await commit.type()}-${await workdir.type()}`) {\n            case 'tree-tree': {\n              return // noop\n            }\n            case 'tree-blob':\n            case 'blob-tree': {\n              return ['conflict', fullpath]\n            }\n            case 'blob-blob': {\n              // Is the incoming file different?\n              if ((await commit.oid()) !== (await workdir.oid())) {\n                if (force) {\n                  return [\n                    'update',\n                    fullpath,\n                    await commit.oid(),\n                    await commit.mode(),\n                    (await commit.mode()) !== (await workdir.mode()),\n                  ]\n                } else {\n                  return ['conflict', fullpath]\n                }\n              } else {\n                // Is the incoming file a different mode?\n                if ((await commit.mode()) !== (await workdir.mode())) {\n                  if (force) {\n                    return [\n                      'update',\n                      fullpath,\n                      await commit.oid(),\n                      await commit.mode(),\n                      true,\n                    ]\n                  } else {\n                    return ['conflict', fullpath]\n                  }\n                } else {\n                  return [\n                    'create-index',\n                    fullpath,\n                    await commit.oid(),\n                    await commit.mode(),\n                  ]\n                }\n              }\n            }\n            case 'commit-tree': {\n              // TODO: submodule\n              // We'll ignore submodule directories for now.\n              // Users prefer we not throw an error for lack of submodule support.\n              // gitlinks\n              return\n            }\n            case 'commit-blob': {\n              // TODO: submodule\n              // But... we'll complain if there is a *file* where we would\n              // put a submodule if we had submodule support.\n              return ['conflict', fullpath]\n            }\n            default: {\n              return ['error', `new entry Unhandled type ${commit.type}`]\n            }\n          }\n        }\n        // Something in stage but not in the commit OR the workdir.\n        // Note: I verified this behavior against canonical git.\n        case '100': {\n          return ['delete-index', fullpath]\n        }\n        // Deleted entries\n        // TODO: How to handle if stage type and workdir type mismatch?\n        case '101': {\n          switch (await stage.type()) {\n            case 'tree': {\n              return ['rmdir-index', fullpath]\n            }\n            case 'blob': {\n              // Git checks that the workdir.oid === stage.oid before deleting file\n              if ((await stage.oid()) !== (await workdir.oid())) {\n                if (force) {\n                  return ['delete', fullpath]\n                } else {\n                  return ['conflict', fullpath]\n                }\n              } else {\n                return ['delete', fullpath]\n              }\n            }\n            case 'commit': {\n              return ['rmdir-index', fullpath]\n            }\n            default: {\n              return [\n                'error',\n                `delete entry Unhandled type ${await stage.type()}`,\n              ]\n            }\n          }\n        }\n        /* eslint-disable no-fallthrough */\n        // File missing from workdir\n        case '110':\n        // Possibly modified entries\n        case '111': {\n          /* eslint-enable no-fallthrough */\n          switch (`${await stage.type()}-${await commit.type()}`) {\n            case 'tree-tree': {\n              return\n            }\n            case 'blob-blob': {\n              // If the file hasn't changed, there is no need to do anything.\n              // Existing file modifications in the workdir can be be left as is.\n              if (\n                (await stage.oid()) === (await commit.oid()) &&\n                (await stage.mode()) === (await commit.mode()) &&\n                !force\n              ) {\n                return\n              }\n\n              // Check for local changes that would be lost\n              if (workdir) {\n                // Note: canonical git only compares with the stage. But we're smart enough\n                // to compare to the stage AND the incoming commit.\n                if (\n                  (await workdir.oid()) !== (await stage.oid()) &&\n                  (await workdir.oid()) !== (await commit.oid())\n                ) {\n                  if (force) {\n                    return [\n                      'update',\n                      fullpath,\n                      await commit.oid(),\n                      await commit.mode(),\n                      (await commit.mode()) !== (await workdir.mode()),\n                    ]\n                  } else {\n                    return ['conflict', fullpath]\n                  }\n                }\n              } else if (force) {\n                return [\n                  'update',\n                  fullpath,\n                  await commit.oid(),\n                  await commit.mode(),\n                  (await commit.mode()) !== (await stage.mode()),\n                ]\n              }\n              // Has file mode changed?\n              if ((await commit.mode()) !== (await stage.mode())) {\n                return [\n                  'update',\n                  fullpath,\n                  await commit.oid(),\n                  await commit.mode(),\n                  true,\n                ]\n              }\n              // TODO: HANDLE SYMLINKS\n              // Has the file content changed?\n              if ((await commit.oid()) !== (await stage.oid())) {\n                return [\n                  'update',\n                  fullpath,\n                  await commit.oid(),\n                  await commit.mode(),\n                  false,\n                ]\n              } else {\n                return\n              }\n            }\n            case 'tree-blob': {\n              return ['update-dir-to-blob', fullpath, await commit.oid()]\n            }\n            case 'blob-tree': {\n              return ['update-blob-to-tree', fullpath]\n            }\n            case 'commit-commit': {\n              return [\n                'mkdir-index',\n                fullpath,\n                await commit.oid(),\n                await commit.mode(),\n              ]\n            }\n            default: {\n              return [\n                'error',\n                `update entry Unhandled type ${await stage.type()}-${await commit.type()}`,\n              ]\n            }\n          }\n        }\n      }\n    },\n    // Modify the default flat mapping\n    reduce: async function (parent, children) {\n      children = flat(children);\n      if (!parent) {\n        return children\n      } else if (parent && parent[0] === 'rmdir') {\n        children.push(parent);\n        return children\n      } else {\n        children.unshift(parent);\n        return children\n      }\n    },\n  })\n}\n\nasync function updateIndex({ index, fullpath, stats, oid }) {\n  try {\n    index.insert({\n      filepath: fullpath,\n      stats,\n      oid,\n    });\n  } catch (e) {\n    console.warn(`Error inserting ${fullpath} into index:`, e);\n  }\n}\nasync function updateWorkingDir(\n  { fs, cache, gitdir, dir },\n  [method, fullpath, oid, mode, chmod]\n) {\n  const filepath = `${dir}/${fullpath}`;\n  if (method !== 'create-index' && method !== 'mkdir-index') {\n    const { object } = await _readObject({ fs, cache, gitdir, oid });\n    if (chmod) {\n      await fs.rm(filepath);\n    }\n    if (mode === 0o100644) {\n      // regular file\n      await fs.write(filepath, object);\n    } else if (mode === 0o100755) {\n      // executable file\n      await fs.write(filepath, object, { mode: 0o777 });\n    } else if (mode === 0o120000) {\n      // symlink\n      await fs.writelink(filepath, object);\n    } else {\n      throw new InternalError(\n        `Invalid mode 0o${mode.toString(8)} detected in blob ${oid}`\n      )\n    }\n  }\n  const stats = await fs.lstat(filepath);\n  if (mode === 0o100755) {\n    stats.mode = 0o755;\n  }\n  if (method === 'mkdir-index') {\n    stats.mode = 0o160000;\n  }\n  return [fullpath, oid, stats]\n}\n\nasync function batchAllSettled(operationName, tasks, onProgress, batchSize) {\n  const results = [];\n  try {\n    for (let i = 0; i < tasks.length; i += batchSize) {\n      const batch = tasks.slice(i, i + batchSize).map(task => task());\n      const batchResults = await Promise.allSettled(batch);\n      batchResults.forEach(result => {\n        if (result.status === 'fulfilled') results.push(result.value);\n      });\n      if (onProgress) {\n        await onProgress({\n          phase: 'Updating workdir',\n          loaded: i + batch.length,\n          total: tasks.length,\n        });\n      }\n    }\n\n    return results\n  } catch (error) {\n    console.error(`Error during ${operationName}: ${error}`);\n  }\n\n  return results\n}\n\n// @ts-check\n\n/**\n * Checkout a branch\n *\n * If the branch already exists it will check out that branch. Otherwise, it will create a new remote tracking branch set to track the remote branch of that name.\n *\n * @param {object} args\n * @param {FsClient} args.fs - a file system implementation\n * @param {ProgressCallback} [args.onProgress] - optional progress event callback\n * @param {PostCheckoutCallback} [args.onPostCheckout] - optional post-checkout hook callback\n * @param {string} args.dir - The [working tree](dir-vs-gitdir.md) directory path\n * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path\n * @param {string} [args.ref = 'HEAD'] - Source to checkout files from\n * @param {string[]} [args.filepaths] - Limit the checkout to the given files and directories\n * @param {string} [args.remote = 'origin'] - Which remote repository to use\n * @param {boolean} [args.noCheckout = false] - If true, will update HEAD but won't update the working directory\n * @param {boolean} [args.noUpdateHead] - If true, will update the working directory but won't update HEAD. Defaults to `false` when `ref` is provided, and `true` if `ref` is not provided.\n * @param {boolean} [args.dryRun = false] - If true, simulates a checkout so you can test whether it would succeed.\n * @param {boolean} [args.force = false] - If true, conflicts will be ignored and files will be overwritten regardless of local changes.\n * @param {boolean} [args.track = true] - If false, will not set the remote branch tracking information. Defaults to true.\n * @param {object} [args.cache] - a [cache](cache.md) object\n * @param {boolean} [args.nonBlocking = false] - If true, will use non-blocking file system operations to allow for better performance in certain environments (For example, in Browsers)\n * @param {number} [args.batchSize = 100] - If args.nonBlocking is true, batchSize is the number of files to process at a time avoid blocking the executing thread. The default value of 100 is a good starting point.\n *\n * @returns {Promise<void>} Resolves successfully when filesystem operations are complete\n *\n * @example\n * // switch to the main branch\n * await git.checkout({\n *   fs,\n *   dir: '/tutorial',\n *   ref: 'main'\n * })\n * console.log('done')\n *\n * @example\n * // restore the 'docs' and 'src/docs' folders to the way they were, overwriting any changes\n * await git.checkout({\n *   fs,\n *   dir: '/tutorial',\n *   force: true,\n *   filepaths: ['docs', 'src/docs']\n * })\n * console.log('done')\n *\n * @example\n * // restore the 'docs' and 'src/docs' folders to the way they are in the 'develop' branch, overwriting any changes\n * await git.checkout({\n *   fs,\n *   dir: '/tutorial',\n *   ref: 'develop',\n *   noUpdateHead: true,\n *   force: true,\n *   filepaths: ['docs', 'src/docs']\n * })\n * console.log('done')\n */\nasync function checkout({\n  fs,\n  onProgress,\n  onPostCheckout,\n  dir,\n  gitdir = join(dir, '.git'),\n  remote = 'origin',\n  ref: _ref,\n  filepaths,\n  noCheckout = false,\n  noUpdateHead = _ref === undefined,\n  dryRun = false,\n  force = false,\n  track = true,\n  cache = {},\n  nonBlocking = false,\n  batchSize = 100,\n}) {\n  try {\n    assertParameter('fs', fs);\n    assertParameter('dir', dir);\n    assertParameter('gitdir', gitdir);\n\n    const ref = _ref || 'HEAD';\n    const fsp = new FileSystem(fs);\n    const updatedGitdir = await discoverGitdir({ fsp, dotgit: gitdir });\n    return await _checkout({\n      fs: fsp,\n      cache,\n      onProgress,\n      onPostCheckout,\n      dir,\n      gitdir: updatedGitdir,\n      remote,\n      ref,\n      filepaths,\n      noCheckout,\n      noUpdateHead,\n      dryRun,\n      force,\n      track,\n      nonBlocking,\n      batchSize,\n    })\n  } catch (err) {\n    err.caller = 'git.checkout';\n    throw err\n  }\n}\n\n// @see https://git-scm.com/docs/git-rev-parse.html#_specifying_revisions\nconst abbreviateRx = /^refs\\/(heads\\/|tags\\/|remotes\\/)?(.*)/;\n\nfunction abbreviateRef(ref) {\n  const match = abbreviateRx.exec(ref);\n  if (match) {\n    if (match[1] === 'remotes/' && ref.endsWith('/HEAD')) {\n      return match[2].slice(0, -5)\n    } else {\n      return match[2]\n    }\n  }\n  return ref\n}\n\n// @ts-check\n\n/**\n * @param {Object} args\n * @param {import('../models/FileSystem.js').FileSystem} args.fs\n * @param {string} args.gitdir\n * @param {boolean} [args.fullname = false] - Return the full path (e.g. \"refs/heads/main\") instead of the abbreviated form.\n * @param {boolean} [args.test = false] - If the current branch doesn't actually exist (such as right after git init) then return `undefined`.\n *\n * @returns {Promise<string|void>} The name of the current branch or undefined if the HEAD is detached.\n *\n */\nasync function _currentBranch({\n  fs,\n  gitdir,\n  fullname = false,\n  test = false,\n}) {\n  const ref = await GitRefManager.resolve({\n    fs,\n    gitdir,\n    ref: 'HEAD',\n    depth: 2,\n  });\n  if (test) {\n    try {\n      await GitRefManager.resolve({ fs, gitdir, ref });\n    } catch (_) {\n      return\n    }\n  }\n  // Return `undefined` for detached HEAD\n  if (!ref.startsWith('refs/')) return\n  return fullname ? ref : abbreviateRef(ref)\n}\n\nfunction translateSSHtoHTTP(url) {\n  // handle \"shorter scp-like syntax\"\n  url = url.replace(/^git@([^:]+):/, 'https://$1/');\n  // handle proper SSH URLs\n  url = url.replace(/^ssh:\\/\\//, 'https://');\n  return url\n}\n\nfunction calculateBasicAuthHeader({ username = '', password = '' }) {\n  return `Basic ${Buffer.from(`${username}:${password}`).toString('base64')}`\n}\n\n// Currently 'for await' upsets my linters.\nasync function forAwait(iterable, cb) {\n  const iter = getIterator(iterable);\n  while (true) {\n    const { value, done } = await iter.next();\n    if (value) await cb(value);\n    if (done) break\n  }\n  if (iter.return) iter.return();\n}\n\nasync function collect(iterable) {\n  let size = 0;\n  const buffers = [];\n  // This will be easier once `for await ... of` loops are available.\n  await forAwait(iterable, value => {\n    buffers.push(value);\n    size += value.byteLength;\n  });\n  const result = new Uint8Array(size);\n  let nextIndex = 0;\n  for (const buffer of buffers) {\n    result.set(buffer, nextIndex);\n    nextIndex += buffer.byteLength;\n  }\n  return result\n}\n\nfunction extractAuthFromUrl(url) {\n  // For whatever reason, the `fetch` API does not convert credentials embedded in the URL\n  // into Basic Authentication headers automatically. Instead it throws an error!\n  // So we must manually parse the URL, rip out the user:password portion if it is present\n  // and compute the Authorization header.\n  // Note: I tried using new URL(url) but that throws a security exception in Edge. :rolleyes:\n  let userpass = url.match(/^https?:\\/\\/([^/]+)@/);\n  // No credentials, return the url unmodified and an empty auth object\n  if (userpass == null) return { url, auth: {} }\n  userpass = userpass[1];\n  const [username, password] = userpass.split(':');\n  // Remove credentials from URL\n  url = url.replace(`${userpass}@`, '');\n  // Has credentials, return the fetch-safe URL and the parsed credentials\n  return { url, auth: { username, password } }\n}\n\nfunction padHex(b, n) {\n  const s = n.toString(16);\n  return '0'.repeat(b - s.length) + s\n}\n\n/**\npkt-line Format\n---------------\n\nMuch (but not all) of the payload is described around pkt-lines.\n\nA pkt-line is a variable length binary string.  The first four bytes\nof the line, the pkt-len, indicates the total length of the line,\nin hexadecimal.  The pkt-len includes the 4 bytes used to contain\nthe length's hexadecimal representation.\n\nA pkt-line MAY contain binary data, so implementers MUST ensure\npkt-line parsing/formatting routines are 8-bit clean.\n\nA non-binary line SHOULD BE terminated by an LF, which if present\nMUST be included in the total length. Receivers MUST treat pkt-lines\nwith non-binary data the same whether or not they contain the trailing\nLF (stripping the LF if present, and not complaining when it is\nmissing).\n\nThe maximum length of a pkt-line's data component is 65516 bytes.\nImplementations MUST NOT send pkt-line whose length exceeds 65520\n(65516 bytes of payload + 4 bytes of length data).\n\nImplementations SHOULD NOT send an empty pkt-line (\"0004\").\n\nA pkt-line with a length field of 0 (\"0000\"), called a flush-pkt,\nis a special case and MUST be handled differently than an empty\npkt-line (\"0004\").\n\n----\n  pkt-line     =  data-pkt / flush-pkt\n\n  data-pkt     =  pkt-len pkt-payload\n  pkt-len      =  4*(HEXDIG)\n  pkt-payload  =  (pkt-len - 4)*(OCTET)\n\n  flush-pkt    = \"0000\"\n----\n\nExamples (as C-style strings):\n\n----\n  pkt-line          actual value\n  ---------------------------------\n  \"0006a\\n\"         \"a\\n\"\n  \"0005a\"           \"a\"\n  \"000bfoobar\\n\"    \"foobar\\n\"\n  \"0004\"            \"\"\n----\n*/\n\n// I'm really using this more as a namespace.\n// There's not a lot of \"state\" in a pkt-line\n\nclass GitPktLine {\n  static flush() {\n    return Buffer.from('0000', 'utf8')\n  }\n\n  static delim() {\n    return Buffer.from('0001', 'utf8')\n  }\n\n  static encode(line) {\n    if (typeof line === 'string') {\n      line = Buffer.from(line);\n    }\n    const length = line.length + 4;\n    const hexlength = padHex(4, length);\n    return Buffer.concat([Buffer.from(hexlength, 'utf8'), line])\n  }\n\n  static streamReader(stream) {\n    const reader = new StreamReader(stream);\n    return async function read() {\n      try {\n        let length = await reader.read(4);\n        if (length == null) return true\n        length = parseInt(length.toString('utf8'), 16);\n        if (length === 0) return null\n        if (length === 1) return null // delim packets\n        const buffer = await reader.read(length - 4);\n        if (buffer == null) return true\n        return buffer\n      } catch (err) {\n        stream.error = err;\n        return true\n      }\n    }\n  }\n}\n\n// @ts-check\n\n/**\n * @param {function} read\n */\nasync function parseCapabilitiesV2(read) {\n  /** @type {Object<string, string | true>} */\n  const capabilities2 = {};\n\n  let line;\n  while (true) {\n    line = await read();\n    if (line === true) break\n    if (line === null) continue\n    line = line.toString('utf8').replace(/\\n$/, '');\n    const i = line.indexOf('=');\n    if (i > -1) {\n      const key = line.slice(0, i);\n      const value = line.slice(i + 1);\n      capabilities2[key] = value;\n    } else {\n      capabilities2[line] = true;\n    }\n  }\n  return { protocolVersion: 2, capabilities2 }\n}\n\nasync function parseRefsAdResponse(stream, { service }) {\n  const capabilities = new Set();\n  const refs = new Map();\n  const symrefs = new Map();\n\n  // There is probably a better way to do this, but for now\n  // let's just throw the result parser inline here.\n  const read = GitPktLine.streamReader(stream);\n  let lineOne = await read();\n  // skip past any flushes\n  while (lineOne === null) lineOne = await read();\n\n  if (lineOne === true) throw new EmptyServerResponseError()\n\n  // Handle protocol v2 responses (Bitbucket Server doesn't include a `# service=` line)\n  if (lineOne.includes('version 2')) {\n    return parseCapabilitiesV2(read)\n  }\n\n  // Clients MUST ignore an LF at the end of the line.\n  if (lineOne.toString('utf8').replace(/\\n$/, '') !== `# service=${service}`) {\n    throw new ParseError(`# service=${service}\\\\n`, lineOne.toString('utf8'))\n  }\n  let lineTwo = await read();\n  // skip past any flushes\n  while (lineTwo === null) lineTwo = await read();\n  // In the edge case of a brand new repo, zero refs (and zero capabilities)\n  // are returned.\n  if (lineTwo === true) return { capabilities, refs, symrefs }\n  lineTwo = lineTwo.toString('utf8');\n\n  // Handle protocol v2 responses\n  if (lineTwo.includes('version 2')) {\n    return parseCapabilitiesV2(read)\n  }\n\n  const [firstRef, capabilitiesLine] = splitAndAssert(lineTwo, '\\x00', '\\\\x00');\n  capabilitiesLine.split(' ').map(x => capabilities.add(x));\n  // see no-refs in https://git-scm.com/docs/pack-protocol#_reference_discovery (since git 2.41.0)\n  if (firstRef !== '0000000000000000000000000000000000000000 capabilities^{}') {\n    const [ref, name] = splitAndAssert(firstRef, ' ', ' ');\n    refs.set(name, ref);\n    while (true) {\n      const line = await read();\n      if (line === true) break\n      if (line !== null) {\n        const [ref, name] = splitAndAssert(line.toString('utf8'), ' ', ' ');\n        refs.set(name, ref);\n      }\n    }\n  }\n  // Symrefs are thrown into the \"capabilities\" unfortunately.\n  for (const cap of capabilities) {\n    if (cap.startsWith('symref=')) {\n      const m = cap.match(/symref=([^:]+):(.*)/);\n      if (m.length === 3) {\n        symrefs.set(m[1], m[2]);\n      }\n    }\n  }\n  return { protocolVersion: 1, capabilities, refs, symrefs }\n}\n\nfunction splitAndAssert(line, sep, expected) {\n  const split = line.trim().split(sep);\n  if (split.length !== 2) {\n    throw new ParseError(\n      `Two strings separated by '${expected}'`,\n      line.toString('utf8')\n    )\n  }\n  return split\n}\n\n// Try to accommodate known CORS proxy implementations:\n// - https://jcubic.pl/proxy.php?  <-- uses query string\n// - https://cors.isomorphic-git.org  <-- uses path\nconst corsProxify = (corsProxy, url) =>\n  corsProxy.endsWith('?')\n    ? `${corsProxy}${url}`\n    : `${corsProxy}/${url.replace(/^https?:\\/\\//, '')}`;\n\nconst updateHeaders = (headers, auth) => {\n  // Update the basic auth header\n  if (auth.username || auth.password) {\n    headers.Authorization = calculateBasicAuthHeader(auth);\n  }\n  // but any manually provided headers take precedence\n  if (auth.headers) {\n    Object.assign(headers, auth.headers);\n  }\n};\n\n/**\n * @param {GitHttpResponse} res\n *\n * @returns {{ preview: string, response: string, data: Buffer }}\n */\nconst stringifyBody = async res => {\n  try {\n    // Some services provide a meaningful error message in the body of 403s like \"token lacks the scopes necessary to perform this action\"\n    const data = Buffer.from(await collect(res.body));\n    const response = data.toString('utf8');\n    const preview =\n      response.length < 256 ? response : response.slice(0, 256) + '...';\n    return { preview, response, data }\n  } catch (e) {\n    return {}\n  }\n};\n\nclass GitRemoteHTTP {\n  /**\n   * Returns the capabilities of the GitRemoteHTTP class.\n   *\n   * @returns {Promise<string[]>} - An array of supported capabilities.\n   */\n  static async capabilities() {\n    return ['discover', 'connect']\n  }\n\n  /**\n   * Discovers references from a remote Git repository.\n   *\n   * @param {Object} args\n   * @param {HttpClient} args.http - The HTTP client to use for requests.\n   * @param {ProgressCallback} [args.onProgress] - Callback for progress updates.\n   * @param {AuthCallback} [args.onAuth] - Callback for providing authentication credentials.\n   * @param {AuthFailureCallback} [args.onAuthFailure] - Callback for handling authentication failures.\n   * @param {AuthSuccessCallback} [args.onAuthSuccess] - Callback for handling successful authentication.\n   * @param {string} [args.corsProxy] - Optional CORS proxy URL.\n   * @param {string} args.service - The Git service (e.g., \"git-upload-pack\").\n   * @param {string} args.url - The URL of the remote repository.\n   * @param {Object<string, string>} args.headers - HTTP headers to include in the request.\n   * @param {1 | 2} args.protocolVersion - The Git protocol version to use.\n   * @returns {Promise<Object>} - The parsed response from the remote repository.\n   * @throws {HttpError} - If the HTTP request fails.\n   * @throws {SmartHttpError} - If the response cannot be parsed.\n   * @throws {UserCanceledError} - If the user cancels the operation.\n   */\n  static async discover({\n    http,\n    onProgress,\n    onAuth,\n    onAuthSuccess,\n    onAuthFailure,\n    corsProxy,\n    service,\n    url: _origUrl,\n    headers,\n    protocolVersion,\n  }) {\n    let { url, auth } = extractAuthFromUrl(_origUrl);\n    const proxifiedURL = corsProxy ? corsProxify(corsProxy, url) : url;\n    if (auth.username || auth.password) {\n      headers.Authorization = calculateBasicAuthHeader(auth);\n    }\n    if (protocolVersion === 2) {\n      headers['Git-Protocol'] = 'version=2';\n    }\n\n    let res;\n    let tryAgain;\n    let providedAuthBefore = false;\n    do {\n      res = await http.request({\n        onProgress,\n        method: 'GET',\n        url: `${proxifiedURL}/info/refs?service=${service}`,\n        headers,\n      });\n\n      // the default loop behavior\n      tryAgain = false;\n\n      // 401 is the \"correct\" response for access denied. 203 is Non-Authoritative Information and comes from Azure DevOps, which\n      // apparently doesn't realize this is a git request and is returning the HTML for the \"Azure DevOps Services | Sign In\" page.\n      if (res.statusCode === 401 || res.statusCode === 203) {\n        // On subsequent 401s, call `onAuthFailure` instead of `onAuth`.\n        // This is so that naive `onAuth` callbacks that return a fixed value don't create an infinite loop of retrying.\n        const getAuth = providedAuthBefore ? onAuthFailure : onAuth;\n        if (getAuth) {\n          // Acquire credentials and try again\n          // TODO: read `useHttpPath` value from git config and pass along?\n          auth = await getAuth(url, {\n            ...auth,\n            headers: { ...headers },\n          });\n          if (auth && auth.cancel) {\n            throw new UserCanceledError()\n          } else if (auth) {\n            updateHeaders(headers, auth);\n            providedAuthBefore = true;\n            tryAgain = true;\n          }\n        }\n      } else if (\n        res.statusCode === 200 &&\n        providedAuthBefore &&\n        onAuthSuccess\n      ) {\n        await onAuthSuccess(url, auth);\n      }\n    } while (tryAgain)\n\n    if (res.statusCode !== 200) {\n      const { response } = await stringifyBody(res);\n      throw new HttpError(res.statusCode, res.statusMessage, response)\n    }\n    // Git \"smart\" HTTP servers should respond with the correct Content-Type header.\n    if (\n      res.headers['content-type'] === `application/x-${service}-advertisement`\n    ) {\n      const remoteHTTP = await parseRefsAdResponse(res.body, { service });\n      remoteHTTP.auth = auth;\n      return remoteHTTP\n    } else {\n      // If they don't send the correct content-type header, that's a good indicator it is either a \"dumb\" HTTP\n      // server, or the user specified an incorrect remote URL and the response is actually an HTML page.\n      // In this case, we save the response as plain text so we can generate a better error message if needed.\n      const { preview, response, data } = await stringifyBody(res);\n      // For backwards compatibility, try to parse it anyway.\n      // TODO: maybe just throw instead of trying?\n      try {\n        const remoteHTTP = await parseRefsAdResponse([data], { service });\n        remoteHTTP.auth = auth;\n        return remoteHTTP\n      } catch (e) {\n        throw new SmartHttpError(preview, response)\n      }\n    }\n  }\n\n  /**\n   * Connects to a remote Git repository and sends a request.\n   *\n   * @param {Object} args\n   * @param {HttpClient} args.http - The HTTP client to use for requests.\n   * @param {ProgressCallback} [args.onProgress] - Callback for progress updates.\n   * @param {string} [args.corsProxy] - Optional CORS proxy URL.\n   * @param {string} args.service - The Git service (e.g., \"git-upload-pack\").\n   * @param {string} args.url - The URL of the remote repository.\n   * @param {Object<string, string>} [args.headers] - HTTP headers to include in the request.\n   * @param {any} args.body - The request body to send.\n   * @param {any} args.auth - Authentication credentials.\n   * @returns {Promise<GitHttpResponse>} - The HTTP response from the remote repository.\n   * @throws {HttpError} - If the HTTP request fails.\n   */\n  static async connect({\n    http,\n    onProgress,\n    corsProxy,\n    service,\n    url,\n    auth,\n    body,\n    headers,\n  }) {\n    // We already have the \"correct\" auth value at this point, but\n    // we need to strip out the username/password from the URL yet again.\n    const urlAuth = extractAuthFromUrl(url);\n    if (urlAuth) url = urlAuth.url;\n\n    if (corsProxy) url = corsProxify(corsProxy, url);\n\n    headers['content-type'] = `application/x-${service}-request`;\n    headers.accept = `application/x-${service}-result`;\n    updateHeaders(headers, auth);\n\n    const res = await http.request({\n      onProgress,\n      method: 'POST',\n      url: `${url}/${service}`,\n      body,\n      headers,\n    });\n    if (res.statusCode !== 200) {\n      const { response } = stringifyBody(res);\n      throw new HttpError(res.statusCode, res.statusMessage, response)\n    }\n    return res\n  }\n}\n\n/**\n * A class for managing Git remotes and determining the appropriate remote helper for a given URL.\n */\nclass GitRemoteManager {\n  /**\n   * Determines the appropriate remote helper for the given URL.\n   *\n   * @param {Object} args\n   * @param {string} args.url - The URL of the remote repository.\n   * @returns {Object} - The remote helper class for the specified transport.\n   * @throws {UrlParseError} - If the URL cannot be parsed.\n   * @throws {UnknownTransportError} - If the transport is not supported.\n   */\n  static getRemoteHelperFor({ url }) {\n    // TODO: clean up the remoteHelper API and move into PluginCore\n    const remoteHelpers = new Map();\n    remoteHelpers.set('http', GitRemoteHTTP);\n    remoteHelpers.set('https', GitRemoteHTTP);\n\n    const parts = parseRemoteUrl({ url });\n    if (!parts) {\n      throw new UrlParseError(url)\n    }\n    if (remoteHelpers.has(parts.transport)) {\n      return remoteHelpers.get(parts.transport)\n    }\n    throw new UnknownTransportError(\n      url,\n      parts.transport,\n      parts.transport === 'ssh' ? translateSSHtoHTTP(url) : undefined\n    )\n  }\n}\n\n/**\n * Parses a remote URL and extracts its transport and address.\n *\n * @param {Object} args\n * @param {string} args.url - The URL of the remote repository.\n * @returns {Object|undefined} - An object containing the transport and address, or undefined if parsing fails.\n */\nfunction parseRemoteUrl({ url }) {\n  // the stupid \"shorter scp-like syntax\"\n  if (url.startsWith('git@')) {\n    return {\n      transport: 'ssh',\n      address: url,\n    }\n  }\n  const matches = url.match(/(\\w+)(:\\/\\/|::)(.*)/);\n  if (matches === null) return\n  /*\n   * When git encounters a URL of the form <transport>://<address>, where <transport> is\n   * a protocol that it cannot handle natively, it automatically invokes git remote-<transport>\n   * with the full URL as the second argument.\n   *\n   * @see https://git-scm.com/docs/git-remote-helpers\n   */\n  if (matches[2] === '://') {\n    return {\n      transport: matches[1],\n      address: matches[0],\n    }\n  }\n  /*\n   * A URL of the form <transport>::<address> explicitly instructs git to invoke\n   * git remote-<transport> with <address> as the second argument.\n   *\n   * @see https://git-scm.com/docs/git-remote-helpers\n   */\n  if (matches[2] === '::') {\n    return {\n      transport: matches[1],\n      address: matches[3],\n    }\n  }\n}\n\nlet lock$2 = null;\n\nclass GitShallowManager {\n  /**\n   * Reads the `shallow` file in the Git repository and returns a set of object IDs (OIDs).\n   *\n   * @param {Object} args\n   * @param {FSClient} args.fs - A file system implementation.\n   * @param {string} [args.gitdir] - [required] The [git directory](dir-vs-gitdir.md) path\n   * @returns {Promise<Set<string>>} - A set of shallow object IDs.\n   */\n  static async read({ fs, gitdir }) {\n    if (lock$2 === null) lock$2 = new AsyncLock();\n    const filepath = join(gitdir, 'shallow');\n    const oids = new Set();\n    await lock$2.acquire(filepath, async function () {\n      const text = await fs.read(filepath, { encoding: 'utf8' });\n      if (text === null) return oids // no file\n      if (text.trim() === '') return oids // empty file\n      text\n        .trim()\n        .split('\\n')\n        .map(oid => oids.add(oid));\n    });\n    return oids\n  }\n\n  /**\n   * Writes a set of object IDs (OIDs) to the `shallow` file in the Git repository.\n   * If the set is empty, the `shallow` file is removed.\n   *\n   * @param {Object} args\n   * @param {FSClient} args.fs - A file system implementation.\n   * @param {string} [args.gitdir] - [required] The [git directory](dir-vs-gitdir.md) path\n   * @param {Set<string>} args.oids - A set of shallow object IDs to write.\n   * @returns {Promise<void>}\n   */\n  static async write({ fs, gitdir, oids }) {\n    if (lock$2 === null) lock$2 = new AsyncLock();\n    const filepath = join(gitdir, 'shallow');\n    if (oids.size > 0) {\n      const text = [...oids].join('\\n') + '\\n';\n      await lock$2.acquire(filepath, async function () {\n        await fs.write(filepath, text, {\n          encoding: 'utf8',\n        });\n      });\n    } else {\n      // No shallows\n      await lock$2.acquire(filepath, async function () {\n        await fs.rm(filepath);\n      });\n    }\n  }\n}\n\nasync function hasObjectLoose({ fs, gitdir, oid }) {\n  const source = `objects/${oid.slice(0, 2)}/${oid.slice(2)}`;\n  return fs.exists(`${gitdir}/${source}`)\n}\n\nasync function hasObjectPacked({\n  fs,\n  cache,\n  gitdir,\n  oid,\n  getExternalRefDelta,\n}) {\n  // Check to see if it's in a packfile.\n  // Iterate through all the .idx files\n  let list = await fs.readdir(join(gitdir, 'objects/pack'));\n  list = list.filter(x => x.endsWith('.idx'));\n  for (const filename of list) {\n    const indexFile = `${gitdir}/objects/pack/${filename}`;\n    const p = await readPackIndex({\n      fs,\n      cache,\n      filename: indexFile,\n      getExternalRefDelta,\n    });\n    if (p.error) throw new InternalError(p.error)\n    // If the packfile DOES have the oid we're looking for...\n    if (p.offsets.has(oid)) {\n      return true\n    }\n  }\n  // Failed to find it\n  return false\n}\n\nasync function hasObject({\n  fs,\n  cache,\n  gitdir,\n  oid,\n  format = 'content',\n}) {\n  // Curry the current read method so that the packfile un-deltification\n  // process can acquire external ref-deltas.\n  const getExternalRefDelta = oid => _readObject({ fs, cache, gitdir, oid });\n\n  // Look for it in the loose object directory.\n  let result = await hasObjectLoose({ fs, gitdir, oid });\n  // Check to see if it's in a packfile.\n  if (!result) {\n    result = await hasObjectPacked({\n      fs,\n      cache,\n      gitdir,\n      oid,\n      getExternalRefDelta,\n    });\n  }\n  // Finally\n  return result\n}\n\n// TODO: make a function that just returns obCount. then emptyPackfile = () => sizePack(pack) === 0\nfunction emptyPackfile(pack) {\n  const pheader = '5041434b';\n  const version = '00000002';\n  const obCount = '00000000';\n  const header = pheader + version + obCount;\n  return pack.slice(0, 12).toString('hex') === header\n}\n\nfunction filterCapabilities(server, client) {\n  const serverNames = server.map(cap => cap.split('=', 1)[0]);\n  return client.filter(cap => {\n    const name = cap.split('=', 1)[0];\n    return serverNames.includes(name)\n  })\n}\n\nconst pkg = {\n  name: 'isomorphic-git',\n  version: '1.36.0',\n  agent: 'git/isomorphic-git@1.36.0',\n};\n\nclass FIFO {\n  constructor() {\n    this._queue = [];\n  }\n\n  write(chunk) {\n    if (this._ended) {\n      throw Error('You cannot write to a FIFO that has already been ended!')\n    }\n    if (this._waiting) {\n      const resolve = this._waiting;\n      this._waiting = null;\n      resolve({ value: chunk });\n    } else {\n      this._queue.push(chunk);\n    }\n  }\n\n  end() {\n    this._ended = true;\n    if (this._waiting) {\n      const resolve = this._waiting;\n      this._waiting = null;\n      resolve({ done: true });\n    }\n  }\n\n  destroy(err) {\n    this.error = err;\n    this.end();\n  }\n\n  async next() {\n    if (this._queue.length > 0) {\n      return { value: this._queue.shift() }\n    }\n    if (this._ended) {\n      return { done: true }\n    }\n    if (this._waiting) {\n      throw Error(\n        'You cannot call read until the previous call to read has returned!'\n      )\n    }\n    return new Promise(resolve => {\n      this._waiting = resolve;\n    })\n  }\n}\n\n// Note: progress messages are designed to be written directly to the terminal,\n// so they are often sent with just a carriage return to overwrite the last line of output.\n// But there are also messages delimited with newlines.\n// I also include CRLF just in case.\nfunction findSplit(str) {\n  const r = str.indexOf('\\r');\n  const n = str.indexOf('\\n');\n  if (r === -1 && n === -1) return -1\n  if (r === -1) return n + 1 // \\n\n  if (n === -1) return r + 1 // \\r\n  if (n === r + 1) return n + 1 // \\r\\n\n  return Math.min(r, n) + 1 // \\r or \\n\n}\n\nfunction splitLines(input) {\n  const output = new FIFO();\n  let tmp = ''\n  ;(async () => {\n    await forAwait(input, chunk => {\n      chunk = chunk.toString('utf8');\n      tmp += chunk;\n      while (true) {\n        const i = findSplit(tmp);\n        if (i === -1) break\n        output.write(tmp.slice(0, i));\n        tmp = tmp.slice(i);\n      }\n    });\n    if (tmp.length > 0) {\n      output.write(tmp);\n    }\n    output.end();\n  })();\n  return output\n}\n\n/*\nIf 'side-band' or 'side-band-64k' capabilities have been specified by\nthe client, the server will send the packfile data multiplexed.\n\nEach packet starting with the packet-line length of the amount of data\nthat follows, followed by a single byte specifying the sideband the\nfollowing data is coming in on.\n\nIn 'side-band' mode, it will send up to 999 data bytes plus 1 control\ncode, for a total of up to 1000 bytes in a pkt-line.  In 'side-band-64k'\nmode it will send up to 65519 data bytes plus 1 control code, for a\ntotal of up to 65520 bytes in a pkt-line.\n\nThe sideband byte will be a '1', '2' or a '3'. Sideband '1' will contain\npackfile data, sideband '2' will be used for progress information that the\nclient will generally print to stderr and sideband '3' is used for error\ninformation.\n\nIf no 'side-band' capability was specified, the server will stream the\nentire packfile without multiplexing.\n*/\n\nclass GitSideBand {\n  static demux(input) {\n    const read = GitPktLine.streamReader(input);\n    // And now for the ridiculous side-band or side-band-64k protocol\n    const packetlines = new FIFO();\n    const packfile = new FIFO();\n    const progress = new FIFO();\n    // TODO: Use a proper through stream?\n    const nextBit = async function () {\n      const line = await read();\n      // Skip over flush packets\n      if (line === null) return nextBit()\n      // A made up convention to signal there's no more to read.\n      if (line === true) {\n        packetlines.end();\n        progress.end();\n        input.error ? packfile.destroy(input.error) : packfile.end();\n        return\n      }\n      // Examine first byte to determine which output \"stream\" to use\n      switch (line[0]) {\n        case 1: {\n          // pack data\n          packfile.write(line.slice(1));\n          break\n        }\n        case 2: {\n          // progress message\n          progress.write(line.slice(1));\n          break\n        }\n        case 3: {\n          // fatal error message just before stream aborts\n          const error = line.slice(1);\n          progress.write(error);\n          packetlines.end();\n          progress.end();\n          packfile.destroy(new Error(error.toString('utf8')));\n          return\n        }\n        default: {\n          // Not part of the side-band-64k protocol\n          packetlines.write(line);\n        }\n      }\n      // Careful not to blow up the stack.\n      // I think Promises in a tail-call position should be OK.\n      nextBit();\n    };\n    nextBit();\n    return {\n      packetlines,\n      packfile,\n      progress,\n    }\n  }\n  // static mux ({\n  //   protocol, // 'side-band' or 'side-band-64k'\n  //   packetlines,\n  //   packfile,\n  //   progress,\n  //   error\n  // }) {\n  //   const MAX_PACKET_LENGTH = protocol === 'side-band-64k' ? 999 : 65519\n  //   let output = new PassThrough()\n  //   packetlines.on('data', data => {\n  //     if (data === null) {\n  //       output.write(GitPktLine.flush())\n  //     } else {\n  //       output.write(GitPktLine.encode(data))\n  //     }\n  //   })\n  //   let packfileWasEmpty = true\n  //   let packfileEnded = false\n  //   let progressEnded = false\n  //   let errorEnded = false\n  //   let goodbye = Buffer.concat([\n  //     GitPktLine.encode(Buffer.from('010A', 'hex')),\n  //     GitPktLine.flush()\n  //   ])\n  //   packfile\n  //     .on('data', data => {\n  //       packfileWasEmpty = false\n  //       const buffers = splitBuffer(data, MAX_PACKET_LENGTH)\n  //       for (const buffer of buffers) {\n  //         output.write(\n  //           GitPktLine.encode(Buffer.concat([Buffer.from('01', 'hex'), buffer]))\n  //         )\n  //       }\n  //     })\n  //     .on('end', () => {\n  //       packfileEnded = true\n  //       if (!packfileWasEmpty) output.write(goodbye)\n  //       if (progressEnded && errorEnded) output.end()\n  //     })\n  //   progress\n  //     .on('data', data => {\n  //       const buffers = splitBuffer(data, MAX_PACKET_LENGTH)\n  //       for (const buffer of buffers) {\n  //         output.write(\n  //           GitPktLine.encode(Buffer.concat([Buffer.from('02', 'hex'), buffer]))\n  //         )\n  //       }\n  //     })\n  //     .on('end', () => {\n  //       progressEnded = true\n  //       if (packfileEnded && errorEnded) output.end()\n  //     })\n  //   error\n  //     .on('data', data => {\n  //       const buffers = splitBuffer(data, MAX_PACKET_LENGTH)\n  //       for (const buffer of buffers) {\n  //         output.write(\n  //           GitPktLine.encode(Buffer.concat([Buffer.from('03', 'hex'), buffer]))\n  //         )\n  //       }\n  //     })\n  //     .on('end', () => {\n  //       errorEnded = true\n  //       if (progressEnded && packfileEnded) output.end()\n  //     })\n  //   return output\n  // }\n}\n\nasync function parseUploadPackResponse(stream) {\n  const { packetlines, packfile, progress } = GitSideBand.demux(stream);\n  const shallows = [];\n  const unshallows = [];\n  const acks = [];\n  let nak = false;\n  let done = false;\n  return new Promise((resolve, reject) => {\n    // Parse the response\n    forAwait(packetlines, data => {\n      const line = data.toString('utf8').trim();\n      if (line.startsWith('shallow')) {\n        const oid = line.slice(-41).trim();\n        if (oid.length !== 40) {\n          reject(new InvalidOidError(oid));\n        }\n        shallows.push(oid);\n      } else if (line.startsWith('unshallow')) {\n        const oid = line.slice(-41).trim();\n        if (oid.length !== 40) {\n          reject(new InvalidOidError(oid));\n        }\n        unshallows.push(oid);\n      } else if (line.startsWith('ACK')) {\n        const [, oid, status] = line.split(' ');\n        acks.push({ oid, status });\n        if (!status) done = true;\n      } else if (line.startsWith('NAK')) {\n        nak = true;\n        done = true;\n      } else {\n        done = true;\n        nak = true;\n      }\n      if (done) {\n        stream.error\n          ? reject(stream.error)\n          : resolve({ shallows, unshallows, acks, nak, packfile, progress });\n      }\n    }).finally(() => {\n      if (!done) {\n        stream.error\n          ? reject(stream.error)\n          : resolve({ shallows, unshallows, acks, nak, packfile, progress });\n      }\n    });\n  })\n}\n\nfunction writeUploadPackRequest({\n  capabilities = [],\n  wants = [],\n  haves = [],\n  shallows = [],\n  depth = null,\n  since = null,\n  exclude = [],\n}) {\n  const packstream = [];\n  wants = [...new Set(wants)]; // remove duplicates\n  let firstLineCapabilities = ` ${capabilities.join(' ')}`;\n  for (const oid of wants) {\n    packstream.push(GitPktLine.encode(`want ${oid}${firstLineCapabilities}\\n`));\n    firstLineCapabilities = '';\n  }\n  for (const oid of shallows) {\n    packstream.push(GitPktLine.encode(`shallow ${oid}\\n`));\n  }\n  if (depth !== null) {\n    packstream.push(GitPktLine.encode(`deepen ${depth}\\n`));\n  }\n  if (since !== null) {\n    packstream.push(\n      GitPktLine.encode(`deepen-since ${Math.floor(since.valueOf() / 1000)}\\n`)\n    );\n  }\n  for (const oid of exclude) {\n    packstream.push(GitPktLine.encode(`deepen-not ${oid}\\n`));\n  }\n  packstream.push(GitPktLine.flush());\n  for (const oid of haves) {\n    packstream.push(GitPktLine.encode(`have ${oid}\\n`));\n  }\n  packstream.push(GitPktLine.encode(`done\\n`));\n  return packstream\n}\n\n// @ts-check\n\n/**\n *\n * @typedef {object} FetchResult - The object returned has the following schema:\n * @property {string | null} defaultBranch - The branch that is cloned if no branch is specified\n * @property {string | null} fetchHead - The SHA-1 object id of the fetched head commit\n * @property {string | null} fetchHeadDescription - a textual description of the branch that was fetched\n * @property {Object<string, string>} [headers] - The HTTP response headers returned by the git server\n * @property {string[]} [pruned] - A list of branches that were pruned, if you provided the `prune` parameter\n *\n */\n\n/**\n * @param {object} args\n * @param {import('../models/FileSystem.js').FileSystem} args.fs\n * @param {any} args.cache\n * @param {HttpClient} args.http\n * @param {ProgressCallback} [args.onProgress]\n * @param {MessageCallback} [args.onMessage]\n * @param {AuthCallback} [args.onAuth]\n * @param {AuthFailureCallback} [args.onAuthFailure]\n * @param {AuthSuccessCallback} [args.onAuthSuccess]\n * @param {string} args.gitdir\n * @param {string|void} [args.url]\n * @param {string} [args.corsProxy]\n * @param {string} [args.ref]\n * @param {string} [args.remoteRef]\n * @param {string} [args.remote]\n * @param {boolean} [args.singleBranch = false]\n * @param {boolean} [args.tags = false]\n * @param {number} [args.depth]\n * @param {Date} [args.since]\n * @param {string[]} [args.exclude = []]\n * @param {boolean} [args.relative = false]\n * @param {Object<string, string>} [args.headers]\n * @param {boolean} [args.prune]\n * @param {boolean} [args.pruneTags]\n *\n * @returns {Promise<FetchResult>}\n * @see FetchResult\n */\nasync function _fetch({\n  fs,\n  cache,\n  http,\n  onProgress,\n  onMessage,\n  onAuth,\n  onAuthSuccess,\n  onAuthFailure,\n  gitdir,\n  ref: _ref,\n  remoteRef: _remoteRef,\n  remote: _remote,\n  url: _url,\n  corsProxy,\n  depth = null,\n  since = null,\n  exclude = [],\n  relative = false,\n  tags = false,\n  singleBranch = false,\n  headers = {},\n  prune = false,\n  pruneTags = false,\n}) {\n  const ref = _ref || (await _currentBranch({ fs, gitdir, test: true }));\n  const config = await GitConfigManager.get({ fs, gitdir });\n  // Figure out what remote to use.\n  const remote =\n    _remote || (ref && (await config.get(`branch.${ref}.remote`))) || 'origin';\n  // Lookup the URL for the given remote.\n  const url = _url || (await config.get(`remote.${remote}.url`));\n  if (typeof url === 'undefined') {\n    throw new MissingParameterError('remote OR url')\n  }\n  // Figure out what remote ref to use.\n  const remoteRef =\n    _remoteRef ||\n    (ref && (await config.get(`branch.${ref}.merge`))) ||\n    _ref ||\n    'HEAD';\n\n  if (corsProxy === undefined) {\n    corsProxy = await config.get('http.corsProxy');\n  }\n\n  const GitRemoteHTTP = GitRemoteManager.getRemoteHelperFor({ url });\n  const remoteHTTP = await GitRemoteHTTP.discover({\n    http,\n    onAuth,\n    onAuthSuccess,\n    onAuthFailure,\n    corsProxy,\n    service: 'git-upload-pack',\n    url,\n    headers,\n    protocolVersion: 1,\n  });\n  const auth = remoteHTTP.auth; // hack to get new credentials from CredentialManager API\n  const remoteRefs = remoteHTTP.refs;\n  // For the special case of an empty repository with no refs, return null.\n  if (remoteRefs.size === 0) {\n    return {\n      defaultBranch: null,\n      fetchHead: null,\n      fetchHeadDescription: null,\n    }\n  }\n  // Check that the remote supports the requested features\n  if (depth !== null && !remoteHTTP.capabilities.has('shallow')) {\n    throw new RemoteCapabilityError('shallow', 'depth')\n  }\n  if (since !== null && !remoteHTTP.capabilities.has('deepen-since')) {\n    throw new RemoteCapabilityError('deepen-since', 'since')\n  }\n  if (exclude.length > 0 && !remoteHTTP.capabilities.has('deepen-not')) {\n    throw new RemoteCapabilityError('deepen-not', 'exclude')\n  }\n  if (relative === true && !remoteHTTP.capabilities.has('deepen-relative')) {\n    throw new RemoteCapabilityError('deepen-relative', 'relative')\n  }\n  // Figure out the SHA for the requested ref\n  const { oid, fullref } = GitRefManager.resolveAgainstMap({\n    ref: remoteRef,\n    map: remoteRefs,\n  });\n  // Filter out refs we want to ignore: only keep ref we're cloning, HEAD, branches, and tags (if we're keeping them)\n  for (const remoteRef of remoteRefs.keys()) {\n    if (\n      remoteRef === fullref ||\n      remoteRef === 'HEAD' ||\n      remoteRef.startsWith('refs/heads/') ||\n      (tags && remoteRef.startsWith('refs/tags/'))\n    ) {\n      continue\n    }\n    remoteRefs.delete(remoteRef);\n  }\n  // Assemble the application/x-git-upload-pack-request\n  const capabilities = filterCapabilities(\n    [...remoteHTTP.capabilities],\n    [\n      'multi_ack_detailed',\n      'no-done',\n      'side-band-64k',\n      // Note: I removed 'thin-pack' option since our code doesn't \"fatten\" packfiles,\n      // which is necessary for compatibility with git. It was the cause of mysterious\n      // 'fatal: pack has [x] unresolved deltas' errors that plagued us for some time.\n      // isomorphic-git is perfectly happy with thin packfiles in .git/objects/pack but\n      // canonical git it turns out is NOT.\n      'ofs-delta',\n      `agent=${pkg.agent}`,\n    ]\n  );\n  if (relative) capabilities.push('deepen-relative');\n  // Start figuring out which oids from the remote we want to request\n  const wants = singleBranch ? [oid] : remoteRefs.values();\n  // Come up with a reasonable list of oids to tell the remote we already have\n  // (preferably oids that are close ancestors of the branch heads we're fetching)\n  const haveRefs = singleBranch\n    ? [ref]\n    : await GitRefManager.listRefs({\n        fs,\n        gitdir,\n        filepath: `refs`,\n      });\n  let haves = [];\n  for (let ref of haveRefs) {\n    try {\n      ref = await GitRefManager.expand({ fs, gitdir, ref });\n      const oid = await GitRefManager.resolve({ fs, gitdir, ref });\n      if (await hasObject({ fs, cache, gitdir, oid })) {\n        haves.push(oid);\n      }\n    } catch (err) {}\n  }\n  haves = [...new Set(haves)];\n  const oids = await GitShallowManager.read({ fs, gitdir });\n  const shallows = remoteHTTP.capabilities.has('shallow') ? [...oids] : [];\n  const packstream = writeUploadPackRequest({\n    capabilities,\n    wants,\n    haves,\n    shallows,\n    depth,\n    since,\n    exclude,\n  });\n  // CodeCommit will hang up if we don't send a Content-Length header\n  // so we can't stream the body.\n  const packbuffer = Buffer.from(await collect(packstream));\n  const raw = await GitRemoteHTTP.connect({\n    http,\n    onProgress,\n    corsProxy,\n    service: 'git-upload-pack',\n    url,\n    auth,\n    body: [packbuffer],\n    headers,\n  });\n  const response = await parseUploadPackResponse(raw.body);\n  if (raw.headers) {\n    response.headers = raw.headers;\n  }\n  // Apply all the 'shallow' and 'unshallow' commands\n  for (const oid of response.shallows) {\n    if (!oids.has(oid)) {\n      // this is in a try/catch mostly because my old test fixtures are missing objects\n      try {\n        // server says it's shallow, but do we have the parents?\n        const { object } = await _readObject({ fs, cache, gitdir, oid });\n        const commit = new GitCommit(object);\n        const hasParents = await Promise.all(\n          commit\n            .headers()\n            .parent.map(oid => hasObject({ fs, cache, gitdir, oid }))\n        );\n        const haveAllParents =\n          hasParents.length === 0 || hasParents.every(has => has);\n        if (!haveAllParents) {\n          oids.add(oid);\n        }\n      } catch (err) {\n        oids.add(oid);\n      }\n    }\n  }\n  for (const oid of response.unshallows) {\n    oids.delete(oid);\n  }\n  await GitShallowManager.write({ fs, gitdir, oids });\n  // Update local remote refs\n  if (singleBranch) {\n    const refs = new Map([[fullref, oid]]);\n    // But wait, maybe it was a symref, like 'HEAD'!\n    // We need to save all the refs in the symref chain (sigh).\n    const symrefs = new Map();\n    let bail = 10;\n    let key = fullref;\n    while (bail--) {\n      const value = remoteHTTP.symrefs.get(key);\n      if (value === undefined) break\n      symrefs.set(key, value);\n      key = value;\n    }\n    // final value must not be a symref but a real ref\n    const realRef = remoteRefs.get(key);\n    // There may be no ref at all if we've fetched a specific commit hash\n    if (realRef) {\n      refs.set(key, realRef);\n    }\n    const { pruned } = await GitRefManager.updateRemoteRefs({\n      fs,\n      gitdir,\n      remote,\n      refs,\n      symrefs,\n      tags,\n      prune,\n    });\n    if (prune) {\n      response.pruned = pruned;\n    }\n  } else {\n    const { pruned } = await GitRefManager.updateRemoteRefs({\n      fs,\n      gitdir,\n      remote,\n      refs: remoteRefs,\n      symrefs: remoteHTTP.symrefs,\n      tags,\n      prune,\n      pruneTags,\n    });\n    if (prune) {\n      response.pruned = pruned;\n    }\n  }\n  // We need this value later for the `clone` command.\n  response.HEAD = remoteHTTP.symrefs.get('HEAD');\n  // AWS CodeCommit doesn't list HEAD as a symref, but we can reverse engineer it\n  // Find the SHA of the branch called HEAD\n  if (response.HEAD === undefined) {\n    const { oid } = GitRefManager.resolveAgainstMap({\n      ref: 'HEAD',\n      map: remoteRefs,\n    });\n    // Use the name of the first branch that's not called HEAD that has\n    // the same SHA as the branch called HEAD.\n    for (const [key, value] of remoteRefs.entries()) {\n      if (key !== 'HEAD' && value === oid) {\n        response.HEAD = key;\n        break\n      }\n    }\n  }\n  const noun = fullref.startsWith('refs/tags') ? 'tag' : 'branch';\n  response.FETCH_HEAD = {\n    oid,\n    description: `${noun} '${abbreviateRef(fullref)}' of ${url}`,\n  };\n\n  if (onProgress || onMessage) {\n    const lines = splitLines(response.progress);\n    forAwait(lines, async line => {\n      if (onMessage) await onMessage(line);\n      if (onProgress) {\n        const matches = line.match(/([^:]*).*\\((\\d+?)\\/(\\d+?)\\)/);\n        if (matches) {\n          await onProgress({\n            phase: matches[1].trim(),\n            loaded: parseInt(matches[2], 10),\n            total: parseInt(matches[3], 10),\n          });\n        }\n      }\n    });\n  }\n  const packfile = Buffer.from(await collect(response.packfile));\n  if (raw.body.error) throw raw.body.error\n  const packfileSha = packfile.slice(-20).toString('hex');\n  const res = {\n    defaultBranch: response.HEAD,\n    fetchHead: response.FETCH_HEAD.oid,\n    fetchHeadDescription: response.FETCH_HEAD.description,\n  };\n  if (response.headers) {\n    res.headers = response.headers;\n  }\n  if (prune) {\n    res.pruned = response.pruned;\n  }\n  // This is a quick fix for the empty .git/objects/pack/pack-.pack file error,\n  // which due to the way `git-list-pack` works causes the program to hang when it tries to read it.\n  // TODO: Longer term, we should actually:\n  // a) NOT concatenate the entire packfile into memory (line 78),\n  // b) compute the SHA of the stream except for the last 20 bytes, using the same library used in push.js, and\n  // c) compare the computed SHA with the last 20 bytes of the stream before saving to disk, and throwing a \"packfile got corrupted during download\" error if the SHA doesn't match.\n  if (packfileSha !== '' && !emptyPackfile(packfile)) {\n    res.packfile = `objects/pack/pack-${packfileSha}.pack`;\n    const fullpath = join(gitdir, res.packfile);\n    await fs.write(fullpath, packfile);\n    const getExternalRefDelta = oid => _readObject({ fs, cache, gitdir, oid });\n    const idx = await GitPackIndex.fromPack({\n      pack: packfile,\n      getExternalRefDelta,\n      onProgress,\n    });\n    await fs.write(fullpath.replace(/\\.pack$/, '.idx'), await idx.toBuffer());\n  }\n  return res\n}\n\n// @ts-check\n\n/**\n * Initialize a new repository\n *\n * @param {object} args\n * @param {import('../models/FileSystem.js').FileSystem} args.fs\n * @param {string} [args.dir]\n * @param {string} [args.gitdir]\n * @param {boolean} [args.bare = false]\n * @param {string} [args.defaultBranch = 'master']\n * @returns {Promise<void>}\n */\nasync function _init({\n  fs,\n  bare = false,\n  dir,\n  gitdir = bare ? dir : join(dir, '.git'),\n  defaultBranch = 'master',\n}) {\n  // Don't overwrite an existing config\n  if (await fs.exists(gitdir + '/config')) return\n\n  let folders = [\n    'hooks',\n    'info',\n    'objects/info',\n    'objects/pack',\n    'refs/heads',\n    'refs/tags',\n  ];\n  folders = folders.map(dir => gitdir + '/' + dir);\n  for (const folder of folders) {\n    await fs.mkdir(folder);\n  }\n\n  await fs.write(\n    gitdir + '/config',\n    '[core]\\n' +\n      '\\trepositoryformatversion = 0\\n' +\n      '\\tfilemode = false\\n' +\n      `\\tbare = ${bare}\\n` +\n      (bare ? '' : '\\tlogallrefupdates = true\\n') +\n      '\\tsymlinks = false\\n' +\n      '\\tignorecase = true\\n'\n  );\n  await fs.write(gitdir + '/HEAD', `ref: refs/heads/${defaultBranch}\\n`);\n}\n\n// @ts-check\n\n/**\n * @param {object} args\n * @param {import('../models/FileSystem.js').FileSystem} args.fs\n * @param {object} args.cache\n * @param {HttpClient} args.http\n * @param {ProgressCallback} [args.onProgress]\n * @param {MessageCallback} [args.onMessage]\n * @param {AuthCallback} [args.onAuth]\n * @param {AuthFailureCallback} [args.onAuthFailure]\n * @param {AuthSuccessCallback} [args.onAuthSuccess]\n * @param {PostCheckoutCallback} [args.onPostCheckout]\n * @param {string} [args.dir]\n * @param {string} args.gitdir\n * @param {string} args.url\n * @param {string} args.corsProxy\n * @param {string} args.ref\n * @param {boolean} args.singleBranch\n * @param {boolean} args.noCheckout\n * @param {boolean} args.noTags\n * @param {string} args.remote\n * @param {number} args.depth\n * @param {Date} args.since\n * @param {string[]} args.exclude\n * @param {boolean} args.relative\n * @param {Object<string, string>} args.headers\n * @param {boolean} [args.nonBlocking]\n * @param {number} [args.batchSize]\n *\n * @returns {Promise<void>} Resolves successfully when clone completes\n *\n */\nasync function _clone({\n  fs,\n  cache,\n  http,\n  onProgress,\n  onMessage,\n  onAuth,\n  onAuthSuccess,\n  onAuthFailure,\n  onPostCheckout,\n  dir,\n  gitdir,\n  url,\n  corsProxy,\n  ref,\n  remote,\n  depth,\n  since,\n  exclude,\n  relative,\n  singleBranch,\n  noCheckout,\n  noTags,\n  headers,\n  nonBlocking,\n  batchSize = 100,\n}) {\n  try {\n    await _init({ fs, gitdir });\n    await _addRemote({ fs, gitdir, remote, url, force: false });\n    if (corsProxy) {\n      const config = await GitConfigManager.get({ fs, gitdir });\n      await config.set(`http.corsProxy`, corsProxy);\n      await GitConfigManager.save({ fs, gitdir, config });\n    }\n    const { defaultBranch, fetchHead } = await _fetch({\n      fs,\n      cache,\n      http,\n      onProgress,\n      onMessage,\n      onAuth,\n      onAuthSuccess,\n      onAuthFailure,\n      gitdir,\n      ref,\n      remote,\n      corsProxy,\n      depth,\n      since,\n      exclude,\n      relative,\n      singleBranch,\n      headers,\n      tags: !noTags,\n    });\n    if (fetchHead === null) return\n    ref = ref || defaultBranch;\n    ref = ref.replace('refs/heads/', '');\n    // Checkout that branch\n    await _checkout({\n      fs,\n      cache,\n      onProgress,\n      onPostCheckout,\n      dir,\n      gitdir,\n      ref,\n      remote,\n      noCheckout,\n      nonBlocking,\n      batchSize,\n    });\n  } catch (err) {\n    // Remove partial local repository, see #1283\n    // Ignore any error as we are already failing.\n    // The catch is necessary so the original error is not masked.\n    await fs\n      .rmdir(gitdir, { recursive: true, maxRetries: 10 })\n      .catch(() => undefined);\n    throw err\n  }\n}\n\n// @ts-check\n\n/**\n * Clone a repository\n *\n * @param {object} args\n * @param {FsClient} args.fs - a file system implementation\n * @param {HttpClient} args.http - an HTTP client\n * @param {ProgressCallback} [args.onProgress] - optional progress event callback\n * @param {MessageCallback} [args.onMessage] - optional message event callback\n * @param {AuthCallback} [args.onAuth] - optional auth fill callback\n * @param {AuthFailureCallback} [args.onAuthFailure] - optional auth rejected callback\n * @param {AuthSuccessCallback} [args.onAuthSuccess] - optional auth approved callback\n * @param {PostCheckoutCallback} [args.onPostCheckout] - optional post-checkout hook callback\n * @param {string} args.dir - The [working tree](dir-vs-gitdir.md) directory path\n * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path\n * @param {string} args.url - The URL of the remote repository\n * @param {string} [args.corsProxy] - Optional [CORS proxy](https://www.npmjs.com/%40isomorphic-git/cors-proxy). Value is stored in the git config file for that repo.\n * @param {string} [args.ref] - Which branch to checkout. By default this is the designated \"main branch\" of the repository.\n * @param {boolean} [args.singleBranch = false] - Instead of the default behavior of fetching all the branches, only fetch a single branch.\n * @param {boolean} [args.noCheckout = false] - If true, clone will only fetch the repo, not check out a branch. Skipping checkout can save a lot of time normally spent writing files to disk.\n * @param {boolean} [args.noTags = false] - By default clone will fetch all tags. `noTags` disables that behavior.\n * @param {string} [args.remote = 'origin'] - What to name the remote that is created.\n * @param {number} [args.depth] - Integer. Determines how much of the git repository's history to retrieve\n * @param {Date} [args.since] - Only fetch commits created after the given date. Mutually exclusive with `depth`.\n * @param {string[]} [args.exclude = []] - A list of branches or tags. Instructs the remote server not to send us any commits reachable from these refs.\n * @param {boolean} [args.relative = false] - Changes the meaning of `depth` to be measured from the current shallow depth rather than from the branch tip.\n * @param {Object<string, string>} [args.headers = {}] - Additional headers to include in HTTP requests, similar to git's `extraHeader` config\n * @param {object} [args.cache] - a [cache](cache.md) object\n * @param {boolean} [args.nonBlocking = false] - if true, checkout will happen non-blockingly (useful for long-running operations blocking the thread in browser environments)\n * @param {number} [args.batchSize = 100] - If args.nonBlocking is true, batchSize is the number of files to process at a time avoid blocking the executing thread. The default value of 100 is a good starting point.\n *\n * @returns {Promise<void>} Resolves successfully when clone completes\n *\n * @example\n * await git.clone({\n *   fs,\n *   http,\n *   dir: '/tutorial',\n *   corsProxy: 'https://cors.isomorphic-git.org',\n *   url: 'https://github.com/isomorphic-git/isomorphic-git',\n *   singleBranch: true,\n *   depth: 1\n * })\n * console.log('done')\n *\n */\nasync function clone({\n  fs,\n  http,\n  onProgress,\n  onMessage,\n  onAuth,\n  onAuthSuccess,\n  onAuthFailure,\n  onPostCheckout,\n  dir,\n  gitdir = join(dir, '.git'),\n  url,\n  corsProxy = undefined,\n  ref = undefined,\n  remote = 'origin',\n  depth = undefined,\n  since = undefined,\n  exclude = [],\n  relative = false,\n  singleBranch = false,\n  noCheckout = false,\n  noTags = false,\n  headers = {},\n  cache = {},\n  nonBlocking = false,\n  batchSize = 100,\n}) {\n  try {\n    assertParameter('fs', fs);\n    assertParameter('http', http);\n    assertParameter('gitdir', gitdir);\n    if (!noCheckout) {\n      assertParameter('dir', dir);\n    }\n    assertParameter('url', url);\n\n    const fsp = new FileSystem(fs);\n    const updatedGitdir = await discoverGitdir({ fsp, dotgit: gitdir });\n    return await _clone({\n      fs: fsp,\n      cache,\n      http,\n      onProgress,\n      onMessage,\n      onAuth,\n      onAuthSuccess,\n      onAuthFailure,\n      onPostCheckout,\n      dir,\n      gitdir: updatedGitdir,\n      url,\n      corsProxy,\n      ref,\n      remote,\n      depth,\n      since,\n      exclude,\n      relative,\n      singleBranch,\n      noCheckout,\n      noTags,\n      headers,\n      nonBlocking,\n      batchSize,\n    })\n  } catch (err) {\n    err.caller = 'git.clone';\n    throw err\n  }\n}\n\n// @ts-check\n/**\n * Create a new commit\n *\n * @param {Object} args\n * @param {FsClient} args.fs - a file system implementation\n * @param {SignCallback} [args.onSign] - a PGP signing implementation\n * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path\n * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path\n * @param {string} [args.message] - The commit message to use. Required, unless `amend === true`\n * @param {Object} [args.author] - The details about the author.\n * @param {string} [args.author.name] - Default is `user.name` config.\n * @param {string} [args.author.email] - Default is `user.email` config.\n * @param {number} [args.author.timestamp=Math.floor(Date.now()/1000)] - Set the author timestamp field. This is the integer number of seconds since the Unix epoch (1970-01-01 00:00:00).\n * @param {number} [args.author.timezoneOffset] - Set the author timezone offset field. This is the difference, in minutes, from the current timezone to UTC. Default is `(new Date()).getTimezoneOffset()`.\n * @param {Object} [args.committer = author] - The details about the commit committer, in the same format as the author parameter. If not specified, the author details are used.\n * @param {string} [args.committer.name] - Default is `user.name` config.\n * @param {string} [args.committer.email] - Default is `user.email` config.\n * @param {number} [args.committer.timestamp=Math.floor(Date.now()/1000)] - Set the committer timestamp field. This is the integer number of seconds since the Unix epoch (1970-01-01 00:00:00).\n * @param {number} [args.committer.timezoneOffset] - Set the committer timezone offset field. This is the difference, in minutes, from the current timezone to UTC. Default is `(new Date()).getTimezoneOffset()`.\n * @param {string} [args.signingKey] - Sign the tag object using this private PGP key.\n * @param {boolean} [args.amend = false] - If true, replaces the last commit pointed to by `ref` with a new commit.\n * @param {boolean} [args.dryRun = false] - If true, simulates making a commit so you can test whether it would succeed. Implies `noUpdateBranch`.\n * @param {boolean} [args.noUpdateBranch = false] - If true, does not update the branch pointer after creating the commit.\n * @param {string} [args.ref] - The fully expanded name of the branch to commit to. Default is the current branch pointed to by HEAD. (TODO: fix it so it can expand branch names without throwing if the branch doesn't exist yet.)\n * @param {string[]} [args.parent] - The SHA-1 object ids of the commits to use as parents. If not specified, the commit pointed to by `ref` is used.\n * @param {string} [args.tree] - The SHA-1 object id of the tree to use. If not specified, a new tree object is created from the current git index.\n * @param {object} [args.cache] - a [cache](cache.md) object\n *\n * @returns {Promise<string>} Resolves successfully with the SHA-1 object id of the newly created commit.\n *\n * @example\n * let sha = await git.commit({\n *   fs,\n *   dir: '/tutorial',\n *   author: {\n *     name: 'Mr. Test',\n *     email: 'mrtest@example.com',\n *   },\n *   message: 'Added the a.txt file'\n * })\n * console.log(sha)\n *\n */\nasync function commit({\n  fs: _fs,\n  onSign,\n  dir,\n  gitdir = join(dir, '.git'),\n  message,\n  author,\n  committer,\n  signingKey,\n  amend = false,\n  dryRun = false,\n  noUpdateBranch = false,\n  ref,\n  parent,\n  tree,\n  cache = {},\n}) {\n  try {\n    assertParameter('fs', _fs);\n    if (!amend) {\n      assertParameter('message', message);\n    }\n    if (signingKey) {\n      assertParameter('onSign', onSign);\n    }\n    const fs = new FileSystem(_fs);\n    const updatedGitdir = await discoverGitdir({ fsp: fs, dotgit: gitdir });\n\n    return await _commit({\n      fs,\n      cache,\n      onSign,\n      gitdir: updatedGitdir,\n      message,\n      author,\n      committer,\n      signingKey,\n      amend,\n      dryRun,\n      noUpdateBranch,\n      ref,\n      parent,\n      tree,\n    })\n  } catch (err) {\n    err.caller = 'git.commit';\n    throw err\n  }\n}\n\n// @ts-check\n\n/**\n * Get the name of the branch currently pointed to by .git/HEAD\n *\n * @param {Object} args\n * @param {FsClient} args.fs - a file system implementation\n * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path\n * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path\n * @param {boolean} [args.fullname = false] - Return the full path (e.g. \"refs/heads/main\") instead of the abbreviated form.\n * @param {boolean} [args.test = false] - If the current branch doesn't actually exist (such as right after git init) then return `undefined`.\n *\n * @returns {Promise<string|void>} The name of the current branch or undefined if the HEAD is detached.\n *\n * @example\n * // Get the current branch name\n * let branch = await git.currentBranch({\n *   fs,\n *   dir: '/tutorial',\n *   fullname: false\n * })\n * console.log(branch)\n *\n */\nasync function currentBranch({\n  fs,\n  dir,\n  gitdir = join(dir, '.git'),\n  fullname = false,\n  test = false,\n}) {\n  try {\n    assertParameter('fs', fs);\n    assertParameter('gitdir', gitdir);\n    const fsp = new FileSystem(fs);\n    const updatedGitdir = await discoverGitdir({ fsp, dotgit: gitdir });\n    return await _currentBranch({\n      fs: fsp,\n      gitdir: updatedGitdir,\n      fullname,\n      test,\n    })\n  } catch (err) {\n    err.caller = 'git.currentBranch';\n    throw err\n  }\n}\n\n// @ts-check\n\n/**\n * @param {Object} args\n * @param {import('../models/FileSystem.js').FileSystem} args.fs\n * @param {string} args.gitdir\n * @param {string} args.ref\n *\n * @returns {Promise<void>}\n */\nasync function _deleteBranch({ fs, gitdir, ref }) {\n  ref = ref.startsWith('refs/heads/') ? ref : `refs/heads/${ref}`;\n  const exist = await GitRefManager.exists({ fs, gitdir, ref });\n  if (!exist) {\n    throw new NotFoundError(ref)\n  }\n\n  const fullRef = await GitRefManager.expand({ fs, gitdir, ref });\n  const currentRef = await _currentBranch({ fs, gitdir, fullname: true });\n  if (fullRef === currentRef) {\n    // detach HEAD\n    const value = await GitRefManager.resolve({ fs, gitdir, ref: fullRef });\n    await GitRefManager.writeRef({ fs, gitdir, ref: 'HEAD', value });\n  }\n\n  // Delete a specified branch\n  await GitRefManager.deleteRef({ fs, gitdir, ref: fullRef });\n\n  // Delete branch config entries\n  const abbrevRef = abbreviateRef(ref);\n  const config = await GitConfigManager.get({ fs, gitdir });\n  await config.deleteSection('branch', abbrevRef);\n  await GitConfigManager.save({ fs, gitdir, config });\n}\n\n// @ts-check\n\n/**\n * Delete a local branch\n *\n * > Note: This only deletes loose branches - it should be fixed in the future to delete packed branches as well.\n *\n * @param {Object} args\n * @param {FsClient} args.fs - a file system implementation\n * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path\n * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path\n * @param {string} args.ref - The branch to delete\n *\n * @returns {Promise<void>} Resolves successfully when filesystem operations are complete\n *\n * @example\n * await git.deleteBranch({ fs, dir: '/tutorial', ref: 'local-branch' })\n * console.log('done')\n *\n */\nasync function deleteBranch({\n  fs,\n  dir,\n  gitdir = join(dir, '.git'),\n  ref,\n}) {\n  try {\n    assertParameter('fs', fs);\n    assertParameter('ref', ref);\n    const fsp = new FileSystem(fs);\n    const updatedGitdir = await discoverGitdir({ fsp, dotgit: gitdir });\n    return await _deleteBranch({\n      fs: fsp,\n      gitdir: updatedGitdir,\n      ref,\n    })\n  } catch (err) {\n    err.caller = 'git.deleteBranch';\n    throw err\n  }\n}\n\n// @ts-check\n\n/**\n * Delete a local ref\n *\n * @param {Object} args\n * @param {FsClient} args.fs - a file system implementation\n * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path\n * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path\n * @param {string} args.ref - The ref to delete\n *\n * @returns {Promise<void>} Resolves successfully when filesystem operations are complete\n *\n * @example\n * await git.deleteRef({ fs, dir: '/tutorial', ref: 'refs/tags/test-tag' })\n * console.log('done')\n *\n */\nasync function deleteRef({ fs, dir, gitdir = join(dir, '.git'), ref }) {\n  try {\n    assertParameter('fs', fs);\n    assertParameter('ref', ref);\n    const fsp = new FileSystem(fs);\n    const updatedGitdir = await discoverGitdir({ fsp, dotgit: gitdir });\n    await GitRefManager.deleteRef({ fs: fsp, gitdir: updatedGitdir, ref });\n  } catch (err) {\n    err.caller = 'git.deleteRef';\n    throw err\n  }\n}\n\n// @ts-check\n\n/**\n * @param {Object} args\n * @param {import('../models/FileSystem.js').FileSystem} args.fs\n * @param {string} args.gitdir\n * @param {string} args.remote\n *\n * @returns {Promise<void>}\n */\nasync function _deleteRemote({ fs, gitdir, remote }) {\n  const config = await GitConfigManager.get({ fs, gitdir });\n  await config.deleteSection('remote', remote);\n  await GitConfigManager.save({ fs, gitdir, config });\n}\n\n// @ts-check\n\n/**\n * Removes the local config entry for a given remote\n *\n * @param {Object} args\n * @param {FsClient} args.fs - a file system implementation\n * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path\n * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path\n * @param {string} args.remote - The name of the remote to delete\n *\n * @returns {Promise<void>} Resolves successfully when filesystem operations are complete\n *\n * @example\n * await git.deleteRemote({ fs, dir: '/tutorial', remote: 'upstream' })\n * console.log('done')\n *\n */\nasync function deleteRemote({\n  fs,\n  dir,\n  gitdir = join(dir, '.git'),\n  remote,\n}) {\n  try {\n    assertParameter('fs', fs);\n    assertParameter('remote', remote);\n    const fsp = new FileSystem(fs);\n    const updatedGitdir = await discoverGitdir({ fsp, dotgit: gitdir });\n    return await _deleteRemote({\n      fs: fsp,\n      gitdir: updatedGitdir,\n      remote,\n    })\n  } catch (err) {\n    err.caller = 'git.deleteRemote';\n    throw err\n  }\n}\n\n// @ts-check\n\n/**\n * Delete a local tag ref\n *\n * @param {Object} args\n * @param {import('../models/FileSystem.js').FileSystem} args.fs\n * @param {string} args.gitdir\n * @param {string} args.ref - The tag to delete\n *\n * @returns {Promise<void>} Resolves successfully when filesystem operations are complete\n *\n * @example\n * await git.deleteTag({ dir: '$input((/))', ref: '$input((test-tag))' })\n * console.log('done')\n *\n */\nasync function _deleteTag({ fs, gitdir, ref }) {\n  ref = ref.startsWith('refs/tags/') ? ref : `refs/tags/${ref}`;\n  await GitRefManager.deleteRef({ fs, gitdir, ref });\n}\n\n// @ts-check\n\n/**\n * Delete a local tag ref\n *\n * @param {Object} args\n * @param {FsClient} args.fs - a file system implementation\n * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path\n * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path\n * @param {string} args.ref - The tag to delete\n *\n * @returns {Promise<void>} Resolves successfully when filesystem operations are complete\n *\n * @example\n * await git.deleteTag({ fs, dir: '/tutorial', ref: 'test-tag' })\n * console.log('done')\n *\n */\nasync function deleteTag({ fs, dir, gitdir = join(dir, '.git'), ref }) {\n  try {\n    assertParameter('fs', fs);\n    assertParameter('ref', ref);\n    const fsp = new FileSystem(fs);\n    const updatedGitdir = await discoverGitdir({ fsp, dotgit: gitdir });\n    return await _deleteTag({\n      fs: fsp,\n      gitdir: updatedGitdir,\n      ref,\n    })\n  } catch (err) {\n    err.caller = 'git.deleteTag';\n    throw err\n  }\n}\n\nasync function expandOidLoose({ fs, gitdir, oid: short }) {\n  const prefix = short.slice(0, 2);\n  const objectsSuffixes = await fs.readdir(`${gitdir}/objects/${prefix}`);\n  return objectsSuffixes\n    .map(suffix => `${prefix}${suffix}`)\n    .filter(_oid => _oid.startsWith(short))\n}\n\nasync function expandOidPacked({\n  fs,\n  cache,\n  gitdir,\n  oid: short,\n  getExternalRefDelta,\n}) {\n  // Iterate through all the .pack files\n  const results = [];\n  let list = await fs.readdir(join(gitdir, 'objects/pack'));\n  list = list.filter(x => x.endsWith('.idx'));\n  for (const filename of list) {\n    const indexFile = `${gitdir}/objects/pack/${filename}`;\n    const p = await readPackIndex({\n      fs,\n      cache,\n      filename: indexFile,\n      getExternalRefDelta,\n    });\n    if (p.error) throw new InternalError(p.error)\n    // Search through the list of oids in the packfile\n    for (const oid of p.offsets.keys()) {\n      if (oid.startsWith(short)) results.push(oid);\n    }\n  }\n  return results\n}\n\nasync function _expandOid({ fs, cache, gitdir, oid: short }) {\n  // Curry the current read method so that the packfile un-deltification\n  // process can acquire external ref-deltas.\n  const getExternalRefDelta = oid => _readObject({ fs, cache, gitdir, oid });\n\n  const results = await expandOidLoose({ fs, gitdir, oid: short });\n  const packedOids = await expandOidPacked({\n    fs,\n    cache,\n    gitdir,\n    oid: short,\n    getExternalRefDelta,\n  });\n  // Objects can exist in a pack file as well as loose, make sure we only get a list of unique oids.\n  for (const packedOid of packedOids) {\n    if (results.indexOf(packedOid) === -1) {\n      results.push(packedOid);\n    }\n  }\n\n  if (results.length === 1) {\n    return results[0]\n  }\n  if (results.length > 1) {\n    throw new AmbiguousError('oids', short, results)\n  }\n  throw new NotFoundError(`an object matching \"${short}\"`)\n}\n\n// @ts-check\n\n/**\n * Expand and resolve a short oid into a full oid\n *\n * @param {Object} args\n * @param {FsClient} args.fs - a file system implementation\n * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path\n * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path\n * @param {string} args.oid - The shortened oid prefix to expand (like \"0414d2a\")\n * @param {object} [args.cache] - a [cache](cache.md) object\n *\n * @returns {Promise<string>} Resolves successfully with the full oid (like \"0414d2a286d7bbc7a4a326a61c1f9f888a8ab87f\")\n *\n * @example\n * let oid = await git.expandOid({ fs, dir: '/tutorial', oid: '0414d2a'})\n * console.log(oid)\n *\n */\nasync function expandOid({\n  fs,\n  dir,\n  gitdir = join(dir, '.git'),\n  oid,\n  cache = {},\n}) {\n  try {\n    assertParameter('fs', fs);\n    assertParameter('gitdir', gitdir);\n    assertParameter('oid', oid);\n    const fsp = new FileSystem(fs);\n    const updatedGitdir = await discoverGitdir({ fsp, dotgit: gitdir });\n    return await _expandOid({\n      fs: fsp,\n      cache,\n      gitdir: updatedGitdir,\n      oid,\n    })\n  } catch (err) {\n    err.caller = 'git.expandOid';\n    throw err\n  }\n}\n\n// @ts-check\n\n/**\n * Expand an abbreviated ref to its full name\n *\n * @param {Object} args\n * @param {FsClient} args.fs - a file system implementation\n * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path\n * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path\n * @param {string} args.ref - The ref to expand (like \"v1.0.0\")\n *\n * @returns {Promise<string>} Resolves successfully with a full ref name (\"refs/tags/v1.0.0\")\n *\n * @example\n * let fullRef = await git.expandRef({ fs, dir: '/tutorial', ref: 'main'})\n * console.log(fullRef)\n *\n */\nasync function expandRef({ fs, dir, gitdir = join(dir, '.git'), ref }) {\n  try {\n    assertParameter('fs', fs);\n    assertParameter('gitdir', gitdir);\n    assertParameter('ref', ref);\n    const fsp = new FileSystem(fs);\n    const updatedGitdir = await discoverGitdir({ fsp, dotgit: gitdir });\n    return await GitRefManager.expand({\n      fs: fsp,\n      gitdir: updatedGitdir,\n      ref,\n    })\n  } catch (err) {\n    err.caller = 'git.expandRef';\n    throw err\n  }\n}\n\n// @ts-check\n\n/**\n * @param {object} args\n * @param {import('../models/FileSystem.js').FileSystem} args.fs\n * @param {any} args.cache\n * @param {string} args.gitdir\n * @param {string[]} args.oids\n *\n */\nasync function _findMergeBase({ fs, cache, gitdir, oids }) {\n  // Note: right now, the tests are geared so that the output should match that of\n  // `git merge-base --all --octopus`\n  // because without the --octopus flag, git's output seems to depend on the ORDER of the oids,\n  // and computing virtual merge bases is just too much for me to fathom right now.\n\n  // If we start N independent walkers, one at each of the given `oids`, and walk backwards\n  // through ancestors, eventually we'll discover a commit where each one of these N walkers\n  // has passed through. So we just need to keep track of which walkers have visited each commit\n  // until we find a commit that N distinct walkers has visited.\n  const visits = {};\n  const passes = oids.length;\n  let heads = oids.map((oid, index) => ({ index, oid }));\n  while (heads.length) {\n    // Count how many times we've passed each commit\n    const result = new Set();\n    for (const { oid, index } of heads) {\n      if (!visits[oid]) visits[oid] = new Set();\n      visits[oid].add(index);\n      if (visits[oid].size === passes) {\n        result.add(oid);\n      }\n    }\n    if (result.size > 0) {\n      return [...result]\n    }\n    // We haven't found a common ancestor yet\n    const newheads = new Map();\n    for (const { oid, index } of heads) {\n      try {\n        const { object } = await _readObject({ fs, cache, gitdir, oid });\n        const commit = GitCommit.from(object);\n        const { parent } = commit.parseHeaders();\n        for (const oid of parent) {\n          if (!visits[oid] || !visits[oid].has(index)) {\n            newheads.set(oid + ':' + index, { oid, index });\n          }\n        }\n      } catch (err) {\n        // do nothing\n      }\n    }\n    heads = Array.from(newheads.values());\n  }\n  return []\n}\n\nconst LINEBREAKS = /^.*(\\r?\\n|$)/gm;\n\nfunction mergeFile({ branches, contents }) {\n  const ourName = branches[1];\n  const theirName = branches[2];\n\n  const baseContent = contents[0];\n  const ourContent = contents[1];\n  const theirContent = contents[2];\n\n  const ours = ourContent.match(LINEBREAKS);\n  const base = baseContent.match(LINEBREAKS);\n  const theirs = theirContent.match(LINEBREAKS);\n\n  // Here we let the diff3 library do the heavy lifting.\n  const result = diff3Merge(ours, base, theirs);\n\n  const markerSize = 7;\n\n  // Here we note whether there are conflicts and format the results\n  let mergedText = '';\n  let cleanMerge = true;\n\n  for (const item of result) {\n    if (item.ok) {\n      mergedText += item.ok.join('');\n    }\n    if (item.conflict) {\n      cleanMerge = false;\n      mergedText += `${'<'.repeat(markerSize)} ${ourName}\\n`;\n      mergedText += item.conflict.a.join('');\n\n      mergedText += `${'='.repeat(markerSize)}\\n`;\n      mergedText += item.conflict.b.join('');\n      mergedText += `${'>'.repeat(markerSize)} ${theirName}\\n`;\n    }\n  }\n  return { cleanMerge, mergedText }\n}\n\n// @ts-check\n\n/**\n * Create a merged tree\n *\n * @param {Object} args\n * @param {import('../models/FileSystem.js').FileSystem} args.fs\n * @param {object} args.cache\n * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path\n * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path\n * @param {string} args.ourOid - The SHA-1 object id of our tree\n * @param {string} args.baseOid - The SHA-1 object id of the base tree\n * @param {string} args.theirOid - The SHA-1 object id of their tree\n * @param {string} [args.ourName='ours'] - The name to use in conflicted files for our hunks\n * @param {string} [args.baseName='base'] - The name to use in conflicted files (in diff3 format) for the base hunks\n * @param {string} [args.theirName='theirs'] - The name to use in conflicted files for their hunks\n * @param {boolean} [args.dryRun=false]\n * @param {boolean} [args.abortOnConflict=false]\n * @param {MergeDriverCallback} [args.mergeDriver]\n *\n * @returns {Promise<string>} - The SHA-1 object id of the merged tree\n *\n */\nasync function mergeTree({\n  fs,\n  cache,\n  dir,\n  gitdir = join(dir, '.git'),\n  index,\n  ourOid,\n  baseOid,\n  theirOid,\n  ourName = 'ours',\n  baseName = 'base',\n  theirName = 'theirs',\n  dryRun = false,\n  abortOnConflict = true,\n  mergeDriver,\n}) {\n  const ourTree = TREE({ ref: ourOid });\n  const baseTree = TREE({ ref: baseOid });\n  const theirTree = TREE({ ref: theirOid });\n\n  const unmergedFiles = [];\n  const bothModified = [];\n  const deleteByUs = [];\n  const deleteByTheirs = [];\n\n  const results = await _walk({\n    fs,\n    cache,\n    dir,\n    gitdir,\n    trees: [ourTree, baseTree, theirTree],\n    map: async function (filepath, [ours, base, theirs]) {\n      const path = basename(filepath);\n      // What we did, what they did\n      const ourChange = await modified(ours, base);\n      const theirChange = await modified(theirs, base);\n      switch (`${ourChange}-${theirChange}`) {\n        case 'false-false': {\n          return {\n            mode: await base.mode(),\n            path,\n            oid: await base.oid(),\n            type: await base.type(),\n          }\n        }\n        case 'false-true': {\n          // if directory is deleted in theirs but not in ours we return our directory\n          if (!theirs && (await ours.type()) === 'tree') {\n            return {\n              mode: await ours.mode(),\n              path,\n              oid: await ours.oid(),\n              type: await ours.type(),\n            }\n          }\n\n          return theirs\n            ? {\n                mode: await theirs.mode(),\n                path,\n                oid: await theirs.oid(),\n                type: await theirs.type(),\n              }\n            : undefined\n        }\n        case 'true-false': {\n          // if directory is deleted in ours but not in theirs we return their directory\n          if (!ours && (await theirs.type()) === 'tree') {\n            return {\n              mode: await theirs.mode(),\n              path,\n              oid: await theirs.oid(),\n              type: await theirs.type(),\n            }\n          }\n\n          return ours\n            ? {\n                mode: await ours.mode(),\n                path,\n                oid: await ours.oid(),\n                type: await ours.type(),\n              }\n            : undefined\n        }\n        case 'true-true': {\n          // Handle tree-tree merges (directories)\n          if (\n            ours &&\n            theirs &&\n            (await ours.type()) === 'tree' &&\n            (await theirs.type()) === 'tree'\n          ) {\n            return {\n              mode: await ours.mode(),\n              path,\n              oid: await ours.oid(),\n              type: 'tree',\n            }\n          }\n\n          // Modifications - both are blobs\n          if (\n            ours &&\n            theirs &&\n            (await ours.type()) === 'blob' &&\n            (await theirs.type()) === 'blob'\n          ) {\n            return mergeBlobs({\n              fs,\n              gitdir,\n              path,\n              ours,\n              base,\n              theirs,\n              ourName,\n              baseName,\n              theirName,\n              mergeDriver,\n            }).then(async r => {\n              if (!r.cleanMerge) {\n                unmergedFiles.push(filepath);\n                bothModified.push(filepath);\n                if (!abortOnConflict) {\n                  let baseOid = '';\n                  if (base && (await base.type()) === 'blob') {\n                    baseOid = await base.oid();\n                  }\n                  const ourOid = await ours.oid();\n                  const theirOid = await theirs.oid();\n\n                  index.delete({ filepath });\n\n                  if (baseOid) {\n                    index.insert({ filepath, oid: baseOid, stage: 1 });\n                  }\n                  index.insert({ filepath, oid: ourOid, stage: 2 });\n                  index.insert({ filepath, oid: theirOid, stage: 3 });\n                }\n              } else if (!abortOnConflict) {\n                index.insert({ filepath, oid: r.mergeResult.oid, stage: 0 });\n              }\n              return r.mergeResult\n            })\n          }\n\n          // deleted by us\n          if (\n            base &&\n            !ours &&\n            theirs &&\n            (await base.type()) === 'blob' &&\n            (await theirs.type()) === 'blob'\n          ) {\n            unmergedFiles.push(filepath);\n            deleteByUs.push(filepath);\n            if (!abortOnConflict) {\n              const baseOid = await base.oid();\n              const theirOid = await theirs.oid();\n\n              index.delete({ filepath });\n\n              index.insert({ filepath, oid: baseOid, stage: 1 });\n              index.insert({ filepath, oid: theirOid, stage: 3 });\n            }\n\n            return {\n              mode: await theirs.mode(),\n              oid: await theirs.oid(),\n              type: 'blob',\n              path,\n            }\n          }\n\n          // deleted by theirs\n          if (\n            base &&\n            ours &&\n            !theirs &&\n            (await base.type()) === 'blob' &&\n            (await ours.type()) === 'blob'\n          ) {\n            unmergedFiles.push(filepath);\n            deleteByTheirs.push(filepath);\n            if (!abortOnConflict) {\n              const baseOid = await base.oid();\n              const ourOid = await ours.oid();\n\n              index.delete({ filepath });\n\n              index.insert({ filepath, oid: baseOid, stage: 1 });\n              index.insert({ filepath, oid: ourOid, stage: 2 });\n            }\n\n            return {\n              mode: await ours.mode(),\n              oid: await ours.oid(),\n              type: 'blob',\n              path,\n            }\n          }\n\n          // deleted by both\n          if (\n            base &&\n            !ours &&\n            !theirs &&\n            ((await base.type()) === 'blob' || (await base.type()) === 'tree')\n          ) {\n            return undefined\n          }\n\n          // all other types of conflicts fail\n          // TODO: Merge conflicts involving additions\n          throw new MergeNotSupportedError()\n        }\n      }\n    },\n    /**\n     * @param {TreeEntry} [parent]\n     * @param {Array<TreeEntry>} children\n     */\n    reduce:\n      unmergedFiles.length !== 0 && (!dir || abortOnConflict)\n        ? undefined\n        : async (parent, children) => {\n            const entries = children.filter(Boolean); // remove undefineds\n\n            // if the parent was deleted, the children have to go\n            if (!parent) return\n\n            // automatically delete directories if they have been emptied\n            // except for the root directory\n            if (\n              parent &&\n              parent.type === 'tree' &&\n              entries.length === 0 &&\n              parent.path !== '.'\n            )\n              return\n\n            if (\n              entries.length > 0 ||\n              (parent.path === '.' && entries.length === 0)\n            ) {\n              const tree = new GitTree(entries);\n              const object = tree.toObject();\n              const oid = await _writeObject({\n                fs,\n                gitdir,\n                type: 'tree',\n                object,\n                dryRun,\n              });\n              parent.oid = oid;\n            }\n            return parent\n          },\n  });\n\n  if (unmergedFiles.length !== 0) {\n    if (dir && !abortOnConflict) {\n      await _walk({\n        fs,\n        cache,\n        dir,\n        gitdir,\n        trees: [TREE({ ref: results.oid })],\n        map: async function (filepath, [entry]) {\n          const path = `${dir}/${filepath}`;\n          if ((await entry.type()) === 'blob') {\n            const mode = await entry.mode();\n            const content = new TextDecoder().decode(await entry.content());\n            await fs.write(path, content, { mode });\n          }\n          return true\n        },\n      });\n    }\n    return new MergeConflictError(\n      unmergedFiles,\n      bothModified,\n      deleteByUs,\n      deleteByTheirs\n    )\n  }\n\n  return results.oid\n}\n\n/**\n *\n * @param {Object} args\n * @param {import('../models/FileSystem').FileSystem} args.fs\n * @param {string} args.gitdir\n * @param {string} args.path\n * @param {WalkerEntry} args.ours\n * @param {WalkerEntry} args.base\n * @param {WalkerEntry} args.theirs\n * @param {string} [args.ourName]\n * @param {string} [args.baseName]\n * @param {string} [args.theirName]\n * @param {boolean} [args.dryRun = false]\n * @param {MergeDriverCallback} [args.mergeDriver]\n *\n */\nasync function mergeBlobs({\n  fs,\n  gitdir,\n  path,\n  ours,\n  base,\n  theirs,\n  ourName,\n  theirName,\n  baseName,\n  dryRun,\n  mergeDriver = mergeFile,\n}) {\n  const type = 'blob';\n  // Compute the new mode.\n  // Since there are ONLY two valid blob modes ('100755' and '100644') it boils down to this\n  let baseMode = '100755';\n  let baseOid = '';\n  let baseContent = '';\n  if (base && (await base.type()) === 'blob') {\n    baseMode = await base.mode();\n    baseOid = await base.oid();\n    baseContent = Buffer.from(await base.content()).toString('utf8');\n  }\n  const mode =\n    baseMode === (await ours.mode()) ? await theirs.mode() : await ours.mode();\n  // The trivial case: nothing to merge except maybe mode\n  if ((await ours.oid()) === (await theirs.oid())) {\n    return {\n      cleanMerge: true,\n      mergeResult: { mode, path, oid: await ours.oid(), type },\n    }\n  }\n  // if only one side made oid changes, return that side's oid\n  if ((await ours.oid()) === baseOid) {\n    return {\n      cleanMerge: true,\n      mergeResult: { mode, path, oid: await theirs.oid(), type },\n    }\n  }\n  if ((await theirs.oid()) === baseOid) {\n    return {\n      cleanMerge: true,\n      mergeResult: { mode, path, oid: await ours.oid(), type },\n    }\n  }\n  // if both sides made changes do a merge\n  const ourContent = Buffer.from(await ours.content()).toString('utf8');\n  const theirContent = Buffer.from(await theirs.content()).toString('utf8');\n  const { mergedText, cleanMerge } = await mergeDriver({\n    branches: [baseName, ourName, theirName],\n    contents: [baseContent, ourContent, theirContent],\n    path,\n  });\n  const oid = await _writeObject({\n    fs,\n    gitdir,\n    type: 'blob',\n    object: Buffer.from(mergedText, 'utf8'),\n    dryRun,\n  });\n\n  return { cleanMerge, mergeResult: { mode, path, oid, type } }\n}\n\n// @ts-check\n\n// import diff3 from 'node-diff3'\n/**\n *\n * @typedef {Object} MergeResult - Returns an object with a schema like this:\n * @property {string} [oid] - The SHA-1 object id that is now at the head of the branch. Absent only if `dryRun` was specified and `mergeCommit` is true.\n * @property {boolean} [alreadyMerged] - True if the branch was already merged so no changes were made\n * @property {boolean} [fastForward] - True if it was a fast-forward merge\n * @property {boolean} [mergeCommit] - True if merge resulted in a merge commit\n * @property {string} [tree] - The SHA-1 object id of the tree resulting from a merge commit\n *\n */\n\n/**\n * @param {object} args\n * @param {import('../models/FileSystem.js').FileSystem} args.fs\n * @param {object} args.cache\n * @param {string} args.gitdir\n * @param {string} [args.ours]\n * @param {string} args.theirs\n * @param {boolean} args.fastForward\n * @param {boolean} args.fastForwardOnly\n * @param {boolean} args.dryRun\n * @param {boolean} args.noUpdateBranch\n * @param {boolean} args.abortOnConflict\n * @param {string} [args.message]\n * @param {Object} args.author\n * @param {string} args.author.name\n * @param {string} args.author.email\n * @param {number} args.author.timestamp\n * @param {number} args.author.timezoneOffset\n * @param {Object} args.committer\n * @param {string} args.committer.name\n * @param {string} args.committer.email\n * @param {number} args.committer.timestamp\n * @param {number} args.committer.timezoneOffset\n * @param {string} [args.signingKey]\n * @param {SignCallback} [args.onSign] - a PGP signing implementation\n * @param {MergeDriverCallback} [args.mergeDriver]\n * @param {boolean} args.allowUnrelatedHistories\n *\n * @returns {Promise<MergeResult>} Resolves to a description of the merge operation\n *\n */\nasync function _merge({\n  fs,\n  cache,\n  dir,\n  gitdir,\n  ours,\n  theirs,\n  fastForward = true,\n  fastForwardOnly = false,\n  dryRun = false,\n  noUpdateBranch = false,\n  abortOnConflict = true,\n  message,\n  author,\n  committer,\n  signingKey,\n  onSign,\n  mergeDriver,\n  allowUnrelatedHistories = false,\n}) {\n  if (ours === undefined) {\n    ours = await _currentBranch({ fs, gitdir, fullname: true });\n  }\n  ours = await GitRefManager.expand({\n    fs,\n    gitdir,\n    ref: ours,\n  });\n  theirs = await GitRefManager.expand({\n    fs,\n    gitdir,\n    ref: theirs,\n  });\n  const ourOid = await GitRefManager.resolve({\n    fs,\n    gitdir,\n    ref: ours,\n  });\n  const theirOid = await GitRefManager.resolve({\n    fs,\n    gitdir,\n    ref: theirs,\n  });\n  // find most recent common ancestor of ref a and ref b\n  const baseOids = await _findMergeBase({\n    fs,\n    cache,\n    gitdir,\n    oids: [ourOid, theirOid],\n  });\n  if (baseOids.length !== 1) {\n    if (baseOids.length === 0 && allowUnrelatedHistories) {\n      // 4b825  == the empty tree used by git\n      baseOids.push('4b825dc642cb6eb9a060e54bf8d69288fbee4904');\n    } else {\n      // TODO: Recursive Merge strategy\n      throw new MergeNotSupportedError()\n    }\n  }\n  const baseOid = baseOids[0];\n  // handle fast-forward case\n  if (baseOid === theirOid) {\n    return {\n      oid: ourOid,\n      alreadyMerged: true,\n    }\n  }\n  if (fastForward && baseOid === ourOid) {\n    if (!dryRun && !noUpdateBranch) {\n      await GitRefManager.writeRef({ fs, gitdir, ref: ours, value: theirOid });\n    }\n    return {\n      oid: theirOid,\n      fastForward: true,\n    }\n  } else {\n    // not a simple fast-forward\n    if (fastForwardOnly) {\n      throw new FastForwardError()\n    }\n    // try a fancier merge\n    const tree = await GitIndexManager.acquire(\n      { fs, gitdir, cache, allowUnmerged: false },\n      async index => {\n        return mergeTree({\n          fs,\n          cache,\n          dir,\n          gitdir,\n          index,\n          ourOid,\n          theirOid,\n          baseOid,\n          ourName: abbreviateRef(ours),\n          baseName: 'base',\n          theirName: abbreviateRef(theirs),\n          dryRun,\n          abortOnConflict,\n          mergeDriver,\n        })\n      }\n    );\n\n    // Defer throwing error until the index lock is relinquished and index is\n    // written to filesystem\n    if (tree instanceof MergeConflictError) throw tree\n\n    if (!message) {\n      message = `Merge branch '${abbreviateRef(theirs)}' into ${abbreviateRef(\n        ours\n      )}`;\n    }\n    const oid = await _commit({\n      fs,\n      cache,\n      gitdir,\n      message,\n      ref: ours,\n      tree,\n      parent: [ourOid, theirOid],\n      author,\n      committer,\n      signingKey,\n      onSign,\n      dryRun,\n      noUpdateBranch,\n    });\n    return {\n      oid,\n      tree,\n      mergeCommit: true,\n    }\n  }\n}\n\n// @ts-check\n\n/**\n * @param {object} args\n * @param {import('../models/FileSystem.js').FileSystem} args.fs\n * @param {object} args.cache\n * @param {HttpClient} args.http\n * @param {ProgressCallback} [args.onProgress]\n * @param {MessageCallback} [args.onMessage]\n * @param {AuthCallback} [args.onAuth]\n * @param {AuthFailureCallback} [args.onAuthFailure]\n * @param {AuthSuccessCallback} [args.onAuthSuccess]\n * @param {string} args.dir\n * @param {string} args.gitdir\n * @param {string} args.ref\n * @param {string} [args.url]\n * @param {string} [args.remote]\n * @param {string} [args.remoteRef]\n * @param {boolean} [args.prune]\n * @param {boolean} [args.pruneTags]\n * @param {string} [args.corsProxy]\n * @param {boolean} args.singleBranch\n * @param {boolean} args.fastForward\n * @param {boolean} args.fastForwardOnly\n * @param {Object<string, string>} [args.headers]\n * @param {Object} args.author\n * @param {string} args.author.name\n * @param {string} args.author.email\n * @param {number} args.author.timestamp\n * @param {number} args.author.timezoneOffset\n * @param {Object} args.committer\n * @param {string} args.committer.name\n * @param {string} args.committer.email\n * @param {number} args.committer.timestamp\n * @param {number} args.committer.timezoneOffset\n * @param {string} [args.signingKey]\n *\n * @returns {Promise<void>} Resolves successfully when pull operation completes\n *\n */\nasync function _pull({\n  fs,\n  cache,\n  http,\n  onProgress,\n  onMessage,\n  onAuth,\n  onAuthSuccess,\n  onAuthFailure,\n  dir,\n  gitdir,\n  ref,\n  url,\n  remote,\n  remoteRef,\n  prune,\n  pruneTags,\n  fastForward,\n  fastForwardOnly,\n  corsProxy,\n  singleBranch,\n  headers,\n  author,\n  committer,\n  signingKey,\n}) {\n  try {\n    // If ref is undefined, use 'HEAD'\n    if (!ref) {\n      const head = await _currentBranch({ fs, gitdir });\n      // TODO: use a better error.\n      if (!head) {\n        throw new MissingParameterError('ref')\n      }\n      ref = head;\n    }\n\n    const { fetchHead, fetchHeadDescription } = await _fetch({\n      fs,\n      cache,\n      http,\n      onProgress,\n      onMessage,\n      onAuth,\n      onAuthSuccess,\n      onAuthFailure,\n      gitdir,\n      corsProxy,\n      ref,\n      url,\n      remote,\n      remoteRef,\n      singleBranch,\n      headers,\n      prune,\n      pruneTags,\n    });\n    // Merge the remote tracking branch into the local one.\n    await _merge({\n      fs,\n      cache,\n      gitdir,\n      ours: ref,\n      theirs: fetchHead,\n      fastForward,\n      fastForwardOnly,\n      message: `Merge ${fetchHeadDescription}`,\n      author,\n      committer,\n      signingKey,\n      dryRun: false,\n      noUpdateBranch: false,\n    });\n    await _checkout({\n      fs,\n      cache,\n      onProgress,\n      dir,\n      gitdir,\n      ref,\n      remote,\n      noCheckout: false,\n    });\n  } catch (err) {\n    err.caller = 'git.pull';\n    throw err\n  }\n}\n\n// @ts-check\n\n/**\n * Like `pull`, but hard-coded with `fastForward: true` so there is no need for an `author` parameter.\n *\n * @param {object} args\n * @param {FsClient} args.fs - a file system client\n * @param {HttpClient} args.http - an HTTP client\n * @param {ProgressCallback} [args.onProgress] - optional progress event callback\n * @param {MessageCallback} [args.onMessage] - optional message event callback\n * @param {AuthCallback} [args.onAuth] - optional auth fill callback\n * @param {AuthFailureCallback} [args.onAuthFailure] - optional auth rejected callback\n * @param {AuthSuccessCallback} [args.onAuthSuccess] - optional auth approved callback\n * @param {string} args.dir] - The [working tree](dir-vs-gitdir.md) directory path\n * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path\n * @param {string} [args.ref] - Which branch to merge into. By default this is the currently checked out branch.\n * @param {string} [args.url] - (Added in 1.1.0) The URL of the remote repository. The default is the value set in the git config for that remote.\n * @param {string} [args.remote] - (Added in 1.1.0) If URL is not specified, determines which remote to use.\n * @param {string} [args.remoteRef] - (Added in 1.1.0) The name of the branch on the remote to fetch. By default this is the configured remote tracking branch.\n * @param {string} [args.corsProxy] - Optional [CORS proxy](https://www.npmjs.com/%40isomorphic-git/cors-proxy). Overrides value in repo config.\n * @param {boolean} [args.singleBranch = false] - Instead of the default behavior of fetching all the branches, only fetch a single branch.\n * @param {Object<string, string>} [args.headers] - Additional headers to include in HTTP requests, similar to git's `extraHeader` config\n * @param {object} [args.cache] - a [cache](cache.md) object\n *\n * @returns {Promise<void>} Resolves successfully when pull operation completes\n *\n * @example\n * await git.fastForward({\n *   fs,\n *   http,\n *   dir: '/tutorial',\n *   ref: 'main',\n *   singleBranch: true\n * })\n * console.log('done')\n *\n */\nasync function fastForward({\n  fs,\n  http,\n  onProgress,\n  onMessage,\n  onAuth,\n  onAuthSuccess,\n  onAuthFailure,\n  dir,\n  gitdir = join(dir, '.git'),\n  ref,\n  url,\n  remote,\n  remoteRef,\n  corsProxy,\n  singleBranch,\n  headers = {},\n  cache = {},\n}) {\n  try {\n    assertParameter('fs', fs);\n    assertParameter('http', http);\n    assertParameter('gitdir', gitdir);\n\n    const thisWillNotBeUsed = {\n      name: '',\n      email: '',\n      timestamp: Date.now(),\n      timezoneOffset: 0,\n    };\n\n    const fsp = new FileSystem(fs);\n    const updatedGitdir = await discoverGitdir({ fsp, dotgit: gitdir });\n    return await _pull({\n      fs: fsp,\n      cache,\n      http,\n      onProgress,\n      onMessage,\n      onAuth,\n      onAuthSuccess,\n      onAuthFailure,\n      dir,\n      gitdir: updatedGitdir,\n      ref,\n      url,\n      remote,\n      remoteRef,\n      fastForwardOnly: true,\n      corsProxy,\n      singleBranch,\n      headers,\n      author: thisWillNotBeUsed,\n      committer: thisWillNotBeUsed,\n    })\n  } catch (err) {\n    err.caller = 'git.fastForward';\n    throw err\n  }\n}\n\n// @ts-check\n\n/**\n *\n * @typedef {object} FetchResult - The object returned has the following schema:\n * @property {string | null} defaultBranch - The branch that is cloned if no branch is specified\n * @property {string | null} fetchHead - The SHA-1 object id of the fetched head commit\n * @property {string | null} fetchHeadDescription - a textual description of the branch that was fetched\n * @property {Object<string, string>} [headers] - The HTTP response headers returned by the git server\n * @property {string[]} [pruned] - A list of branches that were pruned, if you provided the `prune` parameter\n *\n */\n\n/**\n * Fetch commits from a remote repository\n *\n * @param {object} args\n * @param {FsClient} args.fs - a file system client\n * @param {HttpClient} args.http - an HTTP client\n * @param {ProgressCallback} [args.onProgress] - optional progress event callback\n * @param {MessageCallback} [args.onMessage] - optional message event callback\n * @param {AuthCallback} [args.onAuth] - optional auth fill callback\n * @param {AuthFailureCallback} [args.onAuthFailure] - optional auth rejected callback\n * @param {AuthSuccessCallback} [args.onAuthSuccess] - optional auth approved callback\n * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path\n * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path\n * @param {string} [args.url] - The URL of the remote repository. The default is the value set in the git config for that remote.\n * @param {string} [args.remote] - If URL is not specified, determines which remote to use.\n * @param {boolean} [args.singleBranch = false] - Instead of the default behavior of fetching all the branches, only fetch a single branch.\n * @param {string} [args.ref] - Which branch to fetch if `singleBranch` is true. By default this is the current branch or the remote's default branch.\n * @param {string} [args.remoteRef] - The name of the branch on the remote to fetch if `singleBranch` is true. By default this is the configured remote tracking branch.\n * @param {boolean} [args.tags = false] - Also fetch tags\n * @param {number} [args.depth] - Integer. Determines how much of the git repository's history to retrieve\n * @param {boolean} [args.relative = false] - Changes the meaning of `depth` to be measured from the current shallow depth rather than from the branch tip.\n * @param {Date} [args.since] - Only fetch commits created after the given date. Mutually exclusive with `depth`.\n * @param {string[]} [args.exclude = []] - A list of branches or tags. Instructs the remote server not to send us any commits reachable from these refs.\n * @param {boolean} [args.prune = false] - Delete local remote-tracking branches that are not present on the remote\n * @param {boolean} [args.pruneTags = false] - Prune local tags that dont exist on the remote, and force-update those tags that differ\n * @param {string} [args.corsProxy] - Optional [CORS proxy](https://www.npmjs.com/%40isomorphic-git/cors-proxy). Overrides value in repo config.\n * @param {Object<string, string>} [args.headers] - Additional headers to include in HTTP requests, similar to git's `extraHeader` config\n * @param {object} [args.cache] - a [cache](cache.md) object\n *\n * @returns {Promise<FetchResult>} Resolves successfully when fetch completes\n * @see FetchResult\n *\n * @example\n * let result = await git.fetch({\n *   fs,\n *   http,\n *   dir: '/tutorial',\n *   corsProxy: 'https://cors.isomorphic-git.org',\n *   url: 'https://github.com/isomorphic-git/isomorphic-git',\n *   ref: 'main',\n *   depth: 1,\n *   singleBranch: true,\n *   tags: false\n * })\n * console.log(result)\n *\n */\nasync function fetch({\n  fs,\n  http,\n  onProgress,\n  onMessage,\n  onAuth,\n  onAuthSuccess,\n  onAuthFailure,\n  dir,\n  gitdir = join(dir, '.git'),\n  ref,\n  remote,\n  remoteRef,\n  url,\n  corsProxy,\n  depth = null,\n  since = null,\n  exclude = [],\n  relative = false,\n  tags = false,\n  singleBranch = false,\n  headers = {},\n  prune = false,\n  pruneTags = false,\n  cache = {},\n}) {\n  try {\n    assertParameter('fs', fs);\n    assertParameter('http', http);\n    assertParameter('gitdir', gitdir);\n\n    const fsp = new FileSystem(fs);\n    const updatedGitdir = await discoverGitdir({ fsp, dotgit: gitdir });\n    return await _fetch({\n      fs: fsp,\n      cache,\n      http,\n      onProgress,\n      onMessage,\n      onAuth,\n      onAuthSuccess,\n      onAuthFailure,\n      gitdir: updatedGitdir,\n      ref,\n      remote,\n      remoteRef,\n      url,\n      corsProxy,\n      depth,\n      since,\n      exclude,\n      relative,\n      tags,\n      singleBranch,\n      headers,\n      prune,\n      pruneTags,\n    })\n  } catch (err) {\n    err.caller = 'git.fetch';\n    throw err\n  }\n}\n\n// @ts-check\n\n/**\n * Find the merge base for a set of commits\n *\n * @param {object} args\n * @param {FsClient} args.fs - a file system client\n * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path\n * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path\n * @param {string[]} args.oids - Which commits\n * @param {object} [args.cache] - a [cache](cache.md) object\n *\n */\nasync function findMergeBase({\n  fs,\n  dir,\n  gitdir = join(dir, '.git'),\n  oids,\n  cache = {},\n}) {\n  try {\n    assertParameter('fs', fs);\n    assertParameter('gitdir', gitdir);\n    assertParameter('oids', oids);\n\n    const fsp = new FileSystem(fs);\n    const updatedGitdir = await discoverGitdir({ fsp, dotgit: gitdir });\n    return await _findMergeBase({\n      fs: fsp,\n      cache,\n      gitdir: updatedGitdir,\n      oids,\n    })\n  } catch (err) {\n    err.caller = 'git.findMergeBase';\n    throw err\n  }\n}\n\n// @ts-check\n\n/**\n * Find the root git directory\n *\n * Starting at `filepath`, walks upward until it finds a directory that contains a subdirectory called '.git'.\n *\n * @param {Object} args\n * @param {import('../models/FileSystem.js').FileSystem} args.fs\n * @param {string} args.filepath\n *\n * @returns {Promise<string>} Resolves successfully with a root git directory path\n */\nasync function _findRoot({ fs, filepath }) {\n  if (await fs.exists(join(filepath, '.git'))) {\n    return filepath\n  } else {\n    const parent = dirname(filepath);\n    if (parent === filepath) {\n      throw new NotFoundError(`git root for ${filepath}`)\n    }\n    return _findRoot({ fs, filepath: parent })\n  }\n}\n\n// @ts-check\n\n/**\n * Find the root git directory\n *\n * Starting at `filepath`, walks upward until it finds a directory that contains a subdirectory called '.git'.\n *\n * @param {Object} args\n * @param {FsClient} args.fs - a file system client\n * @param {string} args.filepath - The file directory to start searching in.\n *\n * @returns {Promise<string>} Resolves successfully with a root git directory path\n * @throws {NotFoundError}\n *\n * @example\n * let gitroot = await git.findRoot({\n *   fs,\n *   filepath: '/tutorial/src/utils'\n * })\n * console.log(gitroot)\n *\n */\nasync function findRoot({ fs, filepath }) {\n  try {\n    assertParameter('fs', fs);\n    assertParameter('filepath', filepath);\n\n    return await _findRoot({ fs: new FileSystem(fs), filepath })\n  } catch (err) {\n    err.caller = 'git.findRoot';\n    throw err\n  }\n}\n\n// @ts-check\n\n/**\n * Read an entry from the git config files.\n *\n * *Caveats:*\n * - Currently only the local `$GIT_DIR/config` file can be read or written. However support for the global `~/.gitconfig` and system `$(prefix)/etc/gitconfig` will be added in the future.\n * - The current parser does not support the more exotic features of the git-config file format such as `[include]` and `[includeIf]`.\n *\n * @param {Object} args\n * @param {FsClient} args.fs - a file system implementation\n * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path\n * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path\n * @param {string} args.path - The key of the git config entry\n *\n * @returns {Promise<any>} Resolves with the config value\n *\n * @example\n * // Read config value\n * let value = await git.getConfig({\n *   fs,\n *   dir: '/tutorial',\n *   path: 'remote.origin.url'\n * })\n * console.log(value)\n *\n */\nasync function getConfig({ fs, dir, gitdir = join(dir, '.git'), path }) {\n  try {\n    assertParameter('fs', fs);\n    assertParameter('gitdir', gitdir);\n    assertParameter('path', path);\n\n    const fsp = new FileSystem(fs);\n    const updatedGitdir = await discoverGitdir({ fsp, dotgit: gitdir });\n    return await _getConfig({\n      fs: fsp,\n      gitdir: updatedGitdir,\n      path,\n    })\n  } catch (err) {\n    err.caller = 'git.getConfig';\n    throw err\n  }\n}\n\n// @ts-check\n\n/**\n * @param {Object} args\n * @param {import('../models/FileSystem.js').FileSystem} args.fs\n * @param {string} args.gitdir\n * @param {string} args.path\n *\n * @returns {Promise<Array<any>>} Resolves with an array of the config value\n *\n */\nasync function _getConfigAll({ fs, gitdir, path }) {\n  const config = await GitConfigManager.get({ fs, gitdir });\n  return config.getall(path)\n}\n\n// @ts-check\n\n/**\n * Read a multi-valued entry from the git config files.\n *\n * *Caveats:*\n * - Currently only the local `$GIT_DIR/config` file can be read or written. However support for the global `~/.gitconfig` and system `$(prefix)/etc/gitconfig` will be added in the future.\n * - The current parser does not support the more exotic features of the git-config file format such as `[include]` and `[includeIf]`.\n *\n * @param {Object} args\n * @param {FsClient} args.fs - a file system implementation\n * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path\n * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path\n * @param {string} args.path - The key of the git config entry\n *\n * @returns {Promise<Array<any>>} Resolves with the config value\n *\n */\nasync function getConfigAll({\n  fs,\n  dir,\n  gitdir = join(dir, '.git'),\n  path,\n}) {\n  try {\n    assertParameter('fs', fs);\n    assertParameter('gitdir', gitdir);\n    assertParameter('path', path);\n\n    const fsp = new FileSystem(fs);\n    const updatedGitdir = await discoverGitdir({ fsp, dotgit: gitdir });\n    return await _getConfigAll({\n      fs: fsp,\n      gitdir: updatedGitdir,\n      path,\n    })\n  } catch (err) {\n    err.caller = 'git.getConfigAll';\n    throw err\n  }\n}\n\n// @ts-check\n\n/**\n *\n * @typedef {Object} GetRemoteInfoResult - The object returned has the following schema:\n * @property {string[]} capabilities - The list of capabilities returned by the server (part of the Git protocol)\n * @property {Object} [refs]\n * @property {string} [HEAD] - The default branch of the remote\n * @property {Object<string, string>} [refs.heads] - The branches on the remote\n * @property {Object<string, string>} [refs.pull] - The special branches representing pull requests (non-standard)\n * @property {Object<string, string>} [refs.tags] - The tags on the remote\n *\n */\n\n/**\n * List a remote servers branches, tags, and capabilities.\n *\n * This is a rare command that doesn't require an `fs`, `dir`, or even `gitdir` argument.\n * It just communicates to a remote git server, using the first step of the `git-upload-pack` handshake, but stopping short of fetching the packfile.\n *\n * @param {object} args\n * @param {HttpClient} args.http - an HTTP client\n * @param {AuthCallback} [args.onAuth] - optional auth fill callback\n * @param {AuthFailureCallback} [args.onAuthFailure] - optional auth rejected callback\n * @param {AuthSuccessCallback} [args.onAuthSuccess] - optional auth approved callback\n * @param {string} args.url - The URL of the remote repository. Will be gotten from gitconfig if absent.\n * @param {string} [args.corsProxy] - Optional [CORS proxy](https://www.npmjs.com/%40isomorphic-git/cors-proxy). Overrides value in repo config.\n * @param {boolean} [args.forPush = false] - By default, the command queries the 'fetch' capabilities. If true, it will ask for the 'push' capabilities.\n * @param {Object<string, string>} [args.headers] - Additional headers to include in HTTP requests, similar to git's `extraHeader` config\n *\n * @returns {Promise<GetRemoteInfoResult>} Resolves successfully with an object listing the branches, tags, and capabilities of the remote.\n * @see GetRemoteInfoResult\n *\n * @example\n * let info = await git.getRemoteInfo({\n *   http,\n *   url:\n *     \"https://cors.isomorphic-git.org/github.com/isomorphic-git/isomorphic-git.git\"\n * });\n * console.log(info);\n *\n */\nasync function getRemoteInfo({\n  http,\n  onAuth,\n  onAuthSuccess,\n  onAuthFailure,\n  corsProxy,\n  url,\n  headers = {},\n  forPush = false,\n}) {\n  try {\n    assertParameter('http', http);\n    assertParameter('url', url);\n\n    const GitRemoteHTTP = GitRemoteManager.getRemoteHelperFor({ url });\n    const remote = await GitRemoteHTTP.discover({\n      http,\n      onAuth,\n      onAuthSuccess,\n      onAuthFailure,\n      corsProxy,\n      service: forPush ? 'git-receive-pack' : 'git-upload-pack',\n      url,\n      headers,\n      protocolVersion: 1,\n    });\n\n    // Note: remote.capabilities, remote.refs, and remote.symrefs are Set and Map objects,\n    // but one of the objectives of the public API is to always return JSON-compatible objects\n    // so we must JSONify them.\n    const result = {\n      capabilities: [...remote.capabilities],\n    };\n    // Convert the flat list into an object tree, because I figure 99% of the time\n    // that will be easier to use.\n    for (const [ref, oid] of remote.refs) {\n      const parts = ref.split('/');\n      const last = parts.pop();\n      let o = result;\n      for (const part of parts) {\n        o[part] = o[part] || {};\n        o = o[part];\n      }\n      o[last] = oid;\n    }\n    // Merge symrefs on top of refs to more closely match actual git repo layouts\n    for (const [symref, ref] of remote.symrefs) {\n      const parts = symref.split('/');\n      const last = parts.pop();\n      let o = result;\n      for (const part of parts) {\n        o[part] = o[part] || {};\n        o = o[part];\n      }\n      o[last] = ref;\n    }\n    return result\n  } catch (err) {\n    err.caller = 'git.getRemoteInfo';\n    throw err\n  }\n}\n\n// @ts-check\n\n/**\n * @param {any} remote\n * @param {string} prefix\n * @param {boolean} symrefs\n * @param {boolean} peelTags\n * @returns {ServerRef[]}\n */\nfunction formatInfoRefs(remote, prefix, symrefs, peelTags) {\n  const refs = [];\n  for (const [key, value] of remote.refs) {\n    if (prefix && !key.startsWith(prefix)) continue\n\n    if (key.endsWith('^{}')) {\n      if (peelTags) {\n        const _key = key.replace('^{}', '');\n        // Peeled tags are almost always listed immediately after the original tag\n        const last = refs[refs.length - 1];\n        const r = last.ref === _key ? last : refs.find(x => x.ref === _key);\n        if (r === undefined) {\n          throw new Error('I did not expect this to happen')\n        }\n        r.peeled = value;\n      }\n      continue\n    }\n    /** @type ServerRef */\n    const ref = { ref: key, oid: value };\n    if (symrefs) {\n      if (remote.symrefs.has(key)) {\n        ref.target = remote.symrefs.get(key);\n      }\n    }\n    refs.push(ref);\n  }\n  return refs\n}\n\n// @ts-check\n\n/**\n * @typedef {Object} GetRemoteInfo2Result - This object has the following schema:\n * @property {1 | 2} protocolVersion - Git protocol version the server supports\n * @property {Object<string, string | true>} capabilities - An object of capabilities represented as keys and values\n * @property {ServerRef[]} [refs] - Server refs (they get returned by protocol version 1 whether you want them or not)\n */\n\n/**\n * List a remote server's capabilities.\n *\n * This is a rare command that doesn't require an `fs`, `dir`, or even `gitdir` argument.\n * It just communicates to a remote git server, determining what protocol version, commands, and features it supports.\n *\n * > The successor to [`getRemoteInfo`](./getRemoteInfo.md), this command supports Git Wire Protocol Version 2.\n * > Therefore its return type is more complicated as either:\n * >\n * > - v1 capabilities (and refs) or\n * > - v2 capabilities (and no refs)\n * >\n * > are returned.\n * > If you just care about refs, use [`listServerRefs`](./listServerRefs.md)\n *\n * @param {object} args\n * @param {HttpClient} args.http - an HTTP client\n * @param {AuthCallback} [args.onAuth] - optional auth fill callback\n * @param {AuthFailureCallback} [args.onAuthFailure] - optional auth rejected callback\n * @param {AuthSuccessCallback} [args.onAuthSuccess] - optional auth approved callback\n * @param {string} args.url - The URL of the remote repository. Will be gotten from gitconfig if absent.\n * @param {string} [args.corsProxy] - Optional [CORS proxy](https://www.npmjs.com/%40isomorphic-git/cors-proxy). Overrides value in repo config.\n * @param {boolean} [args.forPush = false] - By default, the command queries the 'fetch' capabilities. If true, it will ask for the 'push' capabilities.\n * @param {Object<string, string>} [args.headers] - Additional headers to include in HTTP requests, similar to git's `extraHeader` config\n * @param {1 | 2} [args.protocolVersion = 2] - Which version of the Git Protocol to use.\n *\n * @returns {Promise<GetRemoteInfo2Result>} Resolves successfully with an object listing the capabilities of the remote.\n * @see GetRemoteInfo2Result\n * @see ServerRef\n *\n * @example\n * let info = await git.getRemoteInfo2({\n *   http,\n *   corsProxy: \"https://cors.isomorphic-git.org\",\n *   url: \"https://github.com/isomorphic-git/isomorphic-git.git\"\n * });\n * console.log(info);\n *\n */\nasync function getRemoteInfo2({\n  http,\n  onAuth,\n  onAuthSuccess,\n  onAuthFailure,\n  corsProxy,\n  url,\n  headers = {},\n  forPush = false,\n  protocolVersion = 2,\n}) {\n  try {\n    assertParameter('http', http);\n    assertParameter('url', url);\n\n    const GitRemoteHTTP = GitRemoteManager.getRemoteHelperFor({ url });\n    const remote = await GitRemoteHTTP.discover({\n      http,\n      onAuth,\n      onAuthSuccess,\n      onAuthFailure,\n      corsProxy,\n      service: forPush ? 'git-receive-pack' : 'git-upload-pack',\n      url,\n      headers,\n      protocolVersion,\n    });\n\n    if (remote.protocolVersion === 2) {\n      /** @type GetRemoteInfo2Result */\n      return {\n        protocolVersion: remote.protocolVersion,\n        capabilities: remote.capabilities2,\n      }\n    }\n\n    // Note: remote.capabilities, remote.refs, and remote.symrefs are Set and Map objects,\n    // but one of the objectives of the public API is to always return JSON-compatible objects\n    // so we must JSONify them.\n    /** @type Object<string, true> */\n    const capabilities = {};\n    for (const cap of remote.capabilities) {\n      const [key, value] = cap.split('=');\n      if (value) {\n        capabilities[key] = value;\n      } else {\n        capabilities[key] = true;\n      }\n    }\n    /** @type GetRemoteInfo2Result */\n    return {\n      protocolVersion: 1,\n      capabilities,\n      refs: formatInfoRefs(remote, undefined, true, true),\n    }\n  } catch (err) {\n    err.caller = 'git.getRemoteInfo2';\n    throw err\n  }\n}\n\nasync function hashObject({\n  type,\n  object,\n  format = 'content',\n  oid = undefined,\n}) {\n  if (format !== 'deflated') {\n    if (format !== 'wrapped') {\n      object = GitObject.wrap({ type, object });\n    }\n    oid = await shasum(object);\n  }\n  return { oid, object }\n}\n\n// @ts-check\n\n/**\n *\n * @typedef {object} HashBlobResult - The object returned has the following schema:\n * @property {string} oid - The SHA-1 object id\n * @property {'blob'} type - The type of the object\n * @property {Uint8Array} object - The wrapped git object (the thing that is hashed)\n * @property {'wrapped'} format - The format of the object\n *\n */\n\n/**\n * Compute what the SHA-1 object id of a file would be\n *\n * @param {object} args\n * @param {Uint8Array|string} args.object - The object to write. If `object` is a String then it will be converted to a Uint8Array using UTF-8 encoding.\n *\n * @returns {Promise<HashBlobResult>} Resolves successfully with the SHA-1 object id and the wrapped object Uint8Array.\n * @see HashBlobResult\n *\n * @example\n * let { oid, type, object, format } = await git.hashBlob({\n *   object: 'Hello world!',\n * })\n *\n * console.log('oid', oid)\n * console.log('type', type)\n * console.log('object', object)\n * console.log('format', format)\n *\n */\nasync function hashBlob({ object }) {\n  try {\n    assertParameter('object', object);\n\n    // Convert object to buffer\n    if (typeof object === 'string') {\n      object = Buffer.from(object, 'utf8');\n    } else if (!(object instanceof Uint8Array)) {\n      object = new Uint8Array(object);\n    }\n\n    const type = 'blob';\n    const { oid, object: _object } = await hashObject({\n      type,\n      format: 'content',\n      object,\n    });\n\n    return { oid, type, object: _object, format: 'wrapped' }\n  } catch (err) {\n    err.caller = 'git.hashBlob';\n    throw err\n  }\n}\n\n// @ts-check\n\n/**\n * @param {object} args\n * @param {import('../models/FileSystem.js').FileSystem} args.fs\n * @param {any} args.cache\n * @param {ProgressCallback} [args.onProgress]\n * @param {string} args.dir\n * @param {string} args.gitdir\n * @param {string} args.filepath\n *\n * @returns {Promise<{oids: string[]}>}\n */\nasync function _indexPack({\n  fs,\n  cache,\n  onProgress,\n  dir,\n  gitdir,\n  filepath,\n}) {\n  try {\n    filepath = join(dir, filepath);\n    const pack = await fs.read(filepath);\n    const getExternalRefDelta = oid => _readObject({ fs, cache, gitdir, oid });\n    const idx = await GitPackIndex.fromPack({\n      pack,\n      getExternalRefDelta,\n      onProgress,\n    });\n    await fs.write(filepath.replace(/\\.pack$/, '.idx'), await idx.toBuffer());\n    return {\n      oids: [...idx.hashes],\n    }\n  } catch (err) {\n    err.caller = 'git.indexPack';\n    throw err\n  }\n}\n\n// @ts-check\n\n/**\n * Create the .idx file for a given .pack file\n *\n * @param {object} args\n * @param {FsClient} args.fs - a file system client\n * @param {ProgressCallback} [args.onProgress] - optional progress event callback\n * @param {string} args.dir - The [working tree](dir-vs-gitdir.md) directory path\n * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path\n * @param {string} args.filepath - The path to the .pack file to index\n * @param {object} [args.cache] - a [cache](cache.md) object\n *\n * @returns {Promise<{oids: string[]}>} Resolves with a list of the SHA-1 object ids contained in the packfile\n *\n * @example\n * let packfiles = await fs.promises.readdir('/tutorial/.git/objects/pack')\n * packfiles = packfiles.filter(name => name.endsWith('.pack'))\n * console.log('packfiles', packfiles)\n *\n * const { oids } = await git.indexPack({\n *   fs,\n *   dir: '/tutorial',\n *   filepath: `.git/objects/pack/${packfiles[0]}`,\n *   async onProgress (evt) {\n *     console.log(`${evt.phase}: ${evt.loaded} / ${evt.total}`)\n *   }\n * })\n * console.log(oids)\n *\n */\nasync function indexPack({\n  fs,\n  onProgress,\n  dir,\n  gitdir = join(dir, '.git'),\n  filepath,\n  cache = {},\n}) {\n  try {\n    assertParameter('fs', fs);\n    assertParameter('dir', dir);\n    assertParameter('gitdir', dir);\n    assertParameter('filepath', filepath);\n\n    const fsp = new FileSystem(fs);\n    const updatedGitdir = await discoverGitdir({ fsp, dotgit: gitdir });\n    return await _indexPack({\n      fs: fsp,\n      cache,\n      onProgress,\n      dir,\n      gitdir: updatedGitdir,\n      filepath,\n    })\n  } catch (err) {\n    err.caller = 'git.indexPack';\n    throw err\n  }\n}\n\n// @ts-check\n\n/**\n * Initialize a new repository\n *\n * @param {object} args\n * @param {FsClient} args.fs - a file system client\n * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path\n * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path\n * @param {boolean} [args.bare = false] - Initialize a bare repository\n * @param {string} [args.defaultBranch = 'master'] - The name of the default branch (might be changed to a required argument in 2.0.0)\n * @returns {Promise<void>}  Resolves successfully when filesystem operations are complete\n *\n * @example\n * await git.init({ fs, dir: '/tutorial' })\n * console.log('done')\n *\n */\nasync function init({\n  fs,\n  bare = false,\n  dir,\n  gitdir = bare ? dir : join(dir, '.git'),\n  defaultBranch = 'master',\n}) {\n  try {\n    assertParameter('fs', fs);\n    assertParameter('gitdir', gitdir);\n    if (!bare) {\n      assertParameter('dir', dir);\n    }\n\n    const fsp = new FileSystem(fs);\n    const updatedGitdir = await discoverGitdir({ fsp, dotgit: gitdir });\n    return await _init({\n      fs: fsp,\n      bare,\n      dir,\n      gitdir: updatedGitdir,\n      defaultBranch,\n    })\n  } catch (err) {\n    err.caller = 'git.init';\n    throw err\n  }\n}\n\n// @ts-check\n\n/**\n * @param {object} args\n * @param {import('../models/FileSystem.js').FileSystem} args.fs\n * @param {any} args.cache\n * @param {string} args.gitdir\n * @param {string} args.oid\n * @param {string} args.ancestor\n * @param {number} args.depth - Maximum depth to search before giving up. -1 means no maximum depth.\n *\n * @returns {Promise<boolean>}\n */\nasync function _isDescendent({\n  fs,\n  cache,\n  gitdir,\n  oid,\n  ancestor,\n  depth,\n}) {\n  const shallows = await GitShallowManager.read({ fs, gitdir });\n  if (!oid) {\n    throw new MissingParameterError('oid')\n  }\n  if (!ancestor) {\n    throw new MissingParameterError('ancestor')\n  }\n  // If you don't like this behavior, add your own check.\n  // Edge cases are hard to define a perfect solution.\n  if (oid === ancestor) return false\n  // We do not use recursion here, because that would lead to depth-first traversal,\n  // and we want to maintain a breadth-first traversal to avoid hitting shallow clone depth cutoffs.\n  const queue = [oid];\n  const visited = new Set();\n  let searchdepth = 0;\n  while (queue.length) {\n    if (searchdepth++ === depth) {\n      throw new MaxDepthError(depth)\n    }\n    const oid = queue.shift();\n    const { type, object } = await _readObject({\n      fs,\n      cache,\n      gitdir,\n      oid,\n    });\n    if (type !== 'commit') {\n      throw new ObjectTypeError(oid, type, 'commit')\n    }\n    const commit = GitCommit.from(object).parse();\n    // Are any of the parents the sought-after ancestor?\n    for (const parent of commit.parent) {\n      if (parent === ancestor) return true\n    }\n    // If not, add them to heads (unless we know this is a shallow commit)\n    if (!shallows.has(oid)) {\n      for (const parent of commit.parent) {\n        if (!visited.has(parent)) {\n          queue.push(parent);\n          visited.add(parent);\n        }\n      }\n    }\n    // Eventually, we'll travel entire tree to the roots where all the parents are empty arrays,\n    // or hit the shallow depth and throw an error. Excluding the possibility of grafts, or\n    // different branches cloned to different depths, you would hit this error at the same time\n    // for all parents, so trying to continue is futile.\n  }\n  return false\n}\n\n// @ts-check\n\n/**\n * Check whether a git commit is descended from another\n *\n * @param {object} args\n * @param {FsClient} args.fs - a file system client\n * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path\n * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path\n * @param {string} args.oid - The descendent commit\n * @param {string} args.ancestor - The (proposed) ancestor commit\n * @param {number} [args.depth = -1] - Maximum depth to search before giving up. -1 means no maximum depth.\n * @param {object} [args.cache] - a [cache](cache.md) object\n *\n * @returns {Promise<boolean>} Resolves to true if `oid` is a descendent of `ancestor`\n *\n * @example\n * let oid = await git.resolveRef({ fs, dir: '/tutorial', ref: 'main' })\n * let ancestor = await git.resolveRef({ fs, dir: '/tutorial', ref: 'v0.20.0' })\n * console.log(oid, ancestor)\n * await git.isDescendent({ fs, dir: '/tutorial', oid, ancestor, depth: -1 })\n *\n */\nasync function isDescendent({\n  fs,\n  dir,\n  gitdir = join(dir, '.git'),\n  oid,\n  ancestor,\n  depth = -1,\n  cache = {},\n}) {\n  try {\n    assertParameter('fs', fs);\n    assertParameter('gitdir', gitdir);\n    assertParameter('oid', oid);\n    assertParameter('ancestor', ancestor);\n\n    const fsp = new FileSystem(fs);\n    const updatedGitdir = await discoverGitdir({ fsp, dotgit: gitdir });\n    return await _isDescendent({\n      fs: fsp,\n      cache,\n      gitdir: updatedGitdir,\n      oid,\n      ancestor,\n      depth,\n    })\n  } catch (err) {\n    err.caller = 'git.isDescendent';\n    throw err\n  }\n}\n\n// @ts-check\n\n/**\n * Test whether a filepath should be ignored (because of .gitignore or .git/exclude)\n *\n * @param {object} args\n * @param {FsClient} args.fs - a file system client\n * @param {string} args.dir - The [working tree](dir-vs-gitdir.md) directory path\n * @param {string} [args.gitdir=join(dir, '.git')] - [required] The [git directory](dir-vs-gitdir.md) path\n * @param {string} args.filepath - The filepath to test\n *\n * @returns {Promise<boolean>} Resolves to true if the file should be ignored\n *\n * @example\n * await git.isIgnored({ fs, dir: '/tutorial', filepath: 'docs/add.md' })\n *\n */\nasync function isIgnored({\n  fs,\n  dir,\n  gitdir = join(dir, '.git'),\n  filepath,\n}) {\n  try {\n    assertParameter('fs', fs);\n    assertParameter('dir', dir);\n    assertParameter('gitdir', gitdir);\n    assertParameter('filepath', filepath);\n\n    const fsp = new FileSystem(fs);\n    const updatedGitdir = await discoverGitdir({ fsp, dotgit: gitdir });\n    return GitIgnoreManager.isIgnored({\n      fs: fsp,\n      dir,\n      gitdir: updatedGitdir,\n      filepath,\n    })\n  } catch (err) {\n    err.caller = 'git.isIgnored';\n    throw err\n  }\n}\n\n// @ts-check\n\n/**\n * List branches\n *\n * By default it lists local branches. If a 'remote' is specified, it lists the remote's branches. When listing remote branches, the HEAD branch is not filtered out, so it may be included in the list of results.\n *\n * Note that specifying a remote does not actually contact the server and update the list of branches.\n * If you want an up-to-date list, first do a `fetch` to that remote.\n * (Which branch you fetch doesn't matter - the list of branches available on the remote is updated during the fetch handshake.)\n *\n * Also note, that a branch is a reference to a commit. If you initialize a new repository it has no commits, so the\n * `listBranches` function will return an empty list, until you create the first commit.\n *\n * @param {object} args\n * @param {FsClient} args.fs - a file system client\n * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path\n * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path\n * @param {string} [args.remote] - Instead of the branches in `refs/heads`, list the branches in `refs/remotes/${remote}`.\n *\n * @returns {Promise<Array<string>>} Resolves successfully with an array of branch names\n *\n * @example\n * let branches = await git.listBranches({ fs, dir: '/tutorial' })\n * console.log(branches)\n * let remoteBranches = await git.listBranches({ fs, dir: '/tutorial', remote: 'origin' })\n * console.log(remoteBranches)\n *\n */\nasync function listBranches({\n  fs,\n  dir,\n  gitdir = join(dir, '.git'),\n  remote,\n}) {\n  try {\n    assertParameter('fs', fs);\n    assertParameter('gitdir', gitdir);\n\n    const fsp = new FileSystem(fs);\n    const updatedGitdir = await discoverGitdir({ fsp, dotgit: gitdir });\n    return GitRefManager.listBranches({\n      fs: fsp,\n      gitdir: updatedGitdir,\n      remote,\n    })\n  } catch (err) {\n    err.caller = 'git.listBranches';\n    throw err\n  }\n}\n\n// @ts-check\n\n/**\n * @param {object} args\n * @param {import('../models/FileSystem.js').FileSystem} args.fs\n * @param {object} args.cache\n * @param {string} args.gitdir\n * @param {string} [args.ref]\n *\n * @returns {Promise<Array<string>>}\n */\nasync function _listFiles({ fs, gitdir, ref, cache }) {\n  if (ref) {\n    const oid = await GitRefManager.resolve({ gitdir, fs, ref });\n    const filenames = [];\n    await accumulateFilesFromOid({\n      fs,\n      cache,\n      gitdir,\n      oid,\n      filenames,\n      prefix: '',\n    });\n    return filenames\n  } else {\n    return GitIndexManager.acquire(\n      { fs, gitdir, cache },\n      async function (index) {\n        return index.entries.map(x => x.path)\n      }\n    )\n  }\n}\n\nasync function accumulateFilesFromOid({\n  fs,\n  cache,\n  gitdir,\n  oid,\n  filenames,\n  prefix,\n}) {\n  const { tree } = await _readTree({ fs, cache, gitdir, oid });\n  // TODO: Use `walk` to do this. Should be faster.\n  for (const entry of tree) {\n    if (entry.type === 'tree') {\n      await accumulateFilesFromOid({\n        fs,\n        cache,\n        gitdir,\n        oid: entry.oid,\n        filenames,\n        prefix: join(prefix, entry.path),\n      });\n    } else {\n      filenames.push(join(prefix, entry.path));\n    }\n  }\n}\n\n// @ts-check\n\n/**\n * List all the files in the git index or a commit\n *\n * > Note: This function is efficient for listing the files in the staging area, but listing all the files in a commit requires recursively walking through the git object store.\n * > If you do not require a complete list of every file, better performance can be achieved by using [walk](./walk) and ignoring subdirectories you don't care about.\n *\n * @param {object} args\n * @param {FsClient} args.fs - a file system client\n * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path\n * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path\n * @param {string} [args.ref] - Return a list of all the files in the commit at `ref` instead of the files currently in the git index (aka staging area)\n * @param {object} [args.cache] - a [cache](cache.md) object\n *\n * @returns {Promise<Array<string>>} Resolves successfully with an array of filepaths\n *\n * @example\n * // All the files in the previous commit\n * let files = await git.listFiles({ fs, dir: '/tutorial', ref: 'HEAD' })\n * console.log(files)\n * // All the files in the current staging area\n * files = await git.listFiles({ fs, dir: '/tutorial' })\n * console.log(files)\n *\n */\nasync function listFiles({\n  fs,\n  dir,\n  gitdir = join(dir, '.git'),\n  ref,\n  cache = {},\n}) {\n  try {\n    assertParameter('fs', fs);\n    assertParameter('gitdir', gitdir);\n\n    const fsp = new FileSystem(fs);\n    const updatedGitdir = await discoverGitdir({ fsp, dotgit: gitdir });\n    return await _listFiles({\n      fs: fsp,\n      cache,\n      gitdir: updatedGitdir,\n      ref,\n    })\n  } catch (err) {\n    err.caller = 'git.listFiles';\n    throw err\n  }\n}\n\n// @ts-check\n\n/**\n * List all the object notes\n *\n * @param {object} args\n * @param {import('../models/FileSystem.js').FileSystem} args.fs\n * @param {any} args.cache\n * @param {string} args.gitdir\n * @param {string} args.ref\n *\n * @returns {Promise<Array<{target: string, note: string}>>}\n */\n\nasync function _listNotes({ fs, cache, gitdir, ref }) {\n  // Get the current note commit\n  let parent;\n  try {\n    parent = await GitRefManager.resolve({ gitdir, fs, ref });\n  } catch (err) {\n    if (err instanceof NotFoundError) {\n      return []\n    }\n  }\n\n  // Create the current note tree\n  const result = await _readTree({\n    fs,\n    cache,\n    gitdir,\n    oid: parent,\n  });\n\n  // Format the tree entries\n  const notes = result.tree.map(entry => ({\n    target: entry.path,\n    note: entry.oid,\n  }));\n  return notes\n}\n\n// @ts-check\n\n/**\n * List all the object notes\n *\n * @param {object} args\n * @param {FsClient} args.fs - a file system client\n * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path\n * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path\n * @param {string} [args.ref] - The notes ref to look under\n * @param {object} [args.cache] - a [cache](cache.md) object\n *\n * @returns {Promise<Array<{target: string, note: string}>>} Resolves successfully with an array of entries containing SHA-1 object ids of the note and the object the note targets\n */\n\nasync function listNotes({\n  fs,\n  dir,\n  gitdir = join(dir, '.git'),\n  ref = 'refs/notes/commits',\n  cache = {},\n}) {\n  try {\n    assertParameter('fs', fs);\n    assertParameter('gitdir', gitdir);\n    assertParameter('ref', ref);\n\n    const fsp = new FileSystem(fs);\n    const updatedGitdir = await discoverGitdir({ fsp, dotgit: gitdir });\n    return await _listNotes({\n      fs: fsp,\n      cache,\n      gitdir: updatedGitdir,\n      ref,\n    })\n  } catch (err) {\n    err.caller = 'git.listNotes';\n    throw err\n  }\n}\n\n// @ts-check\n\n/**\n * List refs\n *\n * @param {object} args\n * @param {FsClient} args.fs - a file system client\n * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path\n * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path\n * @param {string} [args.filepath] - [required] The refs path to list\n *\n * @returns {Promise<Array<string>>} Resolves successfully with an array of ref names below the supplied `filepath`\n *\n * @example\n * let refs = await git.listRefs({ fs, dir: '/tutorial', filepath: 'refs/heads' })\n * console.log(refs)\n *\n */\nasync function listRefs({\n  fs,\n  dir,\n  gitdir = join(dir, '.git'),\n  filepath,\n}) {\n  try {\n    assertParameter('fs', fs);\n    assertParameter('gitdir', gitdir);\n    const fsp = new FileSystem(fs);\n    const updatedGitdir = await discoverGitdir({ fsp, dotgit: gitdir });\n    return GitRefManager.listRefs({ fs: fsp, gitdir: updatedGitdir, filepath })\n  } catch (err) {\n    err.caller = 'git.listRefs';\n    throw err\n  }\n}\n\n// @ts-check\n\n/**\n * @param {object} args\n * @param {import('../models/FileSystem.js').FileSystem} args.fs\n * @param {string} args.gitdir\n *\n * @returns {Promise<Array<{remote: string, url: string}>>}\n */\nasync function _listRemotes({ fs, gitdir }) {\n  const config = await GitConfigManager.get({ fs, gitdir });\n  const remoteNames = await config.getSubsections('remote');\n  const remotes = Promise.all(\n    remoteNames.map(async remote => {\n      const url = await config.get(`remote.${remote}.url`);\n      return { remote, url }\n    })\n  );\n  return remotes\n}\n\n// @ts-check\n\n/**\n * List remotes\n *\n * @param {object} args\n * @param {FsClient} args.fs - a file system client\n * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path\n * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path\n *\n * @returns {Promise<Array<{remote: string, url: string}>>} Resolves successfully with an array of `{remote, url}` objects\n *\n * @example\n * let remotes = await git.listRemotes({ fs, dir: '/tutorial' })\n * console.log(remotes)\n *\n */\nasync function listRemotes({ fs, dir, gitdir = join(dir, '.git') }) {\n  try {\n    assertParameter('fs', fs);\n    assertParameter('gitdir', gitdir);\n\n    const fsp = new FileSystem(fs);\n    const updatedGitdir = await discoverGitdir({ fsp, dotgit: gitdir });\n    return await _listRemotes({\n      fs: fsp,\n      gitdir: updatedGitdir,\n    })\n  } catch (err) {\n    err.caller = 'git.listRemotes';\n    throw err\n  }\n}\n\n/**\n * @typedef {Object} ServerRef - This object has the following schema:\n * @property {string} ref - The name of the ref\n * @property {string} oid - The SHA-1 object id the ref points to\n * @property {string} [target] - The target ref pointed to by a symbolic ref\n * @property {string} [peeled] - If the oid is the SHA-1 object id of an annotated tag, this is the SHA-1 object id that the annotated tag points to\n */\n\nasync function parseListRefsResponse(stream) {\n  const read = GitPktLine.streamReader(stream);\n\n  // TODO: when we re-write everything to minimize memory usage,\n  // we could make this a generator\n  const refs = [];\n\n  let line;\n  while (true) {\n    line = await read();\n    if (line === true) break\n    if (line === null) continue\n    line = line.toString('utf8').replace(/\\n$/, '');\n    const [oid, ref, ...attrs] = line.split(' ');\n    const r = { ref, oid };\n    for (const attr of attrs) {\n      const [name, value] = attr.split(':');\n      if (name === 'symref-target') {\n        r.target = value;\n      } else if (name === 'peeled') {\n        r.peeled = value;\n      }\n    }\n    refs.push(r);\n  }\n\n  return refs\n}\n\n/**\n * @param {object} args\n * @param {string} [args.prefix] - Only list refs that start with this prefix\n * @param {boolean} [args.symrefs = false] - Include symbolic ref targets\n * @param {boolean} [args.peelTags = false] - Include peeled tags values\n * @returns {Uint8Array[]}\n */\nasync function writeListRefsRequest({ prefix, symrefs, peelTags }) {\n  const packstream = [];\n  // command\n  packstream.push(GitPktLine.encode('command=ls-refs\\n'));\n  // capability-list\n  packstream.push(GitPktLine.encode(`agent=${pkg.agent}\\n`));\n  // [command-args]\n  if (peelTags || symrefs || prefix) {\n    packstream.push(GitPktLine.delim());\n  }\n  if (peelTags) packstream.push(GitPktLine.encode('peel'));\n  if (symrefs) packstream.push(GitPktLine.encode('symrefs'));\n  if (prefix) packstream.push(GitPktLine.encode(`ref-prefix ${prefix}`));\n  packstream.push(GitPktLine.flush());\n  return packstream\n}\n\n// @ts-check\n\n/**\n * Fetch a list of refs (branches, tags, etc) from a server.\n *\n * This is a rare command that doesn't require an `fs`, `dir`, or even `gitdir` argument.\n * It just requires an `http` argument.\n *\n * ### About `protocolVersion`\n *\n * There's a rather fun trade-off between Git Protocol Version 1 and Git Protocol Version 2.\n * Version 2 actually requires 2 HTTP requests instead of 1, making it similar to fetch or push in that regard.\n * However, version 2 supports server-side filtering by prefix, whereas that filtering is done client-side in version 1.\n * Which protocol is most efficient therefore depends on the number of refs on the remote, the latency of the server, and speed of the network connection.\n * For an small repos (or fast Internet connections), the requirement to make two trips to the server makes protocol 2 slower.\n * But for large repos (or slow Internet connections), the decreased payload size of the second request makes up for the additional request.\n *\n * Hard numbers vary by situation, but here's some numbers from my machine:\n *\n * Using isomorphic-git in a browser, with a CORS proxy, listing only the branches (refs/heads) of https://github.com/isomorphic-git/isomorphic-git\n * - Protocol Version 1 took ~300ms and transferred 84 KB.\n * - Protocol Version 2 took ~500ms and transferred 4.1 KB.\n *\n * Using isomorphic-git in a browser, with a CORS proxy, listing only the branches (refs/heads) of https://gitlab.com/gitlab-org/gitlab\n * - Protocol Version 1 took ~4900ms and transferred 9.41 MB.\n * - Protocol Version 2 took ~1280ms and transferred 433 KB.\n *\n * Finally, there is a fun quirk regarding the `symrefs` parameter.\n * Protocol Version 1 will generally only return the `HEAD` symref and not others.\n * Historically, this meant that servers don't use symbolic refs except for `HEAD`, which is used to point at the \"default branch\".\n * However Protocol Version 2 can return *all* the symbolic refs on the server.\n * So if you are running your own git server, you could take advantage of that I guess.\n *\n * #### TL;DR\n * If you are _not_ taking advantage of `prefix` I would recommend `protocolVersion: 1`.\n * Otherwise, I recommend to use the default which is `protocolVersion: 2`.\n *\n * @param {object} args\n * @param {HttpClient} args.http - an HTTP client\n * @param {AuthCallback} [args.onAuth] - optional auth fill callback\n * @param {AuthFailureCallback} [args.onAuthFailure] - optional auth rejected callback\n * @param {AuthSuccessCallback} [args.onAuthSuccess] - optional auth approved callback\n * @param {string} args.url - The URL of the remote repository. Will be gotten from gitconfig if absent.\n * @param {string} [args.corsProxy] - Optional [CORS proxy](https://www.npmjs.com/%40isomorphic-git/cors-proxy). Overrides value in repo config.\n * @param {boolean} [args.forPush = false] - By default, the command queries the 'fetch' capabilities. If true, it will ask for the 'push' capabilities.\n * @param {Object<string, string>} [args.headers] - Additional headers to include in HTTP requests, similar to git's `extraHeader` config\n * @param {1 | 2} [args.protocolVersion = 2] - Which version of the Git Protocol to use.\n * @param {string} [args.prefix] - Only list refs that start with this prefix\n * @param {boolean} [args.symrefs = false] - Include symbolic ref targets\n * @param {boolean} [args.peelTags = false] - Include annotated tag peeled targets\n *\n * @returns {Promise<ServerRef[]>} Resolves successfully with an array of ServerRef objects\n * @see ServerRef\n *\n * @example\n * // List all the branches on a repo\n * let refs = await git.listServerRefs({\n *   http,\n *   corsProxy: \"https://cors.isomorphic-git.org\",\n *   url: \"https://github.com/isomorphic-git/isomorphic-git.git\",\n *   prefix: \"refs/heads/\",\n * });\n * console.log(refs);\n *\n * @example\n * // Get the default branch on a repo\n * let refs = await git.listServerRefs({\n *   http,\n *   corsProxy: \"https://cors.isomorphic-git.org\",\n *   url: \"https://github.com/isomorphic-git/isomorphic-git.git\",\n *   prefix: \"HEAD\",\n *   symrefs: true,\n * });\n * console.log(refs);\n *\n * @example\n * // List all the tags on a repo\n * let refs = await git.listServerRefs({\n *   http,\n *   corsProxy: \"https://cors.isomorphic-git.org\",\n *   url: \"https://github.com/isomorphic-git/isomorphic-git.git\",\n *   prefix: \"refs/tags/\",\n *   peelTags: true,\n * });\n * console.log(refs);\n *\n * @example\n * // List all the pull requests on a repo\n * let refs = await git.listServerRefs({\n *   http,\n *   corsProxy: \"https://cors.isomorphic-git.org\",\n *   url: \"https://github.com/isomorphic-git/isomorphic-git.git\",\n *   prefix: \"refs/pull/\",\n * });\n * console.log(refs);\n *\n */\nasync function listServerRefs({\n  http,\n  onAuth,\n  onAuthSuccess,\n  onAuthFailure,\n  corsProxy,\n  url,\n  headers = {},\n  forPush = false,\n  protocolVersion = 2,\n  prefix,\n  symrefs,\n  peelTags,\n}) {\n  try {\n    assertParameter('http', http);\n    assertParameter('url', url);\n\n    const remote = await GitRemoteHTTP.discover({\n      http,\n      onAuth,\n      onAuthSuccess,\n      onAuthFailure,\n      corsProxy,\n      service: forPush ? 'git-receive-pack' : 'git-upload-pack',\n      url,\n      headers,\n      protocolVersion,\n    });\n\n    if (remote.protocolVersion === 1) {\n      return formatInfoRefs(remote, prefix, symrefs, peelTags)\n    }\n\n    // Protocol Version 2\n    const body = await writeListRefsRequest({ prefix, symrefs, peelTags });\n\n    const res = await GitRemoteHTTP.connect({\n      http,\n      auth: remote.auth,\n      headers,\n      corsProxy,\n      service: forPush ? 'git-receive-pack' : 'git-upload-pack',\n      url,\n      body,\n    });\n\n    return parseListRefsResponse(res.body)\n  } catch (err) {\n    err.caller = 'git.listServerRefs';\n    throw err\n  }\n}\n\n// @ts-check\n\n/**\n * List tags\n *\n * @param {object} args\n * @param {FsClient} args.fs - a file system client\n * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path\n * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path\n *\n * @returns {Promise<Array<string>>} Resolves successfully with an array of tag names\n *\n * @example\n * let tags = await git.listTags({ fs, dir: '/tutorial' })\n * console.log(tags)\n *\n */\nasync function listTags({ fs, dir, gitdir = join(dir, '.git') }) {\n  try {\n    assertParameter('fs', fs);\n    assertParameter('gitdir', gitdir);\n    const fsp = new FileSystem(fs);\n    const updatedGitdir = await discoverGitdir({ fsp, dotgit: gitdir });\n    return GitRefManager.listTags({ fs: fsp, gitdir: updatedGitdir })\n  } catch (err) {\n    err.caller = 'git.listTags';\n    throw err\n  }\n}\n\nfunction compareAge(a, b) {\n  return a.committer.timestamp - b.committer.timestamp\n}\n\n// @ts-check\n\n// the empty file content object id\nconst EMPTY_OID = 'e69de29bb2d1d6434b8b29ae775ad8c2e48c5391';\n\nasync function resolveFileIdInTree({ fs, cache, gitdir, oid, fileId }) {\n  if (fileId === EMPTY_OID) return\n  const _oid = oid;\n  let filepath;\n  const result = await resolveTree({ fs, cache, gitdir, oid });\n  const tree = result.tree;\n  if (fileId === result.oid) {\n    filepath = result.path;\n  } else {\n    filepath = await _resolveFileId({\n      fs,\n      cache,\n      gitdir,\n      tree,\n      fileId,\n      oid: _oid,\n    });\n    if (Array.isArray(filepath)) {\n      if (filepath.length === 0) filepath = undefined;\n      else if (filepath.length === 1) filepath = filepath[0];\n    }\n  }\n  return filepath\n}\n\nasync function _resolveFileId({\n  fs,\n  cache,\n  gitdir,\n  tree,\n  fileId,\n  oid,\n  filepaths = [],\n  parentPath = '',\n}) {\n  const walks = tree.entries().map(function (entry) {\n    let result;\n    if (entry.oid === fileId) {\n      result = join(parentPath, entry.path);\n      filepaths.push(result);\n    } else if (entry.type === 'tree') {\n      result = _readObject({\n        fs,\n        cache,\n        gitdir,\n        oid: entry.oid,\n      }).then(function ({ object }) {\n        return _resolveFileId({\n          fs,\n          cache,\n          gitdir,\n          tree: GitTree.from(object),\n          fileId,\n          oid,\n          filepaths,\n          parentPath: join(parentPath, entry.path),\n        })\n      });\n    }\n    return result\n  });\n\n  await Promise.all(walks);\n  return filepaths\n}\n\n// @ts-check\n\n/**\n * Get commit descriptions from the git history\n *\n * @param {object} args\n * @param {import('../models/FileSystem.js').FileSystem} args.fs\n * @param {any} args.cache\n * @param {string} args.gitdir\n * @param {string=} args.filepath optional get the commit for the filepath only\n * @param {string} args.ref\n * @param {number|void} args.depth\n * @param {boolean=} [args.force=false] do not throw error if filepath is not exist (works only for a single file). defaults to false\n * @param {boolean=} [args.follow=false] Continue listing the history of a file beyond renames (works only for a single file). defaults to false\n * @param {boolean=} args.follow Continue listing the history of a file beyond renames (works only for a single file). defaults to false\n *\n * @returns {Promise<Array<ReadCommitResult>>} Resolves to an array of ReadCommitResult objects\n * @see ReadCommitResult\n * @see CommitObject\n *\n * @example\n * let commits = await git.log({ dir: '$input((/))', depth: $input((5)), ref: '$input((master))' })\n * console.log(commits)\n *\n */\nasync function _log({\n  fs,\n  cache,\n  gitdir,\n  filepath,\n  ref,\n  depth,\n  since,\n  force,\n  follow,\n}) {\n  const sinceTimestamp =\n    typeof since === 'undefined'\n      ? undefined\n      : Math.floor(since.valueOf() / 1000);\n  // TODO: In the future, we may want to have an API where we return a\n  // async iterator that emits commits.\n  const commits = [];\n  const shallowCommits = await GitShallowManager.read({ fs, gitdir });\n  const oid = await GitRefManager.resolve({ fs, gitdir, ref });\n  const tips = [await _readCommit({ fs, cache, gitdir, oid })];\n  let lastFileOid;\n  let lastCommit;\n  let isOk;\n\n  function endCommit(commit) {\n    if (isOk && filepath) commits.push(commit);\n  }\n\n  while (tips.length > 0) {\n    const commit = tips.pop();\n\n    // Stop the log if we've hit the age limit\n    if (\n      sinceTimestamp !== undefined &&\n      commit.commit.committer.timestamp <= sinceTimestamp\n    ) {\n      break\n    }\n\n    if (filepath) {\n      let vFileOid;\n      try {\n        vFileOid = await resolveFilepath({\n          fs,\n          cache,\n          gitdir,\n          oid: commit.commit.tree,\n          filepath,\n        });\n        if (lastCommit && lastFileOid !== vFileOid) {\n          commits.push(lastCommit);\n        }\n        lastFileOid = vFileOid;\n        lastCommit = commit;\n        isOk = true;\n      } catch (e) {\n        if (e instanceof NotFoundError) {\n          let found = follow && lastFileOid;\n          if (found) {\n            found = await resolveFileIdInTree({\n              fs,\n              cache,\n              gitdir,\n              oid: commit.commit.tree,\n              fileId: lastFileOid,\n            });\n            if (found) {\n              if (Array.isArray(found)) {\n                if (lastCommit) {\n                  const lastFound = await resolveFileIdInTree({\n                    fs,\n                    cache,\n                    gitdir,\n                    oid: lastCommit.commit.tree,\n                    fileId: lastFileOid,\n                  });\n                  if (Array.isArray(lastFound)) {\n                    found = found.filter(p => lastFound.indexOf(p) === -1);\n                    if (found.length === 1) {\n                      found = found[0];\n                      filepath = found;\n                      if (lastCommit) commits.push(lastCommit);\n                    } else {\n                      found = false;\n                      if (lastCommit) commits.push(lastCommit);\n                      break\n                    }\n                  }\n                }\n              } else {\n                filepath = found;\n                if (lastCommit) commits.push(lastCommit);\n              }\n            }\n          }\n          if (!found) {\n            if (isOk && lastFileOid) {\n              commits.push(lastCommit);\n              if (!force) break\n            }\n            if (!force && !follow) throw e\n          }\n          lastCommit = commit;\n          isOk = false;\n        } else throw e\n      }\n    } else {\n      commits.push(commit);\n    }\n\n    // Stop the loop if we have enough commits now.\n    if (depth !== undefined && commits.length === depth) {\n      endCommit(commit);\n      break\n    }\n\n    // If this is not a shallow commit...\n    if (!shallowCommits.has(commit.oid)) {\n      // Add the parents of this commit to the queue\n      // Note: for the case of a commit with no parents, it will concat an empty array, having no net effect.\n      for (const oid of commit.commit.parent) {\n        const commit = await _readCommit({ fs, cache, gitdir, oid });\n        if (!tips.map(commit => commit.oid).includes(commit.oid)) {\n          tips.push(commit);\n        }\n      }\n    }\n\n    // Stop the loop if there are no more commit parents\n    if (tips.length === 0) {\n      endCommit(commit);\n    }\n\n    // Process tips in order by age\n    tips.sort((a, b) => compareAge(a.commit, b.commit));\n  }\n  return commits\n}\n\n// @ts-check\n\n/**\n * Get commit descriptions from the git history\n *\n * @param {object} args\n * @param {FsClient} args.fs - a file system client\n * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path\n * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path\n * @param {string=} args.filepath optional get the commit for the filepath only\n * @param {string} [args.ref = 'HEAD'] - The commit to begin walking backwards through the history from\n * @param {number=} [args.depth] - Limit the number of commits returned. No limit by default.\n * @param {Date} [args.since] - Return history newer than the given date. Can be combined with `depth` to get whichever is shorter.\n * @param {boolean=} [args.force=false] do not throw error if filepath is not exist (works only for a single file). defaults to false\n * @param {boolean=} [args.follow=false] Continue listing the history of a file beyond renames (works only for a single file). defaults to false\n * @param {object} [args.cache] - a [cache](cache.md) object\n *\n * @returns {Promise<Array<ReadCommitResult>>} Resolves to an array of ReadCommitResult objects\n * @see ReadCommitResult\n * @see CommitObject\n *\n * @example\n * let commits = await git.log({\n *   fs,\n *   dir: '/tutorial',\n *   depth: 5,\n *   ref: 'main'\n * })\n * console.log(commits)\n *\n */\nasync function log({\n  fs,\n  dir,\n  gitdir = join(dir, '.git'),\n  filepath,\n  ref = 'HEAD',\n  depth,\n  since, // Date\n  force,\n  follow,\n  cache = {},\n}) {\n  try {\n    assertParameter('fs', fs);\n    assertParameter('gitdir', gitdir);\n    assertParameter('ref', ref);\n\n    const fsp = new FileSystem(fs);\n    const updatedGitdir = await discoverGitdir({ fsp, dotgit: gitdir });\n    return await _log({\n      fs: fsp,\n      cache,\n      gitdir: updatedGitdir,\n      filepath,\n      ref,\n      depth,\n      since,\n      force,\n      follow,\n    })\n  } catch (err) {\n    err.caller = 'git.log';\n    throw err\n  }\n}\n\n// @ts-check\n\n/**\n *\n * @typedef {Object} MergeResult - Returns an object with a schema like this:\n * @property {string} [oid] - The SHA-1 object id that is now at the head of the branch. Absent only if `dryRun` was specified and `mergeCommit` is true.\n * @property {boolean} [alreadyMerged] - True if the branch was already merged so no changes were made\n * @property {boolean} [fastForward] - True if it was a fast-forward merge\n * @property {boolean} [mergeCommit] - True if merge resulted in a merge commit\n * @property {string} [tree] - The SHA-1 object id of the tree resulting from a merge commit\n *\n */\n\n/**\n * Merge two branches\n *\n * Currently it will fail if multiple candidate merge bases are found. (It doesn't yet implement the recursive merge strategy.)\n *\n * Currently it does not support selecting alternative merge strategies.\n *\n * Currently it is not possible to abort an incomplete merge. To restore the worktree to a clean state, you will need to checkout an earlier commit.\n *\n * Currently it does not directly support the behavior of `git merge --continue`. To complete a merge after manual conflict resolution, you will need to add and commit the files manually, and specify the appropriate parent commits.\n *\n * ## Manually resolving merge conflicts\n * By default, if isomorphic-git encounters a merge conflict it cannot resolve using the builtin diff3 algorithm or provided merge driver, it will abort and throw a `MergeNotSupportedError`.\n * This leaves the index and working tree untouched.\n *\n * When `abortOnConflict` is set to `false`, and a merge conflict cannot be automatically resolved, a `MergeConflictError` is thrown and the results of the incomplete merge will be written to the working directory.\n * This includes conflict markers in files with unresolved merge conflicts.\n *\n * To complete the merge, edit the conflicting files as you see fit, and then add and commit the resolved merge.\n *\n * For a proper merge commit, be sure to specify the branches or commits you are merging in the `parent` argument to `git.commit`.\n * For example, say we are merging the branch `feature` into the branch `main` and there is a conflict we want to resolve manually.\n * The flow would look like this:\n *\n * ```\n * await git.merge({\n *   fs,\n *   dir,\n *   ours: 'main',\n *   theirs: 'feature',\n *   abortOnConflict: false,\n * }).catch(e => {\n *   if (e instanceof Errors.MergeConflictError) {\n *     console.log(\n *       'Automatic merge failed for the following files: '\n *       + `${e.data}. `\n *       + 'Resolve these conflicts and then commit your changes.'\n *     )\n *   } else throw e\n * })\n *\n * // This is the where we manually edit the files that have been written to the working directory\n * // ...\n * // Files have been edited and we are ready to commit\n *\n * await git.add({\n *   fs,\n *   dir,\n *   filepath: '.',\n * })\n *\n * await git.commit({\n *   fs,\n *   dir,\n *   ref: 'main',\n *   message: \"Merge branch 'feature' into main\",\n *   parent: ['main', 'feature'], // Be sure to specify the parents when creating a merge commit\n * })\n * ```\n *\n * @param {object} args\n * @param {FsClient} args.fs - a file system client\n * @param {SignCallback} [args.onSign] - a PGP signing implementation\n * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path\n * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path\n * @param {string} [args.ours] - The branch receiving the merge. If undefined, defaults to the current branch.\n * @param {string} args.theirs - The branch to be merged\n * @param {boolean} [args.fastForward = true] - If false, create a merge commit in all cases.\n * @param {boolean} [args.fastForwardOnly = false] - If true, then non-fast-forward merges will throw an Error instead of performing a merge.\n * @param {boolean} [args.dryRun = false] - If true, simulates a merge so you can test whether it would succeed.\n * @param {boolean} [args.noUpdateBranch = false] - If true, does not update the branch pointer after creating the commit.\n * @param {boolean} [args.abortOnConflict = true] - If true, merges with conflicts will not update the worktree or index.\n * @param {string} [args.message] - Overrides the default auto-generated merge commit message\n * @param {Object} [args.author] - passed to [commit](commit.md) when creating a merge commit\n * @param {string} [args.author.name] - Default is `user.name` config.\n * @param {string} [args.author.email] - Default is `user.email` config.\n * @param {number} [args.author.timestamp=Math.floor(Date.now()/1000)] - Set the author timestamp field. This is the integer number of seconds since the Unix epoch (1970-01-01 00:00:00).\n * @param {number} [args.author.timezoneOffset] - Set the author timezone offset field. This is the difference, in minutes, from the current timezone to UTC. Default is `(new Date()).getTimezoneOffset()`.\n * @param {Object} [args.committer] - passed to [commit](commit.md) when creating a merge commit\n * @param {string} [args.committer.name] - Default is `user.name` config.\n * @param {string} [args.committer.email] - Default is `user.email` config.\n * @param {number} [args.committer.timestamp=Math.floor(Date.now()/1000)] - Set the committer timestamp field. This is the integer number of seconds since the Unix epoch (1970-01-01 00:00:00).\n * @param {number} [args.committer.timezoneOffset] - Set the committer timezone offset field. This is the difference, in minutes, from the current timezone to UTC. Default is `(new Date()).getTimezoneOffset()`.\n * @param {string} [args.signingKey] - passed to [commit](commit.md) when creating a merge commit\n * @param {object} [args.cache] - a [cache](cache.md) object\n * @param {MergeDriverCallback} [args.mergeDriver] - a [merge driver](mergeDriver.md) implementation\n * @param {boolean} [args.allowUnrelatedHistories = false] - If true, allows merging histories of two branches that started their lives independently.\n *\n * @returns {Promise<MergeResult>} Resolves to a description of the merge operation\n * @see MergeResult\n *\n * @example\n * let m = await git.merge({\n *   fs,\n *   dir: '/tutorial',\n *   ours: 'main',\n *   theirs: 'remotes/origin/main'\n * })\n * console.log(m)\n *\n */\nasync function merge({\n  fs: _fs,\n  onSign,\n  dir,\n  gitdir = join(dir, '.git'),\n  ours,\n  theirs,\n  fastForward = true,\n  fastForwardOnly = false,\n  dryRun = false,\n  noUpdateBranch = false,\n  abortOnConflict = true,\n  message,\n  author: _author,\n  committer: _committer,\n  signingKey,\n  cache = {},\n  mergeDriver,\n  allowUnrelatedHistories = false,\n}) {\n  try {\n    assertParameter('fs', _fs);\n    if (signingKey) {\n      assertParameter('onSign', onSign);\n    }\n    const fs = new FileSystem(_fs);\n    const updatedGitdir = await discoverGitdir({ fsp: fs, dotgit: gitdir });\n\n    const author = await normalizeAuthorObject({\n      fs,\n      gitdir: updatedGitdir,\n      author: _author,\n    });\n    if (!author && (!fastForwardOnly || !fastForward)) {\n      throw new MissingNameError('author')\n    }\n\n    const committer = await normalizeCommitterObject({\n      fs,\n      gitdir: updatedGitdir,\n      author,\n      committer: _committer,\n    });\n    if (!committer && (!fastForwardOnly || !fastForward)) {\n      throw new MissingNameError('committer')\n    }\n\n    return await _merge({\n      fs,\n      cache,\n      dir,\n      gitdir: updatedGitdir,\n      ours,\n      theirs,\n      fastForward,\n      fastForwardOnly,\n      dryRun,\n      noUpdateBranch,\n      abortOnConflict,\n      message,\n      author,\n      committer,\n      signingKey,\n      onSign,\n      mergeDriver,\n      allowUnrelatedHistories,\n    })\n  } catch (err) {\n    err.caller = 'git.merge';\n    throw err\n  }\n}\n\n/**\n * @enum {number}\n */\nconst types = {\n  commit: 0b0010000,\n  tree: 0b0100000,\n  blob: 0b0110000,\n  tag: 0b1000000,\n  ofs_delta: 0b1100000,\n  ref_delta: 0b1110000,\n};\n\n/**\n * @param {object} args\n * @param {import('../models/FileSystem.js').FileSystem} args.fs\n * @param {any} args.cache\n * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path\n * @param {string} [args.gitdir=join(dir, '.git')] - [required] The [git directory](dir-vs-gitdir.md) path\n * @param {string[]} args.oids\n */\nasync function _pack({\n  fs,\n  cache,\n  dir,\n  gitdir = join(dir, '.git'),\n  oids,\n}) {\n  const hash = new Hash();\n  const outputStream = [];\n  function write(chunk, enc) {\n    const buff = Buffer.from(chunk, enc);\n    outputStream.push(buff);\n    hash.update(buff);\n  }\n  async function writeObject({ stype, object }) {\n    // Object type is encoded in bits 654\n    const type = types[stype];\n    // The length encoding gets complicated.\n    let length = object.length;\n    // Whether the next byte is part of the variable-length encoded number\n    // is encoded in bit 7\n    let multibyte = length > 0b1111 ? 0b10000000 : 0b0;\n    // Last four bits of length is encoded in bits 3210\n    const lastFour = length & 0b1111;\n    // Discard those bits\n    length = length >>> 4;\n    // The first byte is then (1-bit multibyte?), (3-bit type), (4-bit least sig 4-bits of length)\n    let byte = (multibyte | type | lastFour).toString(16);\n    write(byte, 'hex');\n    // Now we keep chopping away at length 7-bits at a time until its zero,\n    // writing out the bytes in what amounts to little-endian order.\n    while (multibyte) {\n      multibyte = length > 0b01111111 ? 0b10000000 : 0b0;\n      byte = multibyte | (length & 0b01111111);\n      write(padHex(2, byte), 'hex');\n      length = length >>> 7;\n    }\n    // Lastly, we can compress and write the object.\n    write(Buffer.from(await deflate(object)));\n  }\n  write('PACK');\n  write('00000002', 'hex');\n  // Write a 4 byte (32-bit) int\n  write(padHex(8, oids.length), 'hex');\n  for (const oid of oids) {\n    const { type, object } = await _readObject({ fs, cache, gitdir, oid });\n    await writeObject({ write, object, stype: type });\n  }\n  // Write SHA1 checksum\n  const digest = hash.digest();\n  outputStream.push(digest);\n  return outputStream\n}\n\n// @ts-check\n\n/**\n *\n * @typedef {Object} PackObjectsResult The packObjects command returns an object with two properties:\n * @property {string} filename - The suggested filename for the packfile if you want to save it to disk somewhere. It includes the packfile SHA.\n * @property {Uint8Array} [packfile] - The packfile contents. Not present if `write` parameter was true, in which case the packfile was written straight to disk.\n */\n\n/**\n * @param {object} args\n * @param {import('../models/FileSystem.js').FileSystem} args.fs\n * @param {any} args.cache\n * @param {string} args.gitdir\n * @param {string[]} args.oids\n * @param {boolean} args.write\n *\n * @returns {Promise<PackObjectsResult>}\n * @see PackObjectsResult\n */\nasync function _packObjects({ fs, cache, gitdir, oids, write }) {\n  const buffers = await _pack({ fs, cache, gitdir, oids });\n  const packfile = Buffer.from(await collect(buffers));\n  const packfileSha = packfile.slice(-20).toString('hex');\n  const filename = `pack-${packfileSha}.pack`;\n  if (write) {\n    await fs.write(join(gitdir, `objects/pack/${filename}`), packfile);\n    return { filename }\n  }\n  return {\n    filename,\n    packfile: new Uint8Array(packfile),\n  }\n}\n\n// @ts-check\n\n/**\n *\n * @typedef {Object} PackObjectsResult The packObjects command returns an object with two properties:\n * @property {string} filename - The suggested filename for the packfile if you want to save it to disk somewhere. It includes the packfile SHA.\n * @property {Uint8Array} [packfile] - The packfile contents. Not present if `write` parameter was true, in which case the packfile was written straight to disk.\n */\n\n/**\n * Create a packfile from an array of SHA-1 object ids\n *\n * @param {object} args\n * @param {FsClient} args.fs - a file system client\n * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path\n * @param {string} [args.gitdir=join(dir, '.git')] - [required] The [git directory](dir-vs-gitdir.md) path\n * @param {string[]} args.oids - An array of SHA-1 object ids to be included in the packfile\n * @param {boolean} [args.write = false] - Whether to save the packfile to disk or not\n * @param {object} [args.cache] - a [cache](cache.md) object\n *\n * @returns {Promise<PackObjectsResult>} Resolves successfully when the packfile is ready with the filename and buffer\n * @see PackObjectsResult\n *\n * @example\n * // Create a packfile containing only an empty tree\n * let { packfile } = await git.packObjects({\n *   fs,\n *   dir: '/tutorial',\n *   oids: ['4b825dc642cb6eb9a060e54bf8d69288fbee4904']\n * })\n * console.log(packfile)\n *\n */\nasync function packObjects({\n  fs,\n  dir,\n  gitdir = join(dir, '.git'),\n  oids,\n  write = false,\n  cache = {},\n}) {\n  try {\n    assertParameter('fs', fs);\n    assertParameter('gitdir', gitdir);\n    assertParameter('oids', oids);\n\n    const fsp = new FileSystem(fs);\n    const updatedGitdir = await discoverGitdir({ fsp, dotgit: gitdir });\n    return await _packObjects({\n      fs: fsp,\n      cache,\n      gitdir: updatedGitdir,\n      oids,\n      write,\n    })\n  } catch (err) {\n    err.caller = 'git.packObjects';\n    throw err\n  }\n}\n\n// @ts-check\n\n/**\n * Fetch and merge commits from a remote repository\n *\n * @param {object} args\n * @param {FsClient} args.fs - a file system client\n * @param {HttpClient} args.http - an HTTP client\n * @param {ProgressCallback} [args.onProgress] - optional progress event callback\n * @param {MessageCallback} [args.onMessage] - optional message event callback\n * @param {AuthCallback} [args.onAuth] - optional auth fill callback\n * @param {AuthFailureCallback} [args.onAuthFailure] - optional auth rejected callback\n * @param {AuthSuccessCallback} [args.onAuthSuccess] - optional auth approved callback\n * @param {string} args.dir] - The [working tree](dir-vs-gitdir.md) directory path\n * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path\n * @param {string} [args.ref] - Which branch to merge into. By default this is the currently checked out branch.\n * @param {string} [args.url] - (Added in 1.1.0) The URL of the remote repository. The default is the value set in the git config for that remote.\n * @param {string} [args.remote] - (Added in 1.1.0) If URL is not specified, determines which remote to use.\n * @param {string} [args.remoteRef] - (Added in 1.1.0) The name of the branch on the remote to fetch. By default this is the configured remote tracking branch.\n * @param {boolean} [args.prune = false] - Delete local remote-tracking branches that are not present on the remote\n * @param {boolean} [args.pruneTags = false] - Prune local tags that dont exist on the remote, and force-update those tags that differ\n * @param {string} [args.corsProxy] - Optional [CORS proxy](https://www.npmjs.com/%40isomorphic-git/cors-proxy). Overrides value in repo config.\n * @param {boolean} [args.singleBranch = false] - Instead of the default behavior of fetching all the branches, only fetch a single branch.\n * @param {boolean} [args.fastForward = true] -  If false, only create merge commits.\n * @param {boolean} [args.fastForwardOnly = false] - Only perform simple fast-forward merges. (Don't create merge commits.)\n * @param {Object<string, string>} [args.headers] - Additional headers to include in HTTP requests, similar to git's `extraHeader` config\n * @param {Object} [args.author] - The details about the author.\n * @param {string} [args.author.name] - Default is `user.name` config.\n * @param {string} [args.author.email] - Default is `user.email` config.\n * @param {number} [args.author.timestamp=Math.floor(Date.now()/1000)] - Set the author timestamp field. This is the integer number of seconds since the Unix epoch (1970-01-01 00:00:00).\n * @param {number} [args.author.timezoneOffset] - Set the author timezone offset field. This is the difference, in minutes, from the current timezone to UTC. Default is `(new Date()).getTimezoneOffset()`.\n * @param {Object} [args.committer = author] - The details about the commit committer, in the same format as the author parameter. If not specified, the author details are used.\n * @param {string} [args.committer.name] - Default is `user.name` config.\n * @param {string} [args.committer.email] - Default is `user.email` config.\n * @param {number} [args.committer.timestamp=Math.floor(Date.now()/1000)] - Set the committer timestamp field. This is the integer number of seconds since the Unix epoch (1970-01-01 00:00:00).\n * @param {number} [args.committer.timezoneOffset] - Set the committer timezone offset field. This is the difference, in minutes, from the current timezone to UTC. Default is `(new Date()).getTimezoneOffset()`.\n * @param {string} [args.signingKey] - passed to [commit](commit.md) when creating a merge commit\n * @param {object} [args.cache] - a [cache](cache.md) object\n *\n * @returns {Promise<void>} Resolves successfully when pull operation completes\n *\n * @example\n * await git.pull({\n *   fs,\n *   http,\n *   dir: '/tutorial',\n *   ref: 'main',\n *   singleBranch: true\n * })\n * console.log('done')\n *\n */\nasync function pull({\n  fs: _fs,\n  http,\n  onProgress,\n  onMessage,\n  onAuth,\n  onAuthSuccess,\n  onAuthFailure,\n  dir,\n  gitdir = join(dir, '.git'),\n  ref,\n  url,\n  remote,\n  remoteRef,\n  prune = false,\n  pruneTags = false,\n  fastForward = true,\n  fastForwardOnly = false,\n  corsProxy,\n  singleBranch,\n  headers = {},\n  author: _author,\n  committer: _committer,\n  signingKey,\n  cache = {},\n}) {\n  try {\n    assertParameter('fs', _fs);\n    assertParameter('gitdir', gitdir);\n\n    const fs = new FileSystem(_fs);\n    const updatedGitdir = await discoverGitdir({ fsp: fs, dotgit: gitdir });\n\n    const author = await normalizeAuthorObject({\n      fs,\n      gitdir: updatedGitdir,\n      author: _author,\n    });\n    if (!author) throw new MissingNameError('author')\n\n    const committer = await normalizeCommitterObject({\n      fs,\n      gitdir: updatedGitdir,\n      author,\n      committer: _committer,\n    });\n    if (!committer) throw new MissingNameError('committer')\n\n    return await _pull({\n      fs,\n      cache,\n      http,\n      onProgress,\n      onMessage,\n      onAuth,\n      onAuthSuccess,\n      onAuthFailure,\n      dir,\n      gitdir: updatedGitdir,\n      ref,\n      url,\n      remote,\n      remoteRef,\n      fastForward,\n      fastForwardOnly,\n      corsProxy,\n      singleBranch,\n      headers,\n      author,\n      committer,\n      signingKey,\n      prune,\n      pruneTags,\n    })\n  } catch (err) {\n    err.caller = 'git.pull';\n    throw err\n  }\n}\n\n/**\n * @param {object} args\n * @param {import('../models/FileSystem.js').FileSystem} args.fs\n * @param {any} args.cache\n * @param {string} [args.dir]\n * @param {string} args.gitdir\n * @param {Iterable<string>} args.start\n * @param {Iterable<string>} args.finish\n * @returns {Promise<Set<string>>}\n */\nasync function listCommitsAndTags({\n  fs,\n  cache,\n  dir,\n  gitdir = join(dir, '.git'),\n  start,\n  finish,\n}) {\n  const shallows = await GitShallowManager.read({ fs, gitdir });\n  const startingSet = new Set();\n  const finishingSet = new Set();\n  for (const ref of start) {\n    startingSet.add(await GitRefManager.resolve({ fs, gitdir, ref }));\n  }\n  for (const ref of finish) {\n    // We may not have these refs locally so we must try/catch\n    try {\n      const oid = await GitRefManager.resolve({ fs, gitdir, ref });\n      finishingSet.add(oid);\n    } catch (err) {}\n  }\n  const visited = new Set();\n  // Because git commits are named by their hash, there is no\n  // way to construct a cycle. Therefore we won't worry about\n  // setting a default recursion limit.\n  async function walk(oid) {\n    visited.add(oid);\n    const { type, object } = await _readObject({ fs, cache, gitdir, oid });\n    // Recursively resolve annotated tags\n    if (type === 'tag') {\n      const tag = GitAnnotatedTag.from(object);\n      const commit = tag.headers().object;\n      return walk(commit)\n    }\n    if (type !== 'commit') {\n      throw new ObjectTypeError(oid, type, 'commit')\n    }\n    if (!shallows.has(oid)) {\n      const commit = GitCommit.from(object);\n      const parents = commit.headers().parent;\n      for (oid of parents) {\n        if (!finishingSet.has(oid) && !visited.has(oid)) {\n          await walk(oid);\n        }\n      }\n    }\n  }\n  // Let's go walking!\n  for (const oid of startingSet) {\n    await walk(oid);\n  }\n  return visited\n}\n\n/**\n * @param {object} args\n * @param {import('../models/FileSystem.js').FileSystem} args.fs\n * @param {any} args.cache\n * @param {string} [args.dir]\n * @param {string} args.gitdir\n * @param {Iterable<string>} args.oids\n * @returns {Promise<Set<string>>}\n */\nasync function listObjects({\n  fs,\n  cache,\n  dir,\n  gitdir = join(dir, '.git'),\n  oids,\n}) {\n  const visited = new Set();\n  // We don't do the purest simplest recursion, because we can\n  // avoid reading Blob objects entirely since the Tree objects\n  // tell us which oids are Blobs and which are Trees.\n  async function walk(oid) {\n    if (visited.has(oid)) return\n    visited.add(oid);\n    const { type, object } = await _readObject({ fs, cache, gitdir, oid });\n    if (type === 'tag') {\n      const tag = GitAnnotatedTag.from(object);\n      const obj = tag.headers().object;\n      await walk(obj);\n    } else if (type === 'commit') {\n      const commit = GitCommit.from(object);\n      const tree = commit.headers().tree;\n      await walk(tree);\n    } else if (type === 'tree') {\n      const tree = GitTree.from(object);\n      for (const entry of tree) {\n        // add blobs to the set\n        // skip over submodules whose type is 'commit'\n        if (entry.type === 'blob') {\n          visited.add(entry.oid);\n        }\n        // recurse for trees\n        if (entry.type === 'tree') {\n          await walk(entry.oid);\n        }\n      }\n    }\n  }\n  // Let's go walking!\n  for (const oid of oids) {\n    await walk(oid);\n  }\n  return visited\n}\n\nasync function parseReceivePackResponse(packfile) {\n  /** @type PushResult */\n  const result = {};\n  let response = '';\n  const read = GitPktLine.streamReader(packfile);\n  let line = await read();\n  while (line !== true) {\n    if (line !== null) response += line.toString('utf8') + '\\n';\n    line = await read();\n  }\n\n  const lines = response.toString('utf8').split('\\n');\n  // We're expecting \"unpack {unpack-result}\"\n  line = lines.shift();\n  if (!line.startsWith('unpack ')) {\n    throw new ParseError('unpack ok\" or \"unpack [error message]', line)\n  }\n  result.ok = line === 'unpack ok';\n  if (!result.ok) {\n    result.error = line.slice('unpack '.length);\n  }\n  result.refs = {};\n  for (const line of lines) {\n    if (line.trim() === '') continue\n    const status = line.slice(0, 2);\n    const refAndMessage = line.slice(3);\n    let space = refAndMessage.indexOf(' ');\n    if (space === -1) space = refAndMessage.length;\n    const ref = refAndMessage.slice(0, space);\n    const error = refAndMessage.slice(space + 1);\n    result.refs[ref] = {\n      ok: status === 'ok',\n      error,\n    };\n  }\n  return result\n}\n\nasync function writeReceivePackRequest({\n  capabilities = [],\n  triplets = [],\n}) {\n  const packstream = [];\n  let capsFirstLine = `\\x00 ${capabilities.join(' ')}`;\n  for (const trip of triplets) {\n    packstream.push(\n      GitPktLine.encode(\n        `${trip.oldoid} ${trip.oid} ${trip.fullRef}${capsFirstLine}\\n`\n      )\n    );\n    capsFirstLine = '';\n  }\n  packstream.push(GitPktLine.flush());\n  return packstream\n}\n\n// @ts-check\n\n/**\n * @param {object} args\n * @param {import('../models/FileSystem.js').FileSystem} args.fs\n * @param {any} args.cache\n * @param {HttpClient} args.http\n * @param {ProgressCallback} [args.onProgress]\n * @param {MessageCallback} [args.onMessage]\n * @param {AuthCallback} [args.onAuth]\n * @param {AuthFailureCallback} [args.onAuthFailure]\n * @param {AuthSuccessCallback} [args.onAuthSuccess]\n * @param {PrePushCallback} [args.onPrePush]\n * @param {string} args.gitdir\n * @param {string} [args.ref]\n * @param {string} [args.remoteRef]\n * @param {string} [args.remote]\n * @param {boolean} [args.force = false]\n * @param {boolean} [args.delete = false]\n * @param {string} [args.url]\n * @param {string} [args.corsProxy]\n * @param {Object<string, string>} [args.headers]\n *\n * @returns {Promise<PushResult>}\n */\nasync function _push({\n  fs,\n  cache,\n  http,\n  onProgress,\n  onMessage,\n  onAuth,\n  onAuthSuccess,\n  onAuthFailure,\n  onPrePush,\n  gitdir,\n  ref: _ref,\n  remoteRef: _remoteRef,\n  remote,\n  url: _url,\n  force = false,\n  delete: _delete = false,\n  corsProxy,\n  headers = {},\n}) {\n  const ref = _ref || (await _currentBranch({ fs, gitdir }));\n  if (typeof ref === 'undefined') {\n    throw new MissingParameterError('ref')\n  }\n  const config = await GitConfigManager.get({ fs, gitdir });\n  // Figure out what remote to use.\n  remote =\n    remote ||\n    (await config.get(`branch.${ref}.pushRemote`)) ||\n    (await config.get('remote.pushDefault')) ||\n    (await config.get(`branch.${ref}.remote`)) ||\n    'origin';\n  // Lookup the URL for the given remote.\n  const url =\n    _url ||\n    (await config.get(`remote.${remote}.pushurl`)) ||\n    (await config.get(`remote.${remote}.url`));\n  if (typeof url === 'undefined') {\n    throw new MissingParameterError('remote OR url')\n  }\n  // Figure out what remote ref to use.\n  const remoteRef = _remoteRef || (await config.get(`branch.${ref}.merge`));\n  if (typeof url === 'undefined') {\n    throw new MissingParameterError('remoteRef')\n  }\n\n  if (corsProxy === undefined) {\n    corsProxy = await config.get('http.corsProxy');\n  }\n\n  const fullRef = await GitRefManager.expand({ fs, gitdir, ref });\n  const oid = _delete\n    ? '0000000000000000000000000000000000000000'\n    : await GitRefManager.resolve({ fs, gitdir, ref: fullRef });\n\n  /** @type typeof import(\"../managers/GitRemoteHTTP\").GitRemoteHTTP */\n  const GitRemoteHTTP = GitRemoteManager.getRemoteHelperFor({ url });\n  const httpRemote = await GitRemoteHTTP.discover({\n    http,\n    onAuth,\n    onAuthSuccess,\n    onAuthFailure,\n    corsProxy,\n    service: 'git-receive-pack',\n    url,\n    headers,\n    protocolVersion: 1,\n  });\n  const auth = httpRemote.auth; // hack to get new credentials from CredentialManager API\n  let fullRemoteRef;\n  if (!remoteRef) {\n    fullRemoteRef = fullRef;\n  } else {\n    try {\n      fullRemoteRef = await GitRefManager.expandAgainstMap({\n        ref: remoteRef,\n        map: httpRemote.refs,\n      });\n    } catch (err) {\n      if (err instanceof NotFoundError) {\n        // The remote reference doesn't exist yet.\n        // If it is fully specified, use that value. Otherwise, treat it as a branch.\n        fullRemoteRef = remoteRef.startsWith('refs/')\n          ? remoteRef\n          : `refs/heads/${remoteRef}`;\n      } else {\n        throw err\n      }\n    }\n  }\n  const oldoid =\n    httpRemote.refs.get(fullRemoteRef) ||\n    '0000000000000000000000000000000000000000';\n\n  if (onPrePush) {\n    const hookCancel = await onPrePush({\n      remote,\n      url,\n      localRef: { ref: _delete ? '(delete)' : fullRef, oid },\n      remoteRef: { ref: fullRemoteRef, oid: oldoid },\n    });\n    if (!hookCancel) throw new UserCanceledError()\n  }\n\n  // Remotes can always accept thin-packs UNLESS they specify the 'no-thin' capability\n  const thinPack = !httpRemote.capabilities.has('no-thin');\n\n  let objects = new Set();\n  if (!_delete) {\n    const finish = [...httpRemote.refs.values()];\n    let skipObjects = new Set();\n\n    // If remote branch is present, look for a common merge base.\n    if (oldoid !== '0000000000000000000000000000000000000000') {\n      // trick to speed up common force push scenarios\n      const mergebase = await _findMergeBase({\n        fs,\n        cache,\n        gitdir,\n        oids: [oid, oldoid],\n      });\n      for (const oid of mergebase) finish.push(oid);\n      if (thinPack) {\n        skipObjects = await listObjects({ fs, cache, gitdir, oids: mergebase });\n      }\n    }\n\n    // If remote does not have the commit, figure out the objects to send\n    if (!finish.includes(oid)) {\n      const commits = await listCommitsAndTags({\n        fs,\n        cache,\n        gitdir,\n        start: [oid],\n        finish,\n      });\n      objects = await listObjects({ fs, cache, gitdir, oids: commits });\n    }\n\n    if (thinPack) {\n      // If there's a default branch for the remote lets skip those objects too.\n      // Since this is an optional optimization, we just catch and continue if there is\n      // an error (because we can't find a default branch, or can't find a commit, etc)\n      try {\n        // Sadly, the discovery phase with 'forPush' doesn't return symrefs, so we have to\n        // rely on existing ones.\n        const ref = await GitRefManager.resolve({\n          fs,\n          gitdir,\n          ref: `refs/remotes/${remote}/HEAD`,\n          depth: 2,\n        });\n        const { oid } = await GitRefManager.resolveAgainstMap({\n          ref: ref.replace(`refs/remotes/${remote}/`, ''),\n          fullref: ref,\n          map: httpRemote.refs,\n        });\n        const oids = [oid];\n        for (const oid of await listObjects({ fs, cache, gitdir, oids })) {\n          skipObjects.add(oid);\n        }\n      } catch (e) {}\n\n      // Remove objects that we know the remote already has\n      for (const oid of skipObjects) {\n        objects.delete(oid);\n      }\n    }\n\n    if (oid === oldoid) force = true;\n    if (!force) {\n      // Is it a tag that already exists?\n      if (\n        fullRef.startsWith('refs/tags') &&\n        oldoid !== '0000000000000000000000000000000000000000'\n      ) {\n        throw new PushRejectedError('tag-exists')\n      }\n      // Is it a non-fast-forward commit?\n      if (\n        oid !== '0000000000000000000000000000000000000000' &&\n        oldoid !== '0000000000000000000000000000000000000000' &&\n        !(await _isDescendent({\n          fs,\n          cache,\n          gitdir,\n          oid,\n          ancestor: oldoid,\n          depth: -1,\n        }))\n      ) {\n        throw new PushRejectedError('not-fast-forward')\n      }\n    }\n  }\n  // We can only safely use capabilities that the server also understands.\n  // For instance, AWS CodeCommit aborts a push if you include the `agent`!!!\n  const capabilities = filterCapabilities(\n    [...httpRemote.capabilities],\n    ['report-status', 'side-band-64k', `agent=${pkg.agent}`]\n  );\n  const packstream1 = await writeReceivePackRequest({\n    capabilities,\n    triplets: [{ oldoid, oid, fullRef: fullRemoteRef }],\n  });\n  const packstream2 = _delete\n    ? []\n    : await _pack({\n        fs,\n        cache,\n        gitdir,\n        oids: [...objects],\n      });\n  const res = await GitRemoteHTTP.connect({\n    http,\n    onProgress,\n    corsProxy,\n    service: 'git-receive-pack',\n    url,\n    auth,\n    headers,\n    body: [...packstream1, ...packstream2],\n  });\n  const { packfile, progress } = await GitSideBand.demux(res.body);\n  if (onMessage) {\n    const lines = splitLines(progress);\n    forAwait(lines, async line => {\n      await onMessage(line);\n    });\n  }\n  // Parse the response!\n  const result = await parseReceivePackResponse(packfile);\n  if (res.headers) {\n    result.headers = res.headers;\n  }\n\n  // Update the local copy of the remote ref\n  if (\n    remote &&\n    result.ok &&\n    result.refs[fullRemoteRef].ok &&\n    !fullRef.startsWith('refs/tags')\n  ) {\n    // TODO: I think this should actually be using a refspec transform rather than assuming 'refs/remotes/{remote}'\n    const ref = `refs/remotes/${remote}/${fullRemoteRef.replace(\n      'refs/heads',\n      ''\n    )}`;\n    if (_delete) {\n      await GitRefManager.deleteRef({ fs, gitdir, ref });\n    } else {\n      await GitRefManager.writeRef({ fs, gitdir, ref, value: oid });\n    }\n  }\n  if (result.ok && Object.values(result.refs).every(result => result.ok)) {\n    return result\n  } else {\n    const prettyDetails = Object.entries(result.refs)\n      .filter(([k, v]) => !v.ok)\n      .map(([k, v]) => `\\n  - ${k}: ${v.error}`)\n      .join('');\n    throw new GitPushError(prettyDetails, result)\n  }\n}\n\n// @ts-check\n\n/**\n * Push a branch or tag\n *\n * The push command returns an object that describes the result of the attempted push operation.\n * *Notes:* If there were no errors, then there will be no `errors` property. There can be a mix of `ok` messages and `errors` messages.\n *\n * | param  | type [= default] | description                                                                                                                                                                                                      |\n * | ------ | ---------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n * | ok     | Array\\<string\\>  | The first item is \"unpack\" if the overall operation was successful. The remaining items are the names of refs that were updated successfully.                                                                    |\n * | errors | Array\\<string\\>  | If the overall operation threw and error, the first item will be \"unpack {Overall error message}\". The remaining items are individual refs that failed to be updated in the format \"{ref name} {error message}\". |\n *\n * @param {object} args\n * @param {FsClient} args.fs - a file system client\n * @param {HttpClient} args.http - an HTTP client\n * @param {ProgressCallback} [args.onProgress] - optional progress event callback\n * @param {MessageCallback} [args.onMessage] - optional message event callback\n * @param {AuthCallback} [args.onAuth] - optional auth fill callback\n * @param {AuthFailureCallback} [args.onAuthFailure] - optional auth rejected callback\n * @param {AuthSuccessCallback} [args.onAuthSuccess] - optional auth approved callback\n * @param {PrePushCallback} [args.onPrePush] - optional pre-push hook callback\n * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path\n * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path\n * @param {string} [args.ref] - Which branch or tag to push. By default this is the currently checked out branch.\n * @param {string} [args.url] - The URL of the remote repository. The default is the value set in the git config for that remote.\n * @param {string} [args.remote] - If URL is not specified, determines which remote to use.\n * @param {string} [args.remoteRef] - The name of the receiving branch on the remote. By default this is the configured remote tracking branch.\n * @param {boolean} [args.force = false] - If true, behaves the same as `git push --force`\n * @param {boolean} [args.delete = false] - If true, delete the remote ref\n * @param {string} [args.corsProxy] - Optional [CORS proxy](https://www.npmjs.com/%40isomorphic-git/cors-proxy). Overrides value in repo config.\n * @param {Object<string, string>} [args.headers] - Additional headers to include in HTTP requests, similar to git's `extraHeader` config\n * @param {object} [args.cache] - a [cache](cache.md) object\n *\n * @returns {Promise<PushResult>} Resolves successfully when push completes with a detailed description of the operation from the server.\n * @see PushResult\n * @see RefUpdateStatus\n *\n * @example\n * let pushResult = await git.push({\n *   fs,\n *   http,\n *   dir: '/tutorial',\n *   remote: 'origin',\n *   ref: 'main',\n *   onAuth: () => ({ username: process.env.GITHUB_TOKEN }),\n * })\n * console.log(pushResult)\n *\n */\nasync function push({\n  fs,\n  http,\n  onProgress,\n  onMessage,\n  onAuth,\n  onAuthSuccess,\n  onAuthFailure,\n  onPrePush,\n  dir,\n  gitdir = join(dir, '.git'),\n  ref,\n  remoteRef,\n  remote = 'origin',\n  url,\n  force = false,\n  delete: _delete = false,\n  corsProxy,\n  headers = {},\n  cache = {},\n}) {\n  try {\n    assertParameter('fs', fs);\n    assertParameter('http', http);\n    assertParameter('gitdir', gitdir);\n\n    const fsp = new FileSystem(fs);\n    const updatedGitdir = await discoverGitdir({ fsp, dotgit: gitdir });\n    return await _push({\n      fs: fsp,\n      cache,\n      http,\n      onProgress,\n      onMessage,\n      onAuth,\n      onAuthSuccess,\n      onAuthFailure,\n      onPrePush,\n      gitdir: updatedGitdir,\n      ref,\n      remoteRef,\n      remote,\n      url,\n      force,\n      delete: _delete,\n      corsProxy,\n      headers,\n    })\n  } catch (err) {\n    err.caller = 'git.push';\n    throw err\n  }\n}\n\nasync function resolveBlob({ fs, cache, gitdir, oid }) {\n  const { type, object } = await _readObject({ fs, cache, gitdir, oid });\n  // Resolve annotated tag objects to whatever\n  if (type === 'tag') {\n    oid = GitAnnotatedTag.from(object).parse().object;\n    return resolveBlob({ fs, cache, gitdir, oid })\n  }\n  if (type !== 'blob') {\n    throw new ObjectTypeError(oid, type, 'blob')\n  }\n  return { oid, blob: new Uint8Array(object) }\n}\n\n// @ts-check\n\n/**\n *\n * @typedef {Object} ReadBlobResult - The object returned has the following schema:\n * @property {string} oid\n * @property {Uint8Array} blob\n *\n */\n\n/**\n * @param {object} args\n * @param {import('../models/FileSystem.js').FileSystem} args.fs\n * @param {any} args.cache\n * @param {string} args.gitdir\n * @param {string} args.oid\n * @param {string} [args.filepath]\n *\n * @returns {Promise<ReadBlobResult>} Resolves successfully with a blob object description\n * @see ReadBlobResult\n */\nasync function _readBlob({\n  fs,\n  cache,\n  gitdir,\n  oid,\n  filepath = undefined,\n}) {\n  if (filepath !== undefined) {\n    oid = await resolveFilepath({ fs, cache, gitdir, oid, filepath });\n  }\n  const blob = await resolveBlob({\n    fs,\n    cache,\n    gitdir,\n    oid,\n  });\n  return blob\n}\n\n// @ts-check\n\n/**\n *\n * @typedef {Object} ReadBlobResult - The object returned has the following schema:\n * @property {string} oid\n * @property {Uint8Array} blob\n *\n */\n\n/**\n * Read a blob object directly\n *\n * @param {object} args\n * @param {FsClient} args.fs - a file system client\n * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path\n * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path\n * @param {string} args.oid - The SHA-1 object id to get. Annotated tags, commits, and trees are peeled.\n * @param {string} [args.filepath] - Don't return the object with `oid` itself, but resolve `oid` to a tree and then return the blob object at that filepath.\n * @param {object} [args.cache] - a [cache](cache.md) object\n *\n * @returns {Promise<ReadBlobResult>} Resolves successfully with a blob object description\n * @see ReadBlobResult\n *\n * @example\n * // Get the contents of 'README.md' in the main branch.\n * let commitOid = await git.resolveRef({ fs, dir: '/tutorial', ref: 'main' })\n * console.log(commitOid)\n * let { blob } = await git.readBlob({\n *   fs,\n *   dir: '/tutorial',\n *   oid: commitOid,\n *   filepath: 'README.md'\n * })\n * console.log(Buffer.from(blob).toString('utf8'))\n *\n */\nasync function readBlob({\n  fs,\n  dir,\n  gitdir = join(dir, '.git'),\n  oid,\n  filepath,\n  cache = {},\n}) {\n  try {\n    assertParameter('fs', fs);\n    assertParameter('gitdir', gitdir);\n    assertParameter('oid', oid);\n\n    const fsp = new FileSystem(fs);\n    const updatedGitdir = await discoverGitdir({ fsp, dotgit: gitdir });\n    return await _readBlob({\n      fs: fsp,\n      cache,\n      gitdir: updatedGitdir,\n      oid,\n      filepath,\n    })\n  } catch (err) {\n    err.caller = 'git.readBlob';\n    throw err\n  }\n}\n\n// @ts-check\n\n/**\n * Read a commit object directly\n *\n * @param {object} args\n * @param {FsClient} args.fs - a file system client\n * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path\n * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path\n * @param {string} args.oid - The SHA-1 object id to get. Annotated tags are peeled.\n * @param {object} [args.cache] - a [cache](cache.md) object\n *\n * @returns {Promise<ReadCommitResult>} Resolves successfully with a git commit object\n * @see ReadCommitResult\n * @see CommitObject\n *\n * @example\n * // Read a commit object\n * let sha = await git.resolveRef({ fs, dir: '/tutorial', ref: 'main' })\n * console.log(sha)\n * let commit = await git.readCommit({ fs, dir: '/tutorial', oid: sha })\n * console.log(commit)\n *\n */\nasync function readCommit({\n  fs,\n  dir,\n  gitdir = join(dir, '.git'),\n  oid,\n  cache = {},\n}) {\n  try {\n    assertParameter('fs', fs);\n    assertParameter('gitdir', gitdir);\n    assertParameter('oid', oid);\n\n    const fsp = new FileSystem(fs);\n    const updatedGitdir = await discoverGitdir({ fsp, dotgit: gitdir });\n    return await _readCommit({\n      fs: fsp,\n      cache,\n      gitdir: updatedGitdir,\n      oid,\n    })\n  } catch (err) {\n    err.caller = 'git.readCommit';\n    throw err\n  }\n}\n\n// @ts-check\n\n/**\n * Read the contents of a note\n *\n * @param {object} args\n * @param {import('../models/FileSystem.js').FileSystem} args.fs\n * @param {any} args.cache\n * @param {string} args.gitdir\n * @param {string} [args.ref] - The notes ref to look under\n * @param {string} args.oid\n *\n * @returns {Promise<Uint8Array>} Resolves successfully with note contents as a Buffer.\n */\n\nasync function _readNote({\n  fs,\n  cache,\n  gitdir,\n  ref = 'refs/notes/commits',\n  oid,\n}) {\n  const parent = await GitRefManager.resolve({ gitdir, fs, ref });\n  const { blob } = await _readBlob({\n    fs,\n    cache,\n    gitdir,\n    oid: parent,\n    filepath: oid,\n  });\n\n  return blob\n}\n\n// @ts-check\n\n/**\n * Read the contents of a note\n *\n * @param {object} args\n * @param {FsClient} args.fs - a file system client\n * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path\n * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path\n * @param {string} [args.ref] - The notes ref to look under\n * @param {string} args.oid - The SHA-1 object id of the object to get the note for.\n * @param {object} [args.cache] - a [cache](cache.md) object\n *\n * @returns {Promise<Uint8Array>} Resolves successfully with note contents as a Buffer.\n */\n\nasync function readNote({\n  fs,\n  dir,\n  gitdir = join(dir, '.git'),\n  ref = 'refs/notes/commits',\n  oid,\n  cache = {},\n}) {\n  try {\n    assertParameter('fs', fs);\n    assertParameter('gitdir', gitdir);\n    assertParameter('ref', ref);\n    assertParameter('oid', oid);\n\n    const fsp = new FileSystem(fs);\n    const updatedGitdir = await discoverGitdir({ fsp, dotgit: gitdir });\n    return await _readNote({\n      fs: fsp,\n      cache,\n      gitdir: updatedGitdir,\n      ref,\n      oid,\n    })\n  } catch (err) {\n    err.caller = 'git.readNote';\n    throw err\n  }\n}\n\n// @ts-check\n\n/**\n *\n * @typedef {Object} DeflatedObject\n * @property {string} oid\n * @property {'deflated'} type\n * @property {'deflated'} format\n * @property {Uint8Array} object\n * @property {string} [source]\n *\n */\n\n/**\n *\n * @typedef {Object} WrappedObject\n * @property {string} oid\n * @property {'wrapped'} type\n * @property {'wrapped'} format\n * @property {Uint8Array} object\n * @property {string} [source]\n *\n */\n\n/**\n *\n * @typedef {Object} RawObject\n * @property {string} oid\n * @property {'blob'|'commit'|'tree'|'tag'} type\n * @property {'content'} format\n * @property {Uint8Array} object\n * @property {string} [source]\n *\n */\n\n/**\n *\n * @typedef {Object} ParsedBlobObject\n * @property {string} oid\n * @property {'blob'} type\n * @property {'parsed'} format\n * @property {string} object\n * @property {string} [source]\n *\n */\n\n/**\n *\n * @typedef {Object} ParsedCommitObject\n * @property {string} oid\n * @property {'commit'} type\n * @property {'parsed'} format\n * @property {CommitObject} object\n * @property {string} [source]\n *\n */\n\n/**\n *\n * @typedef {Object} ParsedTreeObject\n * @property {string} oid\n * @property {'tree'} type\n * @property {'parsed'} format\n * @property {TreeObject} object\n * @property {string} [source]\n *\n */\n\n/**\n *\n * @typedef {Object} ParsedTagObject\n * @property {string} oid\n * @property {'tag'} type\n * @property {'parsed'} format\n * @property {TagObject} object\n * @property {string} [source]\n *\n */\n\n/**\n *\n * @typedef {ParsedBlobObject | ParsedCommitObject | ParsedTreeObject | ParsedTagObject} ParsedObject\n */\n\n/**\n *\n * @typedef {DeflatedObject | WrappedObject | RawObject | ParsedObject } ReadObjectResult\n */\n\n/**\n * Read a git object directly by its SHA-1 object id\n *\n * Regarding `ReadObjectResult`:\n *\n * - `oid` will be the same as the `oid` argument unless the `filepath` argument is provided, in which case it will be the oid of the tree or blob being returned.\n * - `type` of deflated objects is `'deflated'`, and `type` of wrapped objects is `'wrapped'`\n * - `format` is usually, but not always, the format you requested. Packfiles do not store each object individually compressed so if you end up reading the object from a packfile it will be returned in format 'content' even if you requested 'deflated' or 'wrapped'.\n * - `object` will be an actual Object if format is 'parsed' and the object is a commit, tree, or annotated tag. Blobs are still formatted as Buffers unless an encoding is provided in which case they'll be strings. If format is anything other than 'parsed', object will be a Buffer.\n * - `source` is the name of the packfile or loose object file where the object was found.\n *\n * The `format` parameter can have the following values:\n *\n * | param      | description                                                                                                                                                                                               |\n * | ---------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n * | 'deflated' | Return the raw deflate-compressed buffer for an object if possible. Useful for efficiently shuffling around loose objects when you don't care about the contents and can save time by not inflating them. |\n * | 'wrapped'  | Return the inflated object buffer wrapped in the git object header if possible. This is the raw data used when calculating the SHA-1 object id of a git object.                                           |\n * | 'content'  | Return the object buffer without the git header.                                                                                                                                                          |\n * | 'parsed'   | Returns a parsed representation of the object.                                                                                                                                                            |\n *\n * The result will be in one of the following schemas:\n *\n * ## `'deflated'` format\n *\n * {@link DeflatedObject typedef}\n *\n * ## `'wrapped'` format\n *\n * {@link WrappedObject typedef}\n *\n * ## `'content'` format\n *\n * {@link RawObject typedef}\n *\n * ## `'parsed'` format\n *\n * ### parsed `'blob'` type\n *\n * {@link ParsedBlobObject typedef}\n *\n * ### parsed `'commit'` type\n *\n * {@link ParsedCommitObject typedef}\n * {@link CommitObject typedef}\n *\n * ### parsed `'tree'` type\n *\n * {@link ParsedTreeObject typedef}\n * {@link TreeObject typedef}\n * {@link TreeEntry typedef}\n *\n * ### parsed `'tag'` type\n *\n * {@link ParsedTagObject typedef}\n * {@link TagObject typedef}\n *\n * @deprecated\n * > This command is overly complicated.\n * >\n * > If you know the type of object you are reading, use [`readBlob`](./readBlob.md), [`readCommit`](./readCommit.md), [`readTag`](./readTag.md), or [`readTree`](./readTree.md).\n *\n * @param {object} args\n * @param {FsClient} args.fs - a file system client\n * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path\n * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path\n * @param {string} args.oid - The SHA-1 object id to get\n * @param {'deflated' | 'wrapped' | 'content' | 'parsed'} [args.format = 'parsed'] - What format to return the object in. The choices are described in more detail below.\n * @param {string} [args.filepath] - Don't return the object with `oid` itself, but resolve `oid` to a tree and then return the object at that filepath. To return the root directory of a tree set filepath to `''`\n * @param {string} [args.encoding] - A convenience argument that only affects blobs. Instead of returning `object` as a buffer, it returns a string parsed using the given encoding.\n * @param {object} [args.cache] - a [cache](cache.md) object\n *\n * @returns {Promise<ReadObjectResult>} Resolves successfully with a git object description\n * @see ReadObjectResult\n *\n * @example\n * // Given a ransom SHA-1 object id, figure out what it is\n * let { type, object } = await git.readObject({\n *   fs,\n *   dir: '/tutorial',\n *   oid: '0698a781a02264a6f37ba3ff41d78067eaf0f075'\n * })\n * switch (type) {\n *   case 'commit': {\n *     console.log(object)\n *     break\n *   }\n *   case 'tree': {\n *     console.log(object)\n *     break\n *   }\n *   case 'blob': {\n *     console.log(object)\n *     break\n *   }\n *   case 'tag': {\n *     console.log(object)\n *     break\n *   }\n * }\n *\n */\nasync function readObject({\n  fs: _fs,\n  dir,\n  gitdir = join(dir, '.git'),\n  oid,\n  format = 'parsed',\n  filepath = undefined,\n  encoding = undefined,\n  cache = {},\n}) {\n  try {\n    assertParameter('fs', _fs);\n    assertParameter('gitdir', gitdir);\n    assertParameter('oid', oid);\n\n    const fs = new FileSystem(_fs);\n    const updatedGitdir = await discoverGitdir({ fsp: fs, dotgit: gitdir });\n    if (filepath !== undefined) {\n      oid = await resolveFilepath({\n        fs,\n        cache,\n        gitdir: updatedGitdir,\n        oid,\n        filepath,\n      });\n    }\n    // GitObjectManager does not know how to parse content, so we tweak that parameter before passing it.\n    const _format = format === 'parsed' ? 'content' : format;\n    const result = await _readObject({\n      fs,\n      cache,\n      gitdir: updatedGitdir,\n      oid,\n      format: _format,\n    });\n    result.oid = oid;\n    if (format === 'parsed') {\n      result.format = 'parsed';\n      switch (result.type) {\n        case 'commit':\n          result.object = GitCommit.from(result.object).parse();\n          break\n        case 'tree':\n          result.object = GitTree.from(result.object).entries();\n          break\n        case 'blob':\n          // Here we consider returning a raw Buffer as the 'content' format\n          // and returning a string as the 'parsed' format\n          if (encoding) {\n            result.object = result.object.toString(encoding);\n          } else {\n            result.object = new Uint8Array(result.object);\n            result.format = 'content';\n          }\n          break\n        case 'tag':\n          result.object = GitAnnotatedTag.from(result.object).parse();\n          break\n        default:\n          throw new ObjectTypeError(\n            result.oid,\n            result.type,\n            'blob|commit|tag|tree'\n          )\n      }\n    } else if (result.format === 'deflated' || result.format === 'wrapped') {\n      result.type = result.format;\n    }\n    return result\n  } catch (err) {\n    err.caller = 'git.readObject';\n    throw err\n  }\n}\n\n// @ts-check\n\n/**\n *\n * @typedef {Object} ReadTagResult - The object returned has the following schema:\n * @property {string} oid - SHA-1 object id of this tag\n * @property {TagObject} tag - the parsed tag object\n * @property {string} payload - PGP signing payload\n */\n\n/**\n * @param {object} args\n * @param {import('../models/FileSystem.js').FileSystem} args.fs\n * @param {any} args.cache\n * @param {string} args.gitdir\n * @param {string} args.oid\n *\n * @returns {Promise<ReadTagResult>}\n */\nasync function _readTag({ fs, cache, gitdir, oid }) {\n  const { type, object } = await _readObject({\n    fs,\n    cache,\n    gitdir,\n    oid,\n    format: 'content',\n  });\n  if (type !== 'tag') {\n    throw new ObjectTypeError(oid, type, 'tag')\n  }\n  const tag = GitAnnotatedTag.from(object);\n  const result = {\n    oid,\n    tag: tag.parse(),\n    payload: tag.payload(),\n  };\n  // @ts-ignore\n  return result\n}\n\n/**\n *\n * @typedef {Object} ReadTagResult - The object returned has the following schema:\n * @property {string} oid - SHA-1 object id of this tag\n * @property {TagObject} tag - the parsed tag object\n * @property {string} payload - PGP signing payload\n */\n\n/**\n * Read an annotated tag object directly\n *\n * @param {object} args\n * @param {FsClient} args.fs - a file system client\n * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path\n * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path\n * @param {string} args.oid - The SHA-1 object id to get\n * @param {object} [args.cache] - a [cache](cache.md) object\n *\n * @returns {Promise<ReadTagResult>} Resolves successfully with a git object description\n * @see ReadTagResult\n * @see TagObject\n *\n */\nasync function readTag({\n  fs,\n  dir,\n  gitdir = join(dir, '.git'),\n  oid,\n  cache = {},\n}) {\n  try {\n    assertParameter('fs', fs);\n    assertParameter('gitdir', gitdir);\n    assertParameter('oid', oid);\n\n    const fsp = new FileSystem(fs);\n    const updatedGitdir = await discoverGitdir({ fsp, dotgit: gitdir });\n    return await _readTag({\n      fs: fsp,\n      cache,\n      gitdir: updatedGitdir,\n      oid,\n    })\n  } catch (err) {\n    err.caller = 'git.readTag';\n    throw err\n  }\n}\n\n// @ts-check\n\n/**\n *\n * @typedef {Object} ReadTreeResult - The object returned has the following schema:\n * @property {string} oid - SHA-1 object id of this tree\n * @property {TreeObject} tree - the parsed tree object\n */\n\n/**\n * Read a tree object directly\n *\n * @param {object} args\n * @param {FsClient} args.fs - a file system client\n * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path\n * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path\n * @param {string} args.oid - The SHA-1 object id to get. Annotated tags and commits are peeled.\n * @param {string} [args.filepath] - Don't return the object with `oid` itself, but resolve `oid` to a tree and then return the tree object at that filepath.\n * @param {object} [args.cache] - a [cache](cache.md) object\n *\n * @returns {Promise<ReadTreeResult>} Resolves successfully with a git tree object\n * @see ReadTreeResult\n * @see TreeObject\n * @see TreeEntry\n *\n */\nasync function readTree({\n  fs,\n  dir,\n  gitdir = join(dir, '.git'),\n  oid,\n  filepath = undefined,\n  cache = {},\n}) {\n  try {\n    assertParameter('fs', fs);\n    assertParameter('gitdir', gitdir);\n    assertParameter('oid', oid);\n\n    const fsp = new FileSystem(fs);\n    const updatedGitdir = await discoverGitdir({ fsp, dotgit: gitdir });\n    return await _readTree({\n      fs: fsp,\n      cache,\n      gitdir: updatedGitdir,\n      oid,\n      filepath,\n    })\n  } catch (err) {\n    err.caller = 'git.readTree';\n    throw err\n  }\n}\n\n// @ts-check\n\n/**\n * Remove a file from the git index (aka staging area)\n *\n * Note that this does NOT delete the file in the working directory.\n *\n * @param {object} args\n * @param {FsClient} args.fs - a file system client\n * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path\n * @param {string} [args.gitdir=join(dir, '.git')] - [required] The [git directory](dir-vs-gitdir.md) path\n * @param {string} args.filepath - The path to the file to remove from the index\n * @param {object} [args.cache] - a [cache](cache.md) object\n *\n * @returns {Promise<void>} Resolves successfully once the git index has been updated\n *\n * @example\n * await git.remove({ fs, dir: '/tutorial', filepath: 'README.md' })\n * console.log('done')\n *\n */\nasync function remove({\n  fs: _fs,\n  dir,\n  gitdir = join(dir, '.git'),\n  filepath,\n  cache = {},\n}) {\n  try {\n    assertParameter('fs', _fs);\n    assertParameter('gitdir', gitdir);\n    assertParameter('filepath', filepath);\n\n    const fsp = new FileSystem(_fs);\n    const updatedGitdir = await discoverGitdir({ fsp, dotgit: gitdir });\n    await GitIndexManager.acquire(\n      { fs: fsp, gitdir: updatedGitdir, cache },\n      async function (index) {\n        index.delete({ filepath });\n      }\n    );\n  } catch (err) {\n    err.caller = 'git.remove';\n    throw err\n  }\n}\n\n// @ts-check\n\n/**\n * @param {object} args\n * @param {import('../models/FileSystem.js').FileSystem} args.fs\n * @param {object} args.cache\n * @param {SignCallback} [args.onSign]\n * @param {string} [args.dir]\n * @param {string} [args.gitdir=join(dir,'.git')]\n * @param {string} [args.ref]\n * @param {string} args.oid\n * @param {Object} args.author\n * @param {string} args.author.name\n * @param {string} args.author.email\n * @param {number} args.author.timestamp\n * @param {number} args.author.timezoneOffset\n * @param {Object} args.committer\n * @param {string} args.committer.name\n * @param {string} args.committer.email\n * @param {number} args.committer.timestamp\n * @param {number} args.committer.timezoneOffset\n * @param {string} [args.signingKey]\n *\n * @returns {Promise<string>}\n */\n\nasync function _removeNote({\n  fs,\n  cache,\n  onSign,\n  gitdir,\n  ref = 'refs/notes/commits',\n  oid,\n  author,\n  committer,\n  signingKey,\n}) {\n  // Get the current note commit\n  let parent;\n  try {\n    parent = await GitRefManager.resolve({ gitdir, fs, ref });\n  } catch (err) {\n    if (!(err instanceof NotFoundError)) {\n      throw err\n    }\n  }\n\n  // I'm using the \"empty tree\" magic number here for brevity\n  const result = await _readTree({\n    fs,\n    cache,\n    gitdir,\n    oid: parent || '4b825dc642cb6eb9a060e54bf8d69288fbee4904',\n  });\n  let tree = result.tree;\n\n  // Remove the note blob entry from the tree\n  tree = tree.filter(entry => entry.path !== oid);\n\n  // Create the new note tree\n  const treeOid = await _writeTree({\n    fs,\n    gitdir,\n    tree,\n  });\n\n  // Create the new note commit\n  const commitOid = await _commit({\n    fs,\n    cache,\n    onSign,\n    gitdir,\n    ref,\n    tree: treeOid,\n    parent: parent && [parent],\n    message: `Note removed by 'isomorphic-git removeNote'\\n`,\n    author,\n    committer,\n    signingKey,\n  });\n\n  return commitOid\n}\n\n// @ts-check\n\n/**\n * Remove an object note\n *\n * @param {object} args\n * @param {FsClient} args.fs - a file system client\n * @param {SignCallback} [args.onSign] - a PGP signing implementation\n * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path\n * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path\n * @param {string} [args.ref] - The notes ref to look under\n * @param {string} args.oid - The SHA-1 object id of the object to remove the note from.\n * @param {Object} [args.author] - The details about the author.\n * @param {string} [args.author.name] - Default is `user.name` config.\n * @param {string} [args.author.email] - Default is `user.email` config.\n * @param {number} [args.author.timestamp=Math.floor(Date.now()/1000)] - Set the author timestamp field. This is the integer number of seconds since the Unix epoch (1970-01-01 00:00:00).\n * @param {number} [args.author.timezoneOffset] - Set the author timezone offset field. This is the difference, in minutes, from the current timezone to UTC. Default is `(new Date()).getTimezoneOffset()`.\n * @param {Object} [args.committer = author] - The details about the note committer, in the same format as the author parameter. If not specified, the author details are used.\n * @param {string} [args.committer.name] - Default is `user.name` config.\n * @param {string} [args.committer.email] - Default is `user.email` config.\n * @param {number} [args.committer.timestamp=Math.floor(Date.now()/1000)] - Set the committer timestamp field. This is the integer number of seconds since the Unix epoch (1970-01-01 00:00:00).\n * @param {number} [args.committer.timezoneOffset] - Set the committer timezone offset field. This is the difference, in minutes, from the current timezone to UTC. Default is `(new Date()).getTimezoneOffset()`.\n * @param {string} [args.signingKey] - Sign the tag object using this private PGP key.\n * @param {object} [args.cache] - a [cache](cache.md) object\n *\n * @returns {Promise<string>} Resolves successfully with the SHA-1 object id of the commit object for the note removal.\n */\n\nasync function removeNote({\n  fs: _fs,\n  onSign,\n  dir,\n  gitdir = join(dir, '.git'),\n  ref = 'refs/notes/commits',\n  oid,\n  author: _author,\n  committer: _committer,\n  signingKey,\n  cache = {},\n}) {\n  try {\n    assertParameter('fs', _fs);\n    assertParameter('gitdir', gitdir);\n    assertParameter('oid', oid);\n\n    const fs = new FileSystem(_fs);\n    const updatedGitdir = await discoverGitdir({ fsp: fs, dotgit: gitdir });\n\n    const author = await normalizeAuthorObject({\n      fs,\n      gitdir: updatedGitdir,\n      author: _author,\n    });\n    if (!author) throw new MissingNameError('author')\n\n    const committer = await normalizeCommitterObject({\n      fs,\n      gitdir: updatedGitdir,\n      author,\n      committer: _committer,\n    });\n    if (!committer) throw new MissingNameError('committer')\n\n    return await _removeNote({\n      fs,\n      cache,\n      onSign,\n      gitdir: updatedGitdir,\n      ref,\n      oid,\n      author,\n      committer,\n      signingKey,\n    })\n  } catch (err) {\n    err.caller = 'git.removeNote';\n    throw err\n  }\n}\n\n// @ts-check\n\n/**\n * Rename a branch\n *\n * @param {object} args\n * @param {import('../models/FileSystem.js').FileSystem} args.fs\n * @param {string} args.gitdir\n * @param {string} args.ref - The name of the new branch\n * @param {string} args.oldref - The name of the old branch\n * @param {boolean} [args.checkout = false]\n *\n * @returns {Promise<void>} Resolves successfully when filesystem operations are complete\n */\nasync function _renameBranch({\n  fs,\n  gitdir,\n  oldref,\n  ref,\n  checkout = false,\n}) {\n  if (!isValidRef(ref, true)) {\n    throw new InvalidRefNameError(ref, cleanGitRef.clean(ref))\n  }\n\n  if (!isValidRef(oldref, true)) {\n    throw new InvalidRefNameError(oldref, cleanGitRef.clean(oldref))\n  }\n\n  const fulloldref = `refs/heads/${oldref}`;\n  const fullnewref = `refs/heads/${ref}`;\n\n  const newexist = await GitRefManager.exists({ fs, gitdir, ref: fullnewref });\n\n  if (newexist) {\n    throw new AlreadyExistsError('branch', ref, false)\n  }\n\n  const value = await GitRefManager.resolve({\n    fs,\n    gitdir,\n    ref: fulloldref,\n    depth: 1,\n  });\n\n  await GitRefManager.writeRef({ fs, gitdir, ref: fullnewref, value });\n  await GitRefManager.deleteRef({ fs, gitdir, ref: fulloldref });\n\n  const fullCurrentBranchRef = await _currentBranch({\n    fs,\n    gitdir,\n    fullname: true,\n  });\n  const isCurrentBranch = fullCurrentBranchRef === fulloldref;\n\n  if (checkout || isCurrentBranch) {\n    // Update HEAD\n    await GitRefManager.writeSymbolicRef({\n      fs,\n      gitdir,\n      ref: 'HEAD',\n      value: fullnewref,\n    });\n  }\n}\n\n// @ts-check\n\n/**\n * Rename a branch\n *\n * @param {object} args\n * @param {FsClient} args.fs - a file system implementation\n * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path\n * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path\n * @param {string} args.ref - What to name the branch\n * @param {string} args.oldref - What the name of the branch was\n * @param {boolean} [args.checkout = false] - Update `HEAD` to point at the newly created branch\n *\n * @returns {Promise<void>} Resolves successfully when filesystem operations are complete\n *\n * @example\n * await git.renameBranch({ fs, dir: '/tutorial', ref: 'main', oldref: 'master' })\n * console.log('done')\n *\n */\nasync function renameBranch({\n  fs,\n  dir,\n  gitdir = join(dir, '.git'),\n  ref,\n  oldref,\n  checkout = false,\n}) {\n  try {\n    assertParameter('fs', fs);\n    assertParameter('gitdir', gitdir);\n    assertParameter('ref', ref);\n    assertParameter('oldref', oldref);\n    const fsp = new FileSystem(fs);\n    const updatedGitdir = await discoverGitdir({ fsp, dotgit: gitdir });\n    return await _renameBranch({\n      fs: fsp,\n      gitdir: updatedGitdir,\n      ref,\n      oldref,\n      checkout,\n    })\n  } catch (err) {\n    err.caller = 'git.renameBranch';\n    throw err\n  }\n}\n\nasync function hashObject$1({ gitdir, type, object }) {\n  return shasum(GitObject.wrap({ type, object }))\n}\n\n// @ts-check\n\n/**\n * Reset a file in the git index (aka staging area)\n *\n * Note that this does NOT modify the file in the working directory.\n *\n * @param {object} args\n * @param {FsClient} args.fs - a file system client\n * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path\n * @param {string} [args.gitdir=join(dir, '.git')] - [required] The [git directory](dir-vs-gitdir.md) path\n * @param {string} args.filepath - The path to the file to reset in the index\n * @param {string} [args.ref = 'HEAD'] - A ref to the commit to use\n * @param {object} [args.cache] - a [cache](cache.md) object\n *\n * @returns {Promise<void>} Resolves successfully once the git index has been updated\n *\n * @example\n * await git.resetIndex({ fs, dir: '/tutorial', filepath: 'README.md' })\n * console.log('done')\n *\n */\nasync function resetIndex({\n  fs: _fs,\n  dir,\n  gitdir = join(dir, '.git'),\n  filepath,\n  ref,\n  cache = {},\n}) {\n  try {\n    assertParameter('fs', _fs);\n    assertParameter('gitdir', gitdir);\n    assertParameter('filepath', filepath);\n\n    const fs = new FileSystem(_fs);\n    const updatedGitdir = await discoverGitdir({ fsp: fs, dotgit: gitdir });\n\n    let oid;\n    let workdirOid;\n\n    try {\n      // Resolve commit\n      oid = await GitRefManager.resolve({\n        fs,\n        gitdir: updatedGitdir,\n        ref: ref || 'HEAD',\n      });\n    } catch (e) {\n      if (ref) {\n        // Only throw the error if a ref is explicitly provided\n        throw e\n      }\n    }\n\n    // Not having an oid at this point means `resetIndex()` was called without explicit `ref` on a new git\n    // repository. If that happens, we can skip resolving the file path.\n    if (oid) {\n      try {\n        // Resolve blob\n        oid = await resolveFilepath({\n          fs,\n          cache,\n          gitdir: updatedGitdir,\n          oid,\n          filepath,\n        });\n      } catch (e) {\n        // This means we're resetting the file to a \"deleted\" state\n        oid = null;\n      }\n    }\n\n    // For files that aren't in the workdir use zeros\n    let stats = {\n      ctime: new Date(0),\n      mtime: new Date(0),\n      dev: 0,\n      ino: 0,\n      mode: 0,\n      uid: 0,\n      gid: 0,\n      size: 0,\n    };\n    // If the file exists in the workdir...\n    const object = dir && (await fs.read(join(dir, filepath)));\n    if (object) {\n      // ... and has the same hash as the desired state...\n      workdirOid = await hashObject$1({\n        gitdir: updatedGitdir,\n        type: 'blob',\n        object,\n      });\n      if (oid === workdirOid) {\n        // ... use the workdir Stats object\n        stats = await fs.lstat(join(dir, filepath));\n      }\n    }\n    await GitIndexManager.acquire(\n      { fs, gitdir: updatedGitdir, cache },\n      async function (index) {\n        index.delete({ filepath });\n        if (oid) {\n          index.insert({ filepath, stats, oid });\n        }\n      }\n    );\n  } catch (err) {\n    err.caller = 'git.reset';\n    throw err\n  }\n}\n\n// @ts-check\n\n/**\n * Get the value of a symbolic ref or resolve a ref to its SHA-1 object id\n *\n * @param {object} args\n * @param {FsClient} args.fs - a file system client\n * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path\n * @param {string} [args.gitdir=join(dir, '.git')] - [required] The [git directory](dir-vs-gitdir.md) path\n * @param {string} args.ref - The ref to resolve\n * @param {number} [args.depth = undefined] - How many symbolic references to follow before returning\n *\n * @returns {Promise<string>} Resolves successfully with a SHA-1 object id or the value of a symbolic ref\n *\n * @example\n * let currentCommit = await git.resolveRef({ fs, dir: '/tutorial', ref: 'HEAD' })\n * console.log(currentCommit)\n * let currentBranch = await git.resolveRef({ fs, dir: '/tutorial', ref: 'HEAD', depth: 2 })\n * console.log(currentBranch)\n *\n */\nasync function resolveRef({\n  fs,\n  dir,\n  gitdir = join(dir, '.git'),\n  ref,\n  depth,\n}) {\n  try {\n    assertParameter('fs', fs);\n    assertParameter('gitdir', gitdir);\n    assertParameter('ref', ref);\n    const fsp = new FileSystem(fs);\n    const updatedGitdir = await discoverGitdir({ fsp, dotgit: gitdir });\n\n    const oid = await GitRefManager.resolve({\n      fs: fsp,\n      gitdir: updatedGitdir,\n      ref,\n      depth,\n    });\n    return oid\n  } catch (err) {\n    err.caller = 'git.resolveRef';\n    throw err\n  }\n}\n\n// @ts-check\n\n/**\n * Write an entry to the git config files.\n *\n * *Caveats:*\n * - Currently only the local `$GIT_DIR/config` file can be read or written. However support for the global `~/.gitconfig` and system `$(prefix)/etc/gitconfig` will be added in the future.\n * - The current parser does not support the more exotic features of the git-config file format such as `[include]` and `[includeIf]`.\n *\n * @param {Object} args\n * @param {FsClient} args.fs - a file system implementation\n * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path\n * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path\n * @param {string} args.path - The key of the git config entry\n * @param {string | boolean | number | void} args.value - A value to store at that path. (Use `undefined` as the value to delete a config entry.)\n * @param {boolean} [args.append = false] - If true, will append rather than replace when setting (use with multi-valued config options).\n *\n * @returns {Promise<void>} Resolves successfully when operation completed\n *\n * @example\n * // Write config value\n * await git.setConfig({\n *   fs,\n *   dir: '/tutorial',\n *   path: 'user.name',\n *   value: 'Mr. Test'\n * })\n *\n * // Print out config file\n * let file = await fs.promises.readFile('/tutorial/.git/config', 'utf8')\n * console.log(file)\n *\n * // Delete a config entry\n * await git.setConfig({\n *   fs,\n *   dir: '/tutorial',\n *   path: 'user.name',\n *   value: undefined\n * })\n *\n * // Print out config file\n * file = await fs.promises.readFile('/tutorial/.git/config', 'utf8')\n * console.log(file)\n */\nasync function setConfig({\n  fs: _fs,\n  dir,\n  gitdir = join(dir, '.git'),\n  path,\n  value,\n  append = false,\n}) {\n  try {\n    assertParameter('fs', _fs);\n    assertParameter('gitdir', gitdir);\n    assertParameter('path', path);\n    // assertParameter('value', value) // We actually allow 'undefined' as a value to unset/delete\n\n    const fs = new FileSystem(_fs);\n    const updatedGitdir = await discoverGitdir({ fsp: fs, dotgit: gitdir });\n    const config = await GitConfigManager.get({ fs, gitdir: updatedGitdir });\n    if (append) {\n      await config.append(path, value);\n    } else {\n      await config.set(path, value);\n    }\n    await GitConfigManager.save({ fs, gitdir: updatedGitdir, config });\n  } catch (err) {\n    err.caller = 'git.setConfig';\n    throw err\n  }\n}\n\n// @ts-check\n\n/**\n * @param {object} args\n * @param {import('../models/FileSystem.js').FileSystem} args.fs\n * @param {string} args.gitdir\n * @param {CommitObject} args.commit\n *\n * @returns {Promise<string>}\n * @see CommitObject\n *\n */\nasync function _writeCommit({ fs, gitdir, commit }) {\n  // Convert object to buffer\n  const object = GitCommit.from(commit).toObject();\n  const oid = await _writeObject({\n    fs,\n    gitdir,\n    type: 'commit',\n    object,\n    format: 'content',\n  });\n  return oid\n}\n\nclass GitRefStash {\n  // constructor removed\n\n  static get timezoneOffsetForRefLogEntry() {\n    const offsetMinutes = new Date().getTimezoneOffset();\n    const offsetHours = Math.abs(Math.floor(offsetMinutes / 60));\n    const offsetMinutesFormatted = Math.abs(offsetMinutes % 60)\n      .toString()\n      .padStart(2, '0');\n    const sign = offsetMinutes > 0 ? '-' : '+';\n    return `${sign}${offsetHours\n      .toString()\n      .padStart(2, '0')}${offsetMinutesFormatted}`\n  }\n\n  static createStashReflogEntry(author, stashCommit, message) {\n    const nameNoSpace = author.name.replace(/\\s/g, '');\n    const z40 = '0000000000000000000000000000000000000000'; // hard code for now, works with `git stash list`\n    const timestamp = Math.floor(Date.now() / 1000);\n    const timezoneOffset = GitRefStash.timezoneOffsetForRefLogEntry;\n    return `${z40} ${stashCommit} ${nameNoSpace} ${author.email} ${timestamp} ${timezoneOffset}\\t${message}\\n`\n  }\n\n  static getStashReflogEntry(reflogString, parsed = false) {\n    const reflogLines = reflogString.split('\\n');\n    const entries = reflogLines\n      .filter(l => l)\n      .reverse()\n      .map((line, idx) =>\n        parsed ? `stash@{${idx}}: ${line.split('\\t')[1]}` : line\n      );\n    return entries\n  }\n}\n\nconst _TreeMap = {\n  stage: STAGE,\n  workdir: WORKDIR,\n};\n\nlet lock$3;\nasync function acquireLock$1(ref, callback) {\n  if (lock$3 === undefined) lock$3 = new AsyncLock();\n  return lock$3.acquire(ref, callback)\n}\n\n// make sure filepath, blob type and blob object (from loose objects) plus oid are in sync and valid\nasync function checkAndWriteBlob(fs, gitdir, dir, filepath, oid = null) {\n  const currentFilepath = join(dir, filepath);\n  const stats = await fs.lstat(currentFilepath);\n  if (!stats) throw new NotFoundError(currentFilepath)\n  if (stats.isDirectory())\n    throw new InternalError(\n      `${currentFilepath}: file expected, but found directory`\n    )\n\n  // Look for it in the loose object directory.\n  const objContent = oid\n    ? await readObjectLoose({ fs, gitdir, oid })\n    : undefined;\n  let retOid = objContent ? oid : undefined;\n  if (!objContent) {\n    await acquireLock$1({ fs, gitdir, currentFilepath }, async () => {\n      const object = stats.isSymbolicLink()\n        ? await fs.readlink(currentFilepath).then(posixifyPathBuffer)\n        : await fs.read(currentFilepath);\n\n      if (object === null) throw new NotFoundError(currentFilepath)\n\n      retOid = await _writeObject({ fs, gitdir, type: 'blob', object });\n    });\n  }\n\n  return retOid\n}\n\nasync function processTreeEntries({ fs, dir, gitdir, entries }) {\n  // make sure each tree entry has valid oid\n  async function processTreeEntry(entry) {\n    if (entry.type === 'tree') {\n      if (!entry.oid) {\n        // Process children entries if the current entry is a tree\n        const children = await Promise.all(entry.children.map(processTreeEntry));\n        // Write the tree with the processed children\n        entry.oid = await _writeTree({\n          fs,\n          gitdir,\n          tree: children,\n        });\n        entry.mode = 0o40000; // directory\n      }\n    } else if (entry.type === 'blob') {\n      entry.oid = await checkAndWriteBlob(\n        fs,\n        gitdir,\n        dir,\n        entry.path,\n        entry.oid\n      );\n      entry.mode = 0o100644; // file\n    }\n\n    // remove path from entry.path\n    entry.path = entry.path.split('/').pop();\n    return entry\n  }\n\n  return Promise.all(entries.map(processTreeEntry))\n}\n\nasync function writeTreeChanges({\n  fs,\n  dir,\n  gitdir,\n  treePair, // [TREE({ ref: 'HEAD' }), 'STAGE'] would be the equivalent of `git write-tree`\n}) {\n  const isStage = treePair[1] === 'stage';\n  const trees = treePair.map(t => (typeof t === 'string' ? _TreeMap[t]() : t));\n\n  const changedEntries = [];\n  // transform WalkerEntry objects into the desired format\n  const map = async (filepath, [head, stage]) => {\n    if (\n      filepath === '.' ||\n      (await GitIgnoreManager.isIgnored({ fs, dir, gitdir, filepath }))\n    ) {\n      return\n    }\n\n    if (stage) {\n      if (\n        !head ||\n        ((await head.oid()) !== (await stage.oid()) &&\n          (await stage.oid()) !== undefined)\n      ) {\n        changedEntries.push([head, stage]);\n      }\n      return {\n        mode: await stage.mode(),\n        path: filepath,\n        oid: await stage.oid(),\n        type: await stage.type(),\n      }\n    }\n  };\n\n  // combine mapped entries with their parent results\n  const reduce = async (parent, children) => {\n    children = children.filter(Boolean); // Remove undefined entries\n    if (!parent) {\n      return children.length > 0 ? children : undefined\n    } else {\n      parent.children = children;\n      return parent\n    }\n  };\n\n  // if parent is skipped, skip the children\n  const iterate = async (walk, children) => {\n    const filtered = [];\n    for (const child of children) {\n      const [head, stage] = child;\n      if (isStage) {\n        if (stage) {\n          // for deleted file in work dir, it also needs to be added on stage\n          if (await fs.exists(`${dir}/${stage.toString()}`)) {\n            filtered.push(child);\n          } else {\n            changedEntries.push([null, stage]); // record the change (deletion) while stop the iteration\n          }\n        }\n      } else if (head) {\n        // for deleted file in workdir, \"stage\" (workdir in our case) will be undefined\n        if (!stage) {\n          changedEntries.push([head, null]); // record the change (deletion) while stop the iteration\n        } else {\n          filtered.push(child); // workdir, tracked only\n        }\n      }\n    }\n    return filtered.length ? Promise.all(filtered.map(walk)) : []\n  };\n\n  const entries = await _walk({\n    fs,\n    cache: {},\n    dir,\n    gitdir,\n    trees,\n    map,\n    reduce,\n    iterate,\n  });\n\n  if (changedEntries.length === 0 || entries.length === 0) {\n    return null // no changes found to stash\n  }\n\n  const processedEntries = await processTreeEntries({\n    fs,\n    dir,\n    gitdir,\n    entries,\n  });\n\n  const treeEntries = processedEntries.filter(Boolean).map(entry => ({\n    mode: entry.mode,\n    path: entry.path,\n    oid: entry.oid,\n    type: entry.type,\n  }));\n\n  return _writeTree({ fs, gitdir, tree: treeEntries })\n}\n\nasync function applyTreeChanges({\n  fs,\n  dir,\n  gitdir,\n  stashCommit,\n  parentCommit,\n  wasStaged,\n}) {\n  const dirRemoved = [];\n  const stageUpdated = [];\n\n  // analyze the changes\n  const ops = await _walk({\n    fs,\n    cache: {},\n    dir,\n    gitdir,\n    trees: [TREE({ ref: parentCommit }), TREE({ ref: stashCommit })],\n    map: async (filepath, [parent, stash]) => {\n      if (\n        filepath === '.' ||\n        (await GitIgnoreManager.isIgnored({ fs, dir, gitdir, filepath }))\n      ) {\n        return\n      }\n      const type = stash ? await stash.type() : await parent.type();\n      if (type !== 'tree' && type !== 'blob') {\n        return\n      }\n\n      // deleted tree or blob\n      if (!stash && parent) {\n        const method = type === 'tree' ? 'rmdir' : 'rm';\n        if (type === 'tree') dirRemoved.push(filepath);\n        if (type === 'blob' && wasStaged)\n          stageUpdated.push({ filepath, oid: await parent.oid() }); // stats is undefined, will stage the deletion with index.insert\n        return { method, filepath }\n      }\n\n      const oid = await stash.oid();\n      if (!parent || (await parent.oid()) !== oid) {\n        // only apply changes if changed from the parent commit or doesn't exist in the parent commit\n        if (type === 'tree') {\n          return { method: 'mkdir', filepath }\n        } else {\n          if (wasStaged)\n            stageUpdated.push({\n              filepath,\n              oid,\n              stats: await fs.lstat(join(dir, filepath)),\n            });\n          return {\n            method: 'write',\n            filepath,\n            oid,\n          }\n        }\n      }\n    },\n  });\n\n  // apply the changes to work dir\n  await acquireLock$1({ fs, gitdir, dirRemoved, ops }, async () => {\n    for (const op of ops) {\n      const currentFilepath = join(dir, op.filepath);\n      switch (op.method) {\n        case 'rmdir':\n          await fs.rmdir(currentFilepath);\n          break\n        case 'mkdir':\n          await fs.mkdir(currentFilepath);\n          break\n        case 'rm':\n          await fs.rm(currentFilepath);\n          break\n        case 'write':\n          // only writes if file is not in the removedDirs\n          if (\n            !dirRemoved.some(removedDir =>\n              currentFilepath.startsWith(removedDir)\n            )\n          ) {\n            const { object } = await _readObject({\n              fs,\n              cache: {},\n              gitdir,\n              oid: op.oid,\n            });\n            // just like checkout, since mode only applicable to create, not update, delete first\n            if (await fs.exists(currentFilepath)) {\n              await fs.rm(currentFilepath);\n            }\n            await fs.write(currentFilepath, object); // only handles regular files for now\n          }\n          break\n      }\n    }\n  });\n\n  // update the stage\n  await GitIndexManager.acquire({ fs, gitdir, cache: {} }, async index => {\n    stageUpdated.forEach(({ filepath, stats, oid }) => {\n      index.insert({ filepath, stats, oid });\n    });\n  });\n}\n\nclass GitStashManager {\n  /**\n   * Creates an instance of GitStashManager.\n   *\n   * @param {Object} args\n   * @param {FSClient} args.fs - A file system implementation.\n   * @param {string} args.dir - The working directory.\n   * @param {string}[args.gitdir=join(dir, '.git')] - [required] The [git directory](dir-vs-gitdir.md) path\n   */\n  constructor({ fs, dir, gitdir = join(dir, '.git') }) {\n    Object.assign(this, {\n      fs,\n      dir,\n      gitdir,\n      _author: null,\n    });\n  }\n\n  /**\n   * Gets the reference name for the stash.\n   *\n   * @returns {string} - The stash reference name.\n   */\n  static get refStash() {\n    return 'refs/stash'\n  }\n\n  /**\n   * Gets the reference name for the stash reflogs.\n   *\n   * @returns {string} - The stash reflogs reference name.\n   */\n  static get refLogsStash() {\n    return 'logs/refs/stash'\n  }\n\n  /**\n   * Gets the file path for the stash reference.\n   *\n   * @returns {string} - The file path for the stash reference.\n   */\n  get refStashPath() {\n    return join(this.gitdir, GitStashManager.refStash)\n  }\n\n  /**\n   * Gets the file path for the stash reflogs.\n   *\n   * @returns {string} - The file path for the stash reflogs.\n   */\n  get refLogsStashPath() {\n    return join(this.gitdir, GitStashManager.refLogsStash)\n  }\n\n  /**\n   * Retrieves the author information for the stash.\n   *\n   * @returns {Promise<Object>} - The author object.\n   * @throws {MissingNameError} - If the author name is missing.\n   */\n  async getAuthor() {\n    if (!this._author) {\n      this._author = await normalizeAuthorObject({\n        fs: this.fs,\n        gitdir: this.gitdir,\n        author: {},\n      });\n      if (!this._author) throw new MissingNameError('author')\n    }\n    return this._author\n  }\n\n  /**\n   * Gets the SHA of a stash entry by its index.\n   *\n   * @param {number} refIdx - The index of the stash entry.\n   * @param {string[]} [stashEntries] - Optional preloaded stash entries.\n   * @returns {Promise<string|null>} - The SHA of the stash entry or `null` if not found.\n   */\n  async getStashSHA(refIdx, stashEntries) {\n    if (!(await this.fs.exists(this.refStashPath))) {\n      return null\n    }\n\n    const entries =\n      stashEntries || (await this.readStashReflogs({ parsed: false }));\n    return entries[refIdx].split(' ')[1]\n  }\n\n  /**\n   * Writes a stash commit to the repository.\n   *\n   * @param {Object} args\n   * @param {string} args.message - The commit message.\n   * @param {string} args.tree - The tree object ID.\n   * @param {string[]} args.parent - The parent commit object IDs.\n   * @returns {Promise<string>} - The object ID of the written commit.\n   */\n  async writeStashCommit({ message, tree, parent }) {\n    return _writeCommit({\n      fs: this.fs,\n      gitdir: this.gitdir,\n      commit: {\n        message,\n        tree,\n        parent,\n        author: await this.getAuthor(),\n        committer: await this.getAuthor(),\n      },\n    })\n  }\n\n  /**\n   * Reads a stash commit by its index.\n   *\n   * @param {number} refIdx - The index of the stash entry.\n   * @returns {Promise<Object>} - The stash commit object.\n   * @throws {InvalidRefNameError} - If the index is invalid.\n   */\n  async readStashCommit(refIdx) {\n    const stashEntries = await this.readStashReflogs({ parsed: false });\n    if (refIdx !== 0) {\n      // non-default case, throw exceptions if not valid\n      if (refIdx < 0 || refIdx > stashEntries.length - 1) {\n        throw new InvalidRefNameError(\n          `stash@${refIdx}`,\n          'number that is in range of [0, num of stash pushed]'\n        )\n      }\n    }\n\n    const stashSHA = await this.getStashSHA(refIdx, stashEntries);\n    if (!stashSHA) {\n      return {} // no stash found\n    }\n\n    // get the stash commit object\n    return _readCommit({\n      fs: this.fs,\n      cache: {},\n      gitdir: this.gitdir,\n      oid: stashSHA,\n    })\n  }\n\n  /**\n   * Writes a stash reference to the repository.\n   *\n   * @param {string} stashCommit - The object ID of the stash commit.\n   * @returns {Promise<void>}\n   */\n  async writeStashRef(stashCommit) {\n    return GitRefManager.writeRef({\n      fs: this.fs,\n      gitdir: this.gitdir,\n      ref: GitStashManager.refStash,\n      value: stashCommit,\n    })\n  }\n\n  /**\n   * Writes a reflog entry for a stash commit.\n   *\n   * @param {Object} args\n   * @param {string} args.stashCommit - The object ID of the stash commit.\n   * @param {string} args.message - The reflog message.\n   * @returns {Promise<void>}\n   */\n  async writeStashReflogEntry({ stashCommit, message }) {\n    const author = await this.getAuthor();\n    const entry = GitRefStash.createStashReflogEntry(\n      author,\n      stashCommit,\n      message\n    );\n    const filepath = this.refLogsStashPath;\n\n    await acquireLock$1({ filepath, entry }, async () => {\n      const appendTo = (await this.fs.exists(filepath))\n        ? await this.fs.read(filepath, 'utf8')\n        : '';\n      await this.fs.write(filepath, appendTo + entry, 'utf8');\n    });\n  }\n\n  /**\n   * Reads the stash reflogs.\n   *\n   * @param {Object} args\n   * @param {boolean} [args.parsed=false] - Whether to parse the reflog entries.\n   * @returns {Promise<string[]|Object[]>} - The reflog entries as strings or parsed objects.\n   */\n  async readStashReflogs({ parsed = false }) {\n    if (!(await this.fs.exists(this.refLogsStashPath))) {\n      return []\n    }\n\n    const reflogString = await this.fs.read(this.refLogsStashPath, 'utf8');\n\n    return GitRefStash.getStashReflogEntry(reflogString, parsed)\n  }\n}\n\n// @ts-check\n\n/**\n * Common logic for creating a stash commit\n * @private\n */\nasync function _createStashCommit({ fs, dir, gitdir, message = '' }) {\n  const stashMgr = new GitStashManager({ fs, dir, gitdir });\n\n  await stashMgr.getAuthor(); // ensure there is an author\n  const branch = await _currentBranch({\n    fs,\n    gitdir,\n    fullname: false,\n  });\n\n  // prepare the stash commit: first parent is the current branch HEAD\n  const headCommit = await GitRefManager.resolve({\n    fs,\n    gitdir,\n    ref: 'HEAD',\n  });\n\n  const headCommitObj = await readCommit({ fs, dir, gitdir, oid: headCommit });\n  const headMsg = headCommitObj.commit.message;\n\n  const stashCommitParents = [headCommit];\n  let stashCommitTree = null;\n  let workDirCompareBase = TREE({ ref: 'HEAD' });\n\n  const indexTree = await writeTreeChanges({\n    fs,\n    dir,\n    gitdir,\n    treePair: [TREE({ ref: 'HEAD' }), 'stage'],\n  });\n  if (indexTree) {\n    // this indexTree will be the tree of the stash commit\n    // create a commit from the index tree, which has one parent, the current branch HEAD\n    const stashCommitOne = await stashMgr.writeStashCommit({\n      message: `stash-Index: WIP on ${branch} - ${new Date().toISOString()}`,\n      tree: indexTree,\n      parent: stashCommitParents,\n    });\n    stashCommitParents.push(stashCommitOne);\n    stashCommitTree = indexTree;\n    workDirCompareBase = STAGE();\n  }\n\n  const workingTree = await writeTreeChanges({\n    fs,\n    dir,\n    gitdir,\n    treePair: [workDirCompareBase, 'workdir'],\n  });\n  if (workingTree) {\n    // create a commit from the working directory tree, which has one parent, either the one we just had, or the headCommit\n    const workingHeadCommit = await stashMgr.writeStashCommit({\n      message: `stash-WorkDir: WIP on ${branch} - ${new Date().toISOString()}`,\n      tree: workingTree,\n      parent: [stashCommitParents[stashCommitParents.length - 1]],\n    });\n\n    stashCommitParents.push(workingHeadCommit);\n    stashCommitTree = workingTree;\n  }\n\n  if (!stashCommitTree || (!indexTree && !workingTree)) {\n    throw new NotFoundError('changes, nothing to stash')\n  }\n\n  // create another commit from the tree, which has three parents: HEAD and the commit we just made:\n  const stashMsg =\n    (message.trim() || `WIP on ${branch}`) +\n    `: ${headCommit.substring(0, 7)} ${headMsg}`;\n\n  const stashCommit = await stashMgr.writeStashCommit({\n    message: stashMsg,\n    tree: stashCommitTree,\n    parent: stashCommitParents,\n  });\n\n  return { stashCommit, stashMsg, branch, stashMgr }\n}\n\nasync function _stashPush({ fs, dir, gitdir, message = '' }) {\n  const { stashCommit, stashMsg, branch, stashMgr } = await _createStashCommit({\n    fs,\n    dir,\n    gitdir,\n    message,\n  });\n\n  // next, write this commit into .git/refs/stash:\n  await stashMgr.writeStashRef(stashCommit);\n\n  // write the stash commit to the logs\n  await stashMgr.writeStashReflogEntry({\n    stashCommit,\n    message: stashMsg,\n  });\n\n  // finally, go back to a clean working directory\n  await checkout({\n    fs,\n    dir,\n    gitdir,\n    ref: branch,\n    track: false,\n    force: true, // force checkout to discard changes\n  });\n\n  return stashCommit\n}\n\nasync function _stashCreate({ fs, dir, gitdir, message = '' }) {\n  const { stashCommit } = await _createStashCommit({\n    fs,\n    dir,\n    gitdir,\n    message,\n  });\n\n  // Return the stash commit hash without modifying refs or working directory\n  return stashCommit\n}\n\nasync function _stashApply({ fs, dir, gitdir, refIdx = 0 }) {\n  const stashMgr = new GitStashManager({ fs, dir, gitdir });\n\n  // get the stash commit object\n  const stashCommit = await stashMgr.readStashCommit(refIdx);\n  const { parent: stashParents = null } = stashCommit.commit\n    ? stashCommit.commit\n    : {};\n  if (!stashParents || !Array.isArray(stashParents)) {\n    return // no stash found\n  }\n\n  // compare the stash commit tree with its parent commit\n  for (let i = 0; i < stashParents.length - 1; i++) {\n    const applyingCommit = await _readCommit({\n      fs,\n      cache: {},\n      gitdir,\n      oid: stashParents[i + 1],\n    });\n    const wasStaged = applyingCommit.commit.message.startsWith('stash-Index');\n\n    await applyTreeChanges({\n      fs,\n      dir,\n      gitdir,\n      stashCommit: stashParents[i + 1],\n      parentCommit: stashParents[i],\n      wasStaged,\n    });\n  }\n}\n\nasync function _stashDrop({ fs, dir, gitdir, refIdx = 0 }) {\n  const stashMgr = new GitStashManager({ fs, dir, gitdir });\n  const stashCommit = await stashMgr.readStashCommit(refIdx);\n  if (!stashCommit.commit) {\n    return // no stash found\n  }\n  // remove stash ref first\n  const stashRefPath = stashMgr.refStashPath;\n  await acquireLock$1(stashRefPath, async () => {\n    if (await fs.exists(stashRefPath)) {\n      await fs.rm(stashRefPath);\n    }\n  });\n\n  // read from stash reflog and list the stash commits\n  const reflogEntries = await stashMgr.readStashReflogs({ parsed: false });\n  if (!reflogEntries.length) {\n    return // no stash reflog entry\n  }\n\n  // remove the specified stash reflog entry from reflogEntries, then update the stash reflog\n  reflogEntries.splice(refIdx, 1);\n\n  const stashReflogPath = stashMgr.refLogsStashPath;\n  await acquireLock$1({ reflogEntries, stashReflogPath, stashMgr }, async () => {\n    if (reflogEntries.length) {\n      await fs.write(\n        stashReflogPath,\n        reflogEntries.reverse().join('\\n') + '\\n',\n        'utf8'\n      );\n      const lastStashCommit =\n        reflogEntries[reflogEntries.length - 1].split(' ')[1];\n      await stashMgr.writeStashRef(lastStashCommit);\n    } else {\n      // remove the stash reflog file if no entry left\n      await fs.rm(stashReflogPath);\n    }\n  });\n}\n\nasync function _stashList({ fs, dir, gitdir }) {\n  const stashMgr = new GitStashManager({ fs, dir, gitdir });\n  return stashMgr.readStashReflogs({ parsed: true })\n}\n\nasync function _stashClear({ fs, dir, gitdir }) {\n  const stashMgr = new GitStashManager({ fs, dir, gitdir });\n  const stashRefPath = [stashMgr.refStashPath, stashMgr.refLogsStashPath];\n\n  await acquireLock$1(stashRefPath, async () => {\n    await Promise.all(\n      stashRefPath.map(async path => {\n        if (await fs.exists(path)) {\n          return fs.rm(path)\n        }\n      })\n    );\n  });\n}\n\nasync function _stashPop({ fs, dir, gitdir, refIdx = 0 }) {\n  await _stashApply({ fs, dir, gitdir, refIdx });\n  await _stashDrop({ fs, dir, gitdir, refIdx });\n}\n\n// @ts-check\n\n/**\n * stash api, supports  {'push' | 'pop' | 'apply' | 'drop' | 'list' | 'clear' | 'create'} StashOp\n * _note_,\n * - all stash operations are done on tracked files only with loose objects, no packed objects\n * - when op === 'push', both working directory and index (staged) changes will be stashed, tracked files only\n * - when op === 'push', message is optional, and only applicable when op === 'push'\n * - when op === 'apply | pop', the stashed changes will overwrite the working directory, no abort when conflicts\n * - when op === 'create', creates a stash commit without modifying working directory or refs, returns the commit hash\n *\n * @param {object} args\n * @param {FsClient} args.fs - [required] a file system client\n * @param {string} [args.dir] - [required] The [working tree](dir-vs-gitdir.md) directory path\n * @param {string} [args.gitdir=join(dir,'.git')] - [optional] The [git directory](dir-vs-gitdir.md) path\n * @param {'push' | 'pop' | 'apply' | 'drop' | 'list' | 'clear' | 'create'} [args.op = 'push'] - [optional] name of stash operation, default to 'push'\n * @param {string} [args.message = ''] - [optional] message to be used for the stash entry, only applicable when op === 'push' or 'create'\n * @param {number} [args.refIdx = 0] - [optional - Number] stash ref index of entry, only applicable when op === ['apply' | 'drop' | 'pop'], refIdx >= 0 and < num of stash pushed\n * @returns {Promise<string | void>}  Resolves successfully when stash operations are complete. Returns commit hash for 'create' operation.\n *\n * @example\n * // stash changes in the working directory and index\n * let dir = '/tutorial'\n * await fs.promises.writeFile(`${dir}/a.txt`, 'original content - a')\n * await fs.promises.writeFile(`${dir}/b.js`, 'original content - b')\n * await git.add({ fs, dir, filepath: [`a.txt`,`b.txt`] })\n * let sha = await git.commit({\n *   fs,\n *   dir,\n *   author: {\n *     name: 'Mr. Stash',\n *     email: 'mstasher@stash.com',\n *   },\n *   message: 'add a.txt and b.txt to test stash'\n * })\n * console.log(sha)\n *\n * await fs.promises.writeFile(`${dir}/a.txt`, 'stashed chang- a')\n * await git.add({ fs, dir, filepath: `${dir}/a.txt` })\n * await fs.promises.writeFile(`${dir}/b.js`, 'work dir change. not stashed - b')\n *\n * await git.stash({ fs, dir }) // default gitdir and op\n *\n * console.log(await git.status({ fs, dir, filepath: 'a.txt' })) // 'unmodified'\n * console.log(await git.status({ fs, dir, filepath: 'b.txt' })) // 'unmodified'\n *\n * const refLog = await git.stash({ fs, dir, op: 'list' })\n * console.log(refLog) // [{stash{#} message}]\n *\n * await git.stash({ fs, dir, op: 'apply' }) // apply the stash\n *\n * console.log(await git.status({ fs, dir, filepath: 'a.txt' })) // 'modified'\n * console.log(await git.status({ fs, dir, filepath: 'b.txt' })) // '*modified'\n *\n * // create a stash commit without modifying working directory\n * const stashCommitHash = await git.stash({ fs, dir, op: 'create', message: 'my stash' })\n * console.log(stashCommitHash) // returns the stash commit hash\n */\n\nasync function stash({\n  fs,\n  dir,\n  gitdir = join(dir, '.git'),\n  op = 'push',\n  message = '',\n  refIdx = 0,\n}) {\n  assertParameter('fs', fs);\n  assertParameter('dir', dir);\n  assertParameter('gitdir', gitdir);\n  assertParameter('op', op);\n\n  const stashMap = {\n    push: _stashPush,\n    apply: _stashApply,\n    drop: _stashDrop,\n    list: _stashList,\n    clear: _stashClear,\n    pop: _stashPop,\n    create: _stashCreate,\n  };\n\n  const opsNeedRefIdx = ['apply', 'drop', 'pop'];\n\n  try {\n    const _fs = new FileSystem(fs);\n    const updatedGitdir = await discoverGitdir({ fsp: _fs, dotgit: gitdir });\n    const folders = ['refs', 'logs', 'logs/refs'];\n    folders\n      .map(f => join(updatedGitdir, f))\n      .forEach(async folder => {\n        if (!(await _fs.exists(folder))) {\n          await _fs.mkdir(folder);\n        }\n      });\n\n    const opFunc = stashMap[op];\n    if (opFunc) {\n      if (opsNeedRefIdx.includes(op) && refIdx < 0) {\n        throw new InvalidRefNameError(\n          `stash@${refIdx}`,\n          'number that is in range of [0, num of stash pushed]'\n        )\n      }\n      return await opFunc({\n        fs: _fs,\n        dir,\n        gitdir: updatedGitdir,\n        message,\n        refIdx,\n      })\n    }\n    throw new Error(`To be implemented: ${op}`)\n  } catch (err) {\n    err.caller = 'git.stash';\n    throw err\n  }\n}\n\n// @ts-check\n\n/**\n * Tell whether a file has been changed\n *\n * The possible resolve values are:\n *\n * | status                | description                                                                           |\n * | --------------------- | ------------------------------------------------------------------------------------- |\n * | `\"ignored\"`           | file ignored by a .gitignore rule                                                     |\n * | `\"unmodified\"`        | file unchanged from HEAD commit                                                       |\n * | `\"*modified\"`         | file has modifications, not yet staged                                                |\n * | `\"*deleted\"`          | file has been removed, but the removal is not yet staged                              |\n * | `\"*added\"`            | file is untracked, not yet staged                                                     |\n * | `\"absent\"`            | file not present in HEAD commit, staging area, or working dir                         |\n * | `\"modified\"`          | file has modifications, staged                                                        |\n * | `\"deleted\"`           | file has been removed, staged                                                         |\n * | `\"added\"`             | previously untracked file, staged                                                     |\n * | `\"*unmodified\"`       | working dir and HEAD commit match, but index differs                                  |\n * | `\"*absent\"`           | file not present in working dir or HEAD commit, but present in the index              |\n * | `\"*undeleted\"`        | file was deleted from the index, but is still in the working dir                      |\n * | `\"*undeletemodified\"` | file was deleted from the index, but is present with modifications in the working dir |\n *\n * @param {object} args\n * @param {FsClient} args.fs - a file system client\n * @param {string} args.dir - The [working tree](dir-vs-gitdir.md) directory path\n * @param {string} [args.gitdir=join(dir, '.git')] - [required] The [git directory](dir-vs-gitdir.md) path\n * @param {string} args.filepath - The path to the file to query\n * @param {object} [args.cache] - a [cache](cache.md) object\n *\n * @returns {Promise<'ignored'|'unmodified'|'*modified'|'*deleted'|'*added'|'absent'|'modified'|'deleted'|'added'|'*unmodified'|'*absent'|'*undeleted'|'*undeletemodified'>} Resolves successfully with the file's git status\n *\n * @example\n * let status = await git.status({ fs, dir: '/tutorial', filepath: 'README.md' })\n * console.log(status)\n *\n */\nasync function status({\n  fs: _fs,\n  dir,\n  gitdir = join(dir, '.git'),\n  filepath,\n  cache = {},\n}) {\n  try {\n    assertParameter('fs', _fs);\n    assertParameter('gitdir', gitdir);\n    assertParameter('filepath', filepath);\n\n    const fs = new FileSystem(_fs);\n    const updatedGitdir = await discoverGitdir({ fsp: fs, dotgit: gitdir });\n    const ignored = await GitIgnoreManager.isIgnored({\n      fs,\n      gitdir: updatedGitdir,\n      dir,\n      filepath,\n    });\n    if (ignored) {\n      return 'ignored'\n    }\n    const headTree = await getHeadTree({ fs, cache, gitdir: updatedGitdir });\n    const treeOid = await getOidAtPath({\n      fs,\n      cache,\n      gitdir: updatedGitdir,\n      tree: headTree,\n      path: filepath,\n    });\n    const indexEntry = await GitIndexManager.acquire(\n      { fs, gitdir: updatedGitdir, cache },\n      async function (index) {\n        for (const entry of index) {\n          if (entry.path === filepath) return entry\n        }\n        return null\n      }\n    );\n    const stats = await fs.lstat(join(dir, filepath));\n\n    const H = treeOid !== null; // head\n    const I = indexEntry !== null; // index\n    const W = stats !== null; // working dir\n\n    const getWorkdirOid = async () => {\n      if (I && !compareStats(indexEntry, stats)) {\n        return indexEntry.oid\n      } else {\n        const object = await fs.read(join(dir, filepath));\n        const workdirOid = await hashObject$1({\n          gitdir: updatedGitdir,\n          type: 'blob',\n          object,\n        });\n        // If the oid in the index === working dir oid but stats differed update cache\n        if (I && indexEntry.oid === workdirOid) {\n          // and as long as our fs.stats aren't bad.\n          // size of -1 happens over a BrowserFS HTTP Backend that doesn't serve Content-Length headers\n          // (like the Karma webserver) because BrowserFS HTTP Backend uses HTTP HEAD requests to do fs.stat\n          if (stats.size !== -1) {\n            // We don't await this so we can return faster for one-off cases.\n            GitIndexManager.acquire(\n              { fs, gitdir: updatedGitdir, cache },\n              async function (index) {\n                index.insert({ filepath, stats, oid: workdirOid });\n              }\n            );\n          }\n        }\n        return workdirOid\n      }\n    };\n\n    if (!H && !W && !I) return 'absent' // ---\n    if (!H && !W && I) return '*absent' // -A-\n    if (!H && W && !I) return '*added' // --A\n    if (!H && W && I) {\n      const workdirOid = await getWorkdirOid();\n      // @ts-ignore\n      return workdirOid === indexEntry.oid ? 'added' : '*added' // -AA : -AB\n    }\n    if (H && !W && !I) return 'deleted' // A--\n    if (H && !W && I) {\n      // @ts-ignore\n      return treeOid === indexEntry.oid ? '*deleted' : '*deleted' // AA- : AB-\n    }\n    if (H && W && !I) {\n      const workdirOid = await getWorkdirOid();\n      return workdirOid === treeOid ? '*undeleted' : '*undeletemodified' // A-A : A-B\n    }\n    if (H && W && I) {\n      const workdirOid = await getWorkdirOid();\n      if (workdirOid === treeOid) {\n        // @ts-ignore\n        return workdirOid === indexEntry.oid ? 'unmodified' : '*unmodified' // AAA : ABA\n      } else {\n        // @ts-ignore\n        return workdirOid === indexEntry.oid ? 'modified' : '*modified' // ABB : AAB\n      }\n    }\n    /*\n    ---\n    -A-\n    --A\n    -AA\n    -AB\n    A--\n    AA-\n    AB-\n    A-A\n    A-B\n    AAA\n    ABA\n    ABB\n    AAB\n    */\n  } catch (err) {\n    err.caller = 'git.status';\n    throw err\n  }\n}\n\nasync function getOidAtPath({ fs, cache, gitdir: updatedGitdir, tree, path }) {\n  if (typeof path === 'string') path = path.split('/');\n  const dirname = path.shift();\n  for (const entry of tree) {\n    if (entry.path === dirname) {\n      if (path.length === 0) {\n        return entry.oid\n      }\n      const { type, object } = await _readObject({\n        fs,\n        cache,\n        gitdir: updatedGitdir,\n        oid: entry.oid,\n      });\n      if (type === 'tree') {\n        const tree = GitTree.from(object);\n        return getOidAtPath({ fs, cache, gitdir: updatedGitdir, tree, path })\n      }\n      if (type === 'blob') {\n        throw new ObjectTypeError(entry.oid, type, 'blob', path.join('/'))\n      }\n    }\n  }\n  return null\n}\n\nasync function getHeadTree({ fs, cache, gitdir: updatedGitdir }) {\n  // Get the tree from the HEAD commit.\n  let oid;\n  try {\n    oid = await GitRefManager.resolve({\n      fs,\n      gitdir: updatedGitdir,\n      ref: 'HEAD',\n    });\n  } catch (e) {\n    // Handle fresh branches with no commits\n    if (e instanceof NotFoundError) {\n      return []\n    }\n  }\n  const { tree } = await _readTree({ fs, cache, gitdir: updatedGitdir, oid });\n  return tree\n}\n\n// @ts-check\n\n/**\n * Efficiently get the status of multiple files at once.\n *\n * The returned `StatusMatrix` is admittedly not the easiest format to read.\n * However it conveys a large amount of information in dense format that should make it easy to create reports about the current state of the repository;\n * without having to do multiple, time-consuming isomorphic-git calls.\n * My hope is that the speed and flexibility of the function will make up for the learning curve of interpreting the return value.\n *\n * ```js live\n * // get the status of all the files in 'src'\n * let status = await git.statusMatrix({\n *   fs,\n *   dir: '/tutorial',\n *   filter: f => f.startsWith('src/')\n * })\n * console.log(status)\n * ```\n *\n * ```js live\n * // get the status of all the JSON and Markdown files\n * let status = await git.statusMatrix({\n *   fs,\n *   dir: '/tutorial',\n *   filter: f => f.endsWith('.json') || f.endsWith('.md')\n * })\n * console.log(status)\n * ```\n *\n * The result is returned as a 2D array.\n * The outer array represents the files and/or blobs in the repo, in alphabetical order.\n * The inner arrays describe the status of the file:\n * the first value is the filepath, and the next three are integers\n * representing the HEAD status, WORKDIR status, and STAGE status of the entry.\n *\n * ```js\n * // example StatusMatrix\n * [\n *   [\"a.txt\", 0, 2, 0], // new, untracked\n *   [\"b.txt\", 0, 2, 2], // added, staged\n *   [\"c.txt\", 0, 2, 3], // added, staged, with unstaged changes\n *   [\"d.txt\", 1, 1, 1], // unmodified\n *   [\"e.txt\", 1, 2, 1], // modified, unstaged\n *   [\"f.txt\", 1, 2, 2], // modified, staged\n *   [\"g.txt\", 1, 2, 3], // modified, staged, with unstaged changes\n *   [\"h.txt\", 1, 0, 1], // deleted, unstaged\n *   [\"i.txt\", 1, 0, 0], // deleted, staged\n *   [\"j.txt\", 1, 2, 0], // deleted, staged, with unstaged-modified changes (new file of the same name)\n *   [\"k.txt\", 1, 1, 0], // deleted, staged, with unstaged changes (new file of the same name)\n * ]\n * ```\n *\n * - The HEAD status is either absent (0) or present (1).\n * - The WORKDIR status is either absent (0), identical to HEAD (1), or different from HEAD (2).\n * - The STAGE status is either absent (0), identical to HEAD (1), identical to WORKDIR (2), or different from WORKDIR (3).\n *\n * ```ts\n * type Filename      = string\n * type HeadStatus    = 0 | 1\n * type WorkdirStatus = 0 | 1 | 2\n * type StageStatus   = 0 | 1 | 2 | 3\n *\n * type StatusRow     = [Filename, HeadStatus, WorkdirStatus, StageStatus]\n *\n * type StatusMatrix  = StatusRow[]\n * ```\n *\n * > Think of the natural progression of file modifications as being from HEAD (previous) -> WORKDIR (current) -> STAGE (next).\n * > Then HEAD is \"version 1\", WORKDIR is \"version 2\", and STAGE is \"version 3\".\n * > Then, imagine a \"version 0\" which is before the file was created.\n * > Then the status value in each column corresponds to the oldest version of the file it is identical to.\n * > (For a file to be identical to \"version 0\" means the file is deleted.)\n *\n * Here are some examples of queries you can answer using the result:\n *\n * #### Q: What files have been deleted?\n * ```js\n * const FILE = 0, WORKDIR = 2\n *\n * const filenames = (await statusMatrix({ dir }))\n *   .filter(row => row[WORKDIR] === 0)\n *   .map(row => row[FILE])\n * ```\n *\n * #### Q: What files have unstaged changes?\n * ```js\n * const FILE = 0, WORKDIR = 2, STAGE = 3\n *\n * const filenames = (await statusMatrix({ dir }))\n *   .filter(row => row[WORKDIR] !== row[STAGE])\n *   .map(row => row[FILE])\n * ```\n *\n * #### Q: What files have been modified since the last commit?\n * ```js\n * const FILE = 0, HEAD = 1, WORKDIR = 2\n *\n * const filenames = (await statusMatrix({ dir }))\n *   .filter(row => row[HEAD] !== row[WORKDIR])\n *   .map(row => row[FILE])\n * ```\n *\n * #### Q: What files will NOT be changed if I commit right now?\n * ```js\n * const FILE = 0, HEAD = 1, STAGE = 3\n *\n * const filenames = (await statusMatrix({ dir }))\n *   .filter(row => row[HEAD] === row[STAGE])\n *   .map(row => row[FILE])\n * ```\n *\n * For reference, here are all possible combinations:\n *\n * | HEAD | WORKDIR | STAGE | `git status --short` equivalent |\n * | ---- | ------- | ----- | ------------------------------- |\n * | 0    | 0       | 0     | ``                              |\n * | 0    | 0       | 3     | `AD`                            |\n * | 0    | 2       | 0     | `??`                            |\n * | 0    | 2       | 2     | `A `                            |\n * | 0    | 2       | 3     | `AM`                            |\n * | 1    | 0       | 0     | `D `                            |\n * | 1    | 0       | 1     | ` D`                            |\n * | 1    | 0       | 3     | `MD`                            |\n * | 1    | 1       | 0     | `D ` + `??`                     |\n * | 1    | 1       | 1     | ``                              |\n * | 1    | 1       | 3     | `MM`                            |\n * | 1    | 2       | 0     | `D ` + `??`                     |\n * | 1    | 2       | 1     | ` M`                            |\n * | 1    | 2       | 2     | `M `                            |\n * | 1    | 2       | 3     | `MM`                            |\n *\n * @param {object} args\n * @param {FsClient} args.fs - a file system client\n * @param {string} args.dir - The [working tree](dir-vs-gitdir.md) directory path\n * @param {string} [args.gitdir=join(dir, '.git')] - [required] The [git directory](dir-vs-gitdir.md) path\n * @param {string} [args.ref = 'HEAD'] - Optionally specify a different commit to compare against the workdir and stage instead of the HEAD\n * @param {string[]} [args.filepaths = ['.']] - Limit the query to the given files and directories\n * @param {function(string): boolean} [args.filter] - Filter the results to only those whose filepath matches a function.\n * @param {object} [args.cache] - a [cache](cache.md) object\n * @param {boolean} [args.ignored = false] - include ignored files in the result\n *\n * @returns {Promise<Array<StatusRow>>} Resolves with a status matrix, described below.\n * @see StatusRow\n */\nasync function statusMatrix({\n  fs: _fs,\n  dir,\n  gitdir = join(dir, '.git'),\n  ref = 'HEAD',\n  filepaths = ['.'],\n  filter,\n  cache = {},\n  ignored: shouldIgnore = false,\n}) {\n  try {\n    assertParameter('fs', _fs);\n    assertParameter('gitdir', gitdir);\n    assertParameter('ref', ref);\n\n    const fs = new FileSystem(_fs);\n    const updatedGitdir = await discoverGitdir({ fsp: fs, dotgit: gitdir });\n    return await _walk({\n      fs,\n      cache,\n      dir,\n      gitdir: updatedGitdir,\n      trees: [TREE({ ref }), WORKDIR(), STAGE()],\n      map: async function (filepath, [head, workdir, stage]) {\n        // Ignore ignored files, but only if they are not already tracked.\n        if (!head && !stage && workdir) {\n          if (!shouldIgnore) {\n            const isIgnored = await GitIgnoreManager.isIgnored({\n              fs,\n              dir,\n              filepath,\n            });\n            if (isIgnored) {\n              return null\n            }\n          }\n        }\n        // match against base paths\n        if (!filepaths.some(base => worthWalking(filepath, base))) {\n          return null\n        }\n        // Late filter against file names\n        if (filter) {\n          if (!filter(filepath)) return\n        }\n\n        const [headType, workdirType, stageType] = await Promise.all([\n          head && head.type(),\n          workdir && workdir.type(),\n          stage && stage.type(),\n        ]);\n\n        const isBlob = [headType, workdirType, stageType].includes('blob');\n\n        // For now, bail on directories unless the file is also a blob in another tree\n        if ((headType === 'tree' || headType === 'special') && !isBlob) return\n        if (headType === 'commit') return null\n\n        if ((workdirType === 'tree' || workdirType === 'special') && !isBlob)\n          return\n\n        if (stageType === 'commit') return null\n        if ((stageType === 'tree' || stageType === 'special') && !isBlob) return\n\n        // Figure out the oids for files, using the staged oid for the working dir oid if the stats match.\n        const headOid = headType === 'blob' ? await head.oid() : undefined;\n        const stageOid = stageType === 'blob' ? await stage.oid() : undefined;\n        let workdirOid;\n        if (\n          headType !== 'blob' &&\n          workdirType === 'blob' &&\n          stageType !== 'blob'\n        ) {\n          // We don't actually NEED the sha. Any sha will do\n          // TODO: update this logic to handle N trees instead of just 3.\n          workdirOid = '42';\n        } else if (workdirType === 'blob') {\n          workdirOid = await workdir.oid();\n        }\n        const entry = [undefined, headOid, workdirOid, stageOid];\n        const result = entry.map(value => entry.indexOf(value));\n        result.shift(); // remove leading undefined entry\n        return [filepath, ...result]\n      },\n    })\n  } catch (err) {\n    err.caller = 'git.statusMatrix';\n    throw err\n  }\n}\n\n// @ts-check\n\n/**\n * Create a lightweight tag\n *\n * @param {object} args\n * @param {FsClient} args.fs - a file system client\n * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path\n * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path\n * @param {string} args.ref - What to name the tag\n * @param {string} [args.object = 'HEAD'] - What oid the tag refers to. (Will resolve to oid if value is a ref.) By default, the commit object which is referred by the current `HEAD` is used.\n * @param {boolean} [args.force = false] - Instead of throwing an error if a tag named `ref` already exists, overwrite the existing tag.\n *\n * @returns {Promise<void>} Resolves successfully when filesystem operations are complete\n *\n * @example\n * await git.tag({ fs, dir: '/tutorial', ref: 'test-tag' })\n * console.log('done')\n *\n */\nasync function tag({\n  fs: _fs,\n  dir,\n  gitdir = join(dir, '.git'),\n  ref,\n  object,\n  force = false,\n}) {\n  try {\n    assertParameter('fs', _fs);\n    assertParameter('gitdir', gitdir);\n    assertParameter('ref', ref);\n\n    const fs = new FileSystem(_fs);\n\n    if (ref === undefined) {\n      throw new MissingParameterError('ref')\n    }\n\n    ref = ref.startsWith('refs/tags/') ? ref : `refs/tags/${ref}`;\n\n    // Resolve passed object\n    const updatedGitdir = await discoverGitdir({ fsp: fs, dotgit: gitdir });\n    const value = await GitRefManager.resolve({\n      fs,\n      gitdir: updatedGitdir,\n      ref: object || 'HEAD',\n    });\n\n    if (\n      !force &&\n      (await GitRefManager.exists({ fs, gitdir: updatedGitdir, ref }))\n    ) {\n      throw new AlreadyExistsError('tag', ref)\n    }\n\n    await GitRefManager.writeRef({ fs, gitdir: updatedGitdir, ref, value });\n  } catch (err) {\n    err.caller = 'git.tag';\n    throw err\n  }\n}\n\n// @ts-check\n\n/**\n * Register file contents in the working tree or object database to the git index (aka staging area).\n *\n * @param {object} args\n * @param {FsClient} args.fs - a file system client\n * @param {string} args.dir - The [working tree](dir-vs-gitdir.md) directory path\n * @param {string} [args.gitdir=join(dir, '.git')] - [required] The [git directory](dir-vs-gitdir.md) path\n * @param {string} args.filepath - File to act upon.\n * @param {string} [args.oid] - OID of the object in the object database to add to the index with the specified filepath.\n * @param {number} [args.mode = 100644] - The file mode to add the file to the index.\n * @param {boolean} [args.add] - Adds the specified file to the index if it does not yet exist in the index.\n * @param {boolean} [args.remove] - Remove the specified file from the index if it does not exist in the workspace anymore.\n * @param {boolean} [args.force] - Remove the specified file from the index, even if it still exists in the workspace.\n * @param {object} [args.cache] - a [cache](cache.md) object\n *\n * @returns {Promise<string | void>} Resolves successfully with the SHA-1 object id of the object written or updated in the index, or nothing if the file was removed.\n *\n * @example\n * await git.updateIndex({\n *   fs,\n *   dir: '/tutorial',\n *   filepath: 'readme.md'\n * })\n *\n * @example\n * // Manually create a blob in the object database.\n * let oid = await git.writeBlob({\n *   fs,\n *   dir: '/tutorial',\n *   blob: new Uint8Array([])\n * })\n *\n * // Write the object in the object database to the index.\n * await git.updateIndex({\n *   fs,\n *   dir: '/tutorial',\n *   add: true,\n *   filepath: 'readme.md',\n *   oid\n * })\n */\nasync function updateIndex$1({\n  fs: _fs,\n  dir,\n  gitdir = join(dir, '.git'),\n  cache = {},\n  filepath,\n  oid,\n  mode,\n  add,\n  remove,\n  force,\n}) {\n  try {\n    assertParameter('fs', _fs);\n    assertParameter('gitdir', gitdir);\n    assertParameter('filepath', filepath);\n\n    const fs = new FileSystem(_fs);\n    const updatedGitdir = await discoverGitdir({ fsp: fs, dotgit: gitdir });\n\n    if (remove) {\n      return await GitIndexManager.acquire(\n        { fs, gitdir: updatedGitdir, cache },\n        async function (index) {\n          if (!force) {\n            // Check if the file is still present in the working directory\n            const fileStats = await fs.lstat(join(dir, filepath));\n\n            if (fileStats) {\n              if (fileStats.isDirectory()) {\n                // Removing directories should not work\n                throw new InvalidFilepathError('directory')\n              }\n\n              // Do nothing if we don't force and the file still exists in the workdir\n              return\n            }\n          }\n\n          // Directories are not allowed, so we make sure the provided filepath exists in the index\n          if (index.has({ filepath })) {\n            index.delete({\n              filepath,\n            });\n          }\n        }\n      )\n    }\n\n    // Test if it is a file and exists on disk if `remove` is not provided, only of no oid is provided\n    let fileStats;\n\n    if (!oid) {\n      fileStats = await fs.lstat(join(dir, filepath));\n\n      if (!fileStats) {\n        throw new NotFoundError(\n          `file at \"${filepath}\" on disk and \"remove\" not set`\n        )\n      }\n\n      if (fileStats.isDirectory()) {\n        throw new InvalidFilepathError('directory')\n      }\n    }\n\n    return await GitIndexManager.acquire(\n      { fs, gitdir: updatedGitdir, cache },\n      async function (index) {\n        if (!add && !index.has({ filepath })) {\n          // If the index does not contain the filepath yet and `add` is not set, we should throw\n          throw new NotFoundError(\n            `file at \"${filepath}\" in index and \"add\" not set`\n          )\n        }\n\n        let stats;\n        if (!oid) {\n          stats = fileStats;\n\n          // Write the file to the object database\n          const object = stats.isSymbolicLink()\n            ? await fs.readlink(join(dir, filepath))\n            : await fs.read(join(dir, filepath));\n\n          oid = await _writeObject({\n            fs,\n            gitdir: updatedGitdir,\n            type: 'blob',\n            format: 'content',\n            object,\n          });\n        } else {\n          // By default we use 0 for the stats of the index file\n          stats = {\n            ctime: new Date(0),\n            mtime: new Date(0),\n            dev: 0,\n            ino: 0,\n            mode,\n            uid: 0,\n            gid: 0,\n            size: 0,\n          };\n        }\n\n        index.insert({\n          filepath,\n          oid,\n          stats,\n        });\n\n        return oid\n      }\n    )\n  } catch (err) {\n    err.caller = 'git.updateIndex';\n    throw err\n  }\n}\n\n// @ts-check\n\n/**\n * Return the version number of isomorphic-git\n *\n * I don't know why you might need this. I added it just so I could check that I was getting\n * the correct version of the library and not a cached version.\n *\n * @returns {string} the version string taken from package.json at publication time\n *\n * @example\n * console.log(git.version())\n *\n */\nfunction version() {\n  try {\n    return pkg.version\n  } catch (err) {\n    err.caller = 'git.version';\n    throw err\n  }\n}\n\n// @ts-check\n\n/**\n * @callback WalkerMap\n * @param {string} filename\n * @param {Array<WalkerEntry | null>} entries\n * @returns {Promise<any>}\n */\n\n/**\n * @callback WalkerReduce\n * @param {any} parent\n * @param {any[]} children\n * @returns {Promise<any>}\n */\n\n/**\n * @callback WalkerIterateCallback\n * @param {WalkerEntry[]} entries\n * @returns {Promise<any[]>}\n */\n\n/**\n * @callback WalkerIterate\n * @param {WalkerIterateCallback} walk\n * @param {IterableIterator<WalkerEntry[]>} children\n * @returns {Promise<any[]>}\n */\n\n/**\n * A powerful recursive tree-walking utility.\n *\n * The `walk` API simplifies gathering detailed information about a tree or comparing all the filepaths in two or more trees.\n * Trees can be git commits, the working directory, or the or git index (staging area).\n * As long as a file or directory is present in at least one of the trees, it will be traversed.\n * Entries are traversed in alphabetical order.\n *\n * The arguments to `walk` are the `trees` you want to traverse, and 3 optional transform functions:\n *  `map`, `reduce`, and `iterate`.\n *\n * ## `TREE`, `WORKDIR`, and `STAGE`\n *\n * Tree walkers are represented by three separate functions that can be imported:\n *\n * ```js\n * import { TREE, WORKDIR, STAGE } from 'isomorphic-git'\n * ```\n *\n * These functions return opaque handles called `Walker`s.\n * The only thing that `Walker` objects are good for is passing into `walk`.\n * Here are the three `Walker`s passed into `walk` by the `statusMatrix` command for example:\n *\n * ```js\n * let ref = 'HEAD'\n *\n * let trees = [TREE({ ref }), WORKDIR(), STAGE()]\n * ```\n *\n * For the arguments, see the doc pages for [TREE](./TREE.md), [WORKDIR](./WORKDIR.md), and [STAGE](./STAGE.md).\n *\n * `map`, `reduce`, and `iterate` allow you control the recursive walk by pruning and transforming `WalkerEntry`s into the desired result.\n *\n * ## WalkerEntry\n *\n * {@link WalkerEntry typedef}\n *\n * `map` receives an array of `WalkerEntry[]` as its main argument, one `WalkerEntry` for each `Walker` in the `trees` argument.\n * The methods are memoized per `WalkerEntry` so calling them multiple times in a `map` function does not adversely impact performance.\n * By only computing these values if needed, you build can build lean, mean, efficient walking machines.\n *\n * ### WalkerEntry#type()\n *\n * Returns the kind as a string. This is normally either `tree` or `blob`.\n *\n * `TREE`, `STAGE`, and `WORKDIR` walkers all return a string.\n *\n * Possible values:\n *\n * - `'tree'` directory\n * - `'blob'` file\n * - `'special'` used by `WORKDIR` to represent irregular files like sockets and FIFOs\n * - `'commit'` used by `TREE` to represent submodules\n *\n * ```js\n * await entry.type()\n * ```\n *\n * ### WalkerEntry#mode()\n *\n * Returns the file mode as a number. Use this to distinguish between regular files, symlinks, and executable files.\n *\n * `TREE`, `STAGE`, and `WORKDIR` walkers all return a number for all `type`s of entries.\n *\n * It has been normalized to one of the 4 values that are allowed in git commits:\n *\n * - `0o40000` directory\n * - `0o100644` file\n * - `0o100755` file (executable)\n * - `0o120000` symlink\n *\n * Tip: to make modes more readable, you can print them to octal using `.toString(8)`.\n *\n * ```js\n * await entry.mode()\n * ```\n *\n * ### WalkerEntry#oid()\n *\n * Returns the SHA-1 object id for blobs and trees.\n *\n * `TREE` walkers return a string for `blob` and `tree` entries.\n *\n * `STAGE` and `WORKDIR` walkers return a string for `blob` entries and `undefined` for `tree` entries.\n *\n * ```js\n * await entry.oid()\n * ```\n *\n * ### WalkerEntry#content()\n *\n * Returns the file contents as a Buffer.\n *\n * `TREE` and `WORKDIR` walkers return a Buffer for `blob` entries and `undefined` for `tree` entries.\n *\n * `STAGE` walkers always return `undefined` since the file contents are never stored in the stage.\n *\n * ```js\n * await entry.content()\n * ```\n *\n * ### WalkerEntry#stat()\n *\n * Returns a normalized subset of filesystem Stat data.\n *\n * `WORKDIR` walkers return a `Stat` for `blob` and `tree` entries.\n *\n * `STAGE` walkers return a `Stat` for `blob` entries and `undefined` for `tree` entries.\n *\n * `TREE` walkers return `undefined` for all entry types.\n *\n * ```js\n * await entry.stat()\n * ```\n *\n * {@link Stat typedef}\n *\n * ## map(string, Array<WalkerEntry|null>) => Promise<any>\n *\n * {@link WalkerMap typedef}\n *\n * This is the function that is called once per entry BEFORE visiting the children of that node.\n *\n * If you return `null` for a `tree` entry, then none of the children of that `tree` entry will be walked.\n *\n * This is a good place for query logic, such as examining the contents of a file.\n * Ultimately, compare all the entries and return any values you are interested in.\n * If you do not return a value (or return undefined) that entry will be filtered from the results.\n *\n * Example 1: Find all the files containing the word 'foo'.\n * ```js\n * async function map(filepath, [head, workdir]) {\n *   let content = (await workdir.content()).toString('utf8')\n *   if (content.contains('foo')) {\n *     return {\n *       filepath,\n *       content\n *     }\n *   }\n * }\n * ```\n *\n * Example 2: Return the difference between the working directory and the HEAD commit\n * ```js\n * const map = async (filepath, [head, workdir]) => {\n *   return {\n *     filepath,\n *     oid: await head?.oid(),\n *     diff: diff(\n *       (await head?.content())?.toString('utf8') || '',\n *       (await workdir?.content())?.toString('utf8') || ''\n *     )\n *   }\n * }\n * ```\n *\n * Example 3:\n * ```js\n * let path = require('path')\n * // Only examine files in the directory `cwd`\n * let cwd = 'src/app'\n * async function map (filepath, [head, workdir, stage]) {\n *   if (\n *     // don't skip the root directory\n *     head.fullpath !== '.' &&\n *     // return true for 'src' and 'src/app'\n *     !cwd.startsWith(filepath) &&\n *     // return true for 'src/app/*'\n *     path.dirname(filepath) !== cwd\n *   ) {\n *     return null\n *   } else {\n *     return filepath\n *   }\n * }\n * ```\n *\n * ## reduce(parent, children)\n *\n * {@link WalkerReduce typedef}\n *\n * This is the function that is called once per entry AFTER visiting the children of that node.\n *\n * Default: `async (parent, children) => parent === undefined ? children.flat() : [parent, children].flat()`\n *\n * The default implementation of this function returns all directories and children in a giant flat array.\n * You can define a different accumulation method though.\n *\n * Example: Return a hierarchical structure\n * ```js\n * async function reduce (parent, children) {\n *   return Object.assign(parent, { children })\n * }\n * ```\n *\n * ## iterate(walk, children)\n *\n * {@link WalkerIterate typedef}\n *\n * {@link WalkerIterateCallback typedef}\n *\n * Default: `(walk, children) => Promise.all([...children].map(walk))`\n *\n * The default implementation recurses all children concurrently using Promise.all.\n * However you could use a custom function to traverse children serially or use a global queue to throttle recursion.\n *\n * @param {object} args\n * @param {FsClient} args.fs - a file system client\n * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path\n * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path\n * @param {Walker[]} args.trees - The trees you want to traverse\n * @param {WalkerMap} [args.map] - Transform `WalkerEntry`s into a result form\n * @param {WalkerReduce} [args.reduce] - Control how mapped entries are combined with their parent result\n * @param {WalkerIterate} [args.iterate] - Fine-tune how entries within a tree are iterated over\n * @param {object} [args.cache] - a [cache](cache.md) object\n *\n * @returns {Promise<any>} The finished tree-walking result\n */\nasync function walk({\n  fs,\n  dir,\n  gitdir = join(dir, '.git'),\n  trees,\n  map,\n  reduce,\n  iterate,\n  cache = {},\n}) {\n  try {\n    assertParameter('fs', fs);\n    assertParameter('gitdir', gitdir);\n    assertParameter('trees', trees);\n\n    const fsp = new FileSystem(fs);\n    const updatedGitdir = await discoverGitdir({ fsp, dotgit: gitdir });\n    return await _walk({\n      fs: fsp,\n      cache,\n      dir,\n      gitdir: updatedGitdir,\n      trees,\n      map,\n      reduce,\n      iterate,\n    })\n  } catch (err) {\n    err.caller = 'git.walk';\n    throw err\n  }\n}\n\n// @ts-check\n\n/**\n * Write a blob object directly\n *\n * @param {object} args\n * @param {FsClient} args.fs - a file system client\n * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path\n * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path\n * @param {Uint8Array} args.blob - The blob object to write\n *\n * @returns {Promise<string>} Resolves successfully with the SHA-1 object id of the newly written object\n *\n * @example\n * // Manually create a blob.\n * let oid = await git.writeBlob({\n *   fs,\n *   dir: '/tutorial',\n *   blob: new Uint8Array([])\n * })\n *\n * console.log('oid', oid) // should be 'e69de29bb2d1d6434b8b29ae775ad8c2e48c5391'\n *\n */\nasync function writeBlob({ fs, dir, gitdir = join(dir, '.git'), blob }) {\n  try {\n    assertParameter('fs', fs);\n    assertParameter('gitdir', gitdir);\n    assertParameter('blob', blob);\n\n    const fsp = new FileSystem(fs);\n    const updatedGitdir = await discoverGitdir({ fsp, dotgit: gitdir });\n    return await _writeObject({\n      fs: fsp,\n      gitdir: updatedGitdir,\n      type: 'blob',\n      object: blob,\n      format: 'content',\n    })\n  } catch (err) {\n    err.caller = 'git.writeBlob';\n    throw err\n  }\n}\n\n// @ts-check\n\n/**\n * Write a commit object directly\n *\n * @param {object} args\n * @param {FsClient} args.fs - a file system client\n * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path\n * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path\n * @param {CommitObject} args.commit - The object to write\n *\n * @returns {Promise<string>} Resolves successfully with the SHA-1 object id of the newly written object\n * @see CommitObject\n *\n */\nasync function writeCommit({\n  fs,\n  dir,\n  gitdir = join(dir, '.git'),\n  commit,\n}) {\n  try {\n    assertParameter('fs', fs);\n    assertParameter('gitdir', gitdir);\n    assertParameter('commit', commit);\n\n    const fsp = new FileSystem(fs);\n    const updatedGitdir = await discoverGitdir({ fsp, dotgit: gitdir });\n    return await _writeCommit({\n      fs: fsp,\n      gitdir: updatedGitdir,\n      commit,\n    })\n  } catch (err) {\n    err.caller = 'git.writeCommit';\n    throw err\n  }\n}\n\n// @ts-check\n\n/**\n * Write a git object directly\n *\n * `format` can have the following values:\n *\n * | param      | description                                                                                                                                                      |\n * | ---------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n * | 'deflated' | Treat `object` as the raw deflate-compressed buffer for an object, meaning can be written to `.git/objects/**` as-is.                                           |\n * | 'wrapped'  | Treat `object` as the inflated object buffer wrapped in the git object header. This is the raw buffer used when calculating the SHA-1 object id of a git object. |\n * | 'content'  | Treat `object` as the object buffer without the git header.                                                                                                      |\n * | 'parsed'   | Treat `object` as a parsed representation of the object.                                                                                                         |\n *\n * If `format` is `'parsed'`, then `object` must match one of the schemas for `CommitObject`, `TreeObject`, `TagObject`, or a `string` (for blobs).\n *\n * {@link CommitObject typedef}\n *\n * {@link TreeObject typedef}\n *\n * {@link TagObject typedef}\n *\n * If `format` is `'content'`, `'wrapped'`, or `'deflated'`, `object` should be a `Uint8Array`.\n *\n * @deprecated\n * > This command is overly complicated.\n * >\n * > If you know the type of object you are writing, use [`writeBlob`](./writeBlob.md), [`writeCommit`](./writeCommit.md), [`writeTag`](./writeTag.md), or [`writeTree`](./writeTree.md).\n *\n * @param {object} args\n * @param {FsClient} args.fs - a file system client\n * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path\n * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path\n * @param {string | Uint8Array | CommitObject | TreeObject | TagObject} args.object - The object to write.\n * @param {'blob'|'tree'|'commit'|'tag'} [args.type] - The kind of object to write.\n * @param {'deflated' | 'wrapped' | 'content' | 'parsed'} [args.format = 'parsed'] - What format the object is in. The possible choices are listed below.\n * @param {string} [args.oid] - If `format` is `'deflated'` then this param is required. Otherwise it is calculated.\n * @param {string} [args.encoding] - If `type` is `'blob'` then `object` will be converted to a Uint8Array using `encoding`.\n *\n * @returns {Promise<string>} Resolves successfully with the SHA-1 object id of the newly written object.\n *\n * @example\n * // Manually create an annotated tag.\n * let sha = await git.resolveRef({ fs, dir: '/tutorial', ref: 'HEAD' })\n * console.log('commit', sha)\n *\n * let oid = await git.writeObject({\n *   fs,\n *   dir: '/tutorial',\n *   type: 'tag',\n *   object: {\n *     object: sha,\n *     type: 'commit',\n *     tag: 'my-tag',\n *     tagger: {\n *       name: 'your name',\n *       email: 'email@example.com',\n *       timestamp: Math.floor(Date.now()/1000),\n *       timezoneOffset: new Date().getTimezoneOffset()\n *     },\n *     message: 'Optional message'\n *   }\n * })\n *\n * console.log('tag', oid)\n *\n */\nasync function writeObject({\n  fs: _fs,\n  dir,\n  gitdir = join(dir, '.git'),\n  type,\n  object,\n  format = 'parsed',\n  oid,\n  encoding = undefined,\n}) {\n  try {\n    const fs = new FileSystem(_fs);\n    const updatedGitdir = await discoverGitdir({ fsp: fs, dotgit: gitdir });\n    // Convert object to buffer\n    if (format === 'parsed') {\n      switch (type) {\n        case 'commit':\n          object = GitCommit.from(object).toObject();\n          break\n        case 'tree':\n          object = GitTree.from(object).toObject();\n          break\n        case 'blob':\n          object = Buffer.from(object, encoding);\n          break\n        case 'tag':\n          object = GitAnnotatedTag.from(object).toObject();\n          break\n        default:\n          throw new ObjectTypeError(oid || '', type, 'blob|commit|tag|tree')\n      }\n      // GitObjectManager does not know how to serialize content, so we tweak that parameter before passing it.\n      format = 'content';\n    }\n    oid = await _writeObject({\n      fs,\n      gitdir: updatedGitdir,\n      type,\n      object,\n      oid,\n      format,\n    });\n    return oid\n  } catch (err) {\n    err.caller = 'git.writeObject';\n    throw err\n  }\n}\n\n// @ts-check\n\n/**\n * Write a ref which refers to the specified SHA-1 object id, or a symbolic ref which refers to the specified ref.\n *\n * @param {object} args\n * @param {FsClient} args.fs - a file system client\n * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path\n * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path\n * @param {string} args.ref - The name of the ref to write\n * @param {string} args.value - When `symbolic` is false, a ref or an SHA-1 object id. When true, a ref starting with `refs/`.\n * @param {boolean} [args.force = false] - Instead of throwing an error if a ref named `ref` already exists, overwrite the existing ref.\n * @param {boolean} [args.symbolic = false] - Whether the ref is symbolic or not.\n *\n * @returns {Promise<void>} Resolves successfully when filesystem operations are complete\n *\n * @example\n * await git.writeRef({\n *   fs,\n *   dir: '/tutorial',\n *   ref: 'refs/heads/another-branch',\n *   value: 'HEAD'\n * })\n * await git.writeRef({\n *   fs,\n *   dir: '/tutorial',\n *   ref: 'HEAD',\n *   value: 'refs/heads/another-branch',\n *   force: true,\n *   symbolic: true\n * })\n * console.log('done')\n *\n */\nasync function writeRef({\n  fs: _fs,\n  dir,\n  gitdir = join(dir, '.git'),\n  ref,\n  value,\n  force = false,\n  symbolic = false,\n}) {\n  try {\n    assertParameter('fs', _fs);\n    assertParameter('gitdir', gitdir);\n    assertParameter('ref', ref);\n    assertParameter('value', value);\n\n    const fs = new FileSystem(_fs);\n\n    if (!isValidRef(ref, true)) {\n      throw new InvalidRefNameError(ref, cleanGitRef.clean(ref))\n    }\n\n    const updatedGitdir = await discoverGitdir({ fsp: fs, dotgit: gitdir });\n    if (\n      !force &&\n      (await GitRefManager.exists({ fs, gitdir: updatedGitdir, ref }))\n    ) {\n      throw new AlreadyExistsError('ref', ref)\n    }\n\n    if (symbolic) {\n      await GitRefManager.writeSymbolicRef({\n        fs,\n        gitdir: updatedGitdir,\n        ref,\n        value,\n      });\n    } else {\n      value = await GitRefManager.resolve({\n        fs,\n        gitdir: updatedGitdir,\n        ref: value,\n      });\n      await GitRefManager.writeRef({\n        fs,\n        gitdir: updatedGitdir,\n        ref,\n        value,\n      });\n    }\n  } catch (err) {\n    err.caller = 'git.writeRef';\n    throw err\n  }\n}\n\n// @ts-check\n\n/**\n * @param {object} args\n * @param {import('../models/FileSystem.js').FileSystem} args.fs\n * @param {string} args.gitdir\n * @param {TagObject} args.tag\n *\n * @returns {Promise<string>}\n */\nasync function _writeTag({ fs, gitdir, tag }) {\n  // Convert object to buffer\n  const object = GitAnnotatedTag.from(tag).toObject();\n  const oid = await _writeObject({\n    fs,\n    gitdir,\n    type: 'tag',\n    object,\n    format: 'content',\n  });\n  return oid\n}\n\n// @ts-check\n\n/**\n * Write an annotated tag object directly\n *\n * @param {object} args\n * @param {FsClient} args.fs - a file system client\n * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path\n * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path\n * @param {TagObject} args.tag - The object to write\n *\n * @returns {Promise<string>} Resolves successfully with the SHA-1 object id of the newly written object\n * @see TagObject\n *\n * @example\n * // Manually create an annotated tag.\n * let sha = await git.resolveRef({ fs, dir: '/tutorial', ref: 'HEAD' })\n * console.log('commit', sha)\n *\n * let oid = await git.writeTag({\n *   fs,\n *   dir: '/tutorial',\n *   tag: {\n *     object: sha,\n *     type: 'commit',\n *     tag: 'my-tag',\n *     tagger: {\n *       name: 'your name',\n *       email: 'email@example.com',\n *       timestamp: Math.floor(Date.now()/1000),\n *       timezoneOffset: new Date().getTimezoneOffset()\n *     },\n *     message: 'Optional message'\n *   }\n * })\n *\n * console.log('tag', oid)\n *\n */\nasync function writeTag({ fs, dir, gitdir = join(dir, '.git'), tag }) {\n  try {\n    assertParameter('fs', fs);\n    assertParameter('gitdir', gitdir);\n    assertParameter('tag', tag);\n\n    const fsp = new FileSystem(fs);\n    const updatedGitdir = await discoverGitdir({ fsp, dotgit: gitdir });\n    return await _writeTag({\n      fs: fsp,\n      gitdir: updatedGitdir,\n      tag,\n    })\n  } catch (err) {\n    err.caller = 'git.writeTag';\n    throw err\n  }\n}\n\n// @ts-check\n\n/**\n * Write a tree object directly\n *\n * @param {object} args\n * @param {FsClient} args.fs - a file system client\n * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path\n * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path\n * @param {TreeObject} args.tree - The object to write\n *\n * @returns {Promise<string>} Resolves successfully with the SHA-1 object id of the newly written object.\n * @see TreeObject\n * @see TreeEntry\n *\n */\nasync function writeTree({ fs, dir, gitdir = join(dir, '.git'), tree }) {\n  try {\n    assertParameter('fs', fs);\n    assertParameter('gitdir', gitdir);\n    assertParameter('tree', tree);\n\n    const fsp = new FileSystem(fs);\n    const updatedGitdir = await discoverGitdir({ fsp, dotgit: gitdir });\n    return await _writeTree({\n      fs: fsp,\n      gitdir: updatedGitdir,\n      tree,\n    })\n  } catch (err) {\n    err.caller = 'git.writeTree';\n    throw err\n  }\n}\n\n// default export\nvar index = {\n  Errors,\n  STAGE,\n  TREE,\n  WORKDIR,\n  add,\n  abortMerge,\n  addNote,\n  addRemote,\n  annotatedTag,\n  branch,\n  checkout,\n  clone,\n  commit,\n  getConfig,\n  getConfigAll,\n  setConfig,\n  currentBranch,\n  deleteBranch,\n  deleteRef,\n  deleteRemote,\n  deleteTag,\n  expandOid,\n  expandRef,\n  fastForward,\n  fetch,\n  findMergeBase,\n  findRoot,\n  getRemoteInfo,\n  getRemoteInfo2,\n  hashBlob,\n  indexPack,\n  init,\n  isDescendent,\n  isIgnored,\n  listBranches,\n  listFiles,\n  listNotes,\n  listRefs,\n  listRemotes,\n  listServerRefs,\n  listTags,\n  log,\n  merge,\n  packObjects,\n  pull,\n  push,\n  readBlob,\n  readCommit,\n  readNote,\n  readObject,\n  readTag,\n  readTree,\n  remove,\n  removeNote,\n  renameBranch,\n  resetIndex,\n  updateIndex: updateIndex$1,\n  resolveRef,\n  status,\n  statusMatrix,\n  tag,\n  version,\n  walk,\n  writeBlob,\n  writeCommit,\n  writeObject,\n  writeRef,\n  writeTag,\n  writeTree,\n  stash,\n};\n\nexports.Errors = Errors;\nexports.STAGE = STAGE;\nexports.TREE = TREE;\nexports.WORKDIR = WORKDIR;\nexports.abortMerge = abortMerge;\nexports.add = add;\nexports.addNote = addNote;\nexports.addRemote = addRemote;\nexports.annotatedTag = annotatedTag;\nexports.branch = branch;\nexports.checkout = checkout;\nexports.clone = clone;\nexports.commit = commit;\nexports.currentBranch = currentBranch;\nexports.default = index;\nexports.deleteBranch = deleteBranch;\nexports.deleteRef = deleteRef;\nexports.deleteRemote = deleteRemote;\nexports.deleteTag = deleteTag;\nexports.expandOid = expandOid;\nexports.expandRef = expandRef;\nexports.fastForward = fastForward;\nexports.fetch = fetch;\nexports.findMergeBase = findMergeBase;\nexports.findRoot = findRoot;\nexports.getConfig = getConfig;\nexports.getConfigAll = getConfigAll;\nexports.getRemoteInfo = getRemoteInfo;\nexports.getRemoteInfo2 = getRemoteInfo2;\nexports.hashBlob = hashBlob;\nexports.indexPack = indexPack;\nexports.init = init;\nexports.isDescendent = isDescendent;\nexports.isIgnored = isIgnored;\nexports.listBranches = listBranches;\nexports.listFiles = listFiles;\nexports.listNotes = listNotes;\nexports.listRefs = listRefs;\nexports.listRemotes = listRemotes;\nexports.listServerRefs = listServerRefs;\nexports.listTags = listTags;\nexports.log = log;\nexports.merge = merge;\nexports.packObjects = packObjects;\nexports.pull = pull;\nexports.push = push;\nexports.readBlob = readBlob;\nexports.readCommit = readCommit;\nexports.readNote = readNote;\nexports.readObject = readObject;\nexports.readTag = readTag;\nexports.readTree = readTree;\nexports.remove = remove;\nexports.removeNote = removeNote;\nexports.renameBranch = renameBranch;\nexports.resetIndex = resetIndex;\nexports.resolveRef = resolveRef;\nexports.setConfig = setConfig;\nexports.stash = stash;\nexports.status = status;\nexports.statusMatrix = statusMatrix;\nexports.tag = tag;\nexports.updateIndex = updateIndex$1;\nexports.version = version;\nexports.walk = walk;\nexports.writeBlob = writeBlob;\nexports.writeCommit = writeCommit;\nexports.writeObject = writeObject;\nexports.writeRef = writeRef;\nexports.writeTag = writeTag;\nexports.writeTree = writeTree;\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 15796, "column": 0}, "map": {"version":3,"sources":["file:///D:/real-time-code-editor%20%282%29/node_modules/.pnpm/isomorphic-git%401.36.0/node_modules/isomorphic-git/http/web/index.js"],"sourcesContent":["/**\n * @typedef {Object} GitProgressEvent\n * @property {string} phase\n * @property {number} loaded\n * @property {number} total\n */\n\n/**\n * @callback ProgressCallback\n * @param {GitProgressEvent} progress\n * @returns {void | Promise<void>}\n */\n\n/**\n * @typedef {Object} GitHttpRequest\n * @property {string} url - The URL to request\n * @property {string} [method='GET'] - The HTTP method to use\n * @property {Object<string, string>} [headers={}] - Headers to include in the HTTP request\n * @property {Object} [agent] - An HTTP or HTTPS agent that manages connections for the HTTP client (Node.js only)\n * @property {AsyncIterableIterator<Uint8Array>} [body] - An async iterator of Uint8Arrays that make up the body of POST requests\n * @property {ProgressCallback} [onProgress] - Reserved for future use (emitting `GitProgressEvent`s)\n * @property {object} [signal] - Reserved for future use (canceling a request)\n */\n\n/**\n * @typedef {Object} GitHttpResponse\n * @property {string} url - The final URL that was fetched after any redirects\n * @property {string} [method] - The HTTP method that was used\n * @property {Object<string, string>} [headers] - HTTP response headers\n * @property {AsyncIterableIterator<Uint8Array>} [body] - An async iterator of Uint8Arrays that make up the body of the response\n * @property {number} statusCode - The HTTP status code\n * @property {string} statusMessage - The HTTP status message\n */\n\n/**\n * @callback HttpFetch\n * @param {GitHttpRequest} request\n * @returns {Promise<GitHttpResponse>}\n */\n\n/**\n * @typedef {Object} HttpClient\n * @property {HttpFetch} request\n */\n\n// Convert a value to an Async Iterator\n// This will be easier with async generator functions.\nfunction fromValue(value) {\n  let queue = [value];\n  return {\n    next() {\n      return Promise.resolve({ done: queue.length === 0, value: queue.pop() })\n    },\n    return() {\n      queue = [];\n      return {}\n    },\n    [Symbol.asyncIterator]() {\n      return this\n    },\n  }\n}\n\nfunction getIterator(iterable) {\n  if (iterable[Symbol.asyncIterator]) {\n    return iterable[Symbol.asyncIterator]()\n  }\n  if (iterable[Symbol.iterator]) {\n    return iterable[Symbol.iterator]()\n  }\n  if (iterable.next) {\n    return iterable\n  }\n  return fromValue(iterable)\n}\n\n// Currently 'for await' upsets my linters.\nasync function forAwait(iterable, cb) {\n  const iter = getIterator(iterable);\n  while (true) {\n    const { value, done } = await iter.next();\n    if (value) await cb(value);\n    if (done) break\n  }\n  if (iter.return) iter.return();\n}\n\nasync function collect(iterable) {\n  let size = 0;\n  const buffers = [];\n  // This will be easier once `for await ... of` loops are available.\n  await forAwait(iterable, value => {\n    buffers.push(value);\n    size += value.byteLength;\n  });\n  const result = new Uint8Array(size);\n  let nextIndex = 0;\n  for (const buffer of buffers) {\n    result.set(buffer, nextIndex);\n    nextIndex += buffer.byteLength;\n  }\n  return result\n}\n\n// Convert a web ReadableStream (not Node stream!) to an Async Iterator\n// adapted from https://jakearchibald.com/2017/async-iterators-and-generators/\nfunction fromStream(stream) {\n  // Use native async iteration if it's available.\n  if (stream[Symbol.asyncIterator]) return stream\n  const reader = stream.getReader();\n  return {\n    next() {\n      return reader.read()\n    },\n    return() {\n      reader.releaseLock();\n      return {}\n    },\n    [Symbol.asyncIterator]() {\n      return this\n    },\n  }\n}\n\n/* eslint-env browser */\n\n/**\n * HttpClient\n *\n * @param {GitHttpRequest} request\n * @returns {Promise<GitHttpResponse>}\n */\nasync function request({\n  onProgress,\n  url,\n  method = 'GET',\n  headers = {},\n  body,\n}) {\n  // streaming uploads aren't possible yet in the browser\n  if (body) {\n    body = await collect(body);\n  }\n  const res = await fetch(url, { method, headers, body });\n  const iter =\n    res.body && res.body.getReader\n      ? fromStream(res.body)\n      : [new Uint8Array(await res.arrayBuffer())];\n  // convert Header object to ordinary JSON\n  headers = {};\n  for (const [key, value] of res.headers.entries()) {\n    headers[key] = value;\n  }\n  return {\n    url: res.url,\n    method: res.method,\n    statusCode: res.status,\n    statusMessage: res.statusText,\n    body: iter,\n    headers,\n  }\n}\n\nvar index = { request };\n\nexport default index;\nexport { request };\n"],"names":[],"mappings":"AAAA;;;;;CAKC,GAED;;;;CAIC,GAED;;;;;;;;;CASC,GAED;;;;;;;;CAQC,GAED;;;;CAIC,GAED;;;CAGC,GAED,uCAAuC;AACvC,sDAAsD;;;;;;;AACtD,SAAS,UAAU,KAAK;IACtB,IAAI,QAAQ;QAAC;KAAM;IACnB,OAAO;QACL;YACE,OAAO,QAAQ,OAAO,CAAC;gBAAE,MAAM,MAAM,MAAM,KAAK;gBAAG,OAAO,MAAM,GAAG;YAAG;QACxE;QACA;YACE,QAAQ,EAAE;YACV,OAAO,CAAC;QACV;QACA,CAAC,OAAO,aAAa,CAAC;YACpB,OAAO,IAAI;QACb;IACF;AACF;AAEA,SAAS,YAAY,QAAQ;IAC3B,IAAI,QAAQ,CAAC,OAAO,aAAa,CAAC,EAAE;QAClC,OAAO,QAAQ,CAAC,OAAO,aAAa,CAAC;IACvC;IACA,IAAI,QAAQ,CAAC,OAAO,QAAQ,CAAC,EAAE;QAC7B,OAAO,QAAQ,CAAC,OAAO,QAAQ,CAAC;IAClC;IACA,IAAI,SAAS,IAAI,EAAE;QACjB,OAAO;IACT;IACA,OAAO,UAAU;AACnB;AAEA,2CAA2C;AAC3C,eAAe,SAAS,QAAQ,EAAE,EAAE;IAClC,MAAM,OAAO,YAAY;IACzB,MAAO,KAAM;QACX,MAAM,EAAE,KAAK,EAAE,IAAI,EAAE,GAAG,MAAM,KAAK,IAAI;QACvC,IAAI,OAAO,MAAM,GAAG;QACpB,IAAI,MAAM;IACZ;IACA,IAAI,KAAK,MAAM,EAAE,KAAK,MAAM;AAC9B;AAEA,eAAe,QAAQ,QAAQ;IAC7B,IAAI,OAAO;IACX,MAAM,UAAU,EAAE;IAClB,mEAAmE;IACnE,MAAM,SAAS,UAAU,CAAA;QACvB,QAAQ,IAAI,CAAC;QACb,QAAQ,MAAM,UAAU;IAC1B;IACA,MAAM,SAAS,IAAI,WAAW;IAC9B,IAAI,YAAY;IAChB,KAAK,MAAM,UAAU,QAAS;QAC5B,OAAO,GAAG,CAAC,QAAQ;QACnB,aAAa,OAAO,UAAU;IAChC;IACA,OAAO;AACT;AAEA,uEAAuE;AACvE,8EAA8E;AAC9E,SAAS,WAAW,MAAM;IACxB,gDAAgD;IAChD,IAAI,MAAM,CAAC,OAAO,aAAa,CAAC,EAAE,OAAO;IACzC,MAAM,SAAS,OAAO,SAAS;IAC/B,OAAO;QACL;YACE,OAAO,OAAO,IAAI;QACpB;QACA;YACE,OAAO,WAAW;YAClB,OAAO,CAAC;QACV;QACA,CAAC,OAAO,aAAa,CAAC;YACpB,OAAO,IAAI;QACb;IACF;AACF;AAEA,sBAAsB,GAEtB;;;;;CAKC,GACD,eAAe,QAAQ,EACrB,UAAU,EACV,GAAG,EACH,SAAS,KAAK,EACd,UAAU,CAAC,CAAC,EACZ,IAAI,EACL;IACC,uDAAuD;IACvD,IAAI,MAAM;QACR,OAAO,MAAM,QAAQ;IACvB;IACA,MAAM,MAAM,MAAM,MAAM,KAAK;QAAE;QAAQ;QAAS;IAAK;IACrD,MAAM,OACJ,IAAI,IAAI,IAAI,IAAI,IAAI,CAAC,SAAS,GAC1B,WAAW,IAAI,IAAI,IACnB;QAAC,IAAI,WAAW,MAAM,IAAI,WAAW;KAAI;IAC/C,yCAAyC;IACzC,UAAU,CAAC;IACX,KAAK,MAAM,CAAC,KAAK,MAAM,IAAI,IAAI,OAAO,CAAC,OAAO,GAAI;QAChD,OAAO,CAAC,IAAI,GAAG;IACjB;IACA,OAAO;QACL,KAAK,IAAI,GAAG;QACZ,QAAQ,IAAI,MAAM;QAClB,YAAY,IAAI,MAAM;QACtB,eAAe,IAAI,UAAU;QAC7B,MAAM;QACN;IACF;AACF;AAEA,IAAI,QAAQ;IAAE;AAAQ;uCAEP","ignoreList":[0]}}]
}