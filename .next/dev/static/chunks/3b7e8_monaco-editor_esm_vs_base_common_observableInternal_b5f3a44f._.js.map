{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///D:/real-time-code-editor%20%282%29/node_modules/.pnpm/monaco-editor%400.55.1/node_modules/monaco-editor/esm/vs/base/common/observableInternal/logging/logging.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nlet globalObservableLogger;\nfunction addLogger(logger) {\n    if (!globalObservableLogger) {\n        globalObservableLogger = logger;\n    }\n    else if (globalObservableLogger instanceof ComposedLogger) {\n        globalObservableLogger.loggers.push(logger);\n    }\n    else {\n        globalObservableLogger = new ComposedLogger([globalObservableLogger, logger]);\n    }\n}\nfunction getLogger() {\n    return globalObservableLogger;\n}\nclass ComposedLogger {\n    constructor(loggers) {\n        this.loggers = loggers;\n    }\n    handleObservableCreated(observable, location) {\n        for (const logger of this.loggers) {\n            logger.handleObservableCreated(observable, location);\n        }\n    }\n    handleOnListenerCountChanged(observable, newCount) {\n        for (const logger of this.loggers) {\n            logger.handleOnListenerCountChanged(observable, newCount);\n        }\n    }\n    handleObservableUpdated(observable, info) {\n        for (const logger of this.loggers) {\n            logger.handleObservableUpdated(observable, info);\n        }\n    }\n    handleAutorunCreated(autorun, location) {\n        for (const logger of this.loggers) {\n            logger.handleAutorunCreated(autorun, location);\n        }\n    }\n    handleAutorunDisposed(autorun) {\n        for (const logger of this.loggers) {\n            logger.handleAutorunDisposed(autorun);\n        }\n    }\n    handleAutorunDependencyChanged(autorun, observable, change) {\n        for (const logger of this.loggers) {\n            logger.handleAutorunDependencyChanged(autorun, observable, change);\n        }\n    }\n    handleAutorunStarted(autorun) {\n        for (const logger of this.loggers) {\n            logger.handleAutorunStarted(autorun);\n        }\n    }\n    handleAutorunFinished(autorun) {\n        for (const logger of this.loggers) {\n            logger.handleAutorunFinished(autorun);\n        }\n    }\n    handleDerivedDependencyChanged(derived, observable, change) {\n        for (const logger of this.loggers) {\n            logger.handleDerivedDependencyChanged(derived, observable, change);\n        }\n    }\n    handleDerivedCleared(observable) {\n        for (const logger of this.loggers) {\n            logger.handleDerivedCleared(observable);\n        }\n    }\n    handleBeginTransaction(transaction) {\n        for (const logger of this.loggers) {\n            logger.handleBeginTransaction(transaction);\n        }\n    }\n    handleEndTransaction(transaction) {\n        for (const logger of this.loggers) {\n            logger.handleEndTransaction(transaction);\n        }\n    }\n}\n\nexport { addLogger, getLogger };\n"],"names":[],"mappings":"AAAA;;;8FAG8F;;;;;;AAC9F,IAAI;AACJ,SAAS,UAAU,MAAM;IACrB,IAAI,CAAC,wBAAwB;QACzB,yBAAyB;IAC7B,OACK,IAAI,kCAAkC,gBAAgB;QACvD,uBAAuB,OAAO,CAAC,IAAI,CAAC;IACxC,OACK;QACD,yBAAyB,IAAI,eAAe;YAAC;YAAwB;SAAO;IAChF;AACJ;AACA,SAAS;IACL,OAAO;AACX;AACA,MAAM;IACF,YAAY,OAAO,CAAE;QACjB,IAAI,CAAC,OAAO,GAAG;IACnB;IACA,wBAAwB,UAAU,EAAE,QAAQ,EAAE;QAC1C,KAAK,MAAM,UAAU,IAAI,CAAC,OAAO,CAAE;YAC/B,OAAO,uBAAuB,CAAC,YAAY;QAC/C;IACJ;IACA,6BAA6B,UAAU,EAAE,QAAQ,EAAE;QAC/C,KAAK,MAAM,UAAU,IAAI,CAAC,OAAO,CAAE;YAC/B,OAAO,4BAA4B,CAAC,YAAY;QACpD;IACJ;IACA,wBAAwB,UAAU,EAAE,IAAI,EAAE;QACtC,KAAK,MAAM,UAAU,IAAI,CAAC,OAAO,CAAE;YAC/B,OAAO,uBAAuB,CAAC,YAAY;QAC/C;IACJ;IACA,qBAAqB,OAAO,EAAE,QAAQ,EAAE;QACpC,KAAK,MAAM,UAAU,IAAI,CAAC,OAAO,CAAE;YAC/B,OAAO,oBAAoB,CAAC,SAAS;QACzC;IACJ;IACA,sBAAsB,OAAO,EAAE;QAC3B,KAAK,MAAM,UAAU,IAAI,CAAC,OAAO,CAAE;YAC/B,OAAO,qBAAqB,CAAC;QACjC;IACJ;IACA,+BAA+B,OAAO,EAAE,UAAU,EAAE,MAAM,EAAE;QACxD,KAAK,MAAM,UAAU,IAAI,CAAC,OAAO,CAAE;YAC/B,OAAO,8BAA8B,CAAC,SAAS,YAAY;QAC/D;IACJ;IACA,qBAAqB,OAAO,EAAE;QAC1B,KAAK,MAAM,UAAU,IAAI,CAAC,OAAO,CAAE;YAC/B,OAAO,oBAAoB,CAAC;QAChC;IACJ;IACA,sBAAsB,OAAO,EAAE;QAC3B,KAAK,MAAM,UAAU,IAAI,CAAC,OAAO,CAAE;YAC/B,OAAO,qBAAqB,CAAC;QACjC;IACJ;IACA,+BAA+B,OAAO,EAAE,UAAU,EAAE,MAAM,EAAE;QACxD,KAAK,MAAM,UAAU,IAAI,CAAC,OAAO,CAAE;YAC/B,OAAO,8BAA8B,CAAC,SAAS,YAAY;QAC/D;IACJ;IACA,qBAAqB,UAAU,EAAE;QAC7B,KAAK,MAAM,UAAU,IAAI,CAAC,OAAO,CAAE;YAC/B,OAAO,oBAAoB,CAAC;QAChC;IACJ;IACA,uBAAuB,WAAW,EAAE;QAChC,KAAK,MAAM,UAAU,IAAI,CAAC,OAAO,CAAE;YAC/B,OAAO,sBAAsB,CAAC;QAClC;IACJ;IACA,qBAAqB,WAAW,EAAE;QAC9B,KAAK,MAAM,UAAU,IAAI,CAAC,OAAO,CAAE;YAC/B,OAAO,oBAAoB,CAAC;QAChC;IACJ;AACJ","ignoreList":[0]}},
    {"offset": {"line": 99, "column": 0}, "map": {"version":3,"sources":["file:///D:/real-time-code-editor%20%282%29/node_modules/.pnpm/monaco-editor%400.55.1/node_modules/monaco-editor/esm/vs/base/common/observableInternal/debugLocation.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar DebugLocation;\n(function (DebugLocation) {\n    let enabled = false;\n    function enable() {\n        enabled = true;\n    }\n    DebugLocation.enable = enable;\n    function ofCaller() {\n        if (!enabled) {\n            return undefined;\n        }\n        // eslint-disable-next-line local/code-no-any-casts\n        const Err = Error; // For the monaco editor checks, which don't have the nodejs types.\n        const l = Err.stackTraceLimit;\n        Err.stackTraceLimit = 3;\n        const stack = new Error().stack;\n        Err.stackTraceLimit = l;\n        return DebugLocationImpl.fromStack(stack, 2);\n    }\n    DebugLocation.ofCaller = ofCaller;\n})(DebugLocation || (DebugLocation = {}));\nclass DebugLocationImpl {\n    static fromStack(stack, parentIdx) {\n        const lines = stack.split('\\n');\n        const location = parseLine(lines[parentIdx + 1]);\n        if (location) {\n            return new DebugLocationImpl(location.fileName, location.line, location.column, location.id);\n        }\n        else {\n            return undefined;\n        }\n    }\n    constructor(fileName, line, column, id) {\n        this.fileName = fileName;\n        this.line = line;\n        this.column = column;\n        this.id = id;\n    }\n}\nfunction parseLine(stackLine) {\n    const match = stackLine.match(/\\((.*):(\\d+):(\\d+)\\)/);\n    if (match) {\n        return {\n            fileName: match[1],\n            line: parseInt(match[2]),\n            column: parseInt(match[3]),\n            id: stackLine,\n        };\n    }\n    const match2 = stackLine.match(/at ([^\\(\\)]*):(\\d+):(\\d+)/);\n    if (match2) {\n        return {\n            fileName: match2[1],\n            line: parseInt(match2[2]),\n            column: parseInt(match2[3]),\n            id: stackLine,\n        };\n    }\n    return undefined;\n}\n\nexport { DebugLocation };\n"],"names":[],"mappings":"AAAA;;;8FAG8F;;;;AAC9F,IAAI;AACJ,CAAC,SAAU,aAAa;IACpB,IAAI,UAAU;IACd,SAAS;QACL,UAAU;IACd;IACA,cAAc,MAAM,GAAG;IACvB,SAAS;QACL,IAAI,CAAC,SAAS;YACV,OAAO;QACX;QACA,mDAAmD;QACnD,MAAM,MAAM,OAAO,mEAAmE;QACtF,MAAM,IAAI,IAAI,eAAe;QAC7B,IAAI,eAAe,GAAG;QACtB,MAAM,QAAQ,IAAI,QAAQ,KAAK;QAC/B,IAAI,eAAe,GAAG;QACtB,OAAO,kBAAkB,SAAS,CAAC,OAAO;IAC9C;IACA,cAAc,QAAQ,GAAG;AAC7B,CAAC,EAAE,iBAAiB,CAAC,gBAAgB,CAAC,CAAC;AACvC,MAAM;IACF,OAAO,UAAU,KAAK,EAAE,SAAS,EAAE;QAC/B,MAAM,QAAQ,MAAM,KAAK,CAAC;QAC1B,MAAM,WAAW,UAAU,KAAK,CAAC,YAAY,EAAE;QAC/C,IAAI,UAAU;YACV,OAAO,IAAI,kBAAkB,SAAS,QAAQ,EAAE,SAAS,IAAI,EAAE,SAAS,MAAM,EAAE,SAAS,EAAE;QAC/F,OACK;YACD,OAAO;QACX;IACJ;IACA,YAAY,QAAQ,EAAE,IAAI,EAAE,MAAM,EAAE,EAAE,CAAE;QACpC,IAAI,CAAC,QAAQ,GAAG;QAChB,IAAI,CAAC,IAAI,GAAG;QACZ,IAAI,CAAC,MAAM,GAAG;QACd,IAAI,CAAC,EAAE,GAAG;IACd;AACJ;AACA,SAAS,UAAU,SAAS;IACxB,MAAM,QAAQ,UAAU,KAAK,CAAC;IAC9B,IAAI,OAAO;QACP,OAAO;YACH,UAAU,KAAK,CAAC,EAAE;YAClB,MAAM,SAAS,KAAK,CAAC,EAAE;YACvB,QAAQ,SAAS,KAAK,CAAC,EAAE;YACzB,IAAI;QACR;IACJ;IACA,MAAM,SAAS,UAAU,KAAK,CAAC;IAC/B,IAAI,QAAQ;QACR,OAAO;YACH,UAAU,MAAM,CAAC,EAAE;YACnB,MAAM,SAAS,MAAM,CAAC,EAAE;YACxB,QAAQ,SAAS,MAAM,CAAC,EAAE;YAC1B,IAAI;QACR;IACJ;IACA,OAAO;AACX","ignoreList":[0]}},
    {"offset": {"line": 170, "column": 0}, "map": {"version":3,"sources":["file:///D:/real-time-code-editor%20%282%29/node_modules/.pnpm/monaco-editor%400.55.1/node_modules/monaco-editor/esm/vs/base/common/observableInternal/debugName.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nclass DebugNameData {\n    constructor(owner, debugNameSource, referenceFn) {\n        this.owner = owner;\n        this.debugNameSource = debugNameSource;\n        this.referenceFn = referenceFn;\n    }\n    getDebugName(target) {\n        return getDebugName(target, this);\n    }\n}\nconst countPerName = new Map();\nconst cachedDebugName = new WeakMap();\nfunction getDebugName(target, data) {\n    const cached = cachedDebugName.get(target);\n    if (cached) {\n        return cached;\n    }\n    const dbgName = computeDebugName(target, data);\n    if (dbgName) {\n        let count = countPerName.get(dbgName) ?? 0;\n        count++;\n        countPerName.set(dbgName, count);\n        const result = count === 1 ? dbgName : `${dbgName}#${count}`;\n        cachedDebugName.set(target, result);\n        return result;\n    }\n    return undefined;\n}\nfunction computeDebugName(self, data) {\n    const cached = cachedDebugName.get(self);\n    if (cached) {\n        return cached;\n    }\n    const ownerStr = data.owner ? formatOwner(data.owner) + `.` : '';\n    let result;\n    const debugNameSource = data.debugNameSource;\n    if (debugNameSource !== undefined) {\n        if (typeof debugNameSource === 'function') {\n            result = debugNameSource();\n            if (result !== undefined) {\n                return ownerStr + result;\n            }\n        }\n        else {\n            return ownerStr + debugNameSource;\n        }\n    }\n    const referenceFn = data.referenceFn;\n    if (referenceFn !== undefined) {\n        result = getFunctionName(referenceFn);\n        if (result !== undefined) {\n            return ownerStr + result;\n        }\n    }\n    if (data.owner !== undefined) {\n        const key = findKey(data.owner, self);\n        if (key !== undefined) {\n            return ownerStr + key;\n        }\n    }\n    return undefined;\n}\nfunction findKey(obj, value) {\n    for (const key in obj) {\n        // eslint-disable-next-line local/code-no-any-casts\n        if (obj[key] === value) {\n            return key;\n        }\n    }\n    return undefined;\n}\nconst countPerClassName = new Map();\nconst ownerId = new WeakMap();\nfunction formatOwner(owner) {\n    const id = ownerId.get(owner);\n    if (id) {\n        return id;\n    }\n    const className = getClassName(owner) ?? 'Object';\n    let count = countPerClassName.get(className) ?? 0;\n    count++;\n    countPerClassName.set(className, count);\n    const result = count === 1 ? className : `${className}#${count}`;\n    ownerId.set(owner, result);\n    return result;\n}\nfunction getClassName(obj) {\n    const ctor = obj.constructor;\n    if (ctor) {\n        if (ctor.name === 'Object') {\n            return undefined;\n        }\n        return ctor.name;\n    }\n    return undefined;\n}\nfunction getFunctionName(fn) {\n    const fnSrc = fn.toString();\n    // Pattern: /** @description ... */\n    const regexp = /\\/\\*\\*\\s*@description\\s*([^*]*)\\*\\//;\n    const match = regexp.exec(fnSrc);\n    const result = match ? match[1] : undefined;\n    return result?.trim();\n}\n\nexport { DebugNameData, getClassName, getDebugName, getFunctionName };\n"],"names":[],"mappings":"AAAA;;;8FAG8F;;;;;;;;;;AAC9F,MAAM;IACF,YAAY,KAAK,EAAE,eAAe,EAAE,WAAW,CAAE;QAC7C,IAAI,CAAC,KAAK,GAAG;QACb,IAAI,CAAC,eAAe,GAAG;QACvB,IAAI,CAAC,WAAW,GAAG;IACvB;IACA,aAAa,MAAM,EAAE;QACjB,OAAO,aAAa,QAAQ,IAAI;IACpC;AACJ;AACA,MAAM,eAAe,IAAI;AACzB,MAAM,kBAAkB,IAAI;AAC5B,SAAS,aAAa,MAAM,EAAE,IAAI;IAC9B,MAAM,SAAS,gBAAgB,GAAG,CAAC;IACnC,IAAI,QAAQ;QACR,OAAO;IACX;IACA,MAAM,UAAU,iBAAiB,QAAQ;IACzC,IAAI,SAAS;QACT,IAAI,QAAQ,aAAa,GAAG,CAAC,YAAY;QACzC;QACA,aAAa,GAAG,CAAC,SAAS;QAC1B,MAAM,SAAS,UAAU,IAAI,UAAU,GAAG,QAAQ,CAAC,EAAE,OAAO;QAC5D,gBAAgB,GAAG,CAAC,QAAQ;QAC5B,OAAO;IACX;IACA,OAAO;AACX;AACA,SAAS,iBAAiB,IAAI,EAAE,IAAI;IAChC,MAAM,SAAS,gBAAgB,GAAG,CAAC;IACnC,IAAI,QAAQ;QACR,OAAO;IACX;IACA,MAAM,WAAW,KAAK,KAAK,GAAG,YAAY,KAAK,KAAK,IAAI,CAAC,CAAC,CAAC,GAAG;IAC9D,IAAI;IACJ,MAAM,kBAAkB,KAAK,eAAe;IAC5C,IAAI,oBAAoB,WAAW;QAC/B,IAAI,OAAO,oBAAoB,YAAY;YACvC,SAAS;YACT,IAAI,WAAW,WAAW;gBACtB,OAAO,WAAW;YACtB;QACJ,OACK;YACD,OAAO,WAAW;QACtB;IACJ;IACA,MAAM,cAAc,KAAK,WAAW;IACpC,IAAI,gBAAgB,WAAW;QAC3B,SAAS,gBAAgB;QACzB,IAAI,WAAW,WAAW;YACtB,OAAO,WAAW;QACtB;IACJ;IACA,IAAI,KAAK,KAAK,KAAK,WAAW;QAC1B,MAAM,MAAM,QAAQ,KAAK,KAAK,EAAE;QAChC,IAAI,QAAQ,WAAW;YACnB,OAAO,WAAW;QACtB;IACJ;IACA,OAAO;AACX;AACA,SAAS,QAAQ,GAAG,EAAE,KAAK;IACvB,IAAK,MAAM,OAAO,IAAK;QACnB,mDAAmD;QACnD,IAAI,GAAG,CAAC,IAAI,KAAK,OAAO;YACpB,OAAO;QACX;IACJ;IACA,OAAO;AACX;AACA,MAAM,oBAAoB,IAAI;AAC9B,MAAM,UAAU,IAAI;AACpB,SAAS,YAAY,KAAK;IACtB,MAAM,KAAK,QAAQ,GAAG,CAAC;IACvB,IAAI,IAAI;QACJ,OAAO;IACX;IACA,MAAM,YAAY,aAAa,UAAU;IACzC,IAAI,QAAQ,kBAAkB,GAAG,CAAC,cAAc;IAChD;IACA,kBAAkB,GAAG,CAAC,WAAW;IACjC,MAAM,SAAS,UAAU,IAAI,YAAY,GAAG,UAAU,CAAC,EAAE,OAAO;IAChE,QAAQ,GAAG,CAAC,OAAO;IACnB,OAAO;AACX;AACA,SAAS,aAAa,GAAG;IACrB,MAAM,OAAO,IAAI,WAAW;IAC5B,IAAI,MAAM;QACN,IAAI,KAAK,IAAI,KAAK,UAAU;YACxB,OAAO;QACX;QACA,OAAO,KAAK,IAAI;IACpB;IACA,OAAO;AACX;AACA,SAAS,gBAAgB,EAAE;IACvB,MAAM,QAAQ,GAAG,QAAQ;IACzB,mCAAmC;IACnC,MAAM,SAAS;IACf,MAAM,QAAQ,OAAO,IAAI,CAAC;IAC1B,MAAM,SAAS,QAAQ,KAAK,CAAC,EAAE,GAAG;IAClC,OAAO,QAAQ;AACnB","ignoreList":[0]}},
    {"offset": {"line": 291, "column": 0}, "map": {"version":3,"sources":["file:///D:/real-time-code-editor%20%282%29/node_modules/.pnpm/monaco-editor%400.55.1/node_modules/monaco-editor/esm/vs/base/common/observableInternal/observables/baseObservable.js"],"sourcesContent":["import { DebugLocation } from '../debugLocation.js';\nimport { getFunctionName } from '../debugName.js';\nimport { getLogger } from '../logging/logging.js';\n\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nlet _derived;\n/**\n * @internal\n * This is to allow splitting files.\n*/\nfunction _setDerivedOpts(derived) {\n    _derived = derived;\n}\nlet _recomputeInitiallyAndOnChange;\nfunction _setRecomputeInitiallyAndOnChange(recomputeInitiallyAndOnChange) {\n    _recomputeInitiallyAndOnChange = recomputeInitiallyAndOnChange;\n}\nclass ConvenientObservable {\n    get TChange() { return null; }\n    reportChanges() {\n        this.get();\n    }\n    /** @sealed */\n    read(reader) {\n        if (reader) {\n            return reader.readObservable(this);\n        }\n        else {\n            return this.get();\n        }\n    }\n    map(fnOrOwner, fnOrUndefined, debugLocation = DebugLocation.ofCaller()) {\n        const owner = fnOrUndefined === undefined ? undefined : fnOrOwner;\n        const fn = fnOrUndefined === undefined ? fnOrOwner : fnOrUndefined;\n        return _derived({\n            owner,\n            debugName: () => {\n                const name = getFunctionName(fn);\n                if (name !== undefined) {\n                    return name;\n                }\n                // regexp to match `x => x.y` or `x => x?.y` where x and y can be arbitrary identifiers (uses backref):\n                const regexp = /^\\s*\\(?\\s*([a-zA-Z_$][a-zA-Z_$0-9]*)\\s*\\)?\\s*=>\\s*\\1(?:\\??)\\.([a-zA-Z_$][a-zA-Z_$0-9]*)\\s*$/;\n                const match = regexp.exec(fn.toString());\n                if (match) {\n                    return `${this.debugName}.${match[2]}`;\n                }\n                if (!owner) {\n                    return `${this.debugName} (mapped)`;\n                }\n                return undefined;\n            },\n            debugReferenceFn: fn,\n        }, (reader) => fn(this.read(reader), reader), debugLocation);\n    }\n    /**\n     * @sealed\n     * Converts an observable of an observable value into a direct observable of the value.\n    */\n    flatten() {\n        return _derived({\n            owner: undefined,\n            debugName: () => `${this.debugName} (flattened)`,\n        }, (reader) => this.read(reader).read(reader));\n    }\n    recomputeInitiallyAndOnChange(store, handleValue) {\n        store.add(_recomputeInitiallyAndOnChange(this, handleValue));\n        return this;\n    }\n}\nclass BaseObservable extends ConvenientObservable {\n    constructor(debugLocation) {\n        super();\n        this._observers = new Set();\n        getLogger()?.handleObservableCreated(this, debugLocation);\n    }\n    addObserver(observer) {\n        const len = this._observers.size;\n        this._observers.add(observer);\n        if (len === 0) {\n            this.onFirstObserverAdded();\n        }\n        if (len !== this._observers.size) {\n            getLogger()?.handleOnListenerCountChanged(this, this._observers.size);\n        }\n    }\n    removeObserver(observer) {\n        const deleted = this._observers.delete(observer);\n        if (deleted && this._observers.size === 0) {\n            this.onLastObserverRemoved();\n        }\n        if (deleted) {\n            getLogger()?.handleOnListenerCountChanged(this, this._observers.size);\n        }\n    }\n    onFirstObserverAdded() { }\n    onLastObserverRemoved() { }\n    debugGetObservers() {\n        return this._observers;\n    }\n}\n\nexport { BaseObservable, ConvenientObservable, _setDerivedOpts, _setRecomputeInitiallyAndOnChange };\n"],"names":[],"mappings":";;;;;;;;;;AAAA;AACA;AACA;;;;AAEA;;;8FAG8F,GAC9F,IAAI;AACJ;;;AAGA,GACA,SAAS,gBAAgB,OAAO;IAC5B,WAAW;AACf;AACA,IAAI;AACJ,SAAS,kCAAkC,6BAA6B;IACpE,iCAAiC;AACrC;AACA,MAAM;IACF,IAAI,UAAU;QAAE,OAAO;IAAM;IAC7B,gBAAgB;QACZ,IAAI,CAAC,GAAG;IACZ;IACA,YAAY,GACZ,KAAK,MAAM,EAAE;QACT,IAAI,QAAQ;YACR,OAAO,OAAO,cAAc,CAAC,IAAI;QACrC,OACK;YACD,OAAO,IAAI,CAAC,GAAG;QACnB;IACJ;IACA,IAAI,SAAS,EAAE,aAAa,EAAE,gBAAgB,wRAAa,CAAC,QAAQ,EAAE,EAAE;QACpE,MAAM,QAAQ,kBAAkB,YAAY,YAAY;QACxD,MAAM,KAAK,kBAAkB,YAAY,YAAY;QACrD,OAAO,SAAS;YACZ;YACA,WAAW;gBACP,MAAM,OAAO,IAAA,sRAAe,EAAC;gBAC7B,IAAI,SAAS,WAAW;oBACpB,OAAO;gBACX;gBACA,uGAAuG;gBACvG,MAAM,SAAS;gBACf,MAAM,QAAQ,OAAO,IAAI,CAAC,GAAG,QAAQ;gBACrC,IAAI,OAAO;oBACP,OAAO,GAAG,IAAI,CAAC,SAAS,CAAC,CAAC,EAAE,KAAK,CAAC,EAAE,EAAE;gBAC1C;gBACA,IAAI,CAAC,OAAO;oBACR,OAAO,GAAG,IAAI,CAAC,SAAS,CAAC,SAAS,CAAC;gBACvC;gBACA,OAAO;YACX;YACA,kBAAkB;QACtB,GAAG,CAAC,SAAW,GAAG,IAAI,CAAC,IAAI,CAAC,SAAS,SAAS;IAClD;IACA;;;IAGA,GACA,UAAU;QACN,OAAO,SAAS;YACZ,OAAO;YACP,WAAW,IAAM,GAAG,IAAI,CAAC,SAAS,CAAC,YAAY,CAAC;QACpD,GAAG,CAAC,SAAW,IAAI,CAAC,IAAI,CAAC,QAAQ,IAAI,CAAC;IAC1C;IACA,8BAA8B,KAAK,EAAE,WAAW,EAAE;QAC9C,MAAM,GAAG,CAAC,+BAA+B,IAAI,EAAE;QAC/C,OAAO,IAAI;IACf;AACJ;AACA,MAAM,uBAAuB;IACzB,YAAY,aAAa,CAAE;QACvB,KAAK;QACL,IAAI,CAAC,UAAU,GAAG,IAAI;QACtB,IAAA,yRAAS,KAAI,wBAAwB,IAAI,EAAE;IAC/C;IACA,YAAY,QAAQ,EAAE;QAClB,MAAM,MAAM,IAAI,CAAC,UAAU,CAAC,IAAI;QAChC,IAAI,CAAC,UAAU,CAAC,GAAG,CAAC;QACpB,IAAI,QAAQ,GAAG;YACX,IAAI,CAAC,oBAAoB;QAC7B;QACA,IAAI,QAAQ,IAAI,CAAC,UAAU,CAAC,IAAI,EAAE;YAC9B,IAAA,yRAAS,KAAI,6BAA6B,IAAI,EAAE,IAAI,CAAC,UAAU,CAAC,IAAI;QACxE;IACJ;IACA,eAAe,QAAQ,EAAE;QACrB,MAAM,UAAU,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC;QACvC,IAAI,WAAW,IAAI,CAAC,UAAU,CAAC,IAAI,KAAK,GAAG;YACvC,IAAI,CAAC,qBAAqB;QAC9B;QACA,IAAI,SAAS;YACT,IAAA,yRAAS,KAAI,6BAA6B,IAAI,EAAE,IAAI,CAAC,UAAU,CAAC,IAAI;QACxE;IACJ;IACA,uBAAuB,CAAE;IACzB,wBAAwB,CAAE;IAC1B,oBAAoB;QAChB,OAAO,IAAI,CAAC,UAAU;IAC1B;AACJ","ignoreList":[0]}},
    {"offset": {"line": 409, "column": 0}, "map": {"version":3,"sources":["file:///D:/real-time-code-editor%20%282%29/node_modules/.pnpm/monaco-editor%400.55.1/node_modules/monaco-editor/esm/vs/base/common/observableInternal/observables/derivedImpl.js"],"sourcesContent":["import { BaseObservable } from './baseObservable.js';\nimport { assertFn } from '../../assert.js';\nimport '../../arrays.js';\nimport { onBugIndicatingError, BugIndicatingError } from '../../errors.js';\nimport '../../event.js';\nimport { DisposableStore } from '../../lifecycle.js';\nimport { getLogger } from '../logging/logging.js';\n\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nfunction derivedStateToString(state) {\n    switch (state) {\n        case 0 /* DerivedState.initial */: return 'initial';\n        case 1 /* DerivedState.dependenciesMightHaveChanged */: return 'dependenciesMightHaveChanged';\n        case 2 /* DerivedState.stale */: return 'stale';\n        case 3 /* DerivedState.upToDate */: return 'upToDate';\n        default: return '<unknown>';\n    }\n}\nclass Derived extends BaseObservable {\n    get debugName() {\n        return this._debugNameData.getDebugName(this) ?? '(anonymous)';\n    }\n    constructor(_debugNameData, _computeFn, _changeTracker, _handleLastObserverRemoved = undefined, _equalityComparator, debugLocation) {\n        super(debugLocation);\n        this._debugNameData = _debugNameData;\n        this._computeFn = _computeFn;\n        this._changeTracker = _changeTracker;\n        this._handleLastObserverRemoved = _handleLastObserverRemoved;\n        this._equalityComparator = _equalityComparator;\n        this._state = 0 /* DerivedState.initial */;\n        this._value = undefined;\n        this._updateCount = 0;\n        this._dependencies = new Set();\n        this._dependenciesToBeRemoved = new Set();\n        this._changeSummary = undefined;\n        this._isUpdating = false;\n        this._isComputing = false;\n        this._didReportChange = false;\n        this._isInBeforeUpdate = false;\n        this._isReaderValid = false;\n        this._store = undefined;\n        this._delayedStore = undefined;\n        this._removedObserverToCallEndUpdateOn = null;\n        this._changeSummary = this._changeTracker?.createChangeSummary(undefined);\n    }\n    onLastObserverRemoved() {\n        /**\n         * We are not tracking changes anymore, thus we have to assume\n         * that our cache is invalid.\n         */\n        this._state = 0 /* DerivedState.initial */;\n        this._value = undefined;\n        getLogger()?.handleDerivedCleared(this);\n        for (const d of this._dependencies) {\n            d.removeObserver(this);\n        }\n        this._dependencies.clear();\n        if (this._store !== undefined) {\n            this._store.dispose();\n            this._store = undefined;\n        }\n        if (this._delayedStore !== undefined) {\n            this._delayedStore.dispose();\n            this._delayedStore = undefined;\n        }\n        this._handleLastObserverRemoved?.();\n    }\n    get() {\n        const checkEnabled = false; // TODO set to true\n        if (this._isComputing && checkEnabled) ;\n        if (this._observers.size === 0) {\n            let result;\n            // Without observers, we don't know when to clean up stuff.\n            // Thus, we don't cache anything to prevent memory leaks.\n            try {\n                this._isReaderValid = true;\n                let changeSummary = undefined;\n                if (this._changeTracker) {\n                    changeSummary = this._changeTracker.createChangeSummary(undefined);\n                    this._changeTracker.beforeUpdate?.(this, changeSummary);\n                }\n                result = this._computeFn(this, changeSummary);\n            }\n            finally {\n                this._isReaderValid = false;\n            }\n            // Clear new dependencies\n            this.onLastObserverRemoved();\n            return result;\n        }\n        else {\n            do {\n                // We might not get a notification for a dependency that changed while it is updating,\n                // thus we also have to ask all our depedencies if they changed in this case.\n                if (this._state === 1 /* DerivedState.dependenciesMightHaveChanged */) {\n                    for (const d of this._dependencies) {\n                        /** might call {@link handleChange} indirectly, which could make us stale */\n                        d.reportChanges();\n                        if (this._state === 2 /* DerivedState.stale */) {\n                            // The other dependencies will refresh on demand, so early break\n                            break;\n                        }\n                    }\n                }\n                // We called report changes of all dependencies.\n                // If we are still not stale, we can assume to be up to date again.\n                if (this._state === 1 /* DerivedState.dependenciesMightHaveChanged */) {\n                    this._state = 3 /* DerivedState.upToDate */;\n                }\n                if (this._state !== 3 /* DerivedState.upToDate */) {\n                    this._recompute();\n                }\n                // In case recomputation changed one of our dependencies, we need to recompute again.\n            } while (this._state !== 3 /* DerivedState.upToDate */);\n            return this._value;\n        }\n    }\n    _recompute() {\n        let didChange = false;\n        this._isComputing = true;\n        this._didReportChange = false;\n        const emptySet = this._dependenciesToBeRemoved;\n        this._dependenciesToBeRemoved = this._dependencies;\n        this._dependencies = emptySet;\n        try {\n            const changeSummary = this._changeSummary;\n            this._isReaderValid = true;\n            if (this._changeTracker) {\n                this._isInBeforeUpdate = true;\n                this._changeTracker.beforeUpdate?.(this, changeSummary);\n                this._isInBeforeUpdate = false;\n                this._changeSummary = this._changeTracker?.createChangeSummary(changeSummary);\n            }\n            const hadValue = this._state !== 0 /* DerivedState.initial */;\n            const oldValue = this._value;\n            this._state = 3 /* DerivedState.upToDate */;\n            const delayedStore = this._delayedStore;\n            if (delayedStore !== undefined) {\n                this._delayedStore = undefined;\n            }\n            try {\n                if (this._store !== undefined) {\n                    this._store.dispose();\n                    this._store = undefined;\n                }\n                /** might call {@link handleChange} indirectly, which could invalidate us */\n                this._value = this._computeFn(this, changeSummary);\n            }\n            finally {\n                this._isReaderValid = false;\n                // We don't want our observed observables to think that they are (not even temporarily) not being observed.\n                // Thus, we only unsubscribe from observables that are definitely not read anymore.\n                for (const o of this._dependenciesToBeRemoved) {\n                    o.removeObserver(this);\n                }\n                this._dependenciesToBeRemoved.clear();\n                if (delayedStore !== undefined) {\n                    delayedStore.dispose();\n                }\n            }\n            didChange = this._didReportChange || (hadValue && !(this._equalityComparator(oldValue, this._value)));\n            getLogger()?.handleObservableUpdated(this, {\n                oldValue,\n                newValue: this._value,\n                change: undefined,\n                didChange,\n                hadValue,\n            });\n        }\n        catch (e) {\n            onBugIndicatingError(e);\n        }\n        this._isComputing = false;\n        if (!this._didReportChange && didChange) {\n            for (const r of this._observers) {\n                r.handleChange(this, undefined);\n            }\n        }\n        else {\n            this._didReportChange = false;\n        }\n    }\n    toString() {\n        return `LazyDerived<${this.debugName}>`;\n    }\n    // IObserver Implementation\n    beginUpdate(_observable) {\n        if (this._isUpdating) {\n            throw new BugIndicatingError('Cyclic deriveds are not supported yet!');\n        }\n        this._updateCount++;\n        this._isUpdating = true;\n        try {\n            const propagateBeginUpdate = this._updateCount === 1;\n            if (this._state === 3 /* DerivedState.upToDate */) {\n                this._state = 1 /* DerivedState.dependenciesMightHaveChanged */;\n                // If we propagate begin update, that will already signal a possible change.\n                if (!propagateBeginUpdate) {\n                    for (const r of this._observers) {\n                        r.handlePossibleChange(this);\n                    }\n                }\n            }\n            if (propagateBeginUpdate) {\n                for (const r of this._observers) {\n                    r.beginUpdate(this); // This signals a possible change\n                }\n            }\n        }\n        finally {\n            this._isUpdating = false;\n        }\n    }\n    endUpdate(_observable) {\n        this._updateCount--;\n        if (this._updateCount === 0) {\n            // End update could change the observer list.\n            const observers = [...this._observers];\n            for (const r of observers) {\n                r.endUpdate(this);\n            }\n            if (this._removedObserverToCallEndUpdateOn) {\n                const observers = [...this._removedObserverToCallEndUpdateOn];\n                this._removedObserverToCallEndUpdateOn = null;\n                for (const r of observers) {\n                    r.endUpdate(this);\n                }\n            }\n        }\n        assertFn(() => this._updateCount >= 0);\n    }\n    handlePossibleChange(observable) {\n        // In all other states, observers already know that we might have changed.\n        if (this._state === 3 /* DerivedState.upToDate */ && this._dependencies.has(observable) && !this._dependenciesToBeRemoved.has(observable)) {\n            this._state = 1 /* DerivedState.dependenciesMightHaveChanged */;\n            for (const r of this._observers) {\n                r.handlePossibleChange(this);\n            }\n        }\n    }\n    handleChange(observable, change) {\n        if (this._dependencies.has(observable) && !this._dependenciesToBeRemoved.has(observable) || this._isInBeforeUpdate) {\n            getLogger()?.handleDerivedDependencyChanged(this, observable, change);\n            let shouldReact = false;\n            try {\n                shouldReact = this._changeTracker ? this._changeTracker.handleChange({\n                    changedObservable: observable,\n                    change,\n                    // eslint-disable-next-line local/code-no-any-casts\n                    didChange: (o) => o === observable,\n                }, this._changeSummary) : true;\n            }\n            catch (e) {\n                onBugIndicatingError(e);\n            }\n            const wasUpToDate = this._state === 3 /* DerivedState.upToDate */;\n            if (shouldReact && (this._state === 1 /* DerivedState.dependenciesMightHaveChanged */ || wasUpToDate)) {\n                this._state = 2 /* DerivedState.stale */;\n                if (wasUpToDate) {\n                    for (const r of this._observers) {\n                        r.handlePossibleChange(this);\n                    }\n                }\n            }\n        }\n    }\n    // IReader Implementation\n    _ensureReaderValid() {\n        if (!this._isReaderValid) {\n            throw new BugIndicatingError('The reader object cannot be used outside its compute function!');\n        }\n    }\n    readObservable(observable) {\n        this._ensureReaderValid();\n        // Subscribe before getting the value to enable caching\n        observable.addObserver(this);\n        /** This might call {@link handleChange} indirectly, which could invalidate us */\n        const value = observable.get();\n        // Which is why we only add the observable to the dependencies now.\n        this._dependencies.add(observable);\n        this._dependenciesToBeRemoved.delete(observable);\n        return value;\n    }\n    get store() {\n        this._ensureReaderValid();\n        if (this._store === undefined) {\n            this._store = new DisposableStore();\n        }\n        return this._store;\n    }\n    addObserver(observer) {\n        const shouldCallBeginUpdate = !this._observers.has(observer) && this._updateCount > 0;\n        super.addObserver(observer);\n        if (shouldCallBeginUpdate) {\n            if (this._removedObserverToCallEndUpdateOn && this._removedObserverToCallEndUpdateOn.has(observer)) {\n                this._removedObserverToCallEndUpdateOn.delete(observer);\n            }\n            else {\n                observer.beginUpdate(this);\n            }\n        }\n    }\n    removeObserver(observer) {\n        if (this._observers.has(observer) && this._updateCount > 0) {\n            if (!this._removedObserverToCallEndUpdateOn) {\n                this._removedObserverToCallEndUpdateOn = new Set();\n            }\n            this._removedObserverToCallEndUpdateOn.add(observer);\n        }\n        super.removeObserver(observer);\n    }\n    debugGetState() {\n        return {\n            state: this._state,\n            stateStr: derivedStateToString(this._state),\n            updateCount: this._updateCount,\n            isComputing: this._isComputing,\n            dependencies: this._dependencies,\n            value: this._value,\n        };\n    }\n    debugSetValue(newValue) {\n        // eslint-disable-next-line local/code-no-any-casts\n        this._value = newValue;\n    }\n    debugRecompute() {\n        if (!this._isComputing) {\n            this._recompute();\n        }\n        else {\n            this._state = 2 /* DerivedState.stale */;\n        }\n    }\n    setValue(newValue, tx, change) {\n        this._value = newValue;\n        const observers = this._observers;\n        tx.updateObserver(this, this);\n        for (const d of observers) {\n            d.handleChange(this, change);\n        }\n    }\n}\nclass DerivedWithSetter extends Derived {\n    constructor(debugNameData, computeFn, changeTracker, handleLastObserverRemoved = undefined, equalityComparator, set, debugLocation) {\n        super(debugNameData, computeFn, changeTracker, handleLastObserverRemoved, equalityComparator, debugLocation);\n        this.set = set;\n    }\n}\n\nexport { Derived, DerivedWithSetter };\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 771, "column": 0}, "map": {"version":3,"sources":["file:///D:/real-time-code-editor%20%282%29/node_modules/.pnpm/monaco-editor%400.55.1/node_modules/monaco-editor/esm/vs/base/common/observableInternal/observables/derived.js"],"sourcesContent":["import { strictEquals } from '../../equals.js';\nimport '../../event.js';\nimport { DisposableStore } from '../../lifecycle.js';\nimport { DebugLocation } from '../debugLocation.js';\nimport { DebugNameData } from '../debugName.js';\nimport { _setDerivedOpts } from './baseObservable.js';\nimport { Derived, DerivedWithSetter } from './derivedImpl.js';\n\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nfunction derived(computeFnOrOwner, computeFn, debugLocation = DebugLocation.ofCaller()) {\n    if (computeFn !== undefined) {\n        return new Derived(new DebugNameData(computeFnOrOwner, undefined, computeFn), computeFn, undefined, undefined, strictEquals, debugLocation);\n    }\n    return new Derived(\n    // eslint-disable-next-line local/code-no-any-casts\n    new DebugNameData(undefined, undefined, computeFnOrOwner), \n    // eslint-disable-next-line local/code-no-any-casts\n    computeFnOrOwner, undefined, undefined, strictEquals, debugLocation);\n}\nfunction derivedWithSetter(owner, computeFn, setter, debugLocation = DebugLocation.ofCaller()) {\n    return new DerivedWithSetter(new DebugNameData(owner, undefined, computeFn), computeFn, undefined, undefined, strictEquals, setter, debugLocation);\n}\nfunction derivedOpts(options, computeFn, debugLocation = DebugLocation.ofCaller()) {\n    return new Derived(new DebugNameData(options.owner, options.debugName, options.debugReferenceFn), computeFn, undefined, options.onLastObserverRemoved, options.equalsFn ?? strictEquals, debugLocation);\n}\n_setDerivedOpts(derivedOpts);\n/**\n * Represents an observable that is derived from other observables.\n * The value is only recomputed when absolutely needed.\n *\n * {@link computeFn} should start with a JS Doc using `@description` to name the derived.\n *\n * Use `createEmptyChangeSummary` to create a \"change summary\" that can collect the changes.\n * Use `handleChange` to add a reported change to the change summary.\n * The compute function is given the last change summary.\n * The change summary is discarded after the compute function was called.\n *\n * @see derived\n */\nfunction derivedHandleChanges(options, computeFn, debugLocation = DebugLocation.ofCaller()) {\n    return new Derived(new DebugNameData(options.owner, options.debugName, undefined), computeFn, options.changeTracker, undefined, options.equalityComparer ?? strictEquals, debugLocation);\n}\nfunction derivedDisposable(computeFnOrOwner, computeFnOrUndefined, debugLocation = DebugLocation.ofCaller()) {\n    let computeFn;\n    let owner;\n    if (computeFnOrUndefined === undefined) {\n        // eslint-disable-next-line local/code-no-any-casts\n        computeFn = computeFnOrOwner;\n        owner = undefined;\n    }\n    else {\n        owner = computeFnOrOwner;\n        // eslint-disable-next-line local/code-no-any-casts\n        computeFn = computeFnOrUndefined;\n    }\n    let store = undefined;\n    return new Derived(new DebugNameData(owner, undefined, computeFn), r => {\n        if (!store) {\n            store = new DisposableStore();\n        }\n        else {\n            store.clear();\n        }\n        const result = computeFn(r);\n        if (result) {\n            store.add(result);\n        }\n        return result;\n    }, undefined, () => {\n        if (store) {\n            store.dispose();\n            store = undefined;\n        }\n    }, strictEquals, debugLocation);\n}\n\nexport { derived, derivedDisposable, derivedHandleChanges, derivedOpts, derivedWithSetter };\n"],"names":[],"mappings":";;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAEA;;;8FAG8F,GAC9F,SAAS,QAAQ,gBAAgB,EAAE,SAAS,EAAE,gBAAgB,wRAAa,CAAC,QAAQ,EAAE;IAClF,IAAI,cAAc,WAAW;QACzB,OAAO,IAAI,+RAAO,CAAC,IAAI,oRAAa,CAAC,kBAAkB,WAAW,YAAY,WAAW,WAAW,WAAW,0PAAY,EAAE;IACjI;IACA,OAAO,IAAI,+RAAO,CAClB,mDAAmD;IACnD,IAAI,oRAAa,CAAC,WAAW,WAAW,mBACxC,mDAAmD;IACnD,kBAAkB,WAAW,WAAW,0PAAY,EAAE;AAC1D;AACA,SAAS,kBAAkB,KAAK,EAAE,SAAS,EAAE,MAAM,EAAE,gBAAgB,wRAAa,CAAC,QAAQ,EAAE;IACzF,OAAO,IAAI,ySAAiB,CAAC,IAAI,oRAAa,CAAC,OAAO,WAAW,YAAY,WAAW,WAAW,WAAW,0PAAY,EAAE,QAAQ;AACxI;AACA,SAAS,YAAY,OAAO,EAAE,SAAS,EAAE,gBAAgB,wRAAa,CAAC,QAAQ,EAAE;IAC7E,OAAO,IAAI,+RAAO,CAAC,IAAI,oRAAa,CAAC,QAAQ,KAAK,EAAE,QAAQ,SAAS,EAAE,QAAQ,gBAAgB,GAAG,WAAW,WAAW,QAAQ,qBAAqB,EAAE,QAAQ,QAAQ,IAAI,0PAAY,EAAE;AAC7L;AACA,IAAA,0SAAe,EAAC;AAChB;;;;;;;;;;;;CAYC,GACD,SAAS,qBAAqB,OAAO,EAAE,SAAS,EAAE,gBAAgB,wRAAa,CAAC,QAAQ,EAAE;IACtF,OAAO,IAAI,+RAAO,CAAC,IAAI,oRAAa,CAAC,QAAQ,KAAK,EAAE,QAAQ,SAAS,EAAE,YAAY,WAAW,QAAQ,aAAa,EAAE,WAAW,QAAQ,gBAAgB,IAAI,0PAAY,EAAE;AAC9K;AACA,SAAS,kBAAkB,gBAAgB,EAAE,oBAAoB,EAAE,gBAAgB,wRAAa,CAAC,QAAQ,EAAE;IACvG,IAAI;IACJ,IAAI;IACJ,IAAI,yBAAyB,WAAW;QACpC,mDAAmD;QACnD,YAAY;QACZ,QAAQ;IACZ,OACK;QACD,QAAQ;QACR,mDAAmD;QACnD,YAAY;IAChB;IACA,IAAI,QAAQ;IACZ,OAAO,IAAI,+RAAO,CAAC,IAAI,oRAAa,CAAC,OAAO,WAAW,YAAY,CAAA;QAC/D,IAAI,CAAC,OAAO;YACR,QAAQ,IAAI,gQAAe;QAC/B,OACK;YACD,MAAM,KAAK;QACf;QACA,MAAM,SAAS,UAAU;QACzB,IAAI,QAAQ;YACR,MAAM,GAAG,CAAC;QACd;QACA,OAAO;IACX,GAAG,WAAW;QACV,IAAI,OAAO;YACP,MAAM,OAAO;YACb,QAAQ;QACZ;IACJ,GAAG,0PAAY,EAAE;AACrB","ignoreList":[0]}},
    {"offset": {"line": 866, "column": 0}, "map": {"version":3,"sources":["file:///D:/real-time-code-editor%20%282%29/node_modules/.pnpm/monaco-editor%400.55.1/node_modules/monaco-editor/esm/vs/base/common/observableInternal/reactions/autorunImpl.js"],"sourcesContent":["import { assertFn } from '../../assert.js';\nimport '../../arrays.js';\nimport { onBugIndicatingError, BugIndicatingError } from '../../errors.js';\nimport '../../event.js';\nimport { DisposableStore } from '../../lifecycle.js';\nimport { getLogger } from '../logging/logging.js';\n\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nfunction autorunStateToString(state) {\n    switch (state) {\n        case 1 /* AutorunState.dependenciesMightHaveChanged */: return 'dependenciesMightHaveChanged';\n        case 2 /* AutorunState.stale */: return 'stale';\n        case 3 /* AutorunState.upToDate */: return 'upToDate';\n        default: return '<unknown>';\n    }\n}\nclass AutorunObserver {\n    get debugName() {\n        return this._debugNameData.getDebugName(this) ?? '(anonymous)';\n    }\n    constructor(_debugNameData, _runFn, _changeTracker, debugLocation) {\n        this._debugNameData = _debugNameData;\n        this._runFn = _runFn;\n        this._changeTracker = _changeTracker;\n        this._state = 2 /* AutorunState.stale */;\n        this._updateCount = 0;\n        this._disposed = false;\n        this._dependencies = new Set();\n        this._dependenciesToBeRemoved = new Set();\n        this._isRunning = false;\n        this._store = undefined;\n        this._delayedStore = undefined;\n        this._changeSummary = this._changeTracker?.createChangeSummary(undefined);\n        getLogger()?.handleAutorunCreated(this, debugLocation);\n        this._run();\n    }\n    dispose() {\n        if (this._disposed) {\n            return;\n        }\n        this._disposed = true;\n        for (const o of this._dependencies) {\n            o.removeObserver(this); // Warning: external call!\n        }\n        this._dependencies.clear();\n        if (this._store !== undefined) {\n            this._store.dispose();\n        }\n        if (this._delayedStore !== undefined) {\n            this._delayedStore.dispose();\n        }\n        getLogger()?.handleAutorunDisposed(this);\n    }\n    _run() {\n        const emptySet = this._dependenciesToBeRemoved;\n        this._dependenciesToBeRemoved = this._dependencies;\n        this._dependencies = emptySet;\n        this._state = 3 /* AutorunState.upToDate */;\n        try {\n            if (!this._disposed) {\n                getLogger()?.handleAutorunStarted(this);\n                const changeSummary = this._changeSummary;\n                const delayedStore = this._delayedStore;\n                if (delayedStore !== undefined) {\n                    this._delayedStore = undefined;\n                }\n                try {\n                    this._isRunning = true;\n                    if (this._changeTracker) {\n                        this._changeTracker.beforeUpdate?.(this, changeSummary);\n                        this._changeSummary = this._changeTracker.createChangeSummary(changeSummary); // Warning: external call!\n                    }\n                    if (this._store !== undefined) {\n                        this._store.dispose();\n                        this._store = undefined;\n                    }\n                    this._runFn(this, changeSummary); // Warning: external call!\n                }\n                catch (e) {\n                    onBugIndicatingError(e);\n                }\n                finally {\n                    this._isRunning = false;\n                    if (delayedStore !== undefined) {\n                        delayedStore.dispose();\n                    }\n                }\n            }\n        }\n        finally {\n            if (!this._disposed) {\n                getLogger()?.handleAutorunFinished(this);\n            }\n            // We don't want our observed observables to think that they are (not even temporarily) not being observed.\n            // Thus, we only unsubscribe from observables that are definitely not read anymore.\n            for (const o of this._dependenciesToBeRemoved) {\n                o.removeObserver(this); // Warning: external call!\n            }\n            this._dependenciesToBeRemoved.clear();\n        }\n    }\n    toString() {\n        return `Autorun<${this.debugName}>`;\n    }\n    // IObserver implementation\n    beginUpdate(_observable) {\n        if (this._state === 3 /* AutorunState.upToDate */) {\n            this._state = 1 /* AutorunState.dependenciesMightHaveChanged */;\n        }\n        this._updateCount++;\n    }\n    endUpdate(_observable) {\n        try {\n            if (this._updateCount === 1) {\n                do {\n                    if (this._state === 1 /* AutorunState.dependenciesMightHaveChanged */) {\n                        this._state = 3 /* AutorunState.upToDate */;\n                        for (const d of this._dependencies) {\n                            d.reportChanges(); // Warning: external call!\n                            if (this._state === 2 /* AutorunState.stale */) {\n                                // The other dependencies will refresh on demand\n                                break;\n                            }\n                        }\n                    }\n                    if (this._state !== 3 /* AutorunState.upToDate */) {\n                        this._run(); // Warning: indirect external call!\n                    }\n                } while (this._state !== 3 /* AutorunState.upToDate */);\n            }\n        }\n        finally {\n            this._updateCount--;\n        }\n        assertFn(() => this._updateCount >= 0);\n    }\n    handlePossibleChange(observable) {\n        if (this._state === 3 /* AutorunState.upToDate */ && this._isDependency(observable)) {\n            this._state = 1 /* AutorunState.dependenciesMightHaveChanged */;\n        }\n    }\n    handleChange(observable, change) {\n        if (this._isDependency(observable)) {\n            getLogger()?.handleAutorunDependencyChanged(this, observable, change);\n            try {\n                // Warning: external call!\n                const shouldReact = this._changeTracker ? this._changeTracker.handleChange({\n                    changedObservable: observable,\n                    change,\n                    // eslint-disable-next-line local/code-no-any-casts\n                    didChange: (o) => o === observable,\n                }, this._changeSummary) : true;\n                if (shouldReact) {\n                    this._state = 2 /* AutorunState.stale */;\n                }\n            }\n            catch (e) {\n                onBugIndicatingError(e);\n            }\n        }\n    }\n    _isDependency(observable) {\n        return this._dependencies.has(observable) && !this._dependenciesToBeRemoved.has(observable);\n    }\n    // IReader implementation\n    _ensureNoRunning() {\n        if (!this._isRunning) {\n            throw new BugIndicatingError('The reader object cannot be used outside its compute function!');\n        }\n    }\n    readObservable(observable) {\n        this._ensureNoRunning();\n        // In case the run action disposes the autorun\n        if (this._disposed) {\n            return observable.get(); // warning: external call!\n        }\n        observable.addObserver(this); // warning: external call!\n        const value = observable.get(); // warning: external call!\n        this._dependencies.add(observable);\n        this._dependenciesToBeRemoved.delete(observable);\n        return value;\n    }\n    get store() {\n        this._ensureNoRunning();\n        if (this._disposed) {\n            throw new BugIndicatingError('Cannot access store after dispose');\n        }\n        if (this._store === undefined) {\n            this._store = new DisposableStore();\n        }\n        return this._store;\n    }\n    debugGetState() {\n        return {\n            isRunning: this._isRunning,\n            updateCount: this._updateCount,\n            dependencies: this._dependencies,\n            state: this._state,\n            stateStr: autorunStateToString(this._state),\n        };\n    }\n    debugRerun() {\n        if (!this._isRunning) {\n            this._run();\n        }\n        else {\n            this._state = 2 /* AutorunState.stale */;\n        }\n    }\n}\n\nexport { AutorunObserver };\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1089, "column": 0}, "map": {"version":3,"sources":["file:///D:/real-time-code-editor%20%282%29/node_modules/.pnpm/monaco-editor%400.55.1/node_modules/monaco-editor/esm/vs/base/common/observableInternal/reactions/autorun.js"],"sourcesContent":["import '../../arrays.js';\nimport '../../event.js';\nimport { toDisposable, DisposableStore } from '../../lifecycle.js';\nimport { DebugNameData } from '../debugName.js';\nimport { AutorunObserver } from './autorunImpl.js';\nimport { DebugLocation } from '../debugLocation.js';\n\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n/**\n * Runs immediately and whenever a transaction ends and an observed observable changed.\n * {@link fn} should start with a JS Doc using `@description` to name the autorun.\n */\nfunction autorun(fn, debugLocation = DebugLocation.ofCaller()) {\n    return new AutorunObserver(new DebugNameData(undefined, undefined, fn), fn, undefined, debugLocation);\n}\n/**\n * Runs immediately and whenever a transaction ends and an observed observable changed.\n * {@link fn} should start with a JS Doc using `@description` to name the autorun.\n */\nfunction autorunOpts(options, fn, debugLocation = DebugLocation.ofCaller()) {\n    return new AutorunObserver(new DebugNameData(options.owner, options.debugName, options.debugReferenceFn ?? fn), fn, undefined, debugLocation);\n}\n/**\n * Runs immediately and whenever a transaction ends and an observed observable changed.\n * {@link fn} should start with a JS Doc using `@description` to name the autorun.\n *\n * Use `changeTracker.createChangeSummary` to create a \"change summary\" that can collect the changes.\n * Use `changeTracker.handleChange` to add a reported change to the change summary.\n * The run function is given the last change summary.\n * The change summary is discarded after the run function was called.\n *\n * @see autorun\n */\nfunction autorunHandleChanges(options, fn, debugLocation = DebugLocation.ofCaller()) {\n    return new AutorunObserver(new DebugNameData(options.owner, options.debugName, options.debugReferenceFn ?? fn), fn, options.changeTracker, debugLocation);\n}\n/**\n * @see autorunHandleChanges (but with a disposable store that is cleared before the next run or on dispose)\n */\nfunction autorunWithStoreHandleChanges(options, fn) {\n    const store = new DisposableStore();\n    const disposable = autorunHandleChanges({\n        owner: options.owner,\n        debugName: options.debugName,\n        debugReferenceFn: options.debugReferenceFn ?? fn,\n        changeTracker: options.changeTracker,\n    }, (reader, changeSummary) => {\n        store.clear();\n        fn(reader, changeSummary, store);\n    });\n    return toDisposable(() => {\n        disposable.dispose();\n        store.dispose();\n    });\n}\n/**\n * @see autorun (but with a disposable store that is cleared before the next run or on dispose)\n *\n * @deprecated Use `autorun(reader => { reader.store.add(...) })` instead!\n */\nfunction autorunWithStore(fn) {\n    const store = new DisposableStore();\n    const disposable = autorunOpts({\n        owner: undefined,\n        debugName: undefined,\n        debugReferenceFn: fn,\n    }, reader => {\n        store.clear();\n        fn(reader, store);\n    });\n    return toDisposable(() => {\n        disposable.dispose();\n        store.dispose();\n    });\n}\nfunction autorunDelta(observable, handler) {\n    let _lastValue;\n    return autorunOpts({ debugReferenceFn: handler }, (reader) => {\n        const newValue = observable.read(reader);\n        const lastValue = _lastValue;\n        _lastValue = newValue;\n        handler({ lastValue, newValue });\n    });\n}\n\nexport { autorun, autorunDelta, autorunHandleChanges, autorunOpts, autorunWithStore, autorunWithStoreHandleChanges };\n"],"names":[],"mappings":";;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAEA;;;8FAG8F,GAC9F;;;CAGC,GACD,SAAS,QAAQ,EAAE,EAAE,gBAAgB,wRAAa,CAAC,QAAQ,EAAE;IACzD,OAAO,IAAI,qSAAe,CAAC,IAAI,oRAAa,CAAC,WAAW,WAAW,KAAK,IAAI,WAAW;AAC3F;AACA;;;CAGC,GACD,SAAS,YAAY,OAAO,EAAE,EAAE,EAAE,gBAAgB,wRAAa,CAAC,QAAQ,EAAE;IACtE,OAAO,IAAI,qSAAe,CAAC,IAAI,oRAAa,CAAC,QAAQ,KAAK,EAAE,QAAQ,SAAS,EAAE,QAAQ,gBAAgB,IAAI,KAAK,IAAI,WAAW;AACnI;AACA;;;;;;;;;;CAUC,GACD,SAAS,qBAAqB,OAAO,EAAE,EAAE,EAAE,gBAAgB,wRAAa,CAAC,QAAQ,EAAE;IAC/E,OAAO,IAAI,qSAAe,CAAC,IAAI,oRAAa,CAAC,QAAQ,KAAK,EAAE,QAAQ,SAAS,EAAE,QAAQ,gBAAgB,IAAI,KAAK,IAAI,QAAQ,aAAa,EAAE;AAC/I;AACA;;CAEC,GACD,SAAS,8BAA8B,OAAO,EAAE,EAAE;IAC9C,MAAM,QAAQ,IAAI,gQAAe;IACjC,MAAM,aAAa,qBAAqB;QACpC,OAAO,QAAQ,KAAK;QACpB,WAAW,QAAQ,SAAS;QAC5B,kBAAkB,QAAQ,gBAAgB,IAAI;QAC9C,eAAe,QAAQ,aAAa;IACxC,GAAG,CAAC,QAAQ;QACR,MAAM,KAAK;QACX,GAAG,QAAQ,eAAe;IAC9B;IACA,OAAO,IAAA,6PAAY,EAAC;QAChB,WAAW,OAAO;QAClB,MAAM,OAAO;IACjB;AACJ;AACA;;;;CAIC,GACD,SAAS,iBAAiB,EAAE;IACxB,MAAM,QAAQ,IAAI,gQAAe;IACjC,MAAM,aAAa,YAAY;QAC3B,OAAO;QACP,WAAW;QACX,kBAAkB;IACtB,GAAG,CAAA;QACC,MAAM,KAAK;QACX,GAAG,QAAQ;IACf;IACA,OAAO,IAAA,6PAAY,EAAC;QAChB,WAAW,OAAO;QAClB,MAAM,OAAO;IACjB;AACJ;AACA,SAAS,aAAa,UAAU,EAAE,OAAO;IACrC,IAAI;IACJ,OAAO,YAAY;QAAE,kBAAkB;IAAQ,GAAG,CAAC;QAC/C,MAAM,WAAW,WAAW,IAAI,CAAC;QACjC,MAAM,YAAY;QAClB,aAAa;QACb,QAAQ;YAAE;YAAW;QAAS;IAClC;AACJ","ignoreList":[0]}},
    {"offset": {"line": 1199, "column": 0}, "map": {"version":3,"sources":["file:///D:/real-time-code-editor%20%282%29/node_modules/.pnpm/monaco-editor%400.55.1/node_modules/monaco-editor/esm/vs/base/common/observableInternal/base.js"],"sourcesContent":["import { onUnexpectedError } from '../errors.js';\nimport '../arrays.js';\nimport '../event.js';\nimport '../lifecycle.js';\n\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n/**\n * This function is used to indicate that the caller recovered from an error that indicates a bug.\n*/\nfunction handleBugIndicatingErrorRecovery(message) {\n    const err = new Error('BugIndicatingErrorRecovery: ' + message);\n    onUnexpectedError(err);\n    console.error('recovered from an error that indicates a bug', err);\n}\n\nexport { handleBugIndicatingErrorRecovery };\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;AACA;;;;;AAEA;;;8FAG8F,GAC9F;;AAEA,GACA,SAAS,iCAAiC,OAAO;IAC7C,MAAM,MAAM,IAAI,MAAM,iCAAiC;IACvD,IAAA,+PAAiB,EAAC;IAClB,QAAQ,KAAK,CAAC,gDAAgD;AAClE","ignoreList":[0]}},
    {"offset": {"line": 1226, "column": 0}, "map": {"version":3,"sources":["file:///D:/real-time-code-editor%20%282%29/node_modules/.pnpm/monaco-editor%400.55.1/node_modules/monaco-editor/esm/vs/base/common/observableInternal/transaction.js"],"sourcesContent":["import { handleBugIndicatingErrorRecovery } from './base.js';\nimport { getFunctionName } from './debugName.js';\nimport { getLogger } from './logging/logging.js';\n\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n/**\n * Starts a transaction in which many observables can be changed at once.\n * {@link fn} should start with a JS Doc using `@description` to give the transaction a debug name.\n * Reaction run on demand or when the transaction ends.\n */\nfunction transaction(fn, getDebugName) {\n    const tx = new TransactionImpl(fn, getDebugName);\n    try {\n        fn(tx);\n    }\n    finally {\n        tx.finish();\n    }\n}\nlet _globalTransaction = undefined;\nfunction globalTransaction(fn) {\n    if (_globalTransaction) {\n        fn(_globalTransaction);\n    }\n    else {\n        const tx = new TransactionImpl(fn, undefined);\n        _globalTransaction = tx;\n        try {\n            fn(tx);\n        }\n        finally {\n            tx.finish(); // During finish, more actions might be added to the transaction.\n            // Which is why we only clear the global transaction after finish.\n            _globalTransaction = undefined;\n        }\n    }\n}\n/** @deprecated */\nasync function asyncTransaction(fn, getDebugName) {\n    const tx = new TransactionImpl(fn, getDebugName);\n    try {\n        await fn(tx);\n    }\n    finally {\n        tx.finish();\n    }\n}\n/**\n * Allows to chain transactions.\n */\nfunction subtransaction(tx, fn, getDebugName) {\n    if (!tx) {\n        transaction(fn, getDebugName);\n    }\n    else {\n        fn(tx);\n    }\n}\nclass TransactionImpl {\n    constructor(_fn, _getDebugName) {\n        this._fn = _fn;\n        this._getDebugName = _getDebugName;\n        this._updatingObservers = [];\n        getLogger()?.handleBeginTransaction(this);\n    }\n    getDebugName() {\n        if (this._getDebugName) {\n            return this._getDebugName();\n        }\n        return getFunctionName(this._fn);\n    }\n    updateObserver(observer, observable) {\n        if (!this._updatingObservers) {\n            // This happens when a transaction is used in a callback or async function.\n            // If an async transaction is used, make sure the promise awaits all users of the transaction (e.g. no race).\n            handleBugIndicatingErrorRecovery('Transaction already finished!');\n            // Error recovery\n            transaction(tx => {\n                tx.updateObserver(observer, observable);\n            });\n            return;\n        }\n        // When this gets called while finish is active, they will still get considered\n        this._updatingObservers.push({ observer, observable });\n        observer.beginUpdate(observable);\n    }\n    finish() {\n        const updatingObservers = this._updatingObservers;\n        if (!updatingObservers) {\n            handleBugIndicatingErrorRecovery('transaction.finish() has already been called!');\n            return;\n        }\n        for (let i = 0; i < updatingObservers.length; i++) {\n            const { observer, observable } = updatingObservers[i];\n            observer.endUpdate(observable);\n        }\n        // Prevent anyone from updating observers from now on.\n        this._updatingObservers = null;\n        getLogger()?.handleEndTransaction(this);\n    }\n    debugGetUpdatingObservers() {\n        return this._updatingObservers;\n    }\n}\n\nexport { TransactionImpl, asyncTransaction, globalTransaction, subtransaction, transaction };\n"],"names":[],"mappings":";;;;;;;;;;;;AAAA;AACA;AACA;;;;AAEA;;;8FAG8F,GAC9F;;;;CAIC,GACD,SAAS,YAAY,EAAE,EAAE,YAAY;IACjC,MAAM,KAAK,IAAI,gBAAgB,IAAI;IACnC,IAAI;QACA,GAAG;IACP,SACQ;QACJ,GAAG,MAAM;IACb;AACJ;AACA,IAAI,qBAAqB;AACzB,SAAS,kBAAkB,EAAE;IACzB,IAAI,oBAAoB;QACpB,GAAG;IACP,OACK;QACD,MAAM,KAAK,IAAI,gBAAgB,IAAI;QACnC,qBAAqB;QACrB,IAAI;YACA,GAAG;QACP,SACQ;YACJ,GAAG,MAAM,IAAI,iEAAiE;YAC9E,kEAAkE;YAClE,qBAAqB;QACzB;IACJ;AACJ;AACA,gBAAgB,GAChB,eAAe,iBAAiB,EAAE,EAAE,YAAY;IAC5C,MAAM,KAAK,IAAI,gBAAgB,IAAI;IACnC,IAAI;QACA,MAAM,GAAG;IACb,SACQ;QACJ,GAAG,MAAM;IACb;AACJ;AACA;;CAEC,GACD,SAAS,eAAe,EAAE,EAAE,EAAE,EAAE,YAAY;IACxC,IAAI,CAAC,IAAI;QACL,YAAY,IAAI;IACpB,OACK;QACD,GAAG;IACP;AACJ;AACA,MAAM;IACF,YAAY,GAAG,EAAE,aAAa,CAAE;QAC5B,IAAI,CAAC,GAAG,GAAG;QACX,IAAI,CAAC,aAAa,GAAG;QACrB,IAAI,CAAC,kBAAkB,GAAG,EAAE;QAC5B,IAAA,yRAAS,KAAI,uBAAuB,IAAI;IAC5C;IACA,eAAe;QACX,IAAI,IAAI,CAAC,aAAa,EAAE;YACpB,OAAO,IAAI,CAAC,aAAa;QAC7B;QACA,OAAO,IAAA,sRAAe,EAAC,IAAI,CAAC,GAAG;IACnC;IACA,eAAe,QAAQ,EAAE,UAAU,EAAE;QACjC,IAAI,CAAC,IAAI,CAAC,kBAAkB,EAAE;YAC1B,2EAA2E;YAC3E,6GAA6G;YAC7G,IAAA,kSAAgC,EAAC;YACjC,iBAAiB;YACjB,YAAY,CAAA;gBACR,GAAG,cAAc,CAAC,UAAU;YAChC;YACA;QACJ;QACA,+EAA+E;QAC/E,IAAI,CAAC,kBAAkB,CAAC,IAAI,CAAC;YAAE;YAAU;QAAW;QACpD,SAAS,WAAW,CAAC;IACzB;IACA,SAAS;QACL,MAAM,oBAAoB,IAAI,CAAC,kBAAkB;QACjD,IAAI,CAAC,mBAAmB;YACpB,IAAA,kSAAgC,EAAC;YACjC;QACJ;QACA,IAAK,IAAI,IAAI,GAAG,IAAI,kBAAkB,MAAM,EAAE,IAAK;YAC/C,MAAM,EAAE,QAAQ,EAAE,UAAU,EAAE,GAAG,iBAAiB,CAAC,EAAE;YACrD,SAAS,SAAS,CAAC;QACvB;QACA,sDAAsD;QACtD,IAAI,CAAC,kBAAkB,GAAG;QAC1B,IAAA,yRAAS,KAAI,qBAAqB,IAAI;IAC1C;IACA,4BAA4B;QACxB,OAAO,IAAI,CAAC,kBAAkB;IAClC;AACJ","ignoreList":[0]}},
    {"offset": {"line": 1346, "column": 0}, "map": {"version":3,"sources":["file:///D:/real-time-code-editor%20%282%29/node_modules/.pnpm/monaco-editor%400.55.1/node_modules/monaco-editor/esm/vs/base/common/observableInternal/observables/observableFromEvent.js"],"sourcesContent":["import { subtransaction } from '../transaction.js';\nimport { strictEquals } from '../../equals.js';\nimport '../../event.js';\nimport '../../lifecycle.js';\nimport { DebugNameData } from '../debugName.js';\nimport { getLogger } from '../logging/logging.js';\nimport { BaseObservable } from './baseObservable.js';\nimport { DebugLocation } from '../debugLocation.js';\n\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nfunction observableFromEvent(...args) {\n    let owner;\n    let event;\n    let getValue;\n    let debugLocation;\n    if (args.length === 2) {\n        [event, getValue] = args;\n    }\n    else {\n        [owner, event, getValue, debugLocation] = args;\n    }\n    return new FromEventObservable(new DebugNameData(owner, undefined, getValue), event, getValue, () => FromEventObservable.globalTransaction, strictEquals, debugLocation ?? DebugLocation.ofCaller());\n}\nfunction observableFromEventOpts(options, event, getValue, debugLocation = DebugLocation.ofCaller()) {\n    return new FromEventObservable(new DebugNameData(options.owner, options.debugName, options.debugReferenceFn ?? getValue), event, getValue, () => FromEventObservable.globalTransaction, options.equalsFn ?? strictEquals, debugLocation);\n}\nclass FromEventObservable extends BaseObservable {\n    constructor(_debugNameData, event, _getValue, _getTransaction, _equalityComparator, debugLocation) {\n        super(debugLocation);\n        this._debugNameData = _debugNameData;\n        this.event = event;\n        this._getValue = _getValue;\n        this._getTransaction = _getTransaction;\n        this._equalityComparator = _equalityComparator;\n        this._hasValue = false;\n        this.handleEvent = (args) => {\n            const newValue = this._getValue(args);\n            const oldValue = this._value;\n            const didChange = !this._hasValue || !(this._equalityComparator(oldValue, newValue));\n            let didRunTransaction = false;\n            if (didChange) {\n                this._value = newValue;\n                if (this._hasValue) {\n                    didRunTransaction = true;\n                    subtransaction(this._getTransaction(), (tx) => {\n                        getLogger()?.handleObservableUpdated(this, { oldValue, newValue, change: undefined, didChange, hadValue: this._hasValue });\n                        for (const o of this._observers) {\n                            tx.updateObserver(o, this);\n                            o.handleChange(this, undefined);\n                        }\n                    }, () => {\n                        const name = this.getDebugName();\n                        return 'Event fired' + (name ? `: ${name}` : '');\n                    });\n                }\n                this._hasValue = true;\n            }\n            if (!didRunTransaction) {\n                getLogger()?.handleObservableUpdated(this, { oldValue, newValue, change: undefined, didChange, hadValue: this._hasValue });\n            }\n        };\n    }\n    getDebugName() {\n        return this._debugNameData.getDebugName(this);\n    }\n    get debugName() {\n        const name = this.getDebugName();\n        return 'From Event' + (name ? `: ${name}` : '');\n    }\n    onFirstObserverAdded() {\n        this._subscription = this.event(this.handleEvent);\n    }\n    onLastObserverRemoved() {\n        this._subscription.dispose();\n        this._subscription = undefined;\n        this._hasValue = false;\n        this._value = undefined;\n    }\n    get() {\n        if (this._subscription) {\n            if (!this._hasValue) {\n                this.handleEvent(undefined);\n            }\n            return this._value;\n        }\n        else {\n            // no cache, as there are no subscribers to keep it updated\n            const value = this._getValue(undefined);\n            return value;\n        }\n    }\n    debugSetValue(value) {\n        // eslint-disable-next-line local/code-no-any-casts\n        this._value = value;\n    }\n    debugGetState() {\n        return { value: this._value, hasValue: this._hasValue };\n    }\n}\n(function (observableFromEvent) {\n    observableFromEvent.Observer = FromEventObservable;\n    function batchEventsGlobally(tx, fn) {\n        let didSet = false;\n        if (FromEventObservable.globalTransaction === undefined) {\n            FromEventObservable.globalTransaction = tx;\n            didSet = true;\n        }\n        try {\n            fn();\n        }\n        finally {\n            if (didSet) {\n                FromEventObservable.globalTransaction = undefined;\n            }\n        }\n    }\n    observableFromEvent.batchEventsGlobally = batchEventsGlobally;\n})(observableFromEvent || (observableFromEvent = {}));\n\nexport { FromEventObservable, observableFromEvent, observableFromEventOpts };\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1498, "column": 0}, "map": {"version":3,"sources":["file:///D:/real-time-code-editor%20%282%29/node_modules/.pnpm/monaco-editor%400.55.1/node_modules/monaco-editor/esm/vs/base/common/observableInternal/utils/utils.js"],"sourcesContent":["import { autorun } from '../reactions/autorun.js';\nimport '../../arrays.js';\nimport '../../event.js';\nimport { toDisposable, DisposableStore } from '../../lifecycle.js';\nimport { derivedOpts } from '../observables/derived.js';\nimport { observableFromEvent } from '../observables/observableFromEvent.js';\nimport { _setRecomputeInitiallyAndOnChange } from '../observables/baseObservable.js';\nimport '../debugLocation.js';\n\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n/**\n * Creates an observable that debounces the input observable.\n */\nfunction debouncedObservable(observable, debounceMs) {\n    let hasValue = false;\n    let lastValue;\n    let timeout = undefined;\n    return observableFromEvent(cb => {\n        const d = autorun(reader => {\n            const value = observable.read(reader);\n            if (!hasValue) {\n                hasValue = true;\n                lastValue = value;\n            }\n            else {\n                if (timeout) {\n                    clearTimeout(timeout);\n                }\n                timeout = setTimeout(() => {\n                    lastValue = value;\n                    cb();\n                }, debounceMs);\n            }\n        });\n        return {\n            dispose() {\n                d.dispose();\n                hasValue = false;\n                lastValue = undefined;\n            },\n        };\n    }, () => {\n        if (hasValue) {\n            return lastValue;\n        }\n        else {\n            return observable.get();\n        }\n    });\n}\n/**\n * This converts the given observable into an autorun.\n */\nfunction recomputeInitiallyAndOnChange(observable, handleValue) {\n    const o = new KeepAliveObserver(true, handleValue);\n    observable.addObserver(o);\n    try {\n        o.beginUpdate(observable);\n    }\n    finally {\n        o.endUpdate(observable);\n    }\n    return toDisposable(() => {\n        observable.removeObserver(o);\n    });\n}\n_setRecomputeInitiallyAndOnChange(recomputeInitiallyAndOnChange);\nclass KeepAliveObserver {\n    constructor(_forceRecompute, _handleValue) {\n        this._forceRecompute = _forceRecompute;\n        this._handleValue = _handleValue;\n        this._counter = 0;\n    }\n    beginUpdate(observable) {\n        this._counter++;\n    }\n    endUpdate(observable) {\n        if (this._counter === 1 && this._forceRecompute) {\n            if (this._handleValue) {\n                this._handleValue(observable.get());\n            }\n            else {\n                observable.reportChanges();\n            }\n        }\n        this._counter--;\n    }\n    handlePossibleChange(observable) {\n        // NO OP\n    }\n    handleChange(observable, change) {\n        // NO OP\n    }\n}\nfunction derivedObservableWithCache(owner, computeFn) {\n    let lastValue = undefined;\n    const observable = derivedOpts({ owner, debugReferenceFn: computeFn }, reader => {\n        lastValue = computeFn(reader, lastValue);\n        return lastValue;\n    });\n    return observable;\n}\n/**\n * When the items array changes, referential equal items are not mapped again.\n */\nfunction mapObservableArrayCached(owner, items, map, keySelector) {\n    let m = new ArrayMap(map, keySelector);\n    const self = derivedOpts({\n        debugReferenceFn: map,\n        owner,\n        onLastObserverRemoved: () => {\n            m.dispose();\n            m = new ArrayMap(map);\n        }\n    }, (reader) => {\n        m.setItems(items.read(reader));\n        return m.getItems();\n    });\n    return self;\n}\nclass ArrayMap {\n    constructor(_map, _keySelector) {\n        this._map = _map;\n        this._keySelector = _keySelector;\n        this._cache = new Map();\n        this._items = [];\n    }\n    dispose() {\n        this._cache.forEach(entry => entry.store.dispose());\n        this._cache.clear();\n    }\n    setItems(items) {\n        const newItems = [];\n        const itemsToRemove = new Set(this._cache.keys());\n        for (const item of items) {\n            const key = this._keySelector ? this._keySelector(item) : item;\n            let entry = this._cache.get(key);\n            if (!entry) {\n                const store = new DisposableStore();\n                const out = this._map(item, store);\n                entry = { out, store };\n                this._cache.set(key, entry);\n            }\n            else {\n                itemsToRemove.delete(key);\n            }\n            newItems.push(entry.out);\n        }\n        for (const item of itemsToRemove) {\n            const entry = this._cache.get(item);\n            entry.store.dispose();\n            this._cache.delete(item);\n        }\n        this._items = newItems;\n    }\n    getItems() {\n        return this._items;\n    }\n}\n\nexport { KeepAliveObserver, debouncedObservable, derivedObservableWithCache, mapObservableArrayCached, recomputeInitiallyAndOnChange };\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1681, "column": 0}, "map": {"version":3,"sources":["file:///D:/real-time-code-editor%20%282%29/node_modules/.pnpm/monaco-editor%400.55.1/node_modules/monaco-editor/esm/vs/base/common/observableInternal/logging/consoleObservableLogger.js"],"sourcesContent":["import { getClassName } from '../debugName.js';\nimport '../debugLocation.js';\nimport '../../arrays.js';\nimport '../../event.js';\nimport '../../lifecycle.js';\n\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nfunction formatValue(value, availableLen) {\n    switch (typeof value) {\n        case 'number':\n            return '' + value;\n        case 'string':\n            if (value.length + 2 <= availableLen) {\n                return `\"${value}\"`;\n            }\n            return `\"${value.substr(0, availableLen - 7)}\"+...`;\n        case 'boolean':\n            return value ? 'true' : 'false';\n        case 'undefined':\n            return 'undefined';\n        case 'object':\n            if (value === null) {\n                return 'null';\n            }\n            if (Array.isArray(value)) {\n                return formatArray(value, availableLen);\n            }\n            return formatObject(value, availableLen);\n        case 'symbol':\n            return value.toString();\n        case 'function':\n            return `[[Function${value.name ? ' ' + value.name : ''}]]`;\n        default:\n            return '' + value;\n    }\n}\nfunction formatArray(value, availableLen) {\n    let result = '[ ';\n    let first = true;\n    for (const val of value) {\n        if (!first) {\n            result += ', ';\n        }\n        if (result.length - 5 > availableLen) {\n            result += '...';\n            break;\n        }\n        first = false;\n        result += `${formatValue(val, availableLen - result.length)}`;\n    }\n    result += ' ]';\n    return result;\n}\nfunction formatObject(value, availableLen) {\n    if (typeof value.toString === 'function' && value.toString !== Object.prototype.toString) {\n        const val = value.toString();\n        if (val.length <= availableLen) {\n            return val;\n        }\n        return val.substring(0, availableLen - 3) + '...';\n    }\n    const className = getClassName(value);\n    let result = className ? className + '(' : '{ ';\n    let first = true;\n    for (const [key, val] of Object.entries(value)) {\n        if (!first) {\n            result += ', ';\n        }\n        if (result.length - 5 > availableLen) {\n            result += '...';\n            break;\n        }\n        first = false;\n        result += `${key}: ${formatValue(val, availableLen - result.length)}`;\n    }\n    result += className ? ')' : ' }';\n    return result;\n}\n\nexport { formatValue };\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;AACA;AACA;;;;;;AAEA;;;8FAG8F,GAC9F,SAAS,YAAY,KAAK,EAAE,YAAY;IACpC,OAAQ,OAAO;QACX,KAAK;YACD,OAAO,KAAK;QAChB,KAAK;YACD,IAAI,MAAM,MAAM,GAAG,KAAK,cAAc;gBAClC,OAAO,CAAC,CAAC,EAAE,MAAM,CAAC,CAAC;YACvB;YACA,OAAO,CAAC,CAAC,EAAE,MAAM,MAAM,CAAC,GAAG,eAAe,GAAG,KAAK,CAAC;QACvD,KAAK;YACD,OAAO,QAAQ,SAAS;QAC5B,KAAK;YACD,OAAO;QACX,KAAK;YACD,IAAI,UAAU,MAAM;gBAChB,OAAO;YACX;YACA,IAAI,MAAM,OAAO,CAAC,QAAQ;gBACtB,OAAO,YAAY,OAAO;YAC9B;YACA,OAAO,aAAa,OAAO;QAC/B,KAAK;YACD,OAAO,MAAM,QAAQ;QACzB,KAAK;YACD,OAAO,CAAC,UAAU,EAAE,MAAM,IAAI,GAAG,MAAM,MAAM,IAAI,GAAG,GAAG,EAAE,CAAC;QAC9D;YACI,OAAO,KAAK;IACpB;AACJ;AACA,SAAS,YAAY,KAAK,EAAE,YAAY;IACpC,IAAI,SAAS;IACb,IAAI,QAAQ;IACZ,KAAK,MAAM,OAAO,MAAO;QACrB,IAAI,CAAC,OAAO;YACR,UAAU;QACd;QACA,IAAI,OAAO,MAAM,GAAG,IAAI,cAAc;YAClC,UAAU;YACV;QACJ;QACA,QAAQ;QACR,UAAU,GAAG,YAAY,KAAK,eAAe,OAAO,MAAM,GAAG;IACjE;IACA,UAAU;IACV,OAAO;AACX;AACA,SAAS,aAAa,KAAK,EAAE,YAAY;IACrC,IAAI,OAAO,MAAM,QAAQ,KAAK,cAAc,MAAM,QAAQ,KAAK,OAAO,SAAS,CAAC,QAAQ,EAAE;QACtF,MAAM,MAAM,MAAM,QAAQ;QAC1B,IAAI,IAAI,MAAM,IAAI,cAAc;YAC5B,OAAO;QACX;QACA,OAAO,IAAI,SAAS,CAAC,GAAG,eAAe,KAAK;IAChD;IACA,MAAM,YAAY,IAAA,mRAAY,EAAC;IAC/B,IAAI,SAAS,YAAY,YAAY,MAAM;IAC3C,IAAI,QAAQ;IACZ,KAAK,MAAM,CAAC,KAAK,IAAI,IAAI,OAAO,OAAO,CAAC,OAAQ;QAC5C,IAAI,CAAC,OAAO;YACR,UAAU;QACd;QACA,IAAI,OAAO,MAAM,GAAG,IAAI,cAAc;YAClC,UAAU;YACV;QACJ;QACA,QAAQ;QACR,UAAU,GAAG,IAAI,EAAE,EAAE,YAAY,KAAK,eAAe,OAAO,MAAM,GAAG;IACzE;IACA,UAAU,YAAY,MAAM;IAC5B,OAAO;AACX","ignoreList":[0]}},
    {"offset": {"line": 1774, "column": 0}, "map": {"version":3,"sources":["file:///D:/real-time-code-editor%20%282%29/node_modules/.pnpm/monaco-editor%400.55.1/node_modules/monaco-editor/esm/vs/base/common/observableInternal/logging/debugger/rpc.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nclass SimpleTypedRpcConnection {\n    static createClient(channelFactory, getHandler) {\n        return new SimpleTypedRpcConnection(channelFactory, getHandler);\n    }\n    constructor(_channelFactory, _getHandler) {\n        this._channelFactory = _channelFactory;\n        this._getHandler = _getHandler;\n        this._channel = this._channelFactory({\n            handleNotification: (notificationData) => {\n                const m = notificationData;\n                const fn = this._getHandler().notifications[m[0]];\n                if (!fn) {\n                    throw new Error(`Unknown notification \"${m[0]}\"!`);\n                }\n                fn(...m[1]);\n            },\n            handleRequest: (requestData) => {\n                const m = requestData;\n                try {\n                    const result = this._getHandler().requests[m[0]](...m[1]);\n                    return { type: 'result', value: result };\n                }\n                catch (e) {\n                    return { type: 'error', value: e };\n                }\n            },\n        });\n        const requests = new Proxy({}, {\n            get: (target, key) => {\n                return async (...args) => {\n                    const result = await this._channel.sendRequest([key, args]);\n                    if (result.type === 'error') {\n                        throw result.value;\n                    }\n                    else {\n                        return result.value;\n                    }\n                };\n            }\n        });\n        const notifications = new Proxy({}, {\n            get: (target, key) => {\n                return (...args) => {\n                    this._channel.sendNotification([key, args]);\n                };\n            }\n        });\n        // eslint-disable-next-line local/code-no-any-casts\n        this.api = { notifications: notifications, requests: requests };\n    }\n}\n\nexport { SimpleTypedRpcConnection };\n"],"names":[],"mappings":"AAAA;;;8FAG8F;;;;AAC9F,MAAM;IACF,OAAO,aAAa,cAAc,EAAE,UAAU,EAAE;QAC5C,OAAO,IAAI,yBAAyB,gBAAgB;IACxD;IACA,YAAY,eAAe,EAAE,WAAW,CAAE;QACtC,IAAI,CAAC,eAAe,GAAG;QACvB,IAAI,CAAC,WAAW,GAAG;QACnB,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC,eAAe,CAAC;YACjC,oBAAoB,CAAC;gBACjB,MAAM,IAAI;gBACV,MAAM,KAAK,IAAI,CAAC,WAAW,GAAG,aAAa,CAAC,CAAC,CAAC,EAAE,CAAC;gBACjD,IAAI,CAAC,IAAI;oBACL,MAAM,IAAI,MAAM,CAAC,sBAAsB,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC;gBACrD;gBACA,MAAM,CAAC,CAAC,EAAE;YACd;YACA,eAAe,CAAC;gBACZ,MAAM,IAAI;gBACV,IAAI;oBACA,MAAM,SAAS,IAAI,CAAC,WAAW,GAAG,QAAQ,CAAC,CAAC,CAAC,EAAE,CAAC,IAAI,CAAC,CAAC,EAAE;oBACxD,OAAO;wBAAE,MAAM;wBAAU,OAAO;oBAAO;gBAC3C,EACA,OAAO,GAAG;oBACN,OAAO;wBAAE,MAAM;wBAAS,OAAO;oBAAE;gBACrC;YACJ;QACJ;QACA,MAAM,WAAW,IAAI,MAAM,CAAC,GAAG;YAC3B,KAAK,CAAC,QAAQ;gBACV,OAAO,OAAO,GAAG;oBACb,MAAM,SAAS,MAAM,IAAI,CAAC,QAAQ,CAAC,WAAW,CAAC;wBAAC;wBAAK;qBAAK;oBAC1D,IAAI,OAAO,IAAI,KAAK,SAAS;wBACzB,MAAM,OAAO,KAAK;oBACtB,OACK;wBACD,OAAO,OAAO,KAAK;oBACvB;gBACJ;YACJ;QACJ;QACA,MAAM,gBAAgB,IAAI,MAAM,CAAC,GAAG;YAChC,KAAK,CAAC,QAAQ;gBACV,OAAO,CAAC,GAAG;oBACP,IAAI,CAAC,QAAQ,CAAC,gBAAgB,CAAC;wBAAC;wBAAK;qBAAK;gBAC9C;YACJ;QACJ;QACA,mDAAmD;QACnD,IAAI,CAAC,GAAG,GAAG;YAAE,eAAe;YAAe,UAAU;QAAS;IAClE;AACJ","ignoreList":[0]}},
    {"offset": {"line": 1850, "column": 0}, "map": {"version":3,"sources":["file:///D:/real-time-code-editor%20%282%29/node_modules/.pnpm/monaco-editor%400.55.1/node_modules/monaco-editor/esm/vs/base/common/observableInternal/logging/debugger/debuggerRpc.js"],"sourcesContent":["import { SimpleTypedRpcConnection } from './rpc.js';\n\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nfunction registerDebugChannel(channelId, createClient) {\n    // eslint-disable-next-line local/code-no-any-casts\n    const g = globalThis;\n    let queuedNotifications = [];\n    let curHost = undefined;\n    const { channel, handler } = createChannelFactoryFromDebugChannel({\n        sendNotification: (data) => {\n            if (curHost) {\n                curHost.sendNotification(data);\n            }\n            else {\n                queuedNotifications.push(data);\n            }\n        },\n    });\n    let curClient = undefined;\n    (g.$$debugValueEditor_debugChannels ?? (g.$$debugValueEditor_debugChannels = {}))[channelId] = (host) => {\n        curClient = createClient();\n        curHost = host;\n        for (const n of queuedNotifications) {\n            host.sendNotification(n);\n        }\n        queuedNotifications = [];\n        return handler;\n    };\n    return SimpleTypedRpcConnection.createClient(channel, () => {\n        if (!curClient) {\n            throw new Error('Not supported');\n        }\n        return curClient;\n    });\n}\nfunction createChannelFactoryFromDebugChannel(host) {\n    let h;\n    const channel = (handler) => {\n        h = handler;\n        return {\n            sendNotification: data => {\n                host.sendNotification(data);\n            },\n            sendRequest: data => {\n                throw new Error('not supported');\n            },\n        };\n    };\n    return {\n        channel: channel,\n        handler: {\n            handleRequest: (data) => {\n                if (data.type === 'notification') {\n                    return h?.handleNotification(data.data);\n                }\n                else {\n                    return h?.handleRequest(data.data);\n                }\n            },\n        },\n    };\n}\n\nexport { registerDebugChannel };\n"],"names":[],"mappings":";;;;AAAA;;AAEA;;;8FAG8F,GAC9F,SAAS,qBAAqB,SAAS,EAAE,YAAY;IACjD,mDAAmD;IACnD,MAAM,IAAI;IACV,IAAI,sBAAsB,EAAE;IAC5B,IAAI,UAAU;IACd,MAAM,EAAE,OAAO,EAAE,OAAO,EAAE,GAAG,qCAAqC;QAC9D,kBAAkB,CAAC;YACf,IAAI,SAAS;gBACT,QAAQ,gBAAgB,CAAC;YAC7B,OACK;gBACD,oBAAoB,IAAI,CAAC;YAC7B;QACJ;IACJ;IACA,IAAI,YAAY;IAChB,CAAC,EAAE,gCAAgC,IAAI,CAAC,EAAE,gCAAgC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,UAAU,GAAG,CAAC;QAC5F,YAAY;QACZ,UAAU;QACV,KAAK,MAAM,KAAK,oBAAqB;YACjC,KAAK,gBAAgB,CAAC;QAC1B;QACA,sBAAsB,EAAE;QACxB,OAAO;IACX;IACA,OAAO,gTAAwB,CAAC,YAAY,CAAC,SAAS;QAClD,IAAI,CAAC,WAAW;YACZ,MAAM,IAAI,MAAM;QACpB;QACA,OAAO;IACX;AACJ;AACA,SAAS,qCAAqC,IAAI;IAC9C,IAAI;IACJ,MAAM,UAAU,CAAC;QACb,IAAI;QACJ,OAAO;YACH,kBAAkB,CAAA;gBACd,KAAK,gBAAgB,CAAC;YAC1B;YACA,aAAa,CAAA;gBACT,MAAM,IAAI,MAAM;YACpB;QACJ;IACJ;IACA,OAAO;QACH,SAAS;QACT,SAAS;YACL,eAAe,CAAC;gBACZ,IAAI,KAAK,IAAI,KAAK,gBAAgB;oBAC9B,OAAO,GAAG,mBAAmB,KAAK,IAAI;gBAC1C,OACK;oBACD,OAAO,GAAG,cAAc,KAAK,IAAI;gBACrC;YACJ;QACJ;IACJ;AACJ","ignoreList":[0]}},
    {"offset": {"line": 1921, "column": 0}, "map": {"version":3,"sources":["file:///D:/real-time-code-editor%20%282%29/node_modules/.pnpm/monaco-editor%400.55.1/node_modules/monaco-editor/esm/vs/base/common/observableInternal/logging/debugger/utils.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nclass Throttler {\n    constructor() {\n        this._timeout = undefined;\n    }\n    throttle(fn, timeoutMs) {\n        if (this._timeout === undefined) {\n            this._timeout = setTimeout(() => {\n                this._timeout = undefined;\n                fn();\n            }, timeoutMs);\n        }\n    }\n    dispose() {\n        if (this._timeout !== undefined) {\n            clearTimeout(this._timeout);\n        }\n    }\n}\nfunction deepAssign(target, source) {\n    for (const key in source) {\n        if (!!target[key] && typeof target[key] === 'object' && !!source[key] && typeof source[key] === 'object') {\n            deepAssign(target[key], source[key]);\n        }\n        else {\n            target[key] = source[key];\n        }\n    }\n}\nfunction deepAssignDeleteNulls(target, source) {\n    for (const key in source) {\n        if (source[key] === null) {\n            delete target[key];\n        }\n        else if (!!target[key] && typeof target[key] === 'object' && !!source[key] && typeof source[key] === 'object') {\n            deepAssignDeleteNulls(target[key], source[key]);\n        }\n        else {\n            target[key] = source[key];\n        }\n    }\n}\n\nexport { Throttler, deepAssign, deepAssignDeleteNulls };\n"],"names":[],"mappings":"AAAA;;;8FAG8F;;;;;;;;AAC9F,MAAM;IACF,aAAc;QACV,IAAI,CAAC,QAAQ,GAAG;IACpB;IACA,SAAS,EAAE,EAAE,SAAS,EAAE;QACpB,IAAI,IAAI,CAAC,QAAQ,KAAK,WAAW;YAC7B,IAAI,CAAC,QAAQ,GAAG,WAAW;gBACvB,IAAI,CAAC,QAAQ,GAAG;gBAChB;YACJ,GAAG;QACP;IACJ;IACA,UAAU;QACN,IAAI,IAAI,CAAC,QAAQ,KAAK,WAAW;YAC7B,aAAa,IAAI,CAAC,QAAQ;QAC9B;IACJ;AACJ;AACA,SAAS,WAAW,MAAM,EAAE,MAAM;IAC9B,IAAK,MAAM,OAAO,OAAQ;QACtB,IAAI,CAAC,CAAC,MAAM,CAAC,IAAI,IAAI,OAAO,MAAM,CAAC,IAAI,KAAK,YAAY,CAAC,CAAC,MAAM,CAAC,IAAI,IAAI,OAAO,MAAM,CAAC,IAAI,KAAK,UAAU;YACtG,WAAW,MAAM,CAAC,IAAI,EAAE,MAAM,CAAC,IAAI;QACvC,OACK;YACD,MAAM,CAAC,IAAI,GAAG,MAAM,CAAC,IAAI;QAC7B;IACJ;AACJ;AACA,SAAS,sBAAsB,MAAM,EAAE,MAAM;IACzC,IAAK,MAAM,OAAO,OAAQ;QACtB,IAAI,MAAM,CAAC,IAAI,KAAK,MAAM;YACtB,OAAO,MAAM,CAAC,IAAI;QACtB,OACK,IAAI,CAAC,CAAC,MAAM,CAAC,IAAI,IAAI,OAAO,MAAM,CAAC,IAAI,KAAK,YAAY,CAAC,CAAC,MAAM,CAAC,IAAI,IAAI,OAAO,MAAM,CAAC,IAAI,KAAK,UAAU;YAC3G,sBAAsB,MAAM,CAAC,IAAI,EAAE,MAAM,CAAC,IAAI;QAClD,OACK;YACD,MAAM,CAAC,IAAI,GAAG,MAAM,CAAC,IAAI;QAC7B;IACJ;AACJ","ignoreList":[0]}},
    {"offset": {"line": 1975, "column": 0}, "map": {"version":3,"sources":["file:///D:/real-time-code-editor%20%282%29/node_modules/.pnpm/monaco-editor%400.55.1/node_modules/monaco-editor/esm/vs/base/common/observableInternal/observables/observableValue.js"],"sourcesContent":["import { TransactionImpl } from '../transaction.js';\nimport { BaseObservable } from './baseObservable.js';\nimport { strictEquals } from '../../equals.js';\nimport '../../event.js';\nimport '../../lifecycle.js';\nimport { DebugNameData } from '../debugName.js';\nimport { getLogger } from '../logging/logging.js';\nimport { DebugLocation } from '../debugLocation.js';\n\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nfunction observableValue(nameOrOwner, initialValue, debugLocation = DebugLocation.ofCaller()) {\n    let debugNameData;\n    if (typeof nameOrOwner === 'string') {\n        debugNameData = new DebugNameData(undefined, nameOrOwner, undefined);\n    }\n    else {\n        debugNameData = new DebugNameData(nameOrOwner, undefined, undefined);\n    }\n    return new ObservableValue(debugNameData, initialValue, strictEquals, debugLocation);\n}\nclass ObservableValue extends BaseObservable {\n    get debugName() {\n        return this._debugNameData.getDebugName(this) ?? 'ObservableValue';\n    }\n    constructor(_debugNameData, initialValue, _equalityComparator, debugLocation) {\n        super(debugLocation);\n        this._debugNameData = _debugNameData;\n        this._equalityComparator = _equalityComparator;\n        this._value = initialValue;\n        getLogger()?.handleObservableUpdated(this, { hadValue: false, newValue: initialValue, change: undefined, didChange: true, oldValue: undefined });\n    }\n    get() {\n        return this._value;\n    }\n    set(value, tx, change) {\n        if (change === undefined && this._equalityComparator(this._value, value)) {\n            return;\n        }\n        let _tx;\n        if (!tx) {\n            tx = _tx = new TransactionImpl(() => { }, () => `Setting ${this.debugName}`);\n        }\n        try {\n            const oldValue = this._value;\n            this._setValue(value);\n            getLogger()?.handleObservableUpdated(this, { oldValue, newValue: value, change, didChange: true, hadValue: true });\n            for (const observer of this._observers) {\n                tx.updateObserver(observer, this);\n                observer.handleChange(this, change);\n            }\n        }\n        finally {\n            if (_tx) {\n                _tx.finish();\n            }\n        }\n    }\n    toString() {\n        return `${this.debugName}: ${this._value}`;\n    }\n    _setValue(newValue) {\n        this._value = newValue;\n    }\n    debugGetState() {\n        return {\n            value: this._value,\n        };\n    }\n    debugSetValue(value) {\n        this._value = value;\n    }\n}\n/**\n * A disposable observable. When disposed, its value is also disposed.\n * When a new value is set, the previous value is disposed.\n */\nfunction disposableObservableValue(nameOrOwner, initialValue, debugLocation = DebugLocation.ofCaller()) {\n    let debugNameData;\n    if (typeof nameOrOwner === 'string') {\n        debugNameData = new DebugNameData(undefined, nameOrOwner, undefined);\n    }\n    else {\n        debugNameData = new DebugNameData(nameOrOwner, undefined, undefined);\n    }\n    return new DisposableObservableValue(debugNameData, initialValue, strictEquals, debugLocation);\n}\nclass DisposableObservableValue extends ObservableValue {\n    _setValue(newValue) {\n        if (this._value === newValue) {\n            return;\n        }\n        if (this._value) {\n            this._value.dispose();\n        }\n        this._value = newValue;\n    }\n    dispose() {\n        this._value?.dispose();\n    }\n}\n\nexport { DisposableObservableValue, ObservableValue, disposableObservableValue, observableValue };\n"],"names":[],"mappings":";;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AAEA;;;8FAG8F,GAC9F,SAAS,gBAAgB,WAAW,EAAE,YAAY,EAAE,gBAAgB,wRAAa,CAAC,QAAQ,EAAE;IACxF,IAAI;IACJ,IAAI,OAAO,gBAAgB,UAAU;QACjC,gBAAgB,IAAI,oRAAa,CAAC,WAAW,aAAa;IAC9D,OACK;QACD,gBAAgB,IAAI,oRAAa,CAAC,aAAa,WAAW;IAC9D;IACA,OAAO,IAAI,gBAAgB,eAAe,cAAc,0PAAY,EAAE;AAC1E;AACA,MAAM,wBAAwB,ySAAc;IACxC,IAAI,YAAY;QACZ,OAAO,IAAI,CAAC,cAAc,CAAC,YAAY,CAAC,IAAI,KAAK;IACrD;IACA,YAAY,cAAc,EAAE,YAAY,EAAE,mBAAmB,EAAE,aAAa,CAAE;QAC1E,KAAK,CAAC;QACN,IAAI,CAAC,cAAc,GAAG;QACtB,IAAI,CAAC,mBAAmB,GAAG;QAC3B,IAAI,CAAC,MAAM,GAAG;QACd,IAAA,yRAAS,KAAI,wBAAwB,IAAI,EAAE;YAAE,UAAU;YAAO,UAAU;YAAc,QAAQ;YAAW,WAAW;YAAM,UAAU;QAAU;IAClJ;IACA,MAAM;QACF,OAAO,IAAI,CAAC,MAAM;IACtB;IACA,IAAI,KAAK,EAAE,EAAE,EAAE,MAAM,EAAE;QACnB,IAAI,WAAW,aAAa,IAAI,CAAC,mBAAmB,CAAC,IAAI,CAAC,MAAM,EAAE,QAAQ;YACtE;QACJ;QACA,IAAI;QACJ,IAAI,CAAC,IAAI;YACL,KAAK,MAAM,IAAI,wRAAe,CAAC,KAAQ,GAAG,IAAM,CAAC,QAAQ,EAAE,IAAI,CAAC,SAAS,EAAE;QAC/E;QACA,IAAI;YACA,MAAM,WAAW,IAAI,CAAC,MAAM;YAC5B,IAAI,CAAC,SAAS,CAAC;YACf,IAAA,yRAAS,KAAI,wBAAwB,IAAI,EAAE;gBAAE;gBAAU,UAAU;gBAAO;gBAAQ,WAAW;gBAAM,UAAU;YAAK;YAChH,KAAK,MAAM,YAAY,IAAI,CAAC,UAAU,CAAE;gBACpC,GAAG,cAAc,CAAC,UAAU,IAAI;gBAChC,SAAS,YAAY,CAAC,IAAI,EAAE;YAChC;QACJ,SACQ;YACJ,IAAI,KAAK;gBACL,IAAI,MAAM;YACd;QACJ;IACJ;IACA,WAAW;QACP,OAAO,GAAG,IAAI,CAAC,SAAS,CAAC,EAAE,EAAE,IAAI,CAAC,MAAM,EAAE;IAC9C;IACA,UAAU,QAAQ,EAAE;QAChB,IAAI,CAAC,MAAM,GAAG;IAClB;IACA,gBAAgB;QACZ,OAAO;YACH,OAAO,IAAI,CAAC,MAAM;QACtB;IACJ;IACA,cAAc,KAAK,EAAE;QACjB,IAAI,CAAC,MAAM,GAAG;IAClB;AACJ;AACA;;;CAGC,GACD,SAAS,0BAA0B,WAAW,EAAE,YAAY,EAAE,gBAAgB,wRAAa,CAAC,QAAQ,EAAE;IAClG,IAAI;IACJ,IAAI,OAAO,gBAAgB,UAAU;QACjC,gBAAgB,IAAI,oRAAa,CAAC,WAAW,aAAa;IAC9D,OACK;QACD,gBAAgB,IAAI,oRAAa,CAAC,aAAa,WAAW;IAC9D;IACA,OAAO,IAAI,0BAA0B,eAAe,cAAc,0PAAY,EAAE;AACpF;AACA,MAAM,kCAAkC;IACpC,UAAU,QAAQ,EAAE;QAChB,IAAI,IAAI,CAAC,MAAM,KAAK,UAAU;YAC1B;QACJ;QACA,IAAI,IAAI,CAAC,MAAM,EAAE;YACb,IAAI,CAAC,MAAM,CAAC,OAAO;QACvB;QACA,IAAI,CAAC,MAAM,GAAG;IAClB;IACA,UAAU;QACN,IAAI,CAAC,MAAM,EAAE;IACjB;AACJ","ignoreList":[0]}},
    {"offset": {"line": 2107, "column": 0}, "map": {"version":3,"sources":["file:///D:/real-time-code-editor%20%282%29/node_modules/.pnpm/monaco-editor%400.55.1/node_modules/monaco-editor/esm/vs/base/common/observableInternal/logging/debugger/devToolsLogger.js"],"sourcesContent":["import { AutorunObserver } from '../../reactions/autorunImpl.js';\nimport { formatValue } from '../consoleObservableLogger.js';\nimport { registerDebugChannel } from './debuggerRpc.js';\nimport { Throttler, deepAssignDeleteNulls, deepAssign } from './utils.js';\nimport { isDefined } from '../../../types.js';\nimport { FromEventObservable } from '../../observables/observableFromEvent.js';\nimport { onUnexpectedError, BugIndicatingError } from '../../../errors.js';\nimport { Derived } from '../../observables/derivedImpl.js';\nimport { ObservableValue } from '../../observables/observableValue.js';\nimport { DebugLocation } from '../../debugLocation.js';\n\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nclass DevToolsLogger {\n    static { this._instance = undefined; }\n    static getInstance() {\n        if (DevToolsLogger._instance === undefined) {\n            DevToolsLogger._instance = new DevToolsLogger();\n        }\n        return DevToolsLogger._instance;\n    }\n    getTransactionState() {\n        const affected = [];\n        const txs = [...this._activeTransactions];\n        if (txs.length === 0) {\n            return undefined;\n        }\n        const observerQueue = txs.flatMap(t => t.debugGetUpdatingObservers() ?? []).map(o => o.observer);\n        const processedObservers = new Set();\n        while (observerQueue.length > 0) {\n            const observer = observerQueue.shift();\n            if (processedObservers.has(observer)) {\n                continue;\n            }\n            processedObservers.add(observer);\n            const state = this._getInfo(observer, d => {\n                if (!processedObservers.has(d)) {\n                    observerQueue.push(d);\n                }\n            });\n            if (state) {\n                affected.push(state);\n            }\n        }\n        return { names: txs.map(t => t.getDebugName() ?? 'tx'), affected };\n    }\n    _getObservableInfo(observable) {\n        const info = this._instanceInfos.get(observable);\n        if (!info) {\n            onUnexpectedError(new BugIndicatingError('No info found'));\n            return undefined;\n        }\n        return info;\n    }\n    _getAutorunInfo(autorun) {\n        const info = this._instanceInfos.get(autorun);\n        if (!info) {\n            onUnexpectedError(new BugIndicatingError('No info found'));\n            return undefined;\n        }\n        return info;\n    }\n    _getInfo(observer, queue) {\n        if (observer instanceof Derived) {\n            const observersToUpdate = [...observer.debugGetObservers()];\n            for (const o of observersToUpdate) {\n                queue(o);\n            }\n            const info = this._getObservableInfo(observer);\n            if (!info) {\n                return;\n            }\n            const observerState = observer.debugGetState();\n            const base = { name: observer.debugName, instanceId: info.instanceId, updateCount: observerState.updateCount };\n            const changedDependencies = [...info.changedObservables].map(o => this._instanceInfos.get(o)?.instanceId).filter(isDefined);\n            if (observerState.isComputing) {\n                return { ...base, type: 'observable/derived', state: 'updating', changedDependencies, initialComputation: false };\n            }\n            switch (observerState.state) {\n                case 0 /* DerivedState.initial */:\n                    return { ...base, type: 'observable/derived', state: 'noValue' };\n                case 3 /* DerivedState.upToDate */:\n                    return { ...base, type: 'observable/derived', state: 'upToDate' };\n                case 2 /* DerivedState.stale */:\n                    return { ...base, type: 'observable/derived', state: 'stale', changedDependencies };\n                case 1 /* DerivedState.dependenciesMightHaveChanged */:\n                    return { ...base, type: 'observable/derived', state: 'possiblyStale' };\n            }\n        }\n        else if (observer instanceof AutorunObserver) {\n            const info = this._getAutorunInfo(observer);\n            if (!info) {\n                return undefined;\n            }\n            const base = { name: observer.debugName, instanceId: info.instanceId, updateCount: info.updateCount };\n            const changedDependencies = [...info.changedObservables].map(o => this._instanceInfos.get(o).instanceId);\n            if (observer.debugGetState().isRunning) {\n                return { ...base, type: 'autorun', state: 'updating', changedDependencies };\n            }\n            switch (observer.debugGetState().state) {\n                case 3 /* AutorunState.upToDate */:\n                    return { ...base, type: 'autorun', state: 'upToDate' };\n                case 2 /* AutorunState.stale */:\n                    return { ...base, type: 'autorun', state: 'stale', changedDependencies };\n                case 1 /* AutorunState.dependenciesMightHaveChanged */:\n                    return { ...base, type: 'autorun', state: 'possiblyStale' };\n            }\n        }\n        return undefined;\n    }\n    _formatObservable(obs) {\n        const info = this._getObservableInfo(obs);\n        if (!info) {\n            return undefined;\n        }\n        return { name: obs.debugName, instanceId: info.instanceId };\n    }\n    _formatObserver(obs) {\n        if (obs instanceof Derived) {\n            return { name: obs.toString(), instanceId: this._getObservableInfo(obs)?.instanceId };\n        }\n        const autorunInfo = this._getAutorunInfo(obs);\n        if (autorunInfo) {\n            return { name: obs.toString(), instanceId: autorunInfo.instanceId };\n        }\n        return undefined;\n    }\n    constructor() {\n        this._declarationId = 0;\n        this._instanceId = 0;\n        this._declarations = new Map();\n        this._instanceInfos = new WeakMap();\n        this._aliveInstances = new Map();\n        this._activeTransactions = new Set();\n        this._channel = registerDebugChannel('observableDevTools', () => {\n            return {\n                notifications: {\n                    setDeclarationIdFilter: declarationIds => {\n                    },\n                    logObservableValue: (observableId) => {\n                        console.log('logObservableValue', observableId);\n                    },\n                    flushUpdates: () => {\n                        this._flushUpdates();\n                    },\n                    resetUpdates: () => {\n                        this._pendingChanges = null;\n                        this._channel.api.notifications.handleChange(this._fullState, true);\n                    },\n                },\n                requests: {\n                    getDeclarations: () => {\n                        const result = {};\n                        for (const decl of this._declarations.values()) {\n                            result[decl.id] = decl;\n                        }\n                        return { decls: result };\n                    },\n                    getSummarizedInstances: () => {\n                        return null;\n                    },\n                    getObservableValueInfo: instanceId => {\n                        const obs = this._aliveInstances.get(instanceId);\n                        return {\n                            observers: [...obs.debugGetObservers()].map(d => this._formatObserver(d)).filter(isDefined),\n                        };\n                    },\n                    getDerivedInfo: instanceId => {\n                        const d = this._aliveInstances.get(instanceId);\n                        return {\n                            dependencies: [...d.debugGetState().dependencies].map(d => this._formatObservable(d)).filter(isDefined),\n                            observers: [...d.debugGetObservers()].map(d => this._formatObserver(d)).filter(isDefined),\n                        };\n                    },\n                    getAutorunInfo: instanceId => {\n                        const obs = this._aliveInstances.get(instanceId);\n                        return {\n                            dependencies: [...obs.debugGetState().dependencies].map(d => this._formatObservable(d)).filter(isDefined),\n                        };\n                    },\n                    getTransactionState: () => {\n                        return this.getTransactionState();\n                    },\n                    setValue: (instanceId, jsonValue) => {\n                        const obs = this._aliveInstances.get(instanceId);\n                        if (obs instanceof Derived) {\n                            obs.debugSetValue(jsonValue);\n                        }\n                        else if (obs instanceof ObservableValue) {\n                            obs.debugSetValue(jsonValue);\n                        }\n                        else if (obs instanceof FromEventObservable) {\n                            obs.debugSetValue(jsonValue);\n                        }\n                        else {\n                            throw new BugIndicatingError('Observable is not supported');\n                        }\n                        const observers = [...obs.debugGetObservers()];\n                        for (const d of observers) {\n                            d.beginUpdate(obs);\n                        }\n                        for (const d of observers) {\n                            d.handleChange(obs, undefined);\n                        }\n                        for (const d of observers) {\n                            d.endUpdate(obs);\n                        }\n                    },\n                    getValue: instanceId => {\n                        const obs = this._aliveInstances.get(instanceId);\n                        if (obs instanceof Derived) {\n                            return formatValue(obs.debugGetState().value, 200);\n                        }\n                        else if (obs instanceof ObservableValue) {\n                            return formatValue(obs.debugGetState().value, 200);\n                        }\n                        return undefined;\n                    },\n                    logValue: (instanceId) => {\n                        const obs = this._aliveInstances.get(instanceId);\n                        if (obs && 'get' in obs) {\n                            console.log('Logged Value:', obs.get());\n                        }\n                        else {\n                            throw new BugIndicatingError('Observable is not supported');\n                        }\n                    },\n                    rerun: (instanceId) => {\n                        const obs = this._aliveInstances.get(instanceId);\n                        if (obs instanceof Derived) {\n                            obs.debugRecompute();\n                        }\n                        else if (obs instanceof AutorunObserver) {\n                            obs.debugRerun();\n                        }\n                        else {\n                            throw new BugIndicatingError('Observable is not supported');\n                        }\n                    },\n                }\n            };\n        });\n        this._pendingChanges = null;\n        this._changeThrottler = new Throttler();\n        this._fullState = {};\n        this._flushUpdates = () => {\n            if (this._pendingChanges !== null) {\n                this._channel.api.notifications.handleChange(this._pendingChanges, false);\n                this._pendingChanges = null;\n            }\n        };\n        DebugLocation.enable();\n    }\n    _handleChange(update) {\n        deepAssignDeleteNulls(this._fullState, update);\n        if (this._pendingChanges === null) {\n            this._pendingChanges = update;\n        }\n        else {\n            deepAssign(this._pendingChanges, update);\n        }\n        this._changeThrottler.throttle(this._flushUpdates, 10);\n    }\n    _getDeclarationId(type, location) {\n        if (!location) {\n            return -1;\n        }\n        let decInfo = this._declarations.get(location.id);\n        if (decInfo === undefined) {\n            decInfo = {\n                id: this._declarationId++,\n                type,\n                url: location.fileName,\n                line: location.line,\n                column: location.column,\n            };\n            this._declarations.set(location.id, decInfo);\n            this._handleChange({ decls: { [decInfo.id]: decInfo } });\n        }\n        return decInfo.id;\n    }\n    handleObservableCreated(observable, location) {\n        const declarationId = this._getDeclarationId('observable/value', location);\n        const info = {\n            declarationId,\n            instanceId: this._instanceId++,\n            listenerCount: 0,\n            lastValue: undefined,\n            updateCount: 0,\n            changedObservables: new Set(),\n        };\n        this._instanceInfos.set(observable, info);\n    }\n    handleOnListenerCountChanged(observable, newCount) {\n        const info = this._getObservableInfo(observable);\n        if (!info) {\n            return;\n        }\n        if (info.listenerCount === 0 && newCount > 0) {\n            const type = observable instanceof Derived ? 'observable/derived' : 'observable/value';\n            this._aliveInstances.set(info.instanceId, observable);\n            this._handleChange({\n                instances: {\n                    [info.instanceId]: {\n                        instanceId: info.instanceId,\n                        declarationId: info.declarationId,\n                        formattedValue: info.lastValue,\n                        type,\n                        name: observable.debugName,\n                    }\n                }\n            });\n        }\n        else if (info.listenerCount > 0 && newCount === 0) {\n            this._handleChange({\n                instances: { [info.instanceId]: null }\n            });\n            this._aliveInstances.delete(info.instanceId);\n        }\n        info.listenerCount = newCount;\n    }\n    handleObservableUpdated(observable, changeInfo) {\n        if (observable instanceof Derived) {\n            this._handleDerivedRecomputed(observable, changeInfo);\n            return;\n        }\n        const info = this._getObservableInfo(observable);\n        if (info) {\n            if (changeInfo.didChange) {\n                info.lastValue = formatValue(changeInfo.newValue, 30);\n                if (info.listenerCount > 0) {\n                    this._handleChange({\n                        instances: { [info.instanceId]: { formattedValue: info.lastValue } }\n                    });\n                }\n            }\n        }\n    }\n    handleAutorunCreated(autorun, location) {\n        const declarationId = this._getDeclarationId('autorun', location);\n        const info = {\n            declarationId,\n            instanceId: this._instanceId++,\n            updateCount: 0,\n            changedObservables: new Set(),\n        };\n        this._instanceInfos.set(autorun, info);\n        this._aliveInstances.set(info.instanceId, autorun);\n        if (info) {\n            this._handleChange({\n                instances: {\n                    [info.instanceId]: {\n                        instanceId: info.instanceId,\n                        declarationId: info.declarationId,\n                        runCount: 0,\n                        type: 'autorun',\n                        name: autorun.debugName,\n                    }\n                }\n            });\n        }\n    }\n    handleAutorunDisposed(autorun) {\n        const info = this._getAutorunInfo(autorun);\n        if (!info) {\n            return;\n        }\n        this._handleChange({\n            instances: { [info.instanceId]: null }\n        });\n        this._instanceInfos.delete(autorun);\n        this._aliveInstances.delete(info.instanceId);\n    }\n    handleAutorunDependencyChanged(autorun, observable, change) {\n        const info = this._getAutorunInfo(autorun);\n        if (!info) {\n            return;\n        }\n        info.changedObservables.add(observable);\n    }\n    handleAutorunStarted(autorun) {\n    }\n    handleAutorunFinished(autorun) {\n        const info = this._getAutorunInfo(autorun);\n        if (!info) {\n            return;\n        }\n        info.changedObservables.clear();\n        info.updateCount++;\n        this._handleChange({\n            instances: { [info.instanceId]: { runCount: info.updateCount } }\n        });\n    }\n    handleDerivedDependencyChanged(derived, observable, change) {\n        const info = this._getObservableInfo(derived);\n        if (info) {\n            info.changedObservables.add(observable);\n        }\n    }\n    _handleDerivedRecomputed(observable, changeInfo) {\n        const info = this._getObservableInfo(observable);\n        if (!info) {\n            return;\n        }\n        const formattedValue = formatValue(changeInfo.newValue, 30);\n        info.updateCount++;\n        info.changedObservables.clear();\n        info.lastValue = formattedValue;\n        if (info.listenerCount > 0) {\n            this._handleChange({\n                instances: { [info.instanceId]: { formattedValue: formattedValue, recomputationCount: info.updateCount } }\n            });\n        }\n    }\n    handleDerivedCleared(observable) {\n        const info = this._getObservableInfo(observable);\n        if (!info) {\n            return;\n        }\n        info.lastValue = undefined;\n        info.changedObservables.clear();\n        if (info.listenerCount > 0) {\n            this._handleChange({\n                instances: {\n                    [info.instanceId]: {\n                        formattedValue: undefined,\n                    }\n                }\n            });\n        }\n    }\n    handleBeginTransaction(transaction) {\n        this._activeTransactions.add(transaction);\n    }\n    handleEndTransaction(transaction) {\n        this._activeTransactions.delete(transaction);\n    }\n}\n\nexport { DevToolsLogger };\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 2656, "column": 0}, "map": {"version":3,"sources":["file:///D:/real-time-code-editor%20%282%29/node_modules/.pnpm/monaco-editor%400.55.1/node_modules/monaco-editor/esm/vs/base/common/observableInternal/index.js"],"sourcesContent":["import '../arrays.js';\nimport '../event.js';\nimport '../lifecycle.js';\nimport { addLogger } from './logging/logging.js';\nexport { DebugLocation } from './debugLocation.js';\nexport { derived, derivedDisposable, derivedHandleChanges, derivedOpts, derivedWithSetter } from './observables/derived.js';\nimport '../cancellation.js';\nexport { debouncedObservable, derivedObservableWithCache, mapObservableArrayCached, recomputeInitiallyAndOnChange } from './utils/utils.js';\nexport { observableFromEvent, observableFromEventOpts } from './observables/observableFromEvent.js';\nimport { DevToolsLogger } from './logging/debugger/devToolsLogger.js';\nimport { env } from '../process.js';\n\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n// This is a facade for the observable implementation. Only import from here!\nif (env && env['VSCODE_DEV_DEBUG_OBSERVABLES']) {\n    // To debug observables you also need the extension \"ms-vscode.debug-value-editor\"\n    addLogger(DevToolsLogger.getInstance());\n}\n"],"names":[],"mappings":";AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AAEA;;;8FAG8F,GAC9F,6EAA6E;AAC7E,IAAI,kPAAG,IAAI,kPAAG,CAAC,+BAA+B,EAAE;IAC5C,kFAAkF;IAClF,IAAA,yRAAS,EAAC,iTAAc,CAAC,WAAW;AACxC","ignoreList":[0]}},
    {"offset": {"line": 2691, "column": 0}, "map": {"version":3,"sources":["file:///D:/real-time-code-editor%20%282%29/node_modules/.pnpm/monaco-editor%400.55.1/node_modules/monaco-editor/esm/vs/base/common/observableInternal/utils/runOnChange.js"],"sourcesContent":["import { cancelOnDispose } from '../../cancellation.js';\nimport '../../arrays.js';\nimport '../../event.js';\nimport { DisposableStore } from '../../lifecycle.js';\nimport { autorunWithStoreHandleChanges } from '../reactions/autorun.js';\n\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nfunction runOnChange(observable, cb) {\n    let _previousValue;\n    let _firstRun = true;\n    return autorunWithStoreHandleChanges({\n        changeTracker: {\n            createChangeSummary: () => ({ deltas: [], didChange: false }),\n            handleChange: (context, changeSummary) => {\n                if (context.didChange(observable)) {\n                    const e = context.change;\n                    if (e !== undefined) {\n                        changeSummary.deltas.push(e);\n                    }\n                    changeSummary.didChange = true;\n                }\n                return true;\n            },\n        }\n    }, (reader, changeSummary) => {\n        const value = observable.read(reader);\n        const previousValue = _previousValue;\n        if (changeSummary.didChange) {\n            _previousValue = value;\n            // didChange can never be true on the first autorun, so we know previousValue is defined\n            cb(value, previousValue, changeSummary.deltas);\n        }\n        if (_firstRun) {\n            _firstRun = false;\n            _previousValue = value;\n        }\n    });\n}\nfunction runOnChangeWithStore(observable, cb) {\n    const store = new DisposableStore();\n    const disposable = runOnChange(observable, (value, previousValue, deltas) => {\n        store.clear();\n        cb(value, previousValue, deltas, store);\n    });\n    return {\n        dispose() {\n            disposable.dispose();\n            store.dispose();\n        }\n    };\n}\nfunction runOnChangeWithCancellationToken(observable, cb) {\n    return runOnChangeWithStore(observable, (value, previousValue, deltas, store) => {\n        cb(value, previousValue, deltas, cancelOnDispose(store));\n    });\n}\n\nexport { runOnChange, runOnChangeWithCancellationToken, runOnChangeWithStore };\n"],"names":[],"mappings":";;;;;;;;AAAA;AACA;AACA;AACA;AACA;;;;;;AAEA;;;8FAG8F,GAC9F,SAAS,YAAY,UAAU,EAAE,EAAE;IAC/B,IAAI;IACJ,IAAI,YAAY;IAChB,OAAO,IAAA,+SAA6B,EAAC;QACjC,eAAe;YACX,qBAAqB,IAAM,CAAC;oBAAE,QAAQ,EAAE;oBAAE,WAAW;gBAAM,CAAC;YAC5D,cAAc,CAAC,SAAS;gBACpB,IAAI,QAAQ,SAAS,CAAC,aAAa;oBAC/B,MAAM,IAAI,QAAQ,MAAM;oBACxB,IAAI,MAAM,WAAW;wBACjB,cAAc,MAAM,CAAC,IAAI,CAAC;oBAC9B;oBACA,cAAc,SAAS,GAAG;gBAC9B;gBACA,OAAO;YACX;QACJ;IACJ,GAAG,CAAC,QAAQ;QACR,MAAM,QAAQ,WAAW,IAAI,CAAC;QAC9B,MAAM,gBAAgB;QACtB,IAAI,cAAc,SAAS,EAAE;YACzB,iBAAiB;YACjB,wFAAwF;YACxF,GAAG,OAAO,eAAe,cAAc,MAAM;QACjD;QACA,IAAI,WAAW;YACX,YAAY;YACZ,iBAAiB;QACrB;IACJ;AACJ;AACA,SAAS,qBAAqB,UAAU,EAAE,EAAE;IACxC,MAAM,QAAQ,IAAI,gQAAe;IACjC,MAAM,aAAa,YAAY,YAAY,CAAC,OAAO,eAAe;QAC9D,MAAM,KAAK;QACX,GAAG,OAAO,eAAe,QAAQ;IACrC;IACA,OAAO;QACH;YACI,WAAW,OAAO;YAClB,MAAM,OAAO;QACjB;IACJ;AACJ;AACA,SAAS,iCAAiC,UAAU,EAAE,EAAE;IACpD,OAAO,qBAAqB,YAAY,CAAC,OAAO,eAAe,QAAQ;QACnE,GAAG,OAAO,eAAe,QAAQ,IAAA,mQAAe,EAAC;IACrD;AACJ","ignoreList":[0]}},
    {"offset": {"line": 2769, "column": 0}, "map": {"version":3,"sources":["file:///D:/real-time-code-editor%20%282%29/node_modules/.pnpm/monaco-editor%400.55.1/node_modules/monaco-editor/esm/vs/base/common/observableInternal/observables/observableSignal.js"],"sourcesContent":["import { transaction } from '../transaction.js';\nimport { DebugNameData } from '../debugName.js';\nimport { BaseObservable } from './baseObservable.js';\nimport { DebugLocation } from '../debugLocation.js';\n\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nfunction observableSignal(debugNameOrOwner, debugLocation = DebugLocation.ofCaller()) {\n    if (typeof debugNameOrOwner === 'string') {\n        return new ObservableSignal(debugNameOrOwner, undefined, debugLocation);\n    }\n    else {\n        return new ObservableSignal(undefined, debugNameOrOwner, debugLocation);\n    }\n}\nclass ObservableSignal extends BaseObservable {\n    get debugName() {\n        return new DebugNameData(this._owner, this._debugName, undefined).getDebugName(this) ?? 'Observable Signal';\n    }\n    toString() {\n        return this.debugName;\n    }\n    constructor(_debugName, _owner, debugLocation) {\n        super(debugLocation);\n        this._debugName = _debugName;\n        this._owner = _owner;\n    }\n    trigger(tx, change) {\n        if (!tx) {\n            transaction(tx => {\n                this.trigger(tx, change);\n            }, () => `Trigger signal ${this.debugName}`);\n            return;\n        }\n        for (const o of this._observers) {\n            tx.updateObserver(o, this);\n            o.handleChange(this, change);\n        }\n    }\n    get() {\n        // NO OP\n    }\n}\n\nexport { observableSignal };\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;AACA;;;;;AAEA;;;8FAG8F,GAC9F,SAAS,iBAAiB,gBAAgB,EAAE,gBAAgB,wRAAa,CAAC,QAAQ,EAAE;IAChF,IAAI,OAAO,qBAAqB,UAAU;QACtC,OAAO,IAAI,iBAAiB,kBAAkB,WAAW;IAC7D,OACK;QACD,OAAO,IAAI,iBAAiB,WAAW,kBAAkB;IAC7D;AACJ;AACA,MAAM,yBAAyB,ySAAc;IACzC,IAAI,YAAY;QACZ,OAAO,IAAI,oRAAa,CAAC,IAAI,CAAC,MAAM,EAAE,IAAI,CAAC,UAAU,EAAE,WAAW,YAAY,CAAC,IAAI,KAAK;IAC5F;IACA,WAAW;QACP,OAAO,IAAI,CAAC,SAAS;IACzB;IACA,YAAY,UAAU,EAAE,MAAM,EAAE,aAAa,CAAE;QAC3C,KAAK,CAAC;QACN,IAAI,CAAC,UAAU,GAAG;QAClB,IAAI,CAAC,MAAM,GAAG;IAClB;IACA,QAAQ,EAAE,EAAE,MAAM,EAAE;QAChB,IAAI,CAAC,IAAI;YACL,IAAA,oRAAW,EAAC,CAAA;gBACR,IAAI,CAAC,OAAO,CAAC,IAAI;YACrB,GAAG,IAAM,CAAC,eAAe,EAAE,IAAI,CAAC,SAAS,EAAE;YAC3C;QACJ;QACA,KAAK,MAAM,KAAK,IAAI,CAAC,UAAU,CAAE;YAC7B,GAAG,cAAc,CAAC,GAAG,IAAI;YACzB,EAAE,YAAY,CAAC,IAAI,EAAE;QACzB;IACJ;IACA,MAAM;IACF,QAAQ;IACZ;AACJ","ignoreList":[0]}},
    {"offset": {"line": 2824, "column": 0}, "map": {"version":3,"sources":["file:///D:/real-time-code-editor%20%282%29/node_modules/.pnpm/monaco-editor%400.55.1/node_modules/monaco-editor/esm/vs/base/common/observableInternal/observables/lazyObservableValue.js"],"sourcesContent":["import { TransactionImpl } from '../transaction.js';\nimport { getLogger } from '../logging/logging.js';\nimport { BaseObservable } from './baseObservable.js';\n\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n/**\n * Holds off updating observers until the value is actually read.\n*/\nclass LazyObservableValue extends BaseObservable {\n    get debugName() {\n        return this._debugNameData.getDebugName(this) ?? 'LazyObservableValue';\n    }\n    constructor(_debugNameData, initialValue, _equalityComparator, debugLocation) {\n        super(debugLocation);\n        this._debugNameData = _debugNameData;\n        this._equalityComparator = _equalityComparator;\n        this._isUpToDate = true;\n        this._deltas = [];\n        this._updateCounter = 0;\n        this._value = initialValue;\n    }\n    get() {\n        this._update();\n        return this._value;\n    }\n    _update() {\n        if (this._isUpToDate) {\n            return;\n        }\n        this._isUpToDate = true;\n        if (this._deltas.length > 0) {\n            for (const change of this._deltas) {\n                getLogger()?.handleObservableUpdated(this, { change, didChange: true, oldValue: '(unknown)', newValue: this._value, hadValue: true });\n                for (const observer of this._observers) {\n                    observer.handleChange(this, change);\n                }\n            }\n            this._deltas.length = 0;\n        }\n        else {\n            getLogger()?.handleObservableUpdated(this, { change: undefined, didChange: true, oldValue: '(unknown)', newValue: this._value, hadValue: true });\n            for (const observer of this._observers) {\n                observer.handleChange(this, undefined);\n            }\n        }\n    }\n    _beginUpdate() {\n        this._updateCounter++;\n        if (this._updateCounter === 1) {\n            for (const observer of this._observers) {\n                observer.beginUpdate(this);\n            }\n        }\n    }\n    _endUpdate() {\n        this._updateCounter--;\n        if (this._updateCounter === 0) {\n            this._update();\n            // End update could change the observer list.\n            const observers = [...this._observers];\n            for (const r of observers) {\n                r.endUpdate(this);\n            }\n        }\n    }\n    addObserver(observer) {\n        const shouldCallBeginUpdate = !this._observers.has(observer) && this._updateCounter > 0;\n        super.addObserver(observer);\n        if (shouldCallBeginUpdate) {\n            observer.beginUpdate(this);\n        }\n    }\n    removeObserver(observer) {\n        const shouldCallEndUpdate = this._observers.has(observer) && this._updateCounter > 0;\n        super.removeObserver(observer);\n        if (shouldCallEndUpdate) {\n            // Calling end update after removing the observer makes sure endUpdate cannot be called twice here.\n            observer.endUpdate(this);\n        }\n    }\n    set(value, tx, change) {\n        if (change === undefined && this._equalityComparator(this._value, value)) {\n            return;\n        }\n        let _tx;\n        if (!tx) {\n            tx = _tx = new TransactionImpl(() => { }, () => `Setting ${this.debugName}`);\n        }\n        try {\n            this._isUpToDate = false;\n            this._setValue(value);\n            if (change !== undefined) {\n                this._deltas.push(change);\n            }\n            tx.updateObserver({\n                beginUpdate: () => this._beginUpdate(),\n                endUpdate: () => this._endUpdate(),\n                handleChange: (observable, change) => { },\n                handlePossibleChange: (observable) => { },\n            }, this);\n            if (this._updateCounter > 1) {\n                // We already started begin/end update, so we need to manually call handlePossibleChange\n                for (const observer of this._observers) {\n                    observer.handlePossibleChange(this);\n                }\n            }\n        }\n        finally {\n            if (_tx) {\n                _tx.finish();\n            }\n        }\n    }\n    toString() {\n        return `${this.debugName}: ${this._value}`;\n    }\n    _setValue(newValue) {\n        this._value = newValue;\n    }\n}\n\nexport { LazyObservableValue };\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 2968, "column": 0}, "map": {"version":3,"sources":["file:///D:/real-time-code-editor%20%282%29/node_modules/.pnpm/monaco-editor%400.55.1/node_modules/monaco-editor/esm/vs/base/common/observableInternal/observables/observableValueOpts.js"],"sourcesContent":["import { DebugNameData } from '../debugName.js';\nimport { strictEquals } from '../../equals.js';\nimport '../../event.js';\nimport '../../lifecycle.js';\nimport { ObservableValue } from './observableValue.js';\nimport { LazyObservableValue } from './lazyObservableValue.js';\nimport { DebugLocation } from '../debugLocation.js';\n\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nfunction observableValueOpts(options, initialValue, debugLocation = DebugLocation.ofCaller()) {\n    if (options.lazy) {\n        return new LazyObservableValue(new DebugNameData(options.owner, options.debugName, undefined), initialValue, options.equalsFn ?? strictEquals, debugLocation);\n    }\n    return new ObservableValue(new DebugNameData(options.owner, options.debugName, undefined), initialValue, options.equalsFn ?? strictEquals, debugLocation);\n}\n\nexport { observableValueOpts };\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAEA;;;8FAG8F,GAC9F,SAAS,oBAAoB,OAAO,EAAE,YAAY,EAAE,gBAAgB,wRAAa,CAAC,QAAQ,EAAE;IACxF,IAAI,QAAQ,IAAI,EAAE;QACd,OAAO,IAAI,mTAAmB,CAAC,IAAI,oRAAa,CAAC,QAAQ,KAAK,EAAE,QAAQ,SAAS,EAAE,YAAY,cAAc,QAAQ,QAAQ,IAAI,0PAAY,EAAE;IACnJ;IACA,OAAO,IAAI,2SAAe,CAAC,IAAI,oRAAa,CAAC,QAAQ,KAAK,EAAE,QAAQ,SAAS,EAAE,YAAY,cAAc,QAAQ,QAAQ,IAAI,0PAAY,EAAE;AAC/I","ignoreList":[0]}},
    {"offset": {"line": 3000, "column": 0}, "map": {"version":3,"sources":["file:///D:/real-time-code-editor%20%282%29/node_modules/.pnpm/monaco-editor%400.55.1/node_modules/monaco-editor/esm/vs/base/common/observableInternal/changeTracker.js"],"sourcesContent":["import { BugIndicatingError } from '../errors.js';\nimport '../arrays.js';\nimport '../event.js';\nimport '../lifecycle.js';\n\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n/**\n * Subscribes to and records changes and the last value of the given observables.\n * Don't use the key \"changes\", as it is reserved for the changes array!\n*/\nfunction recordChanges(obs) {\n    return {\n        createChangeSummary: (_previousChangeSummary) => {\n            // eslint-disable-next-line local/code-no-any-casts\n            return {\n                changes: [],\n            };\n        },\n        handleChange(ctx, changeSummary) {\n            for (const key in obs) {\n                if (ctx.didChange(obs[key])) {\n                    // eslint-disable-next-line local/code-no-any-casts\n                    changeSummary.changes.push({ key, change: ctx.change });\n                }\n            }\n            return true;\n        },\n        beforeUpdate(reader, changeSummary) {\n            for (const key in obs) {\n                if (key === 'changes') {\n                    throw new BugIndicatingError('property name \"changes\" is reserved for change tracking');\n                }\n                changeSummary[key] = obs[key].read(reader);\n            }\n        }\n    };\n}\n/**\n * Subscribes to and records changes and the last value of the given observables.\n * Don't use the key \"changes\", as it is reserved for the changes array!\n*/\nfunction recordChangesLazy(getObs) {\n    let obs = undefined;\n    return {\n        createChangeSummary: (_previousChangeSummary) => {\n            // eslint-disable-next-line local/code-no-any-casts\n            return {\n                changes: [],\n            };\n        },\n        handleChange(ctx, changeSummary) {\n            if (!obs) {\n                obs = getObs();\n            }\n            for (const key in obs) {\n                if (ctx.didChange(obs[key])) {\n                    // eslint-disable-next-line local/code-no-any-casts\n                    changeSummary.changes.push({ key, change: ctx.change });\n                }\n            }\n            return true;\n        },\n        beforeUpdate(reader, changeSummary) {\n            if (!obs) {\n                obs = getObs();\n            }\n            for (const key in obs) {\n                if (key === 'changes') {\n                    throw new BugIndicatingError('property name \"changes\" is reserved for change tracking');\n                }\n                changeSummary[key] = obs[key].read(reader);\n            }\n        }\n    };\n}\n\nexport { recordChanges, recordChangesLazy };\n"],"names":[],"mappings":";;;;;;AAAA;AACA;AACA;AACA;;;;;AAEA;;;8FAG8F,GAC9F;;;AAGA,GACA,SAAS,cAAc,GAAG;IACtB,OAAO;QACH,qBAAqB,CAAC;YAClB,mDAAmD;YACnD,OAAO;gBACH,SAAS,EAAE;YACf;QACJ;QACA,cAAa,GAAG,EAAE,aAAa;YAC3B,IAAK,MAAM,OAAO,IAAK;gBACnB,IAAI,IAAI,SAAS,CAAC,GAAG,CAAC,IAAI,GAAG;oBACzB,mDAAmD;oBACnD,cAAc,OAAO,CAAC,IAAI,CAAC;wBAAE;wBAAK,QAAQ,IAAI,MAAM;oBAAC;gBACzD;YACJ;YACA,OAAO;QACX;QACA,cAAa,MAAM,EAAE,aAAa;YAC9B,IAAK,MAAM,OAAO,IAAK;gBACnB,IAAI,QAAQ,WAAW;oBACnB,MAAM,IAAI,gQAAkB,CAAC;gBACjC;gBACA,aAAa,CAAC,IAAI,GAAG,GAAG,CAAC,IAAI,CAAC,IAAI,CAAC;YACvC;QACJ;IACJ;AACJ;AACA;;;AAGA,GACA,SAAS,kBAAkB,MAAM;IAC7B,IAAI,MAAM;IACV,OAAO;QACH,qBAAqB,CAAC;YAClB,mDAAmD;YACnD,OAAO;gBACH,SAAS,EAAE;YACf;QACJ;QACA,cAAa,GAAG,EAAE,aAAa;YAC3B,IAAI,CAAC,KAAK;gBACN,MAAM;YACV;YACA,IAAK,MAAM,OAAO,IAAK;gBACnB,IAAI,IAAI,SAAS,CAAC,GAAG,CAAC,IAAI,GAAG;oBACzB,mDAAmD;oBACnD,cAAc,OAAO,CAAC,IAAI,CAAC;wBAAE;wBAAK,QAAQ,IAAI,MAAM;oBAAC;gBACzD;YACJ;YACA,OAAO;QACX;QACA,cAAa,MAAM,EAAE,aAAa;YAC9B,IAAI,CAAC,KAAK;gBACN,MAAM;YACV;YACA,IAAK,MAAM,OAAO,IAAK;gBACnB,IAAI,QAAQ,WAAW;oBACnB,MAAM,IAAI,gQAAkB,CAAC;gBACjC;gBACA,aAAa,CAAC,IAAI,GAAG,GAAG,CAAC,IAAI,CAAC,IAAI,CAAC;YACvC;QACJ;IACJ;AACJ","ignoreList":[0]}},
    {"offset": {"line": 3095, "column": 0}, "map": {"version":3,"sources":["file:///D:/real-time-code-editor%20%282%29/node_modules/.pnpm/monaco-editor%400.55.1/node_modules/monaco-editor/esm/vs/base/common/observableInternal/utils/promise.js"],"sourcesContent":["import { transaction } from '../transaction.js';\nimport { observableValue } from '../observables/observableValue.js';\n\n/**\n * A promise whose state is observable.\n */\nclass ObservablePromise {\n    constructor(promise) {\n        this._value = observableValue(this, undefined);\n        /**\n         * The current state of the promise.\n         * Is `undefined` if the promise didn't resolve yet.\n         */\n        this.promiseResult = this._value;\n        this.promise = promise.then(value => {\n            transaction(tx => {\n                /** @description onPromiseResolved */\n                this._value.set(new PromiseResult(value, undefined), tx);\n            });\n            return value;\n        }, error => {\n            transaction(tx => {\n                /** @description onPromiseRejected */\n                this._value.set(new PromiseResult(undefined, error), tx);\n            });\n            throw error;\n        });\n    }\n}\nclass PromiseResult {\n    constructor(\n    /**\n     * The value of the resolved promise.\n     * Undefined if the promise rejected.\n     */\n    data, \n    /**\n     * The error in case of a rejected promise.\n     * Undefined if the promise resolved.\n     */\n    error) {\n        this.data = data;\n        this.error = error;\n    }\n    /**\n     * Returns the value if the promise resolved, otherwise throws the error.\n     */\n    getDataOrThrow() {\n        if (this.error) {\n            throw this.error;\n        }\n        return this.data;\n    }\n}\n\nexport { ObservablePromise, PromiseResult };\n"],"names":[],"mappings":";;;;;;AAAA;AACA;;;AAEA;;CAEC,GACD,MAAM;IACF,YAAY,OAAO,CAAE;QACjB,IAAI,CAAC,MAAM,GAAG,IAAA,2SAAe,EAAC,IAAI,EAAE;QACpC;;;SAGC,GACD,IAAI,CAAC,aAAa,GAAG,IAAI,CAAC,MAAM;QAChC,IAAI,CAAC,OAAO,GAAG,QAAQ,IAAI,CAAC,CAAA;YACxB,IAAA,oRAAW,EAAC,CAAA;gBACR,mCAAmC,GACnC,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,IAAI,cAAc,OAAO,YAAY;YACzD;YACA,OAAO;QACX,GAAG,CAAA;YACC,IAAA,oRAAW,EAAC,CAAA;gBACR,mCAAmC,GACnC,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,IAAI,cAAc,WAAW,QAAQ;YACzD;YACA,MAAM;QACV;IACJ;AACJ;AACA,MAAM;IACF,YACA;;;KAGC,GACD,IAAI,EACJ;;;KAGC,GACD,KAAK,CAAE;QACH,IAAI,CAAC,IAAI,GAAG;QACZ,IAAI,CAAC,KAAK,GAAG;IACjB;IACA;;KAEC,GACD,iBAAiB;QACb,IAAI,IAAI,CAAC,KAAK,EAAE;YACZ,MAAM,IAAI,CAAC,KAAK;QACpB;QACA,OAAO,IAAI,CAAC,IAAI;IACpB;AACJ","ignoreList":[0]}},
    {"offset": {"line": 3152, "column": 0}, "map": {"version":3,"sources":["file:///D:/real-time-code-editor%20%282%29/node_modules/.pnpm/monaco-editor%400.55.1/node_modules/monaco-editor/esm/vs/base/common/observableInternal/observables/constObservable.js"],"sourcesContent":["import { ConvenientObservable } from './baseObservable.js';\n\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n/**\n * Represents an efficient observable whose value never changes.\n */\nfunction constObservable(value) {\n    return new ConstObservable(value);\n}\nclass ConstObservable extends ConvenientObservable {\n    constructor(value) {\n        super();\n        this.value = value;\n    }\n    get debugName() {\n        return this.toString();\n    }\n    get() {\n        return this.value;\n    }\n    addObserver(observer) {\n        // NO OP\n    }\n    removeObserver(observer) {\n        // NO OP\n    }\n    toString() {\n        return `Const: ${this.value}`;\n    }\n}\n\nexport { constObservable };\n"],"names":[],"mappings":";;;;AAAA;;AAEA;;;8FAG8F,GAC9F;;CAEC,GACD,SAAS,gBAAgB,KAAK;IAC1B,OAAO,IAAI,gBAAgB;AAC/B;AACA,MAAM,wBAAwB,+SAAoB;IAC9C,YAAY,KAAK,CAAE;QACf,KAAK;QACL,IAAI,CAAC,KAAK,GAAG;IACjB;IACA,IAAI,YAAY;QACZ,OAAO,IAAI,CAAC,QAAQ;IACxB;IACA,MAAM;QACF,OAAO,IAAI,CAAC,KAAK;IACrB;IACA,YAAY,QAAQ,EAAE;IAClB,QAAQ;IACZ;IACA,eAAe,QAAQ,EAAE;IACrB,QAAQ;IACZ;IACA,WAAW;QACP,OAAO,CAAC,OAAO,EAAE,IAAI,CAAC,KAAK,EAAE;IACjC;AACJ","ignoreList":[0]}},
    {"offset": {"line": 3192, "column": 0}, "map": {"version":3,"sources":["file:///D:/real-time-code-editor%20%282%29/node_modules/.pnpm/monaco-editor%400.55.1/node_modules/monaco-editor/esm/vs/base/common/observableInternal/utils/utilsCancellation.js"],"sourcesContent":["import { CancellationError } from '../../errors.js';\nimport '../../cancellation.js';\nimport { autorun } from '../reactions/autorun.js';\n\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nfunction waitForState(observable, predicate, isError, cancellationToken) {\n    if (!predicate) {\n        predicate = state => state !== null && state !== undefined;\n    }\n    return new Promise((resolve, reject) => {\n        let isImmediateRun = true;\n        let shouldDispose = false;\n        const stateObs = observable.map(state => {\n            /** @description waitForState.state */\n            return {\n                isFinished: predicate(state),\n                error: isError ? isError(state) : false,\n                state\n            };\n        });\n        const d = autorun(reader => {\n            /** @description waitForState */\n            const { isFinished, error, state } = stateObs.read(reader);\n            if (isFinished || error) {\n                if (isImmediateRun) {\n                    // The variable `d` is not initialized yet\n                    shouldDispose = true;\n                }\n                else {\n                    d.dispose();\n                }\n                if (error) {\n                    reject(error === true ? state : error);\n                }\n                else {\n                    resolve(state);\n                }\n            }\n        });\n        if (cancellationToken) {\n            const dc = cancellationToken.onCancellationRequested(() => {\n                d.dispose();\n                dc.dispose();\n                reject(new CancellationError());\n            });\n            if (cancellationToken.isCancellationRequested) {\n                d.dispose();\n                dc.dispose();\n                reject(new CancellationError());\n                return;\n            }\n        }\n        isImmediateRun = false;\n        if (shouldDispose) {\n            d.dispose();\n        }\n    });\n}\n\nexport { waitForState };\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;;;;AAEA;;;8FAG8F,GAC9F,SAAS,aAAa,UAAU,EAAE,SAAS,EAAE,OAAO,EAAE,iBAAiB;IACnE,IAAI,CAAC,WAAW;QACZ,YAAY,CAAA,QAAS,UAAU,QAAQ,UAAU;IACrD;IACA,OAAO,IAAI,QAAQ,CAAC,SAAS;QACzB,IAAI,iBAAiB;QACrB,IAAI,gBAAgB;QACpB,MAAM,WAAW,WAAW,GAAG,CAAC,CAAA;YAC5B,oCAAoC,GACpC,OAAO;gBACH,YAAY,UAAU;gBACtB,OAAO,UAAU,QAAQ,SAAS;gBAClC;YACJ;QACJ;QACA,MAAM,IAAI,IAAA,yRAAO,EAAC,CAAA;YACd,8BAA8B,GAC9B,MAAM,EAAE,UAAU,EAAE,KAAK,EAAE,KAAK,EAAE,GAAG,SAAS,IAAI,CAAC;YACnD,IAAI,cAAc,OAAO;gBACrB,IAAI,gBAAgB;oBAChB,0CAA0C;oBAC1C,gBAAgB;gBACpB,OACK;oBACD,EAAE,OAAO;gBACb;gBACA,IAAI,OAAO;oBACP,OAAO,UAAU,OAAO,QAAQ;gBACpC,OACK;oBACD,QAAQ;gBACZ;YACJ;QACJ;QACA,IAAI,mBAAmB;YACnB,MAAM,KAAK,kBAAkB,uBAAuB,CAAC;gBACjD,EAAE,OAAO;gBACT,GAAG,OAAO;gBACV,OAAO,IAAI,+PAAiB;YAChC;YACA,IAAI,kBAAkB,uBAAuB,EAAE;gBAC3C,EAAE,OAAO;gBACT,GAAG,OAAO;gBACV,OAAO,IAAI,+PAAiB;gBAC5B;YACJ;QACJ;QACA,iBAAiB;QACjB,IAAI,eAAe;YACf,EAAE,OAAO;QACb;IACJ;AACJ","ignoreList":[0]}},
    {"offset": {"line": 3259, "column": 0}, "map": {"version":3,"sources":["file:///D:/real-time-code-editor%20%282%29/node_modules/.pnpm/monaco-editor%400.55.1/node_modules/monaco-editor/esm/vs/base/common/observableInternal/observables/observableSignalFromEvent.js"],"sourcesContent":["import { transaction } from '../transaction.js';\nimport { DebugNameData } from '../debugName.js';\nimport { BaseObservable } from './baseObservable.js';\nimport { DebugLocation } from '../debugLocation.js';\n\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nfunction observableSignalFromEvent(owner, event, debugLocation = DebugLocation.ofCaller()) {\n    return new FromEventObservableSignal(typeof owner === 'string' ? owner : new DebugNameData(owner, undefined, undefined), event, debugLocation);\n}\nclass FromEventObservableSignal extends BaseObservable {\n    constructor(debugNameDataOrName, event, debugLocation) {\n        super(debugLocation);\n        this.event = event;\n        this.handleEvent = () => {\n            transaction((tx) => {\n                for (const o of this._observers) {\n                    tx.updateObserver(o, this);\n                    o.handleChange(this, undefined);\n                }\n            }, () => this.debugName);\n        };\n        this.debugName = typeof debugNameDataOrName === 'string'\n            ? debugNameDataOrName\n            : debugNameDataOrName.getDebugName(this) ?? 'Observable Signal From Event';\n    }\n    onFirstObserverAdded() {\n        this.subscription = this.event(this.handleEvent);\n    }\n    onLastObserverRemoved() {\n        this.subscription.dispose();\n        this.subscription = undefined;\n    }\n    get() {\n        // NO OP\n    }\n}\n\nexport { observableSignalFromEvent };\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;AACA;;;;;AAEA;;;8FAG8F,GAC9F,SAAS,0BAA0B,KAAK,EAAE,KAAK,EAAE,gBAAgB,wRAAa,CAAC,QAAQ,EAAE;IACrF,OAAO,IAAI,0BAA0B,OAAO,UAAU,WAAW,QAAQ,IAAI,oRAAa,CAAC,OAAO,WAAW,YAAY,OAAO;AACpI;AACA,MAAM,kCAAkC,ySAAc;IAClD,YAAY,mBAAmB,EAAE,KAAK,EAAE,aAAa,CAAE;QACnD,KAAK,CAAC;QACN,IAAI,CAAC,KAAK,GAAG;QACb,IAAI,CAAC,WAAW,GAAG;YACf,IAAA,oRAAW,EAAC,CAAC;gBACT,KAAK,MAAM,KAAK,IAAI,CAAC,UAAU,CAAE;oBAC7B,GAAG,cAAc,CAAC,GAAG,IAAI;oBACzB,EAAE,YAAY,CAAC,IAAI,EAAE;gBACzB;YACJ,GAAG,IAAM,IAAI,CAAC,SAAS;QAC3B;QACA,IAAI,CAAC,SAAS,GAAG,OAAO,wBAAwB,WAC1C,sBACA,oBAAoB,YAAY,CAAC,IAAI,KAAK;IACpD;IACA,uBAAuB;QACnB,IAAI,CAAC,YAAY,GAAG,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,WAAW;IACnD;IACA,wBAAwB;QACpB,IAAI,CAAC,YAAY,CAAC,OAAO;QACzB,IAAI,CAAC,YAAY,GAAG;IACxB;IACA,MAAM;IACF,QAAQ;IACZ;AACJ","ignoreList":[0]}},
    {"offset": {"line": 3307, "column": 0}, "map": {"version":3,"sources":["file:///D:/real-time-code-editor%20%282%29/node_modules/.pnpm/monaco-editor%400.55.1/node_modules/monaco-editor/esm/vs/base/common/observableInternal/experimental/utils.js"],"sourcesContent":["import { derivedObservableWithCache } from '../utils/utils.js';\n\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n/**\n * Works like a derived.\n * However, if the value is not undefined, it is cached and will not be recomputed anymore.\n * In that case, the derived will unsubscribe from its dependencies.\n*/\nfunction derivedConstOnceDefined(owner, fn) {\n    return derivedObservableWithCache(owner, (reader, lastValue) => lastValue ?? fn(reader));\n}\n\nexport { derivedConstOnceDefined };\n"],"names":[],"mappings":";;;;AAAA;;AAEA;;;8FAG8F,GAC9F;;;;AAIA,GACA,SAAS,wBAAwB,KAAK,EAAE,EAAE;IACtC,OAAO,IAAA,sSAA0B,EAAC,OAAO,CAAC,QAAQ,YAAc,aAAa,GAAG;AACpF","ignoreList":[0]}}]
}