{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///D:/real-time-code-editor%20%282%29/node_modules/.pnpm/monaco-editor%400.55.1/node_modules/monaco-editor/esm/vs/editor/common/viewLayout/lineDecorations.js"],"sourcesContent":["import { isHighSurrogate } from '../../../base/common/strings.js';\n\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nclass LineDecoration {\n    constructor(startColumn, endColumn, className, type) {\n        this.startColumn = startColumn;\n        this.endColumn = endColumn;\n        this.className = className;\n        this.type = type;\n        this._lineDecorationBrand = undefined;\n    }\n    static _equals(a, b) {\n        return (a.startColumn === b.startColumn\n            && a.endColumn === b.endColumn\n            && a.className === b.className\n            && a.type === b.type);\n    }\n    static equalsArr(a, b) {\n        const aLen = a.length;\n        const bLen = b.length;\n        if (aLen !== bLen) {\n            return false;\n        }\n        for (let i = 0; i < aLen; i++) {\n            if (!LineDecoration._equals(a[i], b[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n    static extractWrapped(arr, startOffset, endOffset) {\n        if (arr.length === 0) {\n            return arr;\n        }\n        const startColumn = startOffset + 1;\n        const endColumn = endOffset + 1;\n        const lineLength = endOffset - startOffset;\n        const r = [];\n        let rLength = 0;\n        for (const dec of arr) {\n            if (dec.endColumn <= startColumn || dec.startColumn >= endColumn) {\n                continue;\n            }\n            r[rLength++] = new LineDecoration(Math.max(1, dec.startColumn - startColumn + 1), Math.min(lineLength + 1, dec.endColumn - startColumn + 1), dec.className, dec.type);\n        }\n        return r;\n    }\n    static filter(lineDecorations, lineNumber, minLineColumn, maxLineColumn) {\n        if (lineDecorations.length === 0) {\n            return [];\n        }\n        const result = [];\n        let resultLen = 0;\n        for (let i = 0, len = lineDecorations.length; i < len; i++) {\n            const d = lineDecorations[i];\n            const range = d.range;\n            if (range.endLineNumber < lineNumber || range.startLineNumber > lineNumber) {\n                // Ignore decorations that sit outside this line\n                continue;\n            }\n            if (range.isEmpty() && (d.type === 0 /* InlineDecorationType.Regular */ || d.type === 3 /* InlineDecorationType.RegularAffectingLetterSpacing */)) {\n                // Ignore empty range decorations\n                continue;\n            }\n            const startColumn = (range.startLineNumber === lineNumber ? range.startColumn : minLineColumn);\n            const endColumn = (range.endLineNumber === lineNumber ? range.endColumn : maxLineColumn);\n            result[resultLen++] = new LineDecoration(startColumn, endColumn, d.inlineClassName, d.type);\n        }\n        return result;\n    }\n    static _typeCompare(a, b) {\n        const ORDER = [2, 0, 1, 3];\n        return ORDER[a] - ORDER[b];\n    }\n    static compare(a, b) {\n        if (a.startColumn !== b.startColumn) {\n            return a.startColumn - b.startColumn;\n        }\n        if (a.endColumn !== b.endColumn) {\n            return a.endColumn - b.endColumn;\n        }\n        const typeCmp = LineDecoration._typeCompare(a.type, b.type);\n        if (typeCmp !== 0) {\n            return typeCmp;\n        }\n        if (a.className !== b.className) {\n            return a.className < b.className ? -1 : 1;\n        }\n        return 0;\n    }\n}\nclass DecorationSegment {\n    constructor(startOffset, endOffset, className, metadata) {\n        this.startOffset = startOffset;\n        this.endOffset = endOffset;\n        this.className = className;\n        this.metadata = metadata;\n    }\n}\nclass Stack {\n    constructor() {\n        this.stopOffsets = [];\n        this.classNames = [];\n        this.metadata = [];\n        this.count = 0;\n    }\n    static _metadata(metadata) {\n        let result = 0;\n        for (let i = 0, len = metadata.length; i < len; i++) {\n            result |= metadata[i];\n        }\n        return result;\n    }\n    consumeLowerThan(maxStopOffset, nextStartOffset, result) {\n        while (this.count > 0 && this.stopOffsets[0] < maxStopOffset) {\n            let i = 0;\n            // Take all equal stopping offsets\n            while (i + 1 < this.count && this.stopOffsets[i] === this.stopOffsets[i + 1]) {\n                i++;\n            }\n            // Basically we are consuming the first i + 1 elements of the stack\n            result.push(new DecorationSegment(nextStartOffset, this.stopOffsets[i], this.classNames.join(' '), Stack._metadata(this.metadata)));\n            nextStartOffset = this.stopOffsets[i] + 1;\n            // Consume them\n            this.stopOffsets.splice(0, i + 1);\n            this.classNames.splice(0, i + 1);\n            this.metadata.splice(0, i + 1);\n            this.count -= (i + 1);\n        }\n        if (this.count > 0 && nextStartOffset < maxStopOffset) {\n            result.push(new DecorationSegment(nextStartOffset, maxStopOffset - 1, this.classNames.join(' '), Stack._metadata(this.metadata)));\n            nextStartOffset = maxStopOffset;\n        }\n        return nextStartOffset;\n    }\n    insert(stopOffset, className, metadata) {\n        if (this.count === 0 || this.stopOffsets[this.count - 1] <= stopOffset) {\n            // Insert at the end\n            this.stopOffsets.push(stopOffset);\n            this.classNames.push(className);\n            this.metadata.push(metadata);\n        }\n        else {\n            // Find the insertion position for `stopOffset`\n            for (let i = 0; i < this.count; i++) {\n                if (this.stopOffsets[i] >= stopOffset) {\n                    this.stopOffsets.splice(i, 0, stopOffset);\n                    this.classNames.splice(i, 0, className);\n                    this.metadata.splice(i, 0, metadata);\n                    break;\n                }\n            }\n        }\n        this.count++;\n        return;\n    }\n}\nclass LineDecorationsNormalizer {\n    /**\n     * Normalize line decorations. Overlapping decorations will generate multiple segments\n     */\n    static normalize(lineContent, lineDecorations) {\n        if (lineDecorations.length === 0) {\n            return [];\n        }\n        const result = [];\n        const stack = new Stack();\n        let nextStartOffset = 0;\n        for (let i = 0, len = lineDecorations.length; i < len; i++) {\n            const d = lineDecorations[i];\n            let startColumn = d.startColumn;\n            let endColumn = d.endColumn;\n            const className = d.className;\n            const metadata = (d.type === 1 /* InlineDecorationType.Before */\n                ? 2 /* LinePartMetadata.PSEUDO_BEFORE */\n                : d.type === 2 /* InlineDecorationType.After */\n                    ? 4 /* LinePartMetadata.PSEUDO_AFTER */\n                    : 0);\n            // If the position would end up in the middle of a high-low surrogate pair, we move it to before the pair\n            if (startColumn > 1) {\n                const charCodeBefore = lineContent.charCodeAt(startColumn - 2);\n                if (isHighSurrogate(charCodeBefore)) {\n                    startColumn--;\n                }\n            }\n            if (endColumn > 1) {\n                const charCodeBefore = lineContent.charCodeAt(endColumn - 2);\n                if (isHighSurrogate(charCodeBefore)) {\n                    endColumn--;\n                }\n            }\n            const currentStartOffset = startColumn - 1;\n            const currentEndOffset = endColumn - 2;\n            nextStartOffset = stack.consumeLowerThan(currentStartOffset, nextStartOffset, result);\n            if (stack.count === 0) {\n                nextStartOffset = currentStartOffset;\n            }\n            stack.insert(currentEndOffset, className, metadata);\n        }\n        stack.consumeLowerThan(1073741824 /* Constants.MAX_SAFE_SMALL_INTEGER */, nextStartOffset, result);\n        return result;\n    }\n}\n\nexport { DecorationSegment, LineDecoration, LineDecorationsNormalizer };\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 216, "column": 0}, "map": {"version":3,"sources":["file:///D:/real-time-code-editor%20%282%29/node_modules/.pnpm/monaco-editor%400.55.1/node_modules/monaco-editor/esm/vs/editor/common/viewLayout/linePart.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nclass LinePart {\n    constructor(\n    /**\n     * last char index of this token (not inclusive).\n     */\n    endIndex, type, metadata, containsRTL) {\n        this.endIndex = endIndex;\n        this.type = type;\n        this.metadata = metadata;\n        this.containsRTL = containsRTL;\n        this._linePartBrand = undefined;\n    }\n    isWhitespace() {\n        return (this.metadata & 1 /* LinePartMetadata.IS_WHITESPACE_MASK */ ? true : false);\n    }\n    isPseudoAfter() {\n        return (this.metadata & 4 /* LinePartMetadata.PSEUDO_AFTER_MASK */ ? true : false);\n    }\n}\n\nexport { LinePart };\n"],"names":[],"mappings":"AAAA;;;8FAG8F;;;;AAC9F,MAAM;IACF,YACA;;KAEC,GACD,QAAQ,EAAE,IAAI,EAAE,QAAQ,EAAE,WAAW,CAAE;QACnC,IAAI,CAAC,QAAQ,GAAG;QAChB,IAAI,CAAC,IAAI,GAAG;QACZ,IAAI,CAAC,QAAQ,GAAG;QAChB,IAAI,CAAC,WAAW,GAAG;QACnB,IAAI,CAAC,cAAc,GAAG;IAC1B;IACA,eAAe;QACX,OAAQ,IAAI,CAAC,QAAQ,GAAG,EAAE,uCAAuC,MAAK,OAAO;IACjF;IACA,gBAAgB;QACZ,OAAQ,IAAI,CAAC,QAAQ,GAAG,EAAE,sCAAsC,MAAK,OAAO;IAChF;AACJ","ignoreList":[0]}},
    {"offset": {"line": 245, "column": 0}, "map": {"version":3,"sources":["file:///D:/real-time-code-editor%20%282%29/node_modules/.pnpm/monaco-editor%400.55.1/node_modules/monaco-editor/esm/vs/editor/common/viewLayout/viewLineRenderer.js"],"sourcesContent":["import { localize } from '../../../nls.js';\nimport { containsRTL, firstNonWhitespaceIndex, lastNonWhitespaceIndex, isFullWidthCharacter } from '../../../base/common/strings.js';\nimport { StringBuilder } from '../core/stringBuilder.js';\nimport { LineDecoration, LineDecorationsNormalizer } from './lineDecorations.js';\nimport { LinePart } from './linePart.js';\nimport { TextDirection } from '../model.js';\n\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nclass RenderLineInput {\n    get isLTR() {\n        return !this.containsRTL && this.textDirection !== TextDirection.RTL;\n    }\n    constructor(useMonospaceOptimizations, canUseHalfwidthRightwardsArrow, lineContent, continuesWithWrappedLine, isBasicASCII, containsRTL, fauxIndentLength, lineTokens, lineDecorations, tabSize, startVisibleColumn, spaceWidth, middotWidth, wsmiddotWidth, stopRenderingLineAfter, renderWhitespace, renderControlCharacters, fontLigatures, selectionsOnLine, textDirection, verticalScrollbarSize, renderNewLineWhenEmpty = false) {\n        this.useMonospaceOptimizations = useMonospaceOptimizations;\n        this.canUseHalfwidthRightwardsArrow = canUseHalfwidthRightwardsArrow;\n        this.lineContent = lineContent;\n        this.continuesWithWrappedLine = continuesWithWrappedLine;\n        this.isBasicASCII = isBasicASCII;\n        this.containsRTL = containsRTL;\n        this.fauxIndentLength = fauxIndentLength;\n        this.lineTokens = lineTokens;\n        this.lineDecorations = lineDecorations.sort(LineDecoration.compare);\n        this.tabSize = tabSize;\n        this.startVisibleColumn = startVisibleColumn;\n        this.spaceWidth = spaceWidth;\n        this.stopRenderingLineAfter = stopRenderingLineAfter;\n        this.renderWhitespace = (renderWhitespace === 'all'\n            ? 4 /* RenderWhitespace.All */\n            : renderWhitespace === 'boundary'\n                ? 1 /* RenderWhitespace.Boundary */\n                : renderWhitespace === 'selection'\n                    ? 2 /* RenderWhitespace.Selection */\n                    : renderWhitespace === 'trailing'\n                        ? 3 /* RenderWhitespace.Trailing */\n                        : 0 /* RenderWhitespace.None */);\n        this.renderControlCharacters = renderControlCharacters;\n        this.fontLigatures = fontLigatures;\n        this.selectionsOnLine = selectionsOnLine && selectionsOnLine.sort((a, b) => a.start < b.start ? -1 : 1);\n        this.renderNewLineWhenEmpty = renderNewLineWhenEmpty;\n        this.textDirection = textDirection;\n        this.verticalScrollbarSize = verticalScrollbarSize;\n        const wsmiddotDiff = Math.abs(wsmiddotWidth - spaceWidth);\n        const middotDiff = Math.abs(middotWidth - spaceWidth);\n        if (wsmiddotDiff < middotDiff) {\n            this.renderSpaceWidth = wsmiddotWidth;\n            this.renderSpaceCharCode = 0x2E31; // U+2E31 - WORD SEPARATOR MIDDLE DOT\n        }\n        else {\n            this.renderSpaceWidth = middotWidth;\n            this.renderSpaceCharCode = 0xB7; // U+00B7 - MIDDLE DOT\n        }\n    }\n    sameSelection(otherSelections) {\n        if (this.selectionsOnLine === null) {\n            return otherSelections === null;\n        }\n        if (otherSelections === null) {\n            return false;\n        }\n        if (otherSelections.length !== this.selectionsOnLine.length) {\n            return false;\n        }\n        for (let i = 0; i < this.selectionsOnLine.length; i++) {\n            if (!this.selectionsOnLine[i].equals(otherSelections[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n    equals(other) {\n        return (this.useMonospaceOptimizations === other.useMonospaceOptimizations\n            && this.canUseHalfwidthRightwardsArrow === other.canUseHalfwidthRightwardsArrow\n            && this.lineContent === other.lineContent\n            && this.continuesWithWrappedLine === other.continuesWithWrappedLine\n            && this.isBasicASCII === other.isBasicASCII\n            && this.containsRTL === other.containsRTL\n            && this.fauxIndentLength === other.fauxIndentLength\n            && this.tabSize === other.tabSize\n            && this.startVisibleColumn === other.startVisibleColumn\n            && this.spaceWidth === other.spaceWidth\n            && this.renderSpaceWidth === other.renderSpaceWidth\n            && this.renderSpaceCharCode === other.renderSpaceCharCode\n            && this.stopRenderingLineAfter === other.stopRenderingLineAfter\n            && this.renderWhitespace === other.renderWhitespace\n            && this.renderControlCharacters === other.renderControlCharacters\n            && this.fontLigatures === other.fontLigatures\n            && LineDecoration.equalsArr(this.lineDecorations, other.lineDecorations)\n            && this.lineTokens.equals(other.lineTokens)\n            && this.sameSelection(other.selectionsOnLine)\n            && this.textDirection === other.textDirection\n            && this.verticalScrollbarSize === other.verticalScrollbarSize\n            && this.renderNewLineWhenEmpty === other.renderNewLineWhenEmpty);\n    }\n}\nclass DomPosition {\n    constructor(partIndex, charIndex) {\n        this.partIndex = partIndex;\n        this.charIndex = charIndex;\n    }\n}\n/**\n * Provides a both direction mapping between a line's character and its rendered position.\n */\nclass CharacterMapping {\n    static getPartIndex(partData) {\n        return (partData & 4294901760 /* CharacterMappingConstants.PART_INDEX_MASK */) >>> 16 /* CharacterMappingConstants.PART_INDEX_OFFSET */;\n    }\n    static getCharIndex(partData) {\n        return (partData & 65535 /* CharacterMappingConstants.CHAR_INDEX_MASK */) >>> 0 /* CharacterMappingConstants.CHAR_INDEX_OFFSET */;\n    }\n    constructor(length, partCount) {\n        this.length = length;\n        this._data = new Uint32Array(this.length);\n        this._horizontalOffset = new Uint32Array(this.length);\n    }\n    setColumnInfo(column, partIndex, charIndex, horizontalOffset) {\n        const partData = ((partIndex << 16 /* CharacterMappingConstants.PART_INDEX_OFFSET */)\n            | (charIndex << 0 /* CharacterMappingConstants.CHAR_INDEX_OFFSET */)) >>> 0;\n        this._data[column - 1] = partData;\n        this._horizontalOffset[column - 1] = horizontalOffset;\n    }\n    getHorizontalOffset(column) {\n        if (this._horizontalOffset.length === 0) {\n            // No characters on this line\n            return 0;\n        }\n        return this._horizontalOffset[column - 1];\n    }\n    charOffsetToPartData(charOffset) {\n        if (this.length === 0) {\n            return 0;\n        }\n        if (charOffset < 0) {\n            return this._data[0];\n        }\n        if (charOffset >= this.length) {\n            return this._data[this.length - 1];\n        }\n        return this._data[charOffset];\n    }\n    getDomPosition(column) {\n        const partData = this.charOffsetToPartData(column - 1);\n        const partIndex = CharacterMapping.getPartIndex(partData);\n        const charIndex = CharacterMapping.getCharIndex(partData);\n        return new DomPosition(partIndex, charIndex);\n    }\n    getColumn(domPosition, partLength) {\n        const charOffset = this.partDataToCharOffset(domPosition.partIndex, partLength, domPosition.charIndex);\n        return charOffset + 1;\n    }\n    partDataToCharOffset(partIndex, partLength, charIndex) {\n        if (this.length === 0) {\n            return 0;\n        }\n        const searchEntry = ((partIndex << 16 /* CharacterMappingConstants.PART_INDEX_OFFSET */)\n            | (charIndex << 0 /* CharacterMappingConstants.CHAR_INDEX_OFFSET */)) >>> 0;\n        let min = 0;\n        let max = this.length - 1;\n        while (min + 1 < max) {\n            const mid = ((min + max) >>> 1);\n            const midEntry = this._data[mid];\n            if (midEntry === searchEntry) {\n                return mid;\n            }\n            else if (midEntry > searchEntry) {\n                max = mid;\n            }\n            else {\n                min = mid;\n            }\n        }\n        if (min === max) {\n            return min;\n        }\n        const minEntry = this._data[min];\n        const maxEntry = this._data[max];\n        if (minEntry === searchEntry) {\n            return min;\n        }\n        if (maxEntry === searchEntry) {\n            return max;\n        }\n        const minPartIndex = CharacterMapping.getPartIndex(minEntry);\n        const minCharIndex = CharacterMapping.getCharIndex(minEntry);\n        const maxPartIndex = CharacterMapping.getPartIndex(maxEntry);\n        let maxCharIndex;\n        if (minPartIndex !== maxPartIndex) {\n            // sitting between parts\n            maxCharIndex = partLength;\n        }\n        else {\n            maxCharIndex = CharacterMapping.getCharIndex(maxEntry);\n        }\n        const minEntryDistance = charIndex - minCharIndex;\n        const maxEntryDistance = maxCharIndex - charIndex;\n        if (minEntryDistance <= maxEntryDistance) {\n            return min;\n        }\n        return max;\n    }\n}\nclass RenderLineOutput {\n    constructor(characterMapping, containsForeignElements) {\n        this._renderLineOutputBrand = undefined;\n        this.characterMapping = characterMapping;\n        this.containsForeignElements = containsForeignElements;\n    }\n}\nfunction renderViewLine(input, sb) {\n    if (input.lineContent.length === 0) {\n        if (input.lineDecorations.length > 0) {\n            // This line is empty, but it contains inline decorations\n            sb.appendString(`<span>`);\n            let beforeCount = 0;\n            let afterCount = 0;\n            let containsForeignElements = 0 /* ForeignElementType.None */;\n            for (const lineDecoration of input.lineDecorations) {\n                if (lineDecoration.type === 1 /* InlineDecorationType.Before */ || lineDecoration.type === 2 /* InlineDecorationType.After */) {\n                    sb.appendString(`<span class=\"`);\n                    sb.appendString(lineDecoration.className);\n                    sb.appendString(`\"></span>`);\n                    if (lineDecoration.type === 1 /* InlineDecorationType.Before */) {\n                        containsForeignElements |= 1 /* ForeignElementType.Before */;\n                        beforeCount++;\n                    }\n                    if (lineDecoration.type === 2 /* InlineDecorationType.After */) {\n                        containsForeignElements |= 2 /* ForeignElementType.After */;\n                        afterCount++;\n                    }\n                }\n            }\n            sb.appendString(`</span>`);\n            const characterMapping = new CharacterMapping(1, beforeCount + afterCount);\n            characterMapping.setColumnInfo(1, beforeCount, 0, 0);\n            return new RenderLineOutput(characterMapping, containsForeignElements);\n        }\n        // completely empty line\n        if (input.renderNewLineWhenEmpty) {\n            sb.appendString('<span><span>\\n</span></span>');\n        }\n        else {\n            sb.appendString('<span><span></span></span>');\n        }\n        return new RenderLineOutput(new CharacterMapping(0, 0), 0 /* ForeignElementType.None */);\n    }\n    return _renderLine(resolveRenderLineInput(input), sb);\n}\nclass RenderLineOutput2 {\n    constructor(characterMapping, html, containsForeignElements) {\n        this.characterMapping = characterMapping;\n        this.html = html;\n        this.containsForeignElements = containsForeignElements;\n    }\n}\nfunction renderViewLine2(input) {\n    const sb = new StringBuilder(10000);\n    const out = renderViewLine(input, sb);\n    return new RenderLineOutput2(out.characterMapping, sb.build(), out.containsForeignElements);\n}\nclass ResolvedRenderLineInput {\n    constructor(fontIsMonospace, canUseHalfwidthRightwardsArrow, lineContent, len, isOverflowing, overflowingCharCount, parts, containsForeignElements, fauxIndentLength, tabSize, startVisibleColumn, spaceWidth, renderSpaceCharCode, renderWhitespace, renderControlCharacters) {\n        this.fontIsMonospace = fontIsMonospace;\n        this.canUseHalfwidthRightwardsArrow = canUseHalfwidthRightwardsArrow;\n        this.lineContent = lineContent;\n        this.len = len;\n        this.isOverflowing = isOverflowing;\n        this.overflowingCharCount = overflowingCharCount;\n        this.parts = parts;\n        this.containsForeignElements = containsForeignElements;\n        this.fauxIndentLength = fauxIndentLength;\n        this.tabSize = tabSize;\n        this.startVisibleColumn = startVisibleColumn;\n        this.spaceWidth = spaceWidth;\n        this.renderSpaceCharCode = renderSpaceCharCode;\n        this.renderWhitespace = renderWhitespace;\n        this.renderControlCharacters = renderControlCharacters;\n        //\n    }\n}\nfunction resolveRenderLineInput(input) {\n    const lineContent = input.lineContent;\n    let isOverflowing;\n    let overflowingCharCount;\n    let len;\n    if (input.stopRenderingLineAfter !== -1 && input.stopRenderingLineAfter < lineContent.length) {\n        isOverflowing = true;\n        overflowingCharCount = lineContent.length - input.stopRenderingLineAfter;\n        len = input.stopRenderingLineAfter;\n    }\n    else {\n        isOverflowing = false;\n        overflowingCharCount = 0;\n        len = lineContent.length;\n    }\n    let tokens = transformAndRemoveOverflowing(lineContent, input.containsRTL, input.lineTokens, input.fauxIndentLength, len);\n    if (input.renderControlCharacters && !input.isBasicASCII) {\n        // Calling `extractControlCharacters` before adding (possibly empty) line parts\n        // for inline decorations. `extractControlCharacters` removes empty line parts.\n        tokens = extractControlCharacters(lineContent, tokens);\n    }\n    if (input.renderWhitespace === 4 /* RenderWhitespace.All */ ||\n        input.renderWhitespace === 1 /* RenderWhitespace.Boundary */ ||\n        (input.renderWhitespace === 2 /* RenderWhitespace.Selection */ && !!input.selectionsOnLine) ||\n        (input.renderWhitespace === 3 /* RenderWhitespace.Trailing */ && !input.continuesWithWrappedLine)) {\n        tokens = _applyRenderWhitespace(input, lineContent, len, tokens);\n    }\n    let containsForeignElements = 0 /* ForeignElementType.None */;\n    if (input.lineDecorations.length > 0) {\n        for (let i = 0, len = input.lineDecorations.length; i < len; i++) {\n            const lineDecoration = input.lineDecorations[i];\n            if (lineDecoration.type === 3 /* InlineDecorationType.RegularAffectingLetterSpacing */) {\n                // Pretend there are foreign elements... although not 100% accurate.\n                containsForeignElements |= 1 /* ForeignElementType.Before */;\n            }\n            else if (lineDecoration.type === 1 /* InlineDecorationType.Before */) {\n                containsForeignElements |= 1 /* ForeignElementType.Before */;\n            }\n            else if (lineDecoration.type === 2 /* InlineDecorationType.After */) {\n                containsForeignElements |= 2 /* ForeignElementType.After */;\n            }\n        }\n        tokens = _applyInlineDecorations(lineContent, len, tokens, input.lineDecorations);\n    }\n    if (!input.containsRTL) {\n        // We can never split RTL text, as it ruins the rendering\n        tokens = splitLargeTokens(lineContent, tokens, !input.isBasicASCII || input.fontLigatures);\n    }\n    else {\n        // Split the first token if it contains both leading whitespace and RTL text\n        tokens = splitLeadingWhitespaceFromRTL(lineContent, tokens);\n    }\n    return new ResolvedRenderLineInput(input.useMonospaceOptimizations, input.canUseHalfwidthRightwardsArrow, lineContent, len, isOverflowing, overflowingCharCount, tokens, containsForeignElements, input.fauxIndentLength, input.tabSize, input.startVisibleColumn, input.spaceWidth, input.renderSpaceCharCode, input.renderWhitespace, input.renderControlCharacters);\n}\n/**\n * In the rendering phase, characters are always looped until token.endIndex.\n * Ensure that all tokens end before `len` and the last one ends precisely at `len`.\n */\nfunction transformAndRemoveOverflowing(lineContent, lineContainsRTL, tokens, fauxIndentLength, len) {\n    const result = [];\n    let resultLen = 0;\n    // The faux indent part of the line should have no token type\n    if (fauxIndentLength > 0) {\n        result[resultLen++] = new LinePart(fauxIndentLength, '', 0, false);\n    }\n    let startOffset = fauxIndentLength;\n    for (let tokenIndex = 0, tokensLen = tokens.getCount(); tokenIndex < tokensLen; tokenIndex++) {\n        const endIndex = tokens.getEndOffset(tokenIndex);\n        if (endIndex <= fauxIndentLength) {\n            // The faux indent part of the line should have no token type\n            continue;\n        }\n        const type = tokens.getClassName(tokenIndex);\n        if (endIndex >= len) {\n            const tokenContainsRTL = (lineContainsRTL ? containsRTL(lineContent.substring(startOffset, len)) : false);\n            result[resultLen++] = new LinePart(len, type, 0, tokenContainsRTL);\n            break;\n        }\n        const tokenContainsRTL = (lineContainsRTL ? containsRTL(lineContent.substring(startOffset, endIndex)) : false);\n        result[resultLen++] = new LinePart(endIndex, type, 0, tokenContainsRTL);\n        startOffset = endIndex;\n    }\n    return result;\n}\n/**\n * See https://github.com/microsoft/vscode/issues/6885.\n * It appears that having very large spans causes very slow reading of character positions.\n * So here we try to avoid that.\n */\nfunction splitLargeTokens(lineContent, tokens, onlyAtSpaces) {\n    let lastTokenEndIndex = 0;\n    const result = [];\n    let resultLen = 0;\n    if (onlyAtSpaces) {\n        // Split only at spaces => we need to walk each character\n        for (let i = 0, len = tokens.length; i < len; i++) {\n            const token = tokens[i];\n            const tokenEndIndex = token.endIndex;\n            if (lastTokenEndIndex + 50 /* Constants.LongToken */ < tokenEndIndex) {\n                const tokenType = token.type;\n                const tokenMetadata = token.metadata;\n                const tokenContainsRTL = token.containsRTL;\n                let lastSpaceOffset = -1;\n                let currTokenStart = lastTokenEndIndex;\n                for (let j = lastTokenEndIndex; j < tokenEndIndex; j++) {\n                    if (lineContent.charCodeAt(j) === 32 /* CharCode.Space */) {\n                        lastSpaceOffset = j;\n                    }\n                    if (lastSpaceOffset !== -1 && j - currTokenStart >= 50 /* Constants.LongToken */) {\n                        // Split at `lastSpaceOffset` + 1\n                        result[resultLen++] = new LinePart(lastSpaceOffset + 1, tokenType, tokenMetadata, tokenContainsRTL);\n                        currTokenStart = lastSpaceOffset + 1;\n                        lastSpaceOffset = -1;\n                    }\n                }\n                if (currTokenStart !== tokenEndIndex) {\n                    result[resultLen++] = new LinePart(tokenEndIndex, tokenType, tokenMetadata, tokenContainsRTL);\n                }\n            }\n            else {\n                result[resultLen++] = token;\n            }\n            lastTokenEndIndex = tokenEndIndex;\n        }\n    }\n    else {\n        // Split anywhere => we don't need to walk each character\n        for (let i = 0, len = tokens.length; i < len; i++) {\n            const token = tokens[i];\n            const tokenEndIndex = token.endIndex;\n            const diff = (tokenEndIndex - lastTokenEndIndex);\n            if (diff > 50 /* Constants.LongToken */) {\n                const tokenType = token.type;\n                const tokenMetadata = token.metadata;\n                const tokenContainsRTL = token.containsRTL;\n                const piecesCount = Math.ceil(diff / 50 /* Constants.LongToken */);\n                for (let j = 1; j < piecesCount; j++) {\n                    const pieceEndIndex = lastTokenEndIndex + (j * 50 /* Constants.LongToken */);\n                    result[resultLen++] = new LinePart(pieceEndIndex, tokenType, tokenMetadata, tokenContainsRTL);\n                }\n                result[resultLen++] = new LinePart(tokenEndIndex, tokenType, tokenMetadata, tokenContainsRTL);\n            }\n            else {\n                result[resultLen++] = token;\n            }\n            lastTokenEndIndex = tokenEndIndex;\n        }\n    }\n    return result;\n}\n/**\n * Splits leading whitespace from the first token if it contains RTL text.\n */\nfunction splitLeadingWhitespaceFromRTL(lineContent, tokens) {\n    if (tokens.length === 0) {\n        return tokens;\n    }\n    const firstToken = tokens[0];\n    if (!firstToken.containsRTL) {\n        return tokens;\n    }\n    // Check if the first token starts with whitespace\n    const firstTokenEndIndex = firstToken.endIndex;\n    let firstNonWhitespaceIndex = 0;\n    for (let i = 0; i < firstTokenEndIndex; i++) {\n        const charCode = lineContent.charCodeAt(i);\n        if (charCode !== 32 /* CharCode.Space */ && charCode !== 9 /* CharCode.Tab */) {\n            firstNonWhitespaceIndex = i;\n            break;\n        }\n    }\n    if (firstNonWhitespaceIndex === 0) {\n        // No leading whitespace\n        return tokens;\n    }\n    // Split the first token into leading whitespace and the rest\n    const result = [];\n    result.push(new LinePart(firstNonWhitespaceIndex, firstToken.type, firstToken.metadata, false));\n    result.push(new LinePart(firstTokenEndIndex, firstToken.type, firstToken.metadata, firstToken.containsRTL));\n    // Add remaining tokens\n    for (let i = 1; i < tokens.length; i++) {\n        result.push(tokens[i]);\n    }\n    return result;\n}\nfunction isControlCharacter(charCode) {\n    if (charCode < 32) {\n        return (charCode !== 9 /* CharCode.Tab */);\n    }\n    if (charCode === 127) {\n        // DEL\n        return true;\n    }\n    if ((charCode >= 0x202A && charCode <= 0x202E)\n        || (charCode >= 0x2066 && charCode <= 0x2069)\n        || (charCode >= 0x200E && charCode <= 0x200F)\n        || charCode === 0x061C) {\n        // Unicode Directional Formatting Characters\n        // LRE\tU+202A\tLEFT-TO-RIGHT EMBEDDING\n        // RLE\tU+202B\tRIGHT-TO-LEFT EMBEDDING\n        // PDF\tU+202C\tPOP DIRECTIONAL FORMATTING\n        // LRO\tU+202D\tLEFT-TO-RIGHT OVERRIDE\n        // RLO\tU+202E\tRIGHT-TO-LEFT OVERRIDE\n        // LRI\tU+2066\tLEFT-TO-RIGHT ISOLATE\n        // RLI\tU+2067\tRIGHT-TO-LEFT ISOLATE\n        // FSI\tU+2068\tFIRST STRONG ISOLATE\n        // PDI\tU+2069\tPOP DIRECTIONAL ISOLATE\n        // LRM\tU+200E\tLEFT-TO-RIGHT MARK\n        // RLM\tU+200F\tRIGHT-TO-LEFT MARK\n        // ALM\tU+061C\tARABIC LETTER MARK\n        return true;\n    }\n    return false;\n}\nfunction extractControlCharacters(lineContent, tokens) {\n    const result = [];\n    let lastLinePart = new LinePart(0, '', 0, false);\n    let charOffset = 0;\n    for (const token of tokens) {\n        const tokenEndIndex = token.endIndex;\n        for (; charOffset < tokenEndIndex; charOffset++) {\n            const charCode = lineContent.charCodeAt(charOffset);\n            if (isControlCharacter(charCode)) {\n                if (charOffset > lastLinePart.endIndex) {\n                    // emit previous part if it has text\n                    lastLinePart = new LinePart(charOffset, token.type, token.metadata, token.containsRTL);\n                    result.push(lastLinePart);\n                }\n                lastLinePart = new LinePart(charOffset + 1, 'mtkcontrol', token.metadata, false);\n                result.push(lastLinePart);\n            }\n        }\n        if (charOffset > lastLinePart.endIndex) {\n            // emit previous part if it has text\n            lastLinePart = new LinePart(tokenEndIndex, token.type, token.metadata, token.containsRTL);\n            result.push(lastLinePart);\n        }\n    }\n    return result;\n}\n/**\n * Whitespace is rendered by \"replacing\" tokens with a special-purpose `mtkw` type that is later recognized in the rendering phase.\n * Moreover, a token is created for every visual indent because on some fonts the glyphs used for rendering whitespace (&rarr; or &middot;) do not have the same width as &nbsp;.\n * The rendering phase will generate `style=\"width:...\"` for these tokens.\n */\nfunction _applyRenderWhitespace(input, lineContent, len, tokens) {\n    const continuesWithWrappedLine = input.continuesWithWrappedLine;\n    const fauxIndentLength = input.fauxIndentLength;\n    const tabSize = input.tabSize;\n    const startVisibleColumn = input.startVisibleColumn;\n    const useMonospaceOptimizations = input.useMonospaceOptimizations;\n    const selections = input.selectionsOnLine;\n    const onlyBoundary = (input.renderWhitespace === 1 /* RenderWhitespace.Boundary */);\n    const onlyTrailing = (input.renderWhitespace === 3 /* RenderWhitespace.Trailing */);\n    const generateLinePartForEachWhitespace = (input.renderSpaceWidth !== input.spaceWidth);\n    const result = [];\n    let resultLen = 0;\n    let tokenIndex = 0;\n    let tokenType = tokens[tokenIndex].type;\n    let tokenContainsRTL = tokens[tokenIndex].containsRTL;\n    let tokenEndIndex = tokens[tokenIndex].endIndex;\n    const tokensLength = tokens.length;\n    let lineIsEmptyOrWhitespace = false;\n    let firstNonWhitespaceIndex$1 = firstNonWhitespaceIndex(lineContent);\n    let lastNonWhitespaceIndex$1;\n    if (firstNonWhitespaceIndex$1 === -1) {\n        lineIsEmptyOrWhitespace = true;\n        firstNonWhitespaceIndex$1 = len;\n        lastNonWhitespaceIndex$1 = len;\n    }\n    else {\n        lastNonWhitespaceIndex$1 = lastNonWhitespaceIndex(lineContent);\n    }\n    let wasInWhitespace = false;\n    let currentSelectionIndex = 0;\n    let currentSelection = selections && selections[currentSelectionIndex];\n    let tmpIndent = startVisibleColumn % tabSize;\n    for (let charIndex = fauxIndentLength; charIndex < len; charIndex++) {\n        const chCode = lineContent.charCodeAt(charIndex);\n        if (currentSelection && currentSelection.endExclusive <= charIndex) {\n            currentSelectionIndex++;\n            currentSelection = selections && selections[currentSelectionIndex];\n        }\n        let isInWhitespace;\n        if (charIndex < firstNonWhitespaceIndex$1 || charIndex > lastNonWhitespaceIndex$1) {\n            // in leading or trailing whitespace\n            isInWhitespace = true;\n        }\n        else if (chCode === 9 /* CharCode.Tab */) {\n            // a tab character is rendered both in all and boundary cases\n            isInWhitespace = true;\n        }\n        else if (chCode === 32 /* CharCode.Space */) {\n            // hit a space character\n            if (onlyBoundary) {\n                // rendering only boundary whitespace\n                if (wasInWhitespace) {\n                    isInWhitespace = true;\n                }\n                else {\n                    const nextChCode = (charIndex + 1 < len ? lineContent.charCodeAt(charIndex + 1) : 0 /* CharCode.Null */);\n                    isInWhitespace = (nextChCode === 32 /* CharCode.Space */ || nextChCode === 9 /* CharCode.Tab */);\n                }\n            }\n            else {\n                isInWhitespace = true;\n            }\n        }\n        else {\n            isInWhitespace = false;\n        }\n        // If rendering whitespace on selection, check that the charIndex falls within a selection\n        if (isInWhitespace && selections) {\n            isInWhitespace = !!currentSelection && currentSelection.start <= charIndex && charIndex < currentSelection.endExclusive;\n        }\n        // If rendering only trailing whitespace, check that the charIndex points to trailing whitespace.\n        if (isInWhitespace && onlyTrailing) {\n            isInWhitespace = lineIsEmptyOrWhitespace || charIndex > lastNonWhitespaceIndex$1;\n        }\n        if (isInWhitespace && tokenContainsRTL) {\n            // If the token contains RTL text, breaking it up into multiple line parts\n            // to render whitespace might affect the browser's bidi layout.\n            //\n            // We render whitespace in such tokens only if the whitespace\n            // is the leading or the trailing whitespace of the line,\n            // which doesn't affect the browser's bidi layout.\n            if (charIndex >= firstNonWhitespaceIndex$1 && charIndex <= lastNonWhitespaceIndex$1) {\n                isInWhitespace = false;\n            }\n        }\n        if (wasInWhitespace) {\n            // was in whitespace token\n            if (!isInWhitespace || (!useMonospaceOptimizations && tmpIndent >= tabSize)) {\n                // leaving whitespace token or entering a new indent\n                if (generateLinePartForEachWhitespace) {\n                    const lastEndIndex = (resultLen > 0 ? result[resultLen - 1].endIndex : fauxIndentLength);\n                    for (let i = lastEndIndex + 1; i <= charIndex; i++) {\n                        result[resultLen++] = new LinePart(i, 'mtkw', 1 /* LinePartMetadata.IS_WHITESPACE */, false);\n                    }\n                }\n                else {\n                    result[resultLen++] = new LinePart(charIndex, 'mtkw', 1 /* LinePartMetadata.IS_WHITESPACE */, false);\n                }\n                tmpIndent = tmpIndent % tabSize;\n            }\n        }\n        else {\n            // was in regular token\n            if (charIndex === tokenEndIndex || (isInWhitespace && charIndex > fauxIndentLength)) {\n                result[resultLen++] = new LinePart(charIndex, tokenType, 0, tokenContainsRTL);\n                tmpIndent = tmpIndent % tabSize;\n            }\n        }\n        if (chCode === 9 /* CharCode.Tab */) {\n            tmpIndent = tabSize;\n        }\n        else if (isFullWidthCharacter(chCode)) {\n            tmpIndent += 2;\n        }\n        else {\n            tmpIndent++;\n        }\n        wasInWhitespace = isInWhitespace;\n        while (charIndex === tokenEndIndex) {\n            tokenIndex++;\n            if (tokenIndex < tokensLength) {\n                tokenType = tokens[tokenIndex].type;\n                tokenContainsRTL = tokens[tokenIndex].containsRTL;\n                tokenEndIndex = tokens[tokenIndex].endIndex;\n            }\n            else {\n                break;\n            }\n        }\n    }\n    let generateWhitespace = false;\n    if (wasInWhitespace) {\n        // was in whitespace token\n        if (continuesWithWrappedLine && onlyBoundary) {\n            const lastCharCode = (len > 0 ? lineContent.charCodeAt(len - 1) : 0 /* CharCode.Null */);\n            const prevCharCode = (len > 1 ? lineContent.charCodeAt(len - 2) : 0 /* CharCode.Null */);\n            const isSingleTrailingSpace = (lastCharCode === 32 /* CharCode.Space */ && (prevCharCode !== 32 /* CharCode.Space */ && prevCharCode !== 9 /* CharCode.Tab */));\n            if (!isSingleTrailingSpace) {\n                generateWhitespace = true;\n            }\n        }\n        else {\n            generateWhitespace = true;\n        }\n    }\n    if (generateWhitespace) {\n        if (generateLinePartForEachWhitespace) {\n            const lastEndIndex = (resultLen > 0 ? result[resultLen - 1].endIndex : fauxIndentLength);\n            for (let i = lastEndIndex + 1; i <= len; i++) {\n                result[resultLen++] = new LinePart(i, 'mtkw', 1 /* LinePartMetadata.IS_WHITESPACE */, false);\n            }\n        }\n        else {\n            result[resultLen++] = new LinePart(len, 'mtkw', 1 /* LinePartMetadata.IS_WHITESPACE */, false);\n        }\n    }\n    else {\n        result[resultLen++] = new LinePart(len, tokenType, 0, tokenContainsRTL);\n    }\n    return result;\n}\n/**\n * Inline decorations are \"merged\" on top of tokens.\n * Special care must be taken when multiple inline decorations are at play and they overlap.\n */\nfunction _applyInlineDecorations(lineContent, len, tokens, _lineDecorations) {\n    _lineDecorations.sort(LineDecoration.compare);\n    const lineDecorations = LineDecorationsNormalizer.normalize(lineContent, _lineDecorations);\n    const lineDecorationsLen = lineDecorations.length;\n    let lineDecorationIndex = 0;\n    const result = [];\n    let resultLen = 0;\n    let lastResultEndIndex = 0;\n    for (let tokenIndex = 0, len = tokens.length; tokenIndex < len; tokenIndex++) {\n        const token = tokens[tokenIndex];\n        const tokenEndIndex = token.endIndex;\n        const tokenType = token.type;\n        const tokenMetadata = token.metadata;\n        const tokenContainsRTL = token.containsRTL;\n        while (lineDecorationIndex < lineDecorationsLen && lineDecorations[lineDecorationIndex].startOffset < tokenEndIndex) {\n            const lineDecoration = lineDecorations[lineDecorationIndex];\n            if (lineDecoration.startOffset > lastResultEndIndex) {\n                lastResultEndIndex = lineDecoration.startOffset;\n                result[resultLen++] = new LinePart(lastResultEndIndex, tokenType, tokenMetadata, tokenContainsRTL);\n            }\n            if (lineDecoration.endOffset + 1 <= tokenEndIndex) {\n                // This line decoration ends before this token ends\n                lastResultEndIndex = lineDecoration.endOffset + 1;\n                result[resultLen++] = new LinePart(lastResultEndIndex, tokenType + ' ' + lineDecoration.className, tokenMetadata | lineDecoration.metadata, tokenContainsRTL);\n                lineDecorationIndex++;\n            }\n            else {\n                // This line decoration continues on to the next token\n                lastResultEndIndex = tokenEndIndex;\n                result[resultLen++] = new LinePart(lastResultEndIndex, tokenType + ' ' + lineDecoration.className, tokenMetadata | lineDecoration.metadata, tokenContainsRTL);\n                break;\n            }\n        }\n        if (tokenEndIndex > lastResultEndIndex) {\n            lastResultEndIndex = tokenEndIndex;\n            result[resultLen++] = new LinePart(lastResultEndIndex, tokenType, tokenMetadata, tokenContainsRTL);\n        }\n    }\n    const lastTokenEndIndex = tokens[tokens.length - 1].endIndex;\n    if (lineDecorationIndex < lineDecorationsLen && lineDecorations[lineDecorationIndex].startOffset === lastTokenEndIndex) {\n        while (lineDecorationIndex < lineDecorationsLen && lineDecorations[lineDecorationIndex].startOffset === lastTokenEndIndex) {\n            const lineDecoration = lineDecorations[lineDecorationIndex];\n            result[resultLen++] = new LinePart(lastResultEndIndex, lineDecoration.className, lineDecoration.metadata, false);\n            lineDecorationIndex++;\n        }\n    }\n    return result;\n}\n/**\n * This function is on purpose not split up into multiple functions to allow runtime type inference (i.e. performance reasons).\n * Notice how all the needed data is fully resolved and passed in (i.e. no other calls).\n */\nfunction _renderLine(input, sb) {\n    const fontIsMonospace = input.fontIsMonospace;\n    const canUseHalfwidthRightwardsArrow = input.canUseHalfwidthRightwardsArrow;\n    const containsForeignElements = input.containsForeignElements;\n    const lineContent = input.lineContent;\n    const len = input.len;\n    const isOverflowing = input.isOverflowing;\n    const overflowingCharCount = input.overflowingCharCount;\n    const parts = input.parts;\n    const fauxIndentLength = input.fauxIndentLength;\n    const tabSize = input.tabSize;\n    const startVisibleColumn = input.startVisibleColumn;\n    const spaceWidth = input.spaceWidth;\n    const renderSpaceCharCode = input.renderSpaceCharCode;\n    const renderWhitespace = input.renderWhitespace;\n    const renderControlCharacters = input.renderControlCharacters;\n    const characterMapping = new CharacterMapping(len + 1, parts.length);\n    let lastCharacterMappingDefined = false;\n    let charIndex = 0;\n    let visibleColumn = startVisibleColumn;\n    let charOffsetInPart = 0; // the character offset in the current part\n    let charHorizontalOffset = 0; // the character horizontal position in terms of chars relative to line start\n    let partDisplacement = 0;\n    sb.appendString('<span>');\n    for (let partIndex = 0, tokensLen = parts.length; partIndex < tokensLen; partIndex++) {\n        const part = parts[partIndex];\n        const partEndIndex = part.endIndex;\n        const partType = part.type;\n        const partContainsRTL = part.containsRTL;\n        const partRendersWhitespace = (renderWhitespace !== 0 /* RenderWhitespace.None */ && part.isWhitespace());\n        const partRendersWhitespaceWithWidth = partRendersWhitespace && !fontIsMonospace && (partType === 'mtkw' /*only whitespace*/ || !containsForeignElements);\n        const partIsEmptyAndHasPseudoAfter = (charIndex === partEndIndex && part.isPseudoAfter());\n        charOffsetInPart = 0;\n        sb.appendString('<span ');\n        if (partContainsRTL) {\n            sb.appendString('dir=\"rtl\" style=\"unicode-bidi:isolate\" ');\n        }\n        sb.appendString('class=\"');\n        sb.appendString(partRendersWhitespaceWithWidth ? 'mtkz' : partType);\n        sb.appendASCIICharCode(34 /* CharCode.DoubleQuote */);\n        if (partRendersWhitespace) {\n            let partWidth = 0;\n            {\n                let _charIndex = charIndex;\n                let _visibleColumn = visibleColumn;\n                for (; _charIndex < partEndIndex; _charIndex++) {\n                    const charCode = lineContent.charCodeAt(_charIndex);\n                    const charWidth = (charCode === 9 /* CharCode.Tab */ ? (tabSize - (_visibleColumn % tabSize)) : 1) | 0;\n                    partWidth += charWidth;\n                    if (_charIndex >= fauxIndentLength) {\n                        _visibleColumn += charWidth;\n                    }\n                }\n            }\n            if (partRendersWhitespaceWithWidth) {\n                sb.appendString(' style=\"width:');\n                sb.appendString(String(spaceWidth * partWidth));\n                sb.appendString('px\"');\n            }\n            sb.appendASCIICharCode(62 /* CharCode.GreaterThan */);\n            for (; charIndex < partEndIndex; charIndex++) {\n                characterMapping.setColumnInfo(charIndex + 1, partIndex - partDisplacement, charOffsetInPart, charHorizontalOffset);\n                partDisplacement = 0;\n                const charCode = lineContent.charCodeAt(charIndex);\n                let producedCharacters;\n                let charWidth;\n                if (charCode === 9 /* CharCode.Tab */) {\n                    producedCharacters = (tabSize - (visibleColumn % tabSize)) | 0;\n                    charWidth = producedCharacters;\n                    if (!canUseHalfwidthRightwardsArrow || charWidth > 1) {\n                        sb.appendCharCode(0x2192); // RIGHTWARDS ARROW\n                    }\n                    else {\n                        sb.appendCharCode(0xFFEB); // HALFWIDTH RIGHTWARDS ARROW\n                    }\n                    for (let space = 2; space <= charWidth; space++) {\n                        sb.appendCharCode(0xA0); // &nbsp;\n                    }\n                }\n                else { // must be CharCode.Space\n                    producedCharacters = 2;\n                    charWidth = 1;\n                    sb.appendCharCode(renderSpaceCharCode); // &middot; or word separator middle dot\n                    sb.appendCharCode(0x200C); // ZERO WIDTH NON-JOINER\n                }\n                charOffsetInPart += producedCharacters;\n                charHorizontalOffset += charWidth;\n                if (charIndex >= fauxIndentLength) {\n                    visibleColumn += charWidth;\n                }\n            }\n        }\n        else {\n            sb.appendASCIICharCode(62 /* CharCode.GreaterThan */);\n            for (; charIndex < partEndIndex; charIndex++) {\n                characterMapping.setColumnInfo(charIndex + 1, partIndex - partDisplacement, charOffsetInPart, charHorizontalOffset);\n                partDisplacement = 0;\n                const charCode = lineContent.charCodeAt(charIndex);\n                let producedCharacters = 1;\n                let charWidth = 1;\n                switch (charCode) {\n                    case 9 /* CharCode.Tab */:\n                        producedCharacters = (tabSize - (visibleColumn % tabSize));\n                        charWidth = producedCharacters;\n                        for (let space = 1; space <= producedCharacters; space++) {\n                            sb.appendCharCode(0xA0); // &nbsp;\n                        }\n                        break;\n                    case 32 /* CharCode.Space */:\n                        sb.appendCharCode(0xA0); // &nbsp;\n                        break;\n                    case 60 /* CharCode.LessThan */:\n                        sb.appendString('&lt;');\n                        break;\n                    case 62 /* CharCode.GreaterThan */:\n                        sb.appendString('&gt;');\n                        break;\n                    case 38 /* CharCode.Ampersand */:\n                        sb.appendString('&amp;');\n                        break;\n                    case 0 /* CharCode.Null */:\n                        if (renderControlCharacters) {\n                            // See https://unicode-table.com/en/blocks/control-pictures/\n                            sb.appendCharCode(9216);\n                        }\n                        else {\n                            sb.appendString('&#00;');\n                        }\n                        break;\n                    case 65279 /* CharCode.UTF8_BOM */:\n                    case 8232 /* CharCode.LINE_SEPARATOR */:\n                    case 8233 /* CharCode.PARAGRAPH_SEPARATOR */:\n                    case 133 /* CharCode.NEXT_LINE */:\n                        sb.appendCharCode(0xFFFD);\n                        break;\n                    default:\n                        if (isFullWidthCharacter(charCode)) {\n                            charWidth++;\n                        }\n                        // See https://unicode-table.com/en/blocks/control-pictures/\n                        if (renderControlCharacters && charCode < 32) {\n                            sb.appendCharCode(9216 + charCode);\n                        }\n                        else if (renderControlCharacters && charCode === 127) {\n                            // DEL\n                            sb.appendCharCode(9249);\n                        }\n                        else if (renderControlCharacters && isControlCharacter(charCode)) {\n                            sb.appendString('[U+');\n                            sb.appendString(to4CharHex(charCode));\n                            sb.appendString(']');\n                            producedCharacters = 8;\n                            charWidth = producedCharacters;\n                        }\n                        else {\n                            sb.appendCharCode(charCode);\n                        }\n                }\n                charOffsetInPart += producedCharacters;\n                charHorizontalOffset += charWidth;\n                if (charIndex >= fauxIndentLength) {\n                    visibleColumn += charWidth;\n                }\n            }\n        }\n        if (partIsEmptyAndHasPseudoAfter) {\n            partDisplacement++;\n        }\n        else {\n            partDisplacement = 0;\n        }\n        if (charIndex >= len && !lastCharacterMappingDefined && part.isPseudoAfter()) {\n            lastCharacterMappingDefined = true;\n            characterMapping.setColumnInfo(charIndex + 1, partIndex, charOffsetInPart, charHorizontalOffset);\n        }\n        sb.appendString('</span>');\n    }\n    if (!lastCharacterMappingDefined) {\n        // When getting client rects for the last character, we will position the\n        // text range at the end of the span, insteaf of at the beginning of next span\n        characterMapping.setColumnInfo(len + 1, parts.length - 1, charOffsetInPart, charHorizontalOffset);\n    }\n    if (isOverflowing) {\n        sb.appendString('<span class=\"mtkoverflow\">');\n        sb.appendString(localize(796, \"Show more ({0})\", renderOverflowingCharCount(overflowingCharCount)));\n        sb.appendString('</span>');\n    }\n    sb.appendString('</span>');\n    return new RenderLineOutput(characterMapping, containsForeignElements);\n}\nfunction to4CharHex(n) {\n    return n.toString(16).toUpperCase().padStart(4, '0');\n}\nfunction renderOverflowingCharCount(n) {\n    if (n < 1024) {\n        return localize(797, \"{0} chars\", n);\n    }\n    if (n < 1024 * 1024) {\n        return `${(n / 1024).toFixed(1)} KB`;\n    }\n    return `${(n / 1024 / 1024).toFixed(1)} MB`;\n}\n\nexport { CharacterMapping, DomPosition, RenderLineInput, RenderLineOutput, RenderLineOutput2, renderViewLine, renderViewLine2 };\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1136, "column": 0}, "map": {"version":3,"sources":["file:///D:/real-time-code-editor%20%282%29/node_modules/.pnpm/monaco-editor%400.55.1/node_modules/monaco-editor/esm/vs/editor/common/viewLayout/viewLinesViewportData.js"],"sourcesContent":["import { Range } from '../core/range.js';\n\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n/**\n * Contains all data needed to render at a specific viewport.\n */\nclass ViewportData {\n    constructor(selections, partialData, whitespaceViewportData, model) {\n        this.selections = selections;\n        this.startLineNumber = partialData.startLineNumber | 0;\n        this.endLineNumber = partialData.endLineNumber | 0;\n        this.relativeVerticalOffset = partialData.relativeVerticalOffset;\n        this.bigNumbersDelta = partialData.bigNumbersDelta | 0;\n        this.lineHeight = partialData.lineHeight | 0;\n        this.whitespaceViewportData = whitespaceViewportData;\n        this._model = model;\n        this.visibleRange = new Range(partialData.startLineNumber, this._model.getLineMinColumn(partialData.startLineNumber), partialData.endLineNumber, this._model.getLineMaxColumn(partialData.endLineNumber));\n    }\n    getViewLineRenderingData(lineNumber) {\n        return this._model.getViewportViewLineRenderingData(this.visibleRange, lineNumber);\n    }\n    getDecorationsInViewport() {\n        return this._model.getDecorationsInViewport(this.visibleRange);\n    }\n}\n\nexport { ViewportData };\n"],"names":[],"mappings":";;;;AAAA;;AAEA;;;8FAG8F,GAC9F;;CAEC,GACD,MAAM;IACF,YAAY,UAAU,EAAE,WAAW,EAAE,sBAAsB,EAAE,KAAK,CAAE;QAChE,IAAI,CAAC,UAAU,GAAG;QAClB,IAAI,CAAC,eAAe,GAAG,YAAY,eAAe,GAAG;QACrD,IAAI,CAAC,aAAa,GAAG,YAAY,aAAa,GAAG;QACjD,IAAI,CAAC,sBAAsB,GAAG,YAAY,sBAAsB;QAChE,IAAI,CAAC,eAAe,GAAG,YAAY,eAAe,GAAG;QACrD,IAAI,CAAC,UAAU,GAAG,YAAY,UAAU,GAAG;QAC3C,IAAI,CAAC,sBAAsB,GAAG;QAC9B,IAAI,CAAC,MAAM,GAAG;QACd,IAAI,CAAC,YAAY,GAAG,IAAI,4PAAK,CAAC,YAAY,eAAe,EAAE,IAAI,CAAC,MAAM,CAAC,gBAAgB,CAAC,YAAY,eAAe,GAAG,YAAY,aAAa,EAAE,IAAI,CAAC,MAAM,CAAC,gBAAgB,CAAC,YAAY,aAAa;IAC3M;IACA,yBAAyB,UAAU,EAAE;QACjC,OAAO,IAAI,CAAC,MAAM,CAAC,gCAAgC,CAAC,IAAI,CAAC,YAAY,EAAE;IAC3E;IACA,2BAA2B;QACvB,OAAO,IAAI,CAAC,MAAM,CAAC,wBAAwB,CAAC,IAAI,CAAC,YAAY;IACjE;AACJ","ignoreList":[0]}},
    {"offset": {"line": 1171, "column": 0}, "map": {"version":3,"sources":["file:///D:/real-time-code-editor%20%282%29/node_modules/.pnpm/monaco-editor%400.55.1/node_modules/monaco-editor/esm/vs/editor/common/viewLayout/lineHeights.js"],"sourcesContent":["import { binarySearch2 } from '../../../base/common/arrays.js';\nimport { intersection } from '../../../base/common/collections.js';\n\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nclass CustomLine {\n    constructor(decorationId, index, lineNumber, specialHeight, prefixSum) {\n        this.decorationId = decorationId;\n        this.index = index;\n        this.lineNumber = lineNumber;\n        this.specialHeight = specialHeight;\n        this.prefixSum = prefixSum;\n        this.maximumSpecialHeight = specialHeight;\n        this.deleted = false;\n    }\n}\n/**\n * Manages line heights in the editor with support for custom line heights from decorations.\n *\n * This class maintains an ordered collection of line heights, where each line can have either\n * the default height or a custom height specified by decorations. It supports efficient querying\n * of individual line heights as well as accumulated heights up to a specific line.\n *\n * Line heights are stored in a sorted array for efficient binary search operations. Each line\n * with custom height is represented by a {@link CustomLine} object which tracks its special height,\n * accumulated height prefix sum, and associated decoration ID.\n *\n * The class optimizes performance by:\n * - Using binary search to locate lines in the ordered array\n * - Batching updates through a pending changes mechanism\n * - Computing prefix sums for O(1) accumulated height lookup\n * - Tracking maximum height for lines with multiple decorations\n * - Efficiently handling document changes (line insertions and deletions)\n *\n * When lines are inserted or deleted, the manager updates line numbers and prefix sums\n * for all affected lines. It also handles special cases like decorations that span\n * the insertion/deletion points by re-applying those decorations appropriately.\n *\n * All query operations automatically commit pending changes to ensure consistent results.\n * Clients can modify line heights by adding or removing custom line height decorations,\n * which are tracked by their unique decoration IDs.\n */\nclass LineHeightsManager {\n    constructor(defaultLineHeight, customLineHeightData) {\n        this._decorationIDToCustomLine = new ArrayMap();\n        this._orderedCustomLines = [];\n        this._pendingSpecialLinesToInsert = [];\n        this._invalidIndex = 0;\n        this._hasPending = false;\n        this._defaultLineHeight = defaultLineHeight;\n        if (customLineHeightData.length > 0) {\n            for (const data of customLineHeightData) {\n                this.insertOrChangeCustomLineHeight(data.decorationId, data.startLineNumber, data.endLineNumber, data.lineHeight);\n            }\n            this.commit();\n        }\n    }\n    set defaultLineHeight(defaultLineHeight) {\n        this._defaultLineHeight = defaultLineHeight;\n    }\n    get defaultLineHeight() {\n        return this._defaultLineHeight;\n    }\n    removeCustomLineHeight(decorationID) {\n        const customLines = this._decorationIDToCustomLine.get(decorationID);\n        if (!customLines) {\n            return;\n        }\n        this._decorationIDToCustomLine.delete(decorationID);\n        for (const customLine of customLines) {\n            customLine.deleted = true;\n            this._invalidIndex = Math.min(this._invalidIndex, customLine.index);\n        }\n        this._hasPending = true;\n    }\n    insertOrChangeCustomLineHeight(decorationId, startLineNumber, endLineNumber, lineHeight) {\n        this.removeCustomLineHeight(decorationId);\n        for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n            const customLine = new CustomLine(decorationId, -1, lineNumber, lineHeight, 0);\n            this._pendingSpecialLinesToInsert.push(customLine);\n        }\n        this._hasPending = true;\n    }\n    heightForLineNumber(lineNumber) {\n        const searchIndex = this._binarySearchOverOrderedCustomLinesArray(lineNumber);\n        if (searchIndex >= 0) {\n            return this._orderedCustomLines[searchIndex].maximumSpecialHeight;\n        }\n        return this._defaultLineHeight;\n    }\n    getAccumulatedLineHeightsIncludingLineNumber(lineNumber) {\n        const searchIndex = this._binarySearchOverOrderedCustomLinesArray(lineNumber);\n        if (searchIndex >= 0) {\n            return this._orderedCustomLines[searchIndex].prefixSum + this._orderedCustomLines[searchIndex].maximumSpecialHeight;\n        }\n        if (searchIndex === -1) {\n            return this._defaultLineHeight * lineNumber;\n        }\n        const modifiedIndex = -(searchIndex + 1);\n        const previousSpecialLine = this._orderedCustomLines[modifiedIndex - 1];\n        return previousSpecialLine.prefixSum + previousSpecialLine.maximumSpecialHeight + this._defaultLineHeight * (lineNumber - previousSpecialLine.lineNumber);\n    }\n    onLinesDeleted(fromLineNumber, toLineNumber) {\n        const deleteCount = toLineNumber - fromLineNumber + 1;\n        const numberOfCustomLines = this._orderedCustomLines.length;\n        const candidateStartIndexOfDeletion = this._binarySearchOverOrderedCustomLinesArray(fromLineNumber);\n        let startIndexOfDeletion;\n        if (candidateStartIndexOfDeletion >= 0) {\n            startIndexOfDeletion = candidateStartIndexOfDeletion;\n            for (let i = candidateStartIndexOfDeletion - 1; i >= 0; i--) {\n                if (this._orderedCustomLines[i].lineNumber === fromLineNumber) {\n                    startIndexOfDeletion--;\n                }\n                else {\n                    break;\n                }\n            }\n        }\n        else {\n            startIndexOfDeletion = candidateStartIndexOfDeletion === -(numberOfCustomLines + 1) && candidateStartIndexOfDeletion !== -1 ? numberOfCustomLines - 1 : -(candidateStartIndexOfDeletion + 1);\n        }\n        const candidateEndIndexOfDeletion = this._binarySearchOverOrderedCustomLinesArray(toLineNumber);\n        let endIndexOfDeletion;\n        if (candidateEndIndexOfDeletion >= 0) {\n            endIndexOfDeletion = candidateEndIndexOfDeletion;\n            for (let i = candidateEndIndexOfDeletion + 1; i < numberOfCustomLines; i++) {\n                if (this._orderedCustomLines[i].lineNumber === toLineNumber) {\n                    endIndexOfDeletion++;\n                }\n                else {\n                    break;\n                }\n            }\n        }\n        else {\n            endIndexOfDeletion = candidateEndIndexOfDeletion === -(numberOfCustomLines + 1) && candidateEndIndexOfDeletion !== -1 ? numberOfCustomLines - 1 : -(candidateEndIndexOfDeletion + 1);\n        }\n        const isEndIndexBiggerThanStartIndex = endIndexOfDeletion > startIndexOfDeletion;\n        const isEndIndexEqualToStartIndexAndCoversCustomLine = endIndexOfDeletion === startIndexOfDeletion\n            && this._orderedCustomLines[startIndexOfDeletion]\n            && this._orderedCustomLines[startIndexOfDeletion].lineNumber >= fromLineNumber\n            && this._orderedCustomLines[startIndexOfDeletion].lineNumber <= toLineNumber;\n        if (isEndIndexBiggerThanStartIndex || isEndIndexEqualToStartIndexAndCoversCustomLine) {\n            let maximumSpecialHeightOnDeletedInterval = 0;\n            for (let i = startIndexOfDeletion; i <= endIndexOfDeletion; i++) {\n                maximumSpecialHeightOnDeletedInterval = Math.max(maximumSpecialHeightOnDeletedInterval, this._orderedCustomLines[i].maximumSpecialHeight);\n            }\n            let prefixSumOnDeletedInterval = 0;\n            if (startIndexOfDeletion > 0) {\n                const previousSpecialLine = this._orderedCustomLines[startIndexOfDeletion - 1];\n                prefixSumOnDeletedInterval = previousSpecialLine.prefixSum + previousSpecialLine.maximumSpecialHeight + this._defaultLineHeight * (fromLineNumber - previousSpecialLine.lineNumber - 1);\n            }\n            else {\n                prefixSumOnDeletedInterval = fromLineNumber > 0 ? (fromLineNumber - 1) * this._defaultLineHeight : 0;\n            }\n            const firstSpecialLineDeleted = this._orderedCustomLines[startIndexOfDeletion];\n            const lastSpecialLineDeleted = this._orderedCustomLines[endIndexOfDeletion];\n            const firstSpecialLineAfterDeletion = this._orderedCustomLines[endIndexOfDeletion + 1];\n            const heightOfFirstLineAfterDeletion = firstSpecialLineAfterDeletion && firstSpecialLineAfterDeletion.lineNumber === toLineNumber + 1 ? firstSpecialLineAfterDeletion.maximumSpecialHeight : this._defaultLineHeight;\n            const totalHeightDeleted = lastSpecialLineDeleted.prefixSum\n                + lastSpecialLineDeleted.maximumSpecialHeight\n                - firstSpecialLineDeleted.prefixSum\n                + this._defaultLineHeight * (toLineNumber - lastSpecialLineDeleted.lineNumber)\n                + this._defaultLineHeight * (firstSpecialLineDeleted.lineNumber - fromLineNumber)\n                + heightOfFirstLineAfterDeletion - maximumSpecialHeightOnDeletedInterval;\n            const decorationIdsSeen = new Set();\n            const newOrderedCustomLines = [];\n            const newDecorationIDToSpecialLine = new ArrayMap();\n            let numberOfDeletions = 0;\n            for (let i = 0; i < this._orderedCustomLines.length; i++) {\n                const customLine = this._orderedCustomLines[i];\n                if (i < startIndexOfDeletion) {\n                    newOrderedCustomLines.push(customLine);\n                    newDecorationIDToSpecialLine.add(customLine.decorationId, customLine);\n                }\n                else if (i >= startIndexOfDeletion && i <= endIndexOfDeletion) {\n                    const decorationId = customLine.decorationId;\n                    if (!decorationIdsSeen.has(decorationId)) {\n                        customLine.index -= numberOfDeletions;\n                        customLine.lineNumber = fromLineNumber;\n                        customLine.prefixSum = prefixSumOnDeletedInterval;\n                        customLine.maximumSpecialHeight = maximumSpecialHeightOnDeletedInterval;\n                        newOrderedCustomLines.push(customLine);\n                        newDecorationIDToSpecialLine.add(customLine.decorationId, customLine);\n                    }\n                    else {\n                        numberOfDeletions++;\n                    }\n                }\n                else if (i > endIndexOfDeletion) {\n                    customLine.index -= numberOfDeletions;\n                    customLine.lineNumber -= deleteCount;\n                    customLine.prefixSum -= totalHeightDeleted;\n                    newOrderedCustomLines.push(customLine);\n                    newDecorationIDToSpecialLine.add(customLine.decorationId, customLine);\n                }\n                decorationIdsSeen.add(customLine.decorationId);\n            }\n            this._orderedCustomLines = newOrderedCustomLines;\n            this._decorationIDToCustomLine = newDecorationIDToSpecialLine;\n        }\n        else {\n            const totalHeightDeleted = deleteCount * this._defaultLineHeight;\n            for (let i = endIndexOfDeletion; i < this._orderedCustomLines.length; i++) {\n                const customLine = this._orderedCustomLines[i];\n                if (customLine.lineNumber > toLineNumber) {\n                    customLine.lineNumber -= deleteCount;\n                    customLine.prefixSum -= totalHeightDeleted;\n                }\n            }\n        }\n    }\n    onLinesInserted(fromLineNumber, toLineNumber) {\n        const insertCount = toLineNumber - fromLineNumber + 1;\n        const candidateStartIndexOfInsertion = this._binarySearchOverOrderedCustomLinesArray(fromLineNumber);\n        let startIndexOfInsertion;\n        if (candidateStartIndexOfInsertion >= 0) {\n            startIndexOfInsertion = candidateStartIndexOfInsertion;\n            for (let i = candidateStartIndexOfInsertion - 1; i >= 0; i--) {\n                if (this._orderedCustomLines[i].lineNumber === fromLineNumber) {\n                    startIndexOfInsertion--;\n                }\n                else {\n                    break;\n                }\n            }\n        }\n        else {\n            startIndexOfInsertion = -(candidateStartIndexOfInsertion + 1);\n        }\n        const toReAdd = [];\n        const decorationsImmediatelyAfter = new Set();\n        for (let i = startIndexOfInsertion; i < this._orderedCustomLines.length; i++) {\n            if (this._orderedCustomLines[i].lineNumber === fromLineNumber) {\n                decorationsImmediatelyAfter.add(this._orderedCustomLines[i].decorationId);\n            }\n        }\n        const decorationsImmediatelyBefore = new Set();\n        for (let i = startIndexOfInsertion - 1; i >= 0; i--) {\n            if (this._orderedCustomLines[i].lineNumber === fromLineNumber - 1) {\n                decorationsImmediatelyBefore.add(this._orderedCustomLines[i].decorationId);\n            }\n        }\n        const decorationsWithGaps = intersection(decorationsImmediatelyBefore, decorationsImmediatelyAfter);\n        for (let i = startIndexOfInsertion; i < this._orderedCustomLines.length; i++) {\n            this._orderedCustomLines[i].lineNumber += insertCount;\n            this._orderedCustomLines[i].prefixSum += this._defaultLineHeight * insertCount;\n        }\n        if (decorationsWithGaps.size > 0) {\n            for (const decorationId of decorationsWithGaps) {\n                const decoration = this._decorationIDToCustomLine.get(decorationId);\n                if (decoration) {\n                    const startLineNumber = decoration.reduce((min, l) => Math.min(min, l.lineNumber), fromLineNumber); // min\n                    const endLineNumber = decoration.reduce((max, l) => Math.max(max, l.lineNumber), fromLineNumber); // max\n                    const lineHeight = decoration.reduce((max, l) => Math.max(max, l.specialHeight), 0);\n                    toReAdd.push({\n                        decorationId,\n                        startLineNumber,\n                        endLineNumber,\n                        lineHeight\n                    });\n                }\n            }\n            for (const dec of toReAdd) {\n                this.insertOrChangeCustomLineHeight(dec.decorationId, dec.startLineNumber, dec.endLineNumber, dec.lineHeight);\n            }\n            this.commit();\n        }\n    }\n    commit() {\n        if (!this._hasPending) {\n            return;\n        }\n        for (const pendingChange of this._pendingSpecialLinesToInsert) {\n            const candidateInsertionIndex = this._binarySearchOverOrderedCustomLinesArray(pendingChange.lineNumber);\n            const insertionIndex = candidateInsertionIndex >= 0 ? candidateInsertionIndex : -(candidateInsertionIndex + 1);\n            this._orderedCustomLines.splice(insertionIndex, 0, pendingChange);\n            this._invalidIndex = Math.min(this._invalidIndex, insertionIndex);\n        }\n        this._pendingSpecialLinesToInsert = [];\n        const newDecorationIDToSpecialLine = new ArrayMap();\n        const newOrderedSpecialLines = [];\n        for (let i = 0; i < this._invalidIndex; i++) {\n            const customLine = this._orderedCustomLines[i];\n            newOrderedSpecialLines.push(customLine);\n            newDecorationIDToSpecialLine.add(customLine.decorationId, customLine);\n        }\n        let numberOfDeletions = 0;\n        let previousSpecialLine = (this._invalidIndex > 0) ? newOrderedSpecialLines[this._invalidIndex - 1] : undefined;\n        for (let i = this._invalidIndex; i < this._orderedCustomLines.length; i++) {\n            const customLine = this._orderedCustomLines[i];\n            if (customLine.deleted) {\n                numberOfDeletions++;\n                continue;\n            }\n            customLine.index = i - numberOfDeletions;\n            if (previousSpecialLine && previousSpecialLine.lineNumber === customLine.lineNumber) {\n                customLine.maximumSpecialHeight = previousSpecialLine.maximumSpecialHeight;\n                customLine.prefixSum = previousSpecialLine.prefixSum;\n            }\n            else {\n                let maximumSpecialHeight = customLine.specialHeight;\n                for (let j = i; j < this._orderedCustomLines.length; j++) {\n                    const nextSpecialLine = this._orderedCustomLines[j];\n                    if (nextSpecialLine.deleted) {\n                        continue;\n                    }\n                    if (nextSpecialLine.lineNumber !== customLine.lineNumber) {\n                        break;\n                    }\n                    maximumSpecialHeight = Math.max(maximumSpecialHeight, nextSpecialLine.specialHeight);\n                }\n                customLine.maximumSpecialHeight = maximumSpecialHeight;\n                let prefixSum;\n                if (previousSpecialLine) {\n                    prefixSum = previousSpecialLine.prefixSum + previousSpecialLine.maximumSpecialHeight + this._defaultLineHeight * (customLine.lineNumber - previousSpecialLine.lineNumber - 1);\n                }\n                else {\n                    prefixSum = this._defaultLineHeight * (customLine.lineNumber - 1);\n                }\n                customLine.prefixSum = prefixSum;\n            }\n            previousSpecialLine = customLine;\n            newOrderedSpecialLines.push(customLine);\n            newDecorationIDToSpecialLine.add(customLine.decorationId, customLine);\n        }\n        this._orderedCustomLines = newOrderedSpecialLines;\n        this._decorationIDToCustomLine = newDecorationIDToSpecialLine;\n        this._invalidIndex = Infinity;\n        this._hasPending = false;\n    }\n    _binarySearchOverOrderedCustomLinesArray(lineNumber) {\n        return binarySearch2(this._orderedCustomLines.length, (index) => {\n            const line = this._orderedCustomLines[index];\n            if (line.lineNumber === lineNumber) {\n                return 0;\n            }\n            else if (line.lineNumber < lineNumber) {\n                return -1;\n            }\n            else {\n                return 1;\n            }\n        });\n    }\n}\nclass ArrayMap {\n    constructor() {\n        this._map = new Map();\n    }\n    add(key, value) {\n        const array = this._map.get(key);\n        if (!array) {\n            this._map.set(key, [value]);\n        }\n        else {\n            array.push(value);\n        }\n    }\n    get(key) {\n        return this._map.get(key);\n    }\n    delete(key) {\n        this._map.delete(key);\n    }\n}\n\nexport { CustomLine, LineHeightsManager };\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1527, "column": 0}, "map": {"version":3,"sources":["file:///D:/real-time-code-editor%20%282%29/node_modules/.pnpm/monaco-editor%400.55.1/node_modules/monaco-editor/esm/vs/editor/common/viewLayout/linesLayout.js"],"sourcesContent":["import { singleLetterHash } from '../../../base/common/strings.js';\nimport { LineHeightsManager } from './lineHeights.js';\n\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nclass PendingChanges {\n    constructor() {\n        this._hasPending = false;\n        this._inserts = [];\n        this._changes = [];\n        this._removes = [];\n    }\n    insert(x) {\n        this._hasPending = true;\n        this._inserts.push(x);\n    }\n    change(x) {\n        this._hasPending = true;\n        this._changes.push(x);\n    }\n    remove(x) {\n        this._hasPending = true;\n        this._removes.push(x);\n    }\n    commit(linesLayout) {\n        if (!this._hasPending) {\n            return;\n        }\n        const inserts = this._inserts;\n        const changes = this._changes;\n        const removes = this._removes;\n        this._hasPending = false;\n        this._inserts = [];\n        this._changes = [];\n        this._removes = [];\n        linesLayout._commitPendingChanges(inserts, changes, removes);\n    }\n}\nclass EditorWhitespace {\n    constructor(id, afterLineNumber, ordinal, height, minWidth) {\n        this.id = id;\n        this.afterLineNumber = afterLineNumber;\n        this.ordinal = ordinal;\n        this.height = height;\n        this.minWidth = minWidth;\n        this.prefixSum = 0;\n    }\n}\n/**\n * Layouting of objects that take vertical space (by having a height) and push down other objects.\n *\n * These objects are basically either text (lines) or spaces between those lines (whitespaces).\n * This provides commodity operations for working with lines that contain whitespace that pushes lines lower (vertically).\n */\nclass LinesLayout {\n    static { this.INSTANCE_COUNT = 0; }\n    constructor(lineCount, defaultLineHeight, paddingTop, paddingBottom, customLineHeightData) {\n        this._instanceId = singleLetterHash(++LinesLayout.INSTANCE_COUNT);\n        this._pendingChanges = new PendingChanges();\n        this._lastWhitespaceId = 0;\n        this._arr = [];\n        this._prefixSumValidIndex = -1;\n        this._minWidth = -1; /* marker for not being computed */\n        this._lineCount = lineCount;\n        this._paddingTop = paddingTop;\n        this._paddingBottom = paddingBottom;\n        this._lineHeightsManager = new LineHeightsManager(defaultLineHeight, customLineHeightData);\n    }\n    /**\n     * Find the insertion index for a new value inside a sorted array of values.\n     * If the value is already present in the sorted array, the insertion index will be after the already existing value.\n     */\n    static findInsertionIndex(arr, afterLineNumber, ordinal) {\n        let low = 0;\n        let high = arr.length;\n        while (low < high) {\n            const mid = ((low + high) >>> 1);\n            if (afterLineNumber === arr[mid].afterLineNumber) {\n                if (ordinal < arr[mid].ordinal) {\n                    high = mid;\n                }\n                else {\n                    low = mid + 1;\n                }\n            }\n            else if (afterLineNumber < arr[mid].afterLineNumber) {\n                high = mid;\n            }\n            else {\n                low = mid + 1;\n            }\n        }\n        return low;\n    }\n    /**\n     * Change the height of a line in pixels.\n     */\n    setDefaultLineHeight(lineHeight) {\n        this._lineHeightsManager.defaultLineHeight = lineHeight;\n    }\n    /**\n     * Changes the padding used to calculate vertical offsets.\n     */\n    setPadding(paddingTop, paddingBottom) {\n        this._paddingTop = paddingTop;\n        this._paddingBottom = paddingBottom;\n    }\n    /**\n     * Set the number of lines.\n     *\n     * @param lineCount New number of lines.\n     */\n    onFlushed(lineCount, customLineHeightData) {\n        this._lineCount = lineCount;\n        this._lineHeightsManager = new LineHeightsManager(this._lineHeightsManager.defaultLineHeight, customLineHeightData);\n    }\n    changeLineHeights(callback) {\n        let hadAChange = false;\n        try {\n            const accessor = {\n                insertOrChangeCustomLineHeight: (decorationId, startLineNumber, endLineNumber, lineHeight) => {\n                    hadAChange = true;\n                    this._lineHeightsManager.insertOrChangeCustomLineHeight(decorationId, startLineNumber, endLineNumber, lineHeight);\n                },\n                removeCustomLineHeight: (decorationId) => {\n                    hadAChange = true;\n                    this._lineHeightsManager.removeCustomLineHeight(decorationId);\n                }\n            };\n            callback(accessor);\n        }\n        finally {\n            this._lineHeightsManager.commit();\n        }\n        return hadAChange;\n    }\n    changeWhitespace(callback) {\n        let hadAChange = false;\n        try {\n            const accessor = {\n                insertWhitespace: (afterLineNumber, ordinal, heightInPx, minWidth) => {\n                    hadAChange = true;\n                    afterLineNumber = afterLineNumber | 0;\n                    ordinal = ordinal | 0;\n                    heightInPx = heightInPx | 0;\n                    minWidth = minWidth | 0;\n                    const id = this._instanceId + (++this._lastWhitespaceId);\n                    this._pendingChanges.insert(new EditorWhitespace(id, afterLineNumber, ordinal, heightInPx, minWidth));\n                    return id;\n                },\n                changeOneWhitespace: (id, newAfterLineNumber, newHeight) => {\n                    hadAChange = true;\n                    newAfterLineNumber = newAfterLineNumber | 0;\n                    newHeight = newHeight | 0;\n                    this._pendingChanges.change({ id, newAfterLineNumber, newHeight });\n                },\n                removeWhitespace: (id) => {\n                    hadAChange = true;\n                    this._pendingChanges.remove({ id });\n                }\n            };\n            callback(accessor);\n        }\n        finally {\n            this._pendingChanges.commit(this);\n        }\n        return hadAChange;\n    }\n    _commitPendingChanges(inserts, changes, removes) {\n        if (inserts.length > 0 || removes.length > 0) {\n            this._minWidth = -1; /* marker for not being computed */\n        }\n        if (inserts.length + changes.length + removes.length <= 1) {\n            // when only one thing happened, handle it \"delicately\"\n            for (const insert of inserts) {\n                this._insertWhitespace(insert);\n            }\n            for (const change of changes) {\n                this._changeOneWhitespace(change.id, change.newAfterLineNumber, change.newHeight);\n            }\n            for (const remove of removes) {\n                const index = this._findWhitespaceIndex(remove.id);\n                if (index === -1) {\n                    continue;\n                }\n                this._removeWhitespace(index);\n            }\n            return;\n        }\n        // simply rebuild the entire datastructure\n        const toRemove = new Set();\n        for (const remove of removes) {\n            toRemove.add(remove.id);\n        }\n        const toChange = new Map();\n        for (const change of changes) {\n            toChange.set(change.id, change);\n        }\n        const applyRemoveAndChange = (whitespaces) => {\n            const result = [];\n            for (const whitespace of whitespaces) {\n                if (toRemove.has(whitespace.id)) {\n                    continue;\n                }\n                if (toChange.has(whitespace.id)) {\n                    const change = toChange.get(whitespace.id);\n                    whitespace.afterLineNumber = change.newAfterLineNumber;\n                    whitespace.height = change.newHeight;\n                }\n                result.push(whitespace);\n            }\n            return result;\n        };\n        const result = applyRemoveAndChange(this._arr).concat(applyRemoveAndChange(inserts));\n        result.sort((a, b) => {\n            if (a.afterLineNumber === b.afterLineNumber) {\n                return a.ordinal - b.ordinal;\n            }\n            return a.afterLineNumber - b.afterLineNumber;\n        });\n        this._arr = result;\n        this._prefixSumValidIndex = -1;\n    }\n    _insertWhitespace(whitespace) {\n        const insertIndex = LinesLayout.findInsertionIndex(this._arr, whitespace.afterLineNumber, whitespace.ordinal);\n        this._arr.splice(insertIndex, 0, whitespace);\n        this._prefixSumValidIndex = Math.min(this._prefixSumValidIndex, insertIndex - 1);\n    }\n    _findWhitespaceIndex(id) {\n        const arr = this._arr;\n        for (let i = 0, len = arr.length; i < len; i++) {\n            if (arr[i].id === id) {\n                return i;\n            }\n        }\n        return -1;\n    }\n    _changeOneWhitespace(id, newAfterLineNumber, newHeight) {\n        const index = this._findWhitespaceIndex(id);\n        if (index === -1) {\n            return;\n        }\n        if (this._arr[index].height !== newHeight) {\n            this._arr[index].height = newHeight;\n            this._prefixSumValidIndex = Math.min(this._prefixSumValidIndex, index - 1);\n        }\n        if (this._arr[index].afterLineNumber !== newAfterLineNumber) {\n            // `afterLineNumber` changed for this whitespace\n            // Record old whitespace\n            const whitespace = this._arr[index];\n            // Since changing `afterLineNumber` can trigger a reordering, we're gonna remove this whitespace\n            this._removeWhitespace(index);\n            whitespace.afterLineNumber = newAfterLineNumber;\n            // And add it again\n            this._insertWhitespace(whitespace);\n        }\n    }\n    _removeWhitespace(removeIndex) {\n        this._arr.splice(removeIndex, 1);\n        this._prefixSumValidIndex = Math.min(this._prefixSumValidIndex, removeIndex - 1);\n    }\n    /**\n     * Notify the layouter that lines have been deleted (a continuous zone of lines).\n     *\n     * @param fromLineNumber The line number at which the deletion started, inclusive\n     * @param toLineNumber The line number at which the deletion ended, inclusive\n     */\n    onLinesDeleted(fromLineNumber, toLineNumber) {\n        fromLineNumber = fromLineNumber | 0;\n        toLineNumber = toLineNumber | 0;\n        this._lineCount -= (toLineNumber - fromLineNumber + 1);\n        for (let i = 0, len = this._arr.length; i < len; i++) {\n            const afterLineNumber = this._arr[i].afterLineNumber;\n            if (fromLineNumber <= afterLineNumber && afterLineNumber <= toLineNumber) {\n                // The line this whitespace was after has been deleted\n                //  => move whitespace to before first deleted line\n                this._arr[i].afterLineNumber = fromLineNumber - 1;\n            }\n            else if (afterLineNumber > toLineNumber) {\n                // The line this whitespace was after has been moved up\n                //  => move whitespace up\n                this._arr[i].afterLineNumber -= (toLineNumber - fromLineNumber + 1);\n            }\n        }\n        this._lineHeightsManager.onLinesDeleted(fromLineNumber, toLineNumber);\n    }\n    /**\n     * Notify the layouter that lines have been inserted (a continuous zone of lines).\n     *\n     * @param fromLineNumber The line number at which the insertion started, inclusive\n     * @param toLineNumber The line number at which the insertion ended, inclusive.\n     */\n    onLinesInserted(fromLineNumber, toLineNumber) {\n        fromLineNumber = fromLineNumber | 0;\n        toLineNumber = toLineNumber | 0;\n        this._lineCount += (toLineNumber - fromLineNumber + 1);\n        for (let i = 0, len = this._arr.length; i < len; i++) {\n            const afterLineNumber = this._arr[i].afterLineNumber;\n            if (fromLineNumber <= afterLineNumber) {\n                this._arr[i].afterLineNumber += (toLineNumber - fromLineNumber + 1);\n            }\n        }\n        this._lineHeightsManager.onLinesInserted(fromLineNumber, toLineNumber);\n    }\n    /**\n     * Get the sum of all the whitespaces.\n     */\n    getWhitespacesTotalHeight() {\n        if (this._arr.length === 0) {\n            return 0;\n        }\n        return this.getWhitespacesAccumulatedHeight(this._arr.length - 1);\n    }\n    /**\n     * Return the sum of the heights of the whitespaces at [0..index].\n     * This includes the whitespace at `index`.\n     *\n     * @param index The index of the whitespace.\n     * @return The sum of the heights of all whitespaces before the one at `index`, including the one at `index`.\n     */\n    getWhitespacesAccumulatedHeight(index) {\n        index = index | 0;\n        let startIndex = Math.max(0, this._prefixSumValidIndex + 1);\n        if (startIndex === 0) {\n            this._arr[0].prefixSum = this._arr[0].height;\n            startIndex++;\n        }\n        for (let i = startIndex; i <= index; i++) {\n            this._arr[i].prefixSum = this._arr[i - 1].prefixSum + this._arr[i].height;\n        }\n        this._prefixSumValidIndex = Math.max(this._prefixSumValidIndex, index);\n        return this._arr[index].prefixSum;\n    }\n    /**\n     * Get the sum of heights for all objects.\n     *\n     * @return The sum of heights for all objects.\n     */\n    getLinesTotalHeight() {\n        const linesHeight = this._lineHeightsManager.getAccumulatedLineHeightsIncludingLineNumber(this._lineCount);\n        const whitespacesHeight = this.getWhitespacesTotalHeight();\n        return linesHeight + whitespacesHeight + this._paddingTop + this._paddingBottom;\n    }\n    /**\n     * Returns the accumulated height of whitespaces before the given line number.\n     *\n     * @param lineNumber The line number\n     */\n    getWhitespaceAccumulatedHeightBeforeLineNumber(lineNumber) {\n        lineNumber = lineNumber | 0;\n        const lastWhitespaceBeforeLineNumber = this._findLastWhitespaceBeforeLineNumber(lineNumber);\n        if (lastWhitespaceBeforeLineNumber === -1) {\n            return 0;\n        }\n        return this.getWhitespacesAccumulatedHeight(lastWhitespaceBeforeLineNumber);\n    }\n    _findLastWhitespaceBeforeLineNumber(lineNumber) {\n        lineNumber = lineNumber | 0;\n        // Find the whitespace before line number\n        const arr = this._arr;\n        let low = 0;\n        let high = arr.length - 1;\n        while (low <= high) {\n            const delta = (high - low) | 0;\n            const halfDelta = (delta / 2) | 0;\n            const mid = (low + halfDelta) | 0;\n            if (arr[mid].afterLineNumber < lineNumber) {\n                if (mid + 1 >= arr.length || arr[mid + 1].afterLineNumber >= lineNumber) {\n                    return mid;\n                }\n                else {\n                    low = (mid + 1) | 0;\n                }\n            }\n            else {\n                high = (mid - 1) | 0;\n            }\n        }\n        return -1;\n    }\n    _findFirstWhitespaceAfterLineNumber(lineNumber) {\n        lineNumber = lineNumber | 0;\n        const lastWhitespaceBeforeLineNumber = this._findLastWhitespaceBeforeLineNumber(lineNumber);\n        const firstWhitespaceAfterLineNumber = lastWhitespaceBeforeLineNumber + 1;\n        if (firstWhitespaceAfterLineNumber < this._arr.length) {\n            return firstWhitespaceAfterLineNumber;\n        }\n        return -1;\n    }\n    /**\n     * Find the index of the first whitespace which has `afterLineNumber` >= `lineNumber`.\n     * @return The index of the first whitespace with `afterLineNumber` >= `lineNumber` or -1 if no whitespace is found.\n     */\n    getFirstWhitespaceIndexAfterLineNumber(lineNumber) {\n        lineNumber = lineNumber | 0;\n        return this._findFirstWhitespaceAfterLineNumber(lineNumber);\n    }\n    /**\n     * Get the vertical offset (the sum of heights for all objects above) a certain line number.\n     *\n     * @param lineNumber The line number\n     * @return The sum of heights for all objects above `lineNumber`.\n     */\n    getVerticalOffsetForLineNumber(lineNumber, includeViewZones = false) {\n        lineNumber = lineNumber | 0;\n        let previousLinesHeight;\n        if (lineNumber > 1) {\n            previousLinesHeight = this._lineHeightsManager.getAccumulatedLineHeightsIncludingLineNumber(lineNumber - 1);\n        }\n        else {\n            previousLinesHeight = 0;\n        }\n        const previousWhitespacesHeight = this.getWhitespaceAccumulatedHeightBeforeLineNumber(lineNumber - (includeViewZones ? 1 : 0));\n        return previousLinesHeight + previousWhitespacesHeight + this._paddingTop;\n    }\n    getLineHeightForLineNumber(lineNumber) {\n        return this._lineHeightsManager.heightForLineNumber(lineNumber);\n    }\n    /**\n     * Get the vertical offset (the sum of heights for all objects above) a certain line number and also the line height of the line.\n     *\n     * @param lineNumber The line number\n     * @return The sum of heights for all objects above `lineNumber`.\n     */\n    getVerticalOffsetAfterLineNumber(lineNumber, includeViewZones = false) {\n        lineNumber = lineNumber | 0;\n        const previousLinesHeight = this._lineHeightsManager.getAccumulatedLineHeightsIncludingLineNumber(lineNumber);\n        const previousWhitespacesHeight = this.getWhitespaceAccumulatedHeightBeforeLineNumber(lineNumber + (includeViewZones ? 1 : 0));\n        return previousLinesHeight + previousWhitespacesHeight + this._paddingTop;\n    }\n    /**\n     * The maximum min width for all whitespaces.\n     */\n    getWhitespaceMinWidth() {\n        if (this._minWidth === -1) {\n            let minWidth = 0;\n            for (let i = 0, len = this._arr.length; i < len; i++) {\n                minWidth = Math.max(minWidth, this._arr[i].minWidth);\n            }\n            this._minWidth = minWidth;\n        }\n        return this._minWidth;\n    }\n    /**\n     * Check if `verticalOffset` is below all lines.\n     */\n    isAfterLines(verticalOffset) {\n        const totalHeight = this.getLinesTotalHeight();\n        return verticalOffset > totalHeight;\n    }\n    isInTopPadding(verticalOffset) {\n        if (this._paddingTop === 0) {\n            return false;\n        }\n        return (verticalOffset < this._paddingTop);\n    }\n    isInBottomPadding(verticalOffset) {\n        if (this._paddingBottom === 0) {\n            return false;\n        }\n        const totalHeight = this.getLinesTotalHeight();\n        return (verticalOffset >= totalHeight - this._paddingBottom);\n    }\n    /**\n     * Find the first line number that is at or after vertical offset `verticalOffset`.\n     * i.e. if getVerticalOffsetForLine(line) is x and getVerticalOffsetForLine(line + 1) is y, then\n     * getLineNumberAtOrAfterVerticalOffset(i) = line, x <= i < y.\n     *\n     * @param verticalOffset The vertical offset to search at.\n     * @return The line number at or after vertical offset `verticalOffset`.\n     */\n    getLineNumberAtOrAfterVerticalOffset(verticalOffset) {\n        verticalOffset = verticalOffset | 0;\n        if (verticalOffset < 0) {\n            return 1;\n        }\n        const linesCount = this._lineCount | 0;\n        let minLineNumber = 1;\n        let maxLineNumber = linesCount;\n        while (minLineNumber < maxLineNumber) {\n            const midLineNumber = ((minLineNumber + maxLineNumber) / 2) | 0;\n            const lineHeight = this.getLineHeightForLineNumber(midLineNumber);\n            const midLineNumberVerticalOffset = this.getVerticalOffsetForLineNumber(midLineNumber) | 0;\n            if (verticalOffset >= midLineNumberVerticalOffset + lineHeight) {\n                // vertical offset is after mid line number\n                minLineNumber = midLineNumber + 1;\n            }\n            else if (verticalOffset >= midLineNumberVerticalOffset) {\n                // Hit\n                return midLineNumber;\n            }\n            else {\n                // vertical offset is before mid line number, but mid line number could still be what we're searching for\n                maxLineNumber = midLineNumber;\n            }\n        }\n        if (minLineNumber > linesCount) {\n            return linesCount;\n        }\n        return minLineNumber;\n    }\n    /**\n     * Get all the lines and their relative vertical offsets that are positioned between `verticalOffset1` and `verticalOffset2`.\n     *\n     * @param verticalOffset1 The beginning of the viewport.\n     * @param verticalOffset2 The end of the viewport.\n     * @return A structure describing the lines positioned between `verticalOffset1` and `verticalOffset2`.\n     */\n    getLinesViewportData(verticalOffset1, verticalOffset2) {\n        verticalOffset1 = verticalOffset1 | 0;\n        verticalOffset2 = verticalOffset2 | 0;\n        // Find first line number\n        // We don't live in a perfect world, so the line number might start before or after verticalOffset1\n        const startLineNumber = this.getLineNumberAtOrAfterVerticalOffset(verticalOffset1) | 0;\n        const startLineNumberVerticalOffset = this.getVerticalOffsetForLineNumber(startLineNumber) | 0;\n        let endLineNumber = this._lineCount | 0;\n        // Also keep track of what whitespace we've got\n        let whitespaceIndex = this.getFirstWhitespaceIndexAfterLineNumber(startLineNumber) | 0;\n        const whitespaceCount = this.getWhitespacesCount() | 0;\n        let currentWhitespaceHeight;\n        let currentWhitespaceAfterLineNumber;\n        if (whitespaceIndex === -1) {\n            whitespaceIndex = whitespaceCount;\n            currentWhitespaceAfterLineNumber = endLineNumber + 1;\n            currentWhitespaceHeight = 0;\n        }\n        else {\n            currentWhitespaceAfterLineNumber = this.getAfterLineNumberForWhitespaceIndex(whitespaceIndex) | 0;\n            currentWhitespaceHeight = this.getHeightForWhitespaceIndex(whitespaceIndex) | 0;\n        }\n        let currentVerticalOffset = startLineNumberVerticalOffset;\n        let currentLineRelativeOffset = currentVerticalOffset;\n        // IE (all versions) cannot handle units above about 1,533,908 px, so every 500k pixels bring numbers down\n        const STEP_SIZE = 500000;\n        let bigNumbersDelta = 0;\n        if (startLineNumberVerticalOffset >= STEP_SIZE) {\n            // Compute a delta that guarantees that lines are positioned at `lineHeight` increments\n            bigNumbersDelta = Math.floor(startLineNumberVerticalOffset / STEP_SIZE) * STEP_SIZE;\n            bigNumbersDelta = Math.floor(bigNumbersDelta / this._lineHeightsManager.defaultLineHeight) * this._lineHeightsManager.defaultLineHeight;\n            currentLineRelativeOffset -= bigNumbersDelta;\n        }\n        const linesOffsets = [];\n        const verticalCenter = verticalOffset1 + (verticalOffset2 - verticalOffset1) / 2;\n        let centeredLineNumber = -1;\n        // Figure out how far the lines go\n        for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n            const lineHeight = this.getLineHeightForLineNumber(lineNumber);\n            if (centeredLineNumber === -1) {\n                const currentLineTop = currentVerticalOffset;\n                const currentLineBottom = currentVerticalOffset + lineHeight;\n                if ((currentLineTop <= verticalCenter && verticalCenter < currentLineBottom) || currentLineTop > verticalCenter) {\n                    centeredLineNumber = lineNumber;\n                }\n            }\n            // Count current line height in the vertical offsets\n            currentVerticalOffset += lineHeight;\n            linesOffsets[lineNumber - startLineNumber] = currentLineRelativeOffset;\n            // Next line starts immediately after this one\n            currentLineRelativeOffset += lineHeight;\n            while (currentWhitespaceAfterLineNumber === lineNumber) {\n                // Push down next line with the height of the current whitespace\n                currentLineRelativeOffset += currentWhitespaceHeight;\n                // Count current whitespace in the vertical offsets\n                currentVerticalOffset += currentWhitespaceHeight;\n                whitespaceIndex++;\n                if (whitespaceIndex >= whitespaceCount) {\n                    currentWhitespaceAfterLineNumber = endLineNumber + 1;\n                }\n                else {\n                    currentWhitespaceAfterLineNumber = this.getAfterLineNumberForWhitespaceIndex(whitespaceIndex) | 0;\n                    currentWhitespaceHeight = this.getHeightForWhitespaceIndex(whitespaceIndex) | 0;\n                }\n            }\n            if (currentVerticalOffset >= verticalOffset2) {\n                // We have covered the entire viewport area, time to stop\n                endLineNumber = lineNumber;\n                break;\n            }\n        }\n        if (centeredLineNumber === -1) {\n            centeredLineNumber = endLineNumber;\n        }\n        const endLineNumberVerticalOffset = this.getVerticalOffsetForLineNumber(endLineNumber) | 0;\n        let completelyVisibleStartLineNumber = startLineNumber;\n        let completelyVisibleEndLineNumber = endLineNumber;\n        if (completelyVisibleStartLineNumber < completelyVisibleEndLineNumber) {\n            if (startLineNumberVerticalOffset < verticalOffset1) {\n                completelyVisibleStartLineNumber++;\n            }\n        }\n        if (completelyVisibleStartLineNumber < completelyVisibleEndLineNumber) {\n            const endLineHeight = this.getLineHeightForLineNumber(endLineNumber);\n            if (endLineNumberVerticalOffset + endLineHeight > verticalOffset2) {\n                completelyVisibleEndLineNumber--;\n            }\n        }\n        return {\n            bigNumbersDelta: bigNumbersDelta,\n            startLineNumber: startLineNumber,\n            endLineNumber: endLineNumber,\n            relativeVerticalOffset: linesOffsets,\n            centeredLineNumber: centeredLineNumber,\n            completelyVisibleStartLineNumber: completelyVisibleStartLineNumber,\n            completelyVisibleEndLineNumber: completelyVisibleEndLineNumber,\n            lineHeight: this._lineHeightsManager.defaultLineHeight,\n        };\n    }\n    getVerticalOffsetForWhitespaceIndex(whitespaceIndex) {\n        whitespaceIndex = whitespaceIndex | 0;\n        const afterLineNumber = this.getAfterLineNumberForWhitespaceIndex(whitespaceIndex);\n        let previousLinesHeight;\n        if (afterLineNumber >= 1) {\n            previousLinesHeight = this._lineHeightsManager.getAccumulatedLineHeightsIncludingLineNumber(afterLineNumber);\n        }\n        else {\n            previousLinesHeight = 0;\n        }\n        let previousWhitespacesHeight;\n        if (whitespaceIndex > 0) {\n            previousWhitespacesHeight = this.getWhitespacesAccumulatedHeight(whitespaceIndex - 1);\n        }\n        else {\n            previousWhitespacesHeight = 0;\n        }\n        return previousLinesHeight + previousWhitespacesHeight + this._paddingTop;\n    }\n    getWhitespaceIndexAtOrAfterVerticallOffset(verticalOffset) {\n        verticalOffset = verticalOffset | 0;\n        let minWhitespaceIndex = 0;\n        let maxWhitespaceIndex = this.getWhitespacesCount() - 1;\n        if (maxWhitespaceIndex < 0) {\n            return -1;\n        }\n        // Special case: nothing to be found\n        const maxWhitespaceVerticalOffset = this.getVerticalOffsetForWhitespaceIndex(maxWhitespaceIndex);\n        const maxWhitespaceHeight = this.getHeightForWhitespaceIndex(maxWhitespaceIndex);\n        if (verticalOffset >= maxWhitespaceVerticalOffset + maxWhitespaceHeight) {\n            return -1;\n        }\n        while (minWhitespaceIndex < maxWhitespaceIndex) {\n            const midWhitespaceIndex = Math.floor((minWhitespaceIndex + maxWhitespaceIndex) / 2);\n            const midWhitespaceVerticalOffset = this.getVerticalOffsetForWhitespaceIndex(midWhitespaceIndex);\n            const midWhitespaceHeight = this.getHeightForWhitespaceIndex(midWhitespaceIndex);\n            if (verticalOffset >= midWhitespaceVerticalOffset + midWhitespaceHeight) {\n                // vertical offset is after whitespace\n                minWhitespaceIndex = midWhitespaceIndex + 1;\n            }\n            else if (verticalOffset >= midWhitespaceVerticalOffset) {\n                // Hit\n                return midWhitespaceIndex;\n            }\n            else {\n                // vertical offset is before whitespace, but midWhitespaceIndex might still be what we're searching for\n                maxWhitespaceIndex = midWhitespaceIndex;\n            }\n        }\n        return minWhitespaceIndex;\n    }\n    /**\n     * Get exactly the whitespace that is layouted at `verticalOffset`.\n     *\n     * @param verticalOffset The vertical offset.\n     * @return Precisely the whitespace that is layouted at `verticaloffset` or null.\n     */\n    getWhitespaceAtVerticalOffset(verticalOffset) {\n        verticalOffset = verticalOffset | 0;\n        const candidateIndex = this.getWhitespaceIndexAtOrAfterVerticallOffset(verticalOffset);\n        if (candidateIndex < 0) {\n            return null;\n        }\n        if (candidateIndex >= this.getWhitespacesCount()) {\n            return null;\n        }\n        const candidateTop = this.getVerticalOffsetForWhitespaceIndex(candidateIndex);\n        if (candidateTop > verticalOffset) {\n            return null;\n        }\n        const candidateHeight = this.getHeightForWhitespaceIndex(candidateIndex);\n        const candidateId = this.getIdForWhitespaceIndex(candidateIndex);\n        const candidateAfterLineNumber = this.getAfterLineNumberForWhitespaceIndex(candidateIndex);\n        return {\n            id: candidateId,\n            afterLineNumber: candidateAfterLineNumber,\n            verticalOffset: candidateTop,\n            height: candidateHeight\n        };\n    }\n    /**\n     * Get a list of whitespaces that are positioned between `verticalOffset1` and `verticalOffset2`.\n     *\n     * @param verticalOffset1 The beginning of the viewport.\n     * @param verticalOffset2 The end of the viewport.\n     * @return An array with all the whitespaces in the viewport. If no whitespace is in viewport, the array is empty.\n     */\n    getWhitespaceViewportData(verticalOffset1, verticalOffset2) {\n        verticalOffset1 = verticalOffset1 | 0;\n        verticalOffset2 = verticalOffset2 | 0;\n        const startIndex = this.getWhitespaceIndexAtOrAfterVerticallOffset(verticalOffset1);\n        const endIndex = this.getWhitespacesCount() - 1;\n        if (startIndex < 0) {\n            return [];\n        }\n        const result = [];\n        for (let i = startIndex; i <= endIndex; i++) {\n            const top = this.getVerticalOffsetForWhitespaceIndex(i);\n            const height = this.getHeightForWhitespaceIndex(i);\n            if (top >= verticalOffset2) {\n                break;\n            }\n            result.push({\n                id: this.getIdForWhitespaceIndex(i),\n                afterLineNumber: this.getAfterLineNumberForWhitespaceIndex(i),\n                verticalOffset: top,\n                height: height\n            });\n        }\n        return result;\n    }\n    /**\n     * Get all whitespaces.\n     */\n    getWhitespaces() {\n        return this._arr.slice(0);\n    }\n    /**\n     * The number of whitespaces.\n     */\n    getWhitespacesCount() {\n        return this._arr.length;\n    }\n    /**\n     * Get the `id` for whitespace at index `index`.\n     *\n     * @param index The index of the whitespace.\n     * @return `id` of whitespace at `index`.\n     */\n    getIdForWhitespaceIndex(index) {\n        index = index | 0;\n        return this._arr[index].id;\n    }\n    /**\n     * Get the `afterLineNumber` for whitespace at index `index`.\n     *\n     * @param index The index of the whitespace.\n     * @return `afterLineNumber` of whitespace at `index`.\n     */\n    getAfterLineNumberForWhitespaceIndex(index) {\n        index = index | 0;\n        return this._arr[index].afterLineNumber;\n    }\n    /**\n     * Get the `height` for whitespace at index `index`.\n     *\n     * @param index The index of the whitespace.\n     * @return `height` of whitespace at `index`.\n     */\n    getHeightForWhitespaceIndex(index) {\n        index = index | 0;\n        return this._arr[index].height;\n    }\n}\n\nexport { EditorWhitespace, LinesLayout };\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 2267, "column": 0}, "map": {"version":3,"sources":["file:///D:/real-time-code-editor%20%282%29/node_modules/.pnpm/monaco-editor%400.55.1/node_modules/monaco-editor/esm/vs/editor/common/viewLayout/viewLayout.js"],"sourcesContent":["import { Emitter } from '../../../base/common/event.js';\nimport { Disposable } from '../../../base/common/lifecycle.js';\nimport { Scrollable } from '../../../base/common/scrollable.js';\nimport { LinesLayout } from './linesLayout.js';\nimport { Viewport } from '../viewModel.js';\nimport { ContentSizeChangedEvent } from '../viewModelEventDispatcher.js';\n\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nconst SMOOTH_SCROLLING_TIME = 125;\nclass EditorScrollDimensions {\n    constructor(width, contentWidth, height, contentHeight) {\n        width = width | 0;\n        contentWidth = contentWidth | 0;\n        height = height | 0;\n        contentHeight = contentHeight | 0;\n        if (width < 0) {\n            width = 0;\n        }\n        if (contentWidth < 0) {\n            contentWidth = 0;\n        }\n        if (height < 0) {\n            height = 0;\n        }\n        if (contentHeight < 0) {\n            contentHeight = 0;\n        }\n        this.width = width;\n        this.contentWidth = contentWidth;\n        this.scrollWidth = Math.max(width, contentWidth);\n        this.height = height;\n        this.contentHeight = contentHeight;\n        this.scrollHeight = Math.max(height, contentHeight);\n    }\n    equals(other) {\n        return (this.width === other.width\n            && this.contentWidth === other.contentWidth\n            && this.height === other.height\n            && this.contentHeight === other.contentHeight);\n    }\n}\nclass EditorScrollable extends Disposable {\n    constructor(smoothScrollDuration, scheduleAtNextAnimationFrame) {\n        super();\n        this._onDidContentSizeChange = this._register(new Emitter());\n        this.onDidContentSizeChange = this._onDidContentSizeChange.event;\n        this._dimensions = new EditorScrollDimensions(0, 0, 0, 0);\n        this._scrollable = this._register(new Scrollable({\n            forceIntegerValues: true,\n            smoothScrollDuration,\n            scheduleAtNextAnimationFrame\n        }));\n        this.onDidScroll = this._scrollable.onScroll;\n    }\n    getScrollable() {\n        return this._scrollable;\n    }\n    setSmoothScrollDuration(smoothScrollDuration) {\n        this._scrollable.setSmoothScrollDuration(smoothScrollDuration);\n    }\n    validateScrollPosition(scrollPosition) {\n        return this._scrollable.validateScrollPosition(scrollPosition);\n    }\n    getScrollDimensions() {\n        return this._dimensions;\n    }\n    setScrollDimensions(dimensions) {\n        if (this._dimensions.equals(dimensions)) {\n            return;\n        }\n        const oldDimensions = this._dimensions;\n        this._dimensions = dimensions;\n        this._scrollable.setScrollDimensions({\n            width: dimensions.width,\n            scrollWidth: dimensions.scrollWidth,\n            height: dimensions.height,\n            scrollHeight: dimensions.scrollHeight\n        }, true);\n        const contentWidthChanged = (oldDimensions.contentWidth !== dimensions.contentWidth);\n        const contentHeightChanged = (oldDimensions.contentHeight !== dimensions.contentHeight);\n        if (contentWidthChanged || contentHeightChanged) {\n            this._onDidContentSizeChange.fire(new ContentSizeChangedEvent(oldDimensions.contentWidth, oldDimensions.contentHeight, dimensions.contentWidth, dimensions.contentHeight));\n        }\n    }\n    getFutureScrollPosition() {\n        return this._scrollable.getFutureScrollPosition();\n    }\n    getCurrentScrollPosition() {\n        return this._scrollable.getCurrentScrollPosition();\n    }\n    setScrollPositionNow(update) {\n        this._scrollable.setScrollPositionNow(update);\n    }\n    setScrollPositionSmooth(update) {\n        this._scrollable.setScrollPositionSmooth(update);\n    }\n    hasPendingScrollAnimation() {\n        return this._scrollable.hasPendingScrollAnimation();\n    }\n}\nclass ViewLayout extends Disposable {\n    constructor(configuration, lineCount, customLineHeightData, scheduleAtNextAnimationFrame) {\n        super();\n        this._configuration = configuration;\n        const options = this._configuration.options;\n        const layoutInfo = options.get(165 /* EditorOption.layoutInfo */);\n        const padding = options.get(96 /* EditorOption.padding */);\n        this._linesLayout = new LinesLayout(lineCount, options.get(75 /* EditorOption.lineHeight */), padding.top, padding.bottom, customLineHeightData);\n        this._maxLineWidth = 0;\n        this._overlayWidgetsMinWidth = 0;\n        this._scrollable = this._register(new EditorScrollable(0, scheduleAtNextAnimationFrame));\n        this._configureSmoothScrollDuration();\n        this._scrollable.setScrollDimensions(new EditorScrollDimensions(layoutInfo.contentWidth, 0, layoutInfo.height, 0));\n        this.onDidScroll = this._scrollable.onDidScroll;\n        this.onDidContentSizeChange = this._scrollable.onDidContentSizeChange;\n        this._updateHeight();\n    }\n    dispose() {\n        super.dispose();\n    }\n    getScrollable() {\n        return this._scrollable.getScrollable();\n    }\n    onHeightMaybeChanged() {\n        this._updateHeight();\n    }\n    _configureSmoothScrollDuration() {\n        this._scrollable.setSmoothScrollDuration(this._configuration.options.get(130 /* EditorOption.smoothScrolling */) ? SMOOTH_SCROLLING_TIME : 0);\n    }\n    // ---- begin view event handlers\n    onConfigurationChanged(e) {\n        const options = this._configuration.options;\n        if (e.hasChanged(75 /* EditorOption.lineHeight */)) {\n            this._linesLayout.setDefaultLineHeight(options.get(75 /* EditorOption.lineHeight */));\n        }\n        if (e.hasChanged(96 /* EditorOption.padding */)) {\n            const padding = options.get(96 /* EditorOption.padding */);\n            this._linesLayout.setPadding(padding.top, padding.bottom);\n        }\n        if (e.hasChanged(165 /* EditorOption.layoutInfo */)) {\n            const layoutInfo = options.get(165 /* EditorOption.layoutInfo */);\n            const width = layoutInfo.contentWidth;\n            const height = layoutInfo.height;\n            const scrollDimensions = this._scrollable.getScrollDimensions();\n            const contentWidth = scrollDimensions.contentWidth;\n            this._scrollable.setScrollDimensions(new EditorScrollDimensions(width, scrollDimensions.contentWidth, height, this._getContentHeight(width, height, contentWidth)));\n        }\n        else {\n            this._updateHeight();\n        }\n        if (e.hasChanged(130 /* EditorOption.smoothScrolling */)) {\n            this._configureSmoothScrollDuration();\n        }\n    }\n    onFlushed(lineCount, customLineHeightData) {\n        this._linesLayout.onFlushed(lineCount, customLineHeightData);\n    }\n    onLinesDeleted(fromLineNumber, toLineNumber) {\n        this._linesLayout.onLinesDeleted(fromLineNumber, toLineNumber);\n    }\n    onLinesInserted(fromLineNumber, toLineNumber) {\n        this._linesLayout.onLinesInserted(fromLineNumber, toLineNumber);\n    }\n    // ---- end view event handlers\n    _getHorizontalScrollbarHeight(width, scrollWidth) {\n        const options = this._configuration.options;\n        const scrollbar = options.get(117 /* EditorOption.scrollbar */);\n        if (scrollbar.horizontal === 2 /* ScrollbarVisibility.Hidden */) {\n            // horizontal scrollbar not visible\n            return 0;\n        }\n        if (width >= scrollWidth) {\n            // horizontal scrollbar not visible\n            return 0;\n        }\n        return scrollbar.horizontalScrollbarSize;\n    }\n    _getContentHeight(width, height, contentWidth) {\n        const options = this._configuration.options;\n        let result = this._linesLayout.getLinesTotalHeight();\n        if (options.get(119 /* EditorOption.scrollBeyondLastLine */)) {\n            result += Math.max(0, height - options.get(75 /* EditorOption.lineHeight */) - options.get(96 /* EditorOption.padding */).bottom);\n        }\n        else if (!options.get(117 /* EditorOption.scrollbar */).ignoreHorizontalScrollbarInContentHeight) {\n            result += this._getHorizontalScrollbarHeight(width, contentWidth);\n        }\n        return result;\n    }\n    _updateHeight() {\n        const scrollDimensions = this._scrollable.getScrollDimensions();\n        const width = scrollDimensions.width;\n        const height = scrollDimensions.height;\n        const contentWidth = scrollDimensions.contentWidth;\n        this._scrollable.setScrollDimensions(new EditorScrollDimensions(width, scrollDimensions.contentWidth, height, this._getContentHeight(width, height, contentWidth)));\n    }\n    // ---- Layouting logic\n    getCurrentViewport() {\n        const scrollDimensions = this._scrollable.getScrollDimensions();\n        const currentScrollPosition = this._scrollable.getCurrentScrollPosition();\n        return new Viewport(currentScrollPosition.scrollTop, currentScrollPosition.scrollLeft, scrollDimensions.width, scrollDimensions.height);\n    }\n    getFutureViewport() {\n        const scrollDimensions = this._scrollable.getScrollDimensions();\n        const currentScrollPosition = this._scrollable.getFutureScrollPosition();\n        return new Viewport(currentScrollPosition.scrollTop, currentScrollPosition.scrollLeft, scrollDimensions.width, scrollDimensions.height);\n    }\n    _computeContentWidth() {\n        const options = this._configuration.options;\n        const maxLineWidth = this._maxLineWidth;\n        const wrappingInfo = options.get(166 /* EditorOption.wrappingInfo */);\n        const fontInfo = options.get(59 /* EditorOption.fontInfo */);\n        const layoutInfo = options.get(165 /* EditorOption.layoutInfo */);\n        if (wrappingInfo.isViewportWrapping) {\n            const minimap = options.get(81 /* EditorOption.minimap */);\n            if (maxLineWidth > layoutInfo.contentWidth + fontInfo.typicalHalfwidthCharacterWidth) {\n                // This is a case where viewport wrapping is on, but the line extends above the viewport\n                if (minimap.enabled && minimap.side === 'right') {\n                    // We need to accomodate the scrollbar width\n                    return maxLineWidth + layoutInfo.verticalScrollbarWidth;\n                }\n            }\n            return maxLineWidth;\n        }\n        else {\n            const extraHorizontalSpace = options.get(118 /* EditorOption.scrollBeyondLastColumn */) * fontInfo.typicalHalfwidthCharacterWidth;\n            const whitespaceMinWidth = this._linesLayout.getWhitespaceMinWidth();\n            return Math.max(maxLineWidth + extraHorizontalSpace + layoutInfo.verticalScrollbarWidth, whitespaceMinWidth, this._overlayWidgetsMinWidth);\n        }\n    }\n    setMaxLineWidth(maxLineWidth) {\n        this._maxLineWidth = maxLineWidth;\n        this._updateContentWidth();\n    }\n    setOverlayWidgetsMinWidth(maxMinWidth) {\n        this._overlayWidgetsMinWidth = maxMinWidth;\n        this._updateContentWidth();\n    }\n    _updateContentWidth() {\n        const scrollDimensions = this._scrollable.getScrollDimensions();\n        this._scrollable.setScrollDimensions(new EditorScrollDimensions(scrollDimensions.width, this._computeContentWidth(), scrollDimensions.height, scrollDimensions.contentHeight));\n        // The height might depend on the fact that there is a horizontal scrollbar or not\n        this._updateHeight();\n    }\n    // ---- view state\n    saveState() {\n        const currentScrollPosition = this._scrollable.getFutureScrollPosition();\n        const scrollTop = currentScrollPosition.scrollTop;\n        const firstLineNumberInViewport = this._linesLayout.getLineNumberAtOrAfterVerticalOffset(scrollTop);\n        const whitespaceAboveFirstLine = this._linesLayout.getWhitespaceAccumulatedHeightBeforeLineNumber(firstLineNumberInViewport);\n        return {\n            scrollTop: scrollTop,\n            scrollTopWithoutViewZones: scrollTop - whitespaceAboveFirstLine,\n            scrollLeft: currentScrollPosition.scrollLeft\n        };\n    }\n    // ----\n    changeWhitespace(callback) {\n        const hadAChange = this._linesLayout.changeWhitespace(callback);\n        if (hadAChange) {\n            this.onHeightMaybeChanged();\n        }\n        return hadAChange;\n    }\n    changeSpecialLineHeights(callback) {\n        const hadAChange = this._linesLayout.changeLineHeights(callback);\n        if (hadAChange) {\n            this.onHeightMaybeChanged();\n        }\n        return hadAChange;\n    }\n    getVerticalOffsetForLineNumber(lineNumber, includeViewZones = false) {\n        return this._linesLayout.getVerticalOffsetForLineNumber(lineNumber, includeViewZones);\n    }\n    getVerticalOffsetAfterLineNumber(lineNumber, includeViewZones = false) {\n        return this._linesLayout.getVerticalOffsetAfterLineNumber(lineNumber, includeViewZones);\n    }\n    getLineHeightForLineNumber(lineNumber) {\n        return this._linesLayout.getLineHeightForLineNumber(lineNumber);\n    }\n    isAfterLines(verticalOffset) {\n        return this._linesLayout.isAfterLines(verticalOffset);\n    }\n    isInTopPadding(verticalOffset) {\n        return this._linesLayout.isInTopPadding(verticalOffset);\n    }\n    isInBottomPadding(verticalOffset) {\n        return this._linesLayout.isInBottomPadding(verticalOffset);\n    }\n    getLineNumberAtVerticalOffset(verticalOffset) {\n        return this._linesLayout.getLineNumberAtOrAfterVerticalOffset(verticalOffset);\n    }\n    getWhitespaceAtVerticalOffset(verticalOffset) {\n        return this._linesLayout.getWhitespaceAtVerticalOffset(verticalOffset);\n    }\n    getLinesViewportData() {\n        const visibleBox = this.getCurrentViewport();\n        return this._linesLayout.getLinesViewportData(visibleBox.top, visibleBox.top + visibleBox.height);\n    }\n    getLinesViewportDataAtScrollTop(scrollTop) {\n        // do some minimal validations on scrollTop\n        const scrollDimensions = this._scrollable.getScrollDimensions();\n        if (scrollTop + scrollDimensions.height > scrollDimensions.scrollHeight) {\n            scrollTop = scrollDimensions.scrollHeight - scrollDimensions.height;\n        }\n        if (scrollTop < 0) {\n            scrollTop = 0;\n        }\n        return this._linesLayout.getLinesViewportData(scrollTop, scrollTop + scrollDimensions.height);\n    }\n    getWhitespaceViewportData() {\n        const visibleBox = this.getCurrentViewport();\n        return this._linesLayout.getWhitespaceViewportData(visibleBox.top, visibleBox.top + visibleBox.height);\n    }\n    getWhitespaces() {\n        return this._linesLayout.getWhitespaces();\n    }\n    // ----\n    getContentWidth() {\n        const scrollDimensions = this._scrollable.getScrollDimensions();\n        return scrollDimensions.contentWidth;\n    }\n    getScrollWidth() {\n        const scrollDimensions = this._scrollable.getScrollDimensions();\n        return scrollDimensions.scrollWidth;\n    }\n    getContentHeight() {\n        const scrollDimensions = this._scrollable.getScrollDimensions();\n        return scrollDimensions.contentHeight;\n    }\n    getScrollHeight() {\n        const scrollDimensions = this._scrollable.getScrollDimensions();\n        return scrollDimensions.scrollHeight;\n    }\n    getCurrentScrollLeft() {\n        const currentScrollPosition = this._scrollable.getCurrentScrollPosition();\n        return currentScrollPosition.scrollLeft;\n    }\n    getCurrentScrollTop() {\n        const currentScrollPosition = this._scrollable.getCurrentScrollPosition();\n        return currentScrollPosition.scrollTop;\n    }\n    validateScrollPosition(scrollPosition) {\n        return this._scrollable.validateScrollPosition(scrollPosition);\n    }\n    setScrollPosition(position, type) {\n        if (type === 1 /* ScrollType.Immediate */) {\n            this._scrollable.setScrollPositionNow(position);\n        }\n        else {\n            this._scrollable.setScrollPositionSmooth(position);\n        }\n    }\n    hasPendingScrollAnimation() {\n        return this._scrollable.hasPendingScrollAnimation();\n    }\n    deltaScrollNow(deltaScrollLeft, deltaScrollTop) {\n        const currentScrollPosition = this._scrollable.getCurrentScrollPosition();\n        this._scrollable.setScrollPositionNow({\n            scrollLeft: currentScrollPosition.scrollLeft + deltaScrollLeft,\n            scrollTop: currentScrollPosition.scrollTop + deltaScrollTop\n        });\n    }\n}\n\nexport { ViewLayout };\n"],"names":[],"mappings":"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","ignoreList":[0]}}]
}