{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///D:/real-time-code-editor%20%282%29/node_modules/.pnpm/monaco-editor%400.55.1/node_modules/monaco-editor/esm/vs/editor/browser/gpu/gpuUtils.js"],"sourcesContent":["import { BugIndicatingError } from '../../../base/common/errors.js';\nimport { toDisposable } from '../../../base/common/lifecycle.js';\n\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nconst quadVertices = new Float32Array([\n    1, 0,\n    1, 1,\n    0, 1,\n    0, 0,\n    0, 1,\n    1, 0,\n]);\nfunction ensureNonNullable(value) {\n    if (!value) {\n        throw new Error(`Value \"${value}\" cannot be null`);\n    }\n    return value;\n}\n// TODO: Move capabilities into ElementSizeObserver?\nfunction observeDevicePixelDimensions(element, parentWindow, callback) {\n    // Observe any resizes to the element and extract the actual pixel size of the element if the\n    // devicePixelContentBoxSize API is supported. This allows correcting rounding errors when\n    // converting between CSS pixels and device pixels which causes blurry rendering when device\n    // pixel ratio is not a round number.\n    let observer = new parentWindow.ResizeObserver((entries) => {\n        const entry = entries.find((entry) => entry.target === element);\n        if (!entry) {\n            return;\n        }\n        // Disconnect if devicePixelContentBoxSize isn't supported by the browser\n        if (!('devicePixelContentBoxSize' in entry)) {\n            observer?.disconnect();\n            observer = undefined;\n            return;\n        }\n        // Fire the callback, ignore events where the dimensions are 0x0 as the canvas is likely hidden\n        const width = entry.devicePixelContentBoxSize[0].inlineSize;\n        const height = entry.devicePixelContentBoxSize[0].blockSize;\n        if (width > 0 && height > 0) {\n            callback(width, height);\n        }\n    });\n    try {\n        // eslint-disable-next-line local/code-no-any-casts, @typescript-eslint/no-explicit-any\n        observer.observe(element, { box: ['device-pixel-content-box'] });\n    }\n    catch {\n        observer.disconnect();\n        observer = undefined;\n        throw new BugIndicatingError('Could not observe device pixel dimensions');\n    }\n    return toDisposable(() => observer?.disconnect());\n}\n\nexport { ensureNonNullable, observeDevicePixelDimensions, quadVertices };\n"],"names":[],"mappings":";;;;;;;;AAAA;AACA;;;AAEA;;;8FAG8F,GAC9F,MAAM,eAAe,IAAI,aAAa;IAClC;IAAG;IACH;IAAG;IACH;IAAG;IACH;IAAG;IACH;IAAG;IACH;IAAG;CACN;AACD,SAAS,kBAAkB,KAAK;IAC5B,IAAI,CAAC,OAAO;QACR,MAAM,IAAI,MAAM,CAAC,OAAO,EAAE,MAAM,gBAAgB,CAAC;IACrD;IACA,OAAO;AACX;AACA,oDAAoD;AACpD,SAAS,6BAA6B,OAAO,EAAE,YAAY,EAAE,QAAQ;IACjE,6FAA6F;IAC7F,0FAA0F;IAC1F,4FAA4F;IAC5F,qCAAqC;IACrC,IAAI,WAAW,IAAI,aAAa,cAAc,CAAC,CAAC;QAC5C,MAAM,QAAQ,QAAQ,IAAI,CAAC,CAAC,QAAU,MAAM,MAAM,KAAK;QACvD,IAAI,CAAC,OAAO;YACR;QACJ;QACA,yEAAyE;QACzE,IAAI,CAAC,CAAC,+BAA+B,KAAK,GAAG;YACzC,UAAU;YACV,WAAW;YACX;QACJ;QACA,+FAA+F;QAC/F,MAAM,QAAQ,MAAM,yBAAyB,CAAC,EAAE,CAAC,UAAU;QAC3D,MAAM,SAAS,MAAM,yBAAyB,CAAC,EAAE,CAAC,SAAS;QAC3D,IAAI,QAAQ,KAAK,SAAS,GAAG;YACzB,SAAS,OAAO;QACpB;IACJ;IACA,IAAI;QACA,uFAAuF;QACvF,SAAS,OAAO,CAAC,SAAS;YAAE,KAAK;gBAAC;aAA2B;QAAC;IAClE,EACA,OAAM;QACF,SAAS,UAAU;QACnB,WAAW;QACX,MAAM,IAAI,gQAAkB,CAAC;IACjC;IACA,OAAO,IAAA,6PAAY,EAAC,IAAM,UAAU;AACxC","ignoreList":[0]}},
    {"offset": {"line": 82, "column": 0}, "map": {"version":3,"sources":["file:///D:/real-time-code-editor%20%282%29/node_modules/.pnpm/monaco-editor%400.55.1/node_modules/monaco-editor/esm/vs/editor/browser/gpu/raster/glyphRasterizer.js"],"sourcesContent":["import { memoize } from '../../../../base/common/decorators.js';\nimport { Disposable } from '../../../../base/common/lifecycle.js';\nimport { isMacintosh } from '../../../../base/common/platform.js';\nimport { StringBuilder } from '../../../common/core/stringBuilder.js';\nimport { TokenMetadata } from '../../../common/encodedTokenAttributes.js';\nimport { ensureNonNullable } from '../gpuUtils.js';\n\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nlet nextId = 0;\nclass GlyphRasterizer extends Disposable {\n    get cacheKey() {\n        return `${this.fontFamily}_${this.fontSize}px`;\n    }\n    constructor(fontSize, fontFamily, devicePixelRatio, _decorationStyleCache) {\n        super();\n        this.fontSize = fontSize;\n        this.fontFamily = fontFamily;\n        this.devicePixelRatio = devicePixelRatio;\n        this._decorationStyleCache = _decorationStyleCache;\n        this.id = nextId++;\n        this._workGlyph = {\n            source: null,\n            boundingBox: {\n                left: 0,\n                bottom: 0,\n                right: 0,\n                top: 0,\n            },\n            originOffset: {\n                x: 0,\n                y: 0,\n            },\n            fontBoundingBoxAscent: 0,\n            fontBoundingBoxDescent: 0,\n        };\n        this._workGlyphConfig = { chars: undefined, tokenMetadata: 0, decorationStyleSetId: 0 };\n        // TODO: Support workbench.fontAliasing correctly\n        this._antiAliasing = isMacintosh ? 'greyscale' : 'subpixel';\n        const devicePixelFontSize = Math.ceil(this.fontSize * devicePixelRatio);\n        this._canvas = new OffscreenCanvas(devicePixelFontSize * 3, devicePixelFontSize * 3);\n        this._ctx = ensureNonNullable(this._canvas.getContext('2d', {\n            willReadFrequently: true,\n            alpha: this._antiAliasing === 'greyscale',\n        }));\n        this._ctx.textBaseline = 'top';\n        this._ctx.fillStyle = '#FFFFFF';\n        this._ctx.font = `${devicePixelFontSize}px ${this.fontFamily}`;\n        this._textMetrics = this._ctx.measureText('A');\n    }\n    /**\n     * Rasterizes a glyph. Note that the returned object is reused across different glyphs and\n     * therefore is only safe for synchronous access.\n     */\n    rasterizeGlyph(chars, tokenMetadata, decorationStyleSetId, colorMap) {\n        if (chars === '') {\n            return {\n                source: this._canvas,\n                boundingBox: { top: 0, left: 0, bottom: -1, right: -1 },\n                originOffset: { x: 0, y: 0 },\n                fontBoundingBoxAscent: 0,\n                fontBoundingBoxDescent: 0,\n            };\n        }\n        // Check if the last glyph matches the config, reuse if so. This helps avoid unnecessary\n        // work when the rasterizer is called multiple times like when the glyph doesn't fit into a\n        // page.\n        if (this._workGlyphConfig.chars === chars && this._workGlyphConfig.tokenMetadata === tokenMetadata && this._workGlyphConfig.decorationStyleSetId === decorationStyleSetId) {\n            return this._workGlyph;\n        }\n        this._workGlyphConfig.chars = chars;\n        this._workGlyphConfig.tokenMetadata = tokenMetadata;\n        this._workGlyphConfig.decorationStyleSetId = decorationStyleSetId;\n        return this._rasterizeGlyph(chars, tokenMetadata, decorationStyleSetId, colorMap);\n    }\n    _rasterizeGlyph(chars, tokenMetadata, decorationStyleSetId, colorMap) {\n        const devicePixelFontSize = Math.ceil(this.fontSize * this.devicePixelRatio);\n        const canvasDim = devicePixelFontSize * 3;\n        if (this._canvas.width !== canvasDim) {\n            this._canvas.width = canvasDim;\n            this._canvas.height = canvasDim;\n        }\n        this._ctx.save();\n        // The sub-pixel x offset is the fractional part of the x pixel coordinate of the cell, this\n        // is used to improve the spacing between rendered characters.\n        const xSubPixelXOffset = (tokenMetadata & 0b1111) / 10;\n        const bgId = TokenMetadata.getBackground(tokenMetadata);\n        const bg = colorMap[bgId];\n        const decorationStyleSet = this._decorationStyleCache.getStyleSet(decorationStyleSetId);\n        // When SPAA is used, the background color must be present to get the right glyph\n        if (this._antiAliasing === 'subpixel') {\n            this._ctx.fillStyle = bg;\n            this._ctx.fillRect(0, 0, this._canvas.width, this._canvas.height);\n        }\n        else {\n            this._ctx.clearRect(0, 0, this._canvas.width, this._canvas.height);\n        }\n        const fontSb = new StringBuilder(200);\n        const fontStyle = TokenMetadata.getFontStyle(tokenMetadata);\n        if (fontStyle & 1 /* FontStyle.Italic */) {\n            fontSb.appendString('italic ');\n        }\n        if (decorationStyleSet?.bold !== undefined) {\n            if (decorationStyleSet.bold) {\n                fontSb.appendString('bold ');\n            }\n        }\n        else if (fontStyle & 2 /* FontStyle.Bold */) {\n            fontSb.appendString('bold ');\n        }\n        fontSb.appendString(`${devicePixelFontSize}px ${this.fontFamily}`);\n        this._ctx.font = fontSb.build();\n        // TODO: Support FontStyle.Strikethrough and FontStyle.Underline text decorations, these\n        //       need to be drawn manually to the canvas. See xterm.js for \"dodging\" the text for\n        //       underlines.\n        const originX = devicePixelFontSize;\n        const originY = devicePixelFontSize;\n        if (decorationStyleSet?.color !== undefined) {\n            this._ctx.fillStyle = `#${decorationStyleSet.color.toString(16).padStart(8, '0')}`;\n        }\n        else {\n            this._ctx.fillStyle = colorMap[TokenMetadata.getForeground(tokenMetadata)];\n        }\n        this._ctx.textBaseline = 'top';\n        if (decorationStyleSet?.opacity !== undefined) {\n            this._ctx.globalAlpha = decorationStyleSet.opacity;\n        }\n        this._ctx.fillText(chars, originX + xSubPixelXOffset, originY);\n        this._ctx.restore();\n        const imageData = this._ctx.getImageData(0, 0, this._canvas.width, this._canvas.height);\n        if (this._antiAliasing === 'subpixel') {\n            const bgR = parseInt(bg.substring(1, 3), 16);\n            const bgG = parseInt(bg.substring(3, 5), 16);\n            const bgB = parseInt(bg.substring(5, 7), 16);\n            this._clearColor(imageData, bgR, bgG, bgB);\n            this._ctx.putImageData(imageData, 0, 0);\n        }\n        this._findGlyphBoundingBox(imageData, this._workGlyph.boundingBox);\n        // const offset = {\n        // \tx: textMetrics.actualBoundingBoxLeft,\n        // \ty: textMetrics.actualBoundingBoxAscent\n        // };\n        // const size = {\n        // \tw: textMetrics.actualBoundingBoxRight + textMetrics.actualBoundingBoxLeft,\n        // \ty: textMetrics.actualBoundingBoxDescent + textMetrics.actualBoundingBoxAscent,\n        // \twInt: Math.ceil(textMetrics.actualBoundingBoxRight + textMetrics.actualBoundingBoxLeft),\n        // \tyInt: Math.ceil(textMetrics.actualBoundingBoxDescent + textMetrics.actualBoundingBoxAscent),\n        // };\n        // console.log(`${chars}_${fg}`, textMetrics, boundingBox, originX, originY, { width: boundingBox.right - boundingBox.left, height: boundingBox.bottom - boundingBox.top });\n        this._workGlyph.source = this._canvas;\n        this._workGlyph.originOffset.x = this._workGlyph.boundingBox.left - originX;\n        this._workGlyph.originOffset.y = this._workGlyph.boundingBox.top - originY;\n        this._workGlyph.fontBoundingBoxAscent = this._textMetrics.fontBoundingBoxAscent;\n        this._workGlyph.fontBoundingBoxDescent = this._textMetrics.fontBoundingBoxDescent;\n        // const result2: IRasterizedGlyph = {\n        // \tsource: this._canvas,\n        // \tboundingBox: {\n        // \t\tleft: Math.floor(originX - textMetrics.actualBoundingBoxLeft),\n        // \t\tright: Math.ceil(originX + textMetrics.actualBoundingBoxRight),\n        // \t\ttop: Math.floor(originY - textMetrics.actualBoundingBoxAscent),\n        // \t\tbottom: Math.ceil(originY + textMetrics.actualBoundingBoxDescent),\n        // \t},\n        // \toriginOffset: {\n        // \t\tx: Math.floor(boundingBox.left - originX),\n        // \t\ty: Math.floor(boundingBox.top - originY)\n        // \t}\n        // };\n        // TODO: Verify result 1 and 2 are the same\n        // if (result2.boundingBox.left > result.boundingBox.left) {\n        // \tdebugger;\n        // }\n        // if (result2.boundingBox.top > result.boundingBox.top) {\n        // \tdebugger;\n        // }\n        // if (result2.boundingBox.right < result.boundingBox.right) {\n        // \tdebugger;\n        // }\n        // if (result2.boundingBox.bottom < result.boundingBox.bottom) {\n        // \tdebugger;\n        // }\n        // if (JSON.stringify(result2.originOffset) !== JSON.stringify(result.originOffset)) {\n        // \tdebugger;\n        // }\n        return this._workGlyph;\n    }\n    _clearColor(imageData, r, g, b) {\n        for (let offset = 0; offset < imageData.data.length; offset += 4) {\n            // Check exact match\n            if (imageData.data[offset] === r &&\n                imageData.data[offset + 1] === g &&\n                imageData.data[offset + 2] === b) {\n                imageData.data[offset + 3] = 0;\n            }\n        }\n    }\n    // TODO: Does this even need to happen when measure text is used?\n    _findGlyphBoundingBox(imageData, outBoundingBox) {\n        const height = this._canvas.height;\n        const width = this._canvas.width;\n        let found = false;\n        for (let y = 0; y < height; y++) {\n            for (let x = 0; x < width; x++) {\n                const alphaOffset = y * width * 4 + x * 4 + 3;\n                if (imageData.data[alphaOffset] !== 0) {\n                    outBoundingBox.top = y;\n                    found = true;\n                    break;\n                }\n            }\n            if (found) {\n                break;\n            }\n        }\n        outBoundingBox.left = 0;\n        found = false;\n        for (let x = 0; x < width; x++) {\n            for (let y = 0; y < height; y++) {\n                const alphaOffset = y * width * 4 + x * 4 + 3;\n                if (imageData.data[alphaOffset] !== 0) {\n                    outBoundingBox.left = x;\n                    found = true;\n                    break;\n                }\n            }\n            if (found) {\n                break;\n            }\n        }\n        outBoundingBox.right = width;\n        found = false;\n        for (let x = width - 1; x >= outBoundingBox.left; x--) {\n            for (let y = 0; y < height; y++) {\n                const alphaOffset = y * width * 4 + x * 4 + 3;\n                if (imageData.data[alphaOffset] !== 0) {\n                    outBoundingBox.right = x;\n                    found = true;\n                    break;\n                }\n            }\n            if (found) {\n                break;\n            }\n        }\n        outBoundingBox.bottom = outBoundingBox.top;\n        found = false;\n        for (let y = height - 1; y >= 0; y--) {\n            for (let x = 0; x < width; x++) {\n                const alphaOffset = y * width * 4 + x * 4 + 3;\n                if (imageData.data[alphaOffset] !== 0) {\n                    outBoundingBox.bottom = y;\n                    found = true;\n                    break;\n                }\n            }\n            if (found) {\n                break;\n            }\n        }\n    }\n    getTextMetrics(text) {\n        return this._ctx.measureText(text);\n    }\n}\n__decorate([\n    memoize\n], GlyphRasterizer.prototype, \"cacheKey\", null);\n\nexport { GlyphRasterizer };\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 375, "column": 0}, "map": {"version":3,"sources":["file:///D:/real-time-code-editor%20%282%29/node_modules/.pnpm/monaco-editor%400.55.1/node_modules/monaco-editor/esm/vs/editor/browser/gpu/taskQueue.js"],"sourcesContent":["import { getActiveWindow } from '../../../base/browser/dom.js';\nimport { Disposable, toDisposable } from '../../../base/common/lifecycle.js';\nimport { ILogService } from '../../../platform/log/common/log.js';\n\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (undefined && undefined.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nlet TaskQueue = class TaskQueue extends Disposable {\n    constructor(_logService) {\n        super();\n        this._logService = _logService;\n        this._tasks = [];\n        this._i = 0;\n        this._register(toDisposable(() => this.clear()));\n    }\n    enqueue(task) {\n        this._tasks.push(task);\n        this._start();\n    }\n    clear() {\n        if (this._idleCallback) {\n            this._cancelCallback(this._idleCallback);\n            this._idleCallback = undefined;\n        }\n        this._i = 0;\n        this._tasks.length = 0;\n    }\n    _start() {\n        if (!this._idleCallback) {\n            this._idleCallback = this._requestCallback(this._process.bind(this));\n        }\n    }\n    _process(deadline) {\n        this._idleCallback = undefined;\n        let taskDuration = 0;\n        let longestTask = 0;\n        let lastDeadlineRemaining = deadline.timeRemaining();\n        let deadlineRemaining = 0;\n        while (this._i < this._tasks.length) {\n            taskDuration = Date.now();\n            if (!this._tasks[this._i]()) {\n                this._i++;\n            }\n            // other than performance.now, Date.now might not be stable (changes on wall clock changes),\n            // this is not an issue here as a clock change during a short running task is very unlikely\n            // in case it still happened and leads to negative duration, simply assume 1 msec\n            taskDuration = Math.max(1, Date.now() - taskDuration);\n            longestTask = Math.max(taskDuration, longestTask);\n            // Guess the following task will take a similar time to the longest task in this batch, allow\n            // additional room to try avoid exceeding the deadline\n            deadlineRemaining = deadline.timeRemaining();\n            if (longestTask * 1.5 > deadlineRemaining) {\n                // Warn when the time exceeding the deadline is over 20ms, if this happens in practice the\n                // task should be split into sub-tasks to ensure the UI remains responsive.\n                if (lastDeadlineRemaining - taskDuration < -20) {\n                    this._logService.warn(`task queue exceeded allotted deadline by ${Math.abs(Math.round(lastDeadlineRemaining - taskDuration))}ms`);\n                }\n                this._start();\n                return;\n            }\n            lastDeadlineRemaining = deadlineRemaining;\n        }\n        this.clear();\n    }\n};\nTaskQueue = __decorate([\n    __param(0, ILogService)\n], TaskQueue);\n/**\n * A queue of that runs tasks over several tasks via setTimeout, trying to maintain above 60 frames\n * per second. The tasks will run in the order they are enqueued, but they will run some time later,\n * and care should be taken to ensure they're non-urgent and will not introduce race conditions.\n */\nclass PriorityTaskQueue extends TaskQueue {\n    _requestCallback(callback) {\n        return getActiveWindow().setTimeout(() => callback(this._createDeadline(16)));\n    }\n    _cancelCallback(identifier) {\n        getActiveWindow().clearTimeout(identifier);\n    }\n    _createDeadline(duration) {\n        const end = Date.now() + duration;\n        return {\n            timeRemaining: () => Math.max(0, end - Date.now())\n        };\n    }\n}\nclass IdleTaskQueueInternal extends TaskQueue {\n    _requestCallback(callback) {\n        return getActiveWindow().requestIdleCallback(callback);\n    }\n    _cancelCallback(identifier) {\n        getActiveWindow().cancelIdleCallback(identifier);\n    }\n}\n/**\n * A queue of that runs tasks over several idle callbacks, trying to respect the idle callback's\n * deadline given by the environment. The tasks will run in the order they are enqueued, but they\n * will run some time later, and care should be taken to ensure they're non-urgent and will not\n * introduce race conditions.\n *\n * This reverts to a {@link PriorityTaskQueue} if the environment does not support idle callbacks.\n */\nconst IdleTaskQueue = ('requestIdleCallback' in getActiveWindow()) ? IdleTaskQueueInternal : PriorityTaskQueue;\n\nexport { IdleTaskQueue, PriorityTaskQueue };\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 501, "column": 0}, "map": {"version":3,"sources":["file:///D:/real-time-code-editor%20%282%29/node_modules/.pnpm/monaco-editor%400.55.1/node_modules/monaco-editor/esm/vs/editor/browser/gpu/atlas/textureAtlasShelfAllocator.js"],"sourcesContent":["import { BugIndicatingError } from '../../../../base/common/errors.js';\nimport { ensureNonNullable } from '../gpuUtils.js';\n\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n/**\n * The shelf allocator is a simple allocator that places glyphs in rows, starting a new row when the\n * current row is full. Due to its simplicity, it can waste space but it is very fast.\n */\nclass TextureAtlasShelfAllocator {\n    constructor(_canvas, _textureIndex) {\n        this._canvas = _canvas;\n        this._textureIndex = _textureIndex;\n        this._currentRow = {\n            x: 0,\n            y: 0,\n            h: 0\n        };\n        /** A set of all glyphs allocated, this is only tracked to enable debug related functionality */\n        this._allocatedGlyphs = new Set();\n        this._nextIndex = 0;\n        this._ctx = ensureNonNullable(this._canvas.getContext('2d', {\n            willReadFrequently: true\n        }));\n    }\n    allocate(rasterizedGlyph) {\n        // The glyph does not fit into the atlas page\n        const glyphWidth = rasterizedGlyph.boundingBox.right - rasterizedGlyph.boundingBox.left + 1;\n        const glyphHeight = rasterizedGlyph.boundingBox.bottom - rasterizedGlyph.boundingBox.top + 1;\n        if (glyphWidth > this._canvas.width || glyphHeight > this._canvas.height) {\n            throw new BugIndicatingError('Glyph is too large for the atlas page');\n        }\n        // Finalize and increment row if it doesn't fix horizontally\n        if (rasterizedGlyph.boundingBox.right - rasterizedGlyph.boundingBox.left + 1 > this._canvas.width - this._currentRow.x) {\n            this._currentRow.x = 0;\n            this._currentRow.y += this._currentRow.h;\n            this._currentRow.h = 1;\n        }\n        // Return undefined if there isn't any room left\n        if (this._currentRow.y + rasterizedGlyph.boundingBox.bottom - rasterizedGlyph.boundingBox.top + 1 > this._canvas.height) {\n            return undefined;\n        }\n        // Draw glyph\n        this._ctx.drawImage(rasterizedGlyph.source, \n        // source\n        rasterizedGlyph.boundingBox.left, rasterizedGlyph.boundingBox.top, glyphWidth, glyphHeight, \n        // destination\n        this._currentRow.x, this._currentRow.y, glyphWidth, glyphHeight);\n        // Create glyph object\n        const glyph = {\n            pageIndex: this._textureIndex,\n            glyphIndex: this._nextIndex++,\n            x: this._currentRow.x,\n            y: this._currentRow.y,\n            w: glyphWidth,\n            h: glyphHeight,\n            originOffsetX: rasterizedGlyph.originOffset.x,\n            originOffsetY: rasterizedGlyph.originOffset.y,\n            fontBoundingBoxAscent: rasterizedGlyph.fontBoundingBoxAscent,\n            fontBoundingBoxDescent: rasterizedGlyph.fontBoundingBoxDescent,\n        };\n        // Shift current row\n        this._currentRow.x += glyphWidth;\n        this._currentRow.h = Math.max(this._currentRow.h, glyphHeight);\n        // Set the glyph\n        this._allocatedGlyphs.add(glyph);\n        return glyph;\n    }\n    getUsagePreview() {\n        const w = this._canvas.width;\n        const h = this._canvas.height;\n        const canvas = new OffscreenCanvas(w, h);\n        const ctx = ensureNonNullable(canvas.getContext('2d'));\n        ctx.fillStyle = \"#808080\" /* UsagePreviewColors.Unused */;\n        ctx.fillRect(0, 0, w, h);\n        const rowHeight = new Map(); // y -> h\n        const rowWidth = new Map(); // y -> w\n        for (const g of this._allocatedGlyphs) {\n            rowHeight.set(g.y, Math.max(rowHeight.get(g.y) ?? 0, g.h));\n            rowWidth.set(g.y, Math.max(rowWidth.get(g.y) ?? 0, g.x + g.w));\n        }\n        for (const g of this._allocatedGlyphs) {\n            ctx.fillStyle = \"#4040FF\" /* UsagePreviewColors.Used */;\n            ctx.fillRect(g.x, g.y, g.w, g.h);\n            ctx.fillStyle = \"#FF0000\" /* UsagePreviewColors.Wasted */;\n            ctx.fillRect(g.x, g.y + g.h, g.w, rowHeight.get(g.y) - g.h);\n        }\n        for (const [rowY, rowW] of rowWidth.entries()) {\n            if (rowY !== this._currentRow.y) {\n                ctx.fillStyle = \"#FF0000\" /* UsagePreviewColors.Wasted */;\n                ctx.fillRect(rowW, rowY, w - rowW, rowHeight.get(rowY));\n            }\n        }\n        return canvas.convertToBlob();\n    }\n    getStats() {\n        const w = this._canvas.width;\n        const h = this._canvas.height;\n        let usedPixels = 0;\n        let wastedPixels = 0;\n        const totalPixels = w * h;\n        const rowHeight = new Map(); // y -> h\n        const rowWidth = new Map(); // y -> w\n        for (const g of this._allocatedGlyphs) {\n            rowHeight.set(g.y, Math.max(rowHeight.get(g.y) ?? 0, g.h));\n            rowWidth.set(g.y, Math.max(rowWidth.get(g.y) ?? 0, g.x + g.w));\n        }\n        for (const g of this._allocatedGlyphs) {\n            usedPixels += g.w * g.h;\n            wastedPixels += g.w * (rowHeight.get(g.y) - g.h);\n        }\n        for (const [rowY, rowW] of rowWidth.entries()) {\n            if (rowY !== this._currentRow.y) {\n                wastedPixels += (w - rowW) * rowHeight.get(rowY);\n            }\n        }\n        return [\n            `page${this._textureIndex}:`,\n            `     Total: ${totalPixels} (${w}x${h})`,\n            `      Used: ${usedPixels} (${((usedPixels / totalPixels) * 100).toPrecision(2)}%)`,\n            `    Wasted: ${wastedPixels} (${((wastedPixels / totalPixels) * 100).toPrecision(2)}%)`,\n            `Efficiency: ${((usedPixels / (usedPixels + wastedPixels)) * 100).toPrecision(2)}%`,\n        ].join('\\n');\n    }\n}\n\nexport { TextureAtlasShelfAllocator };\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 633, "column": 0}, "map": {"version":3,"sources":["file:///D:/real-time-code-editor%20%282%29/node_modules/.pnpm/monaco-editor%400.55.1/node_modules/monaco-editor/esm/vs/editor/browser/gpu/atlas/textureAtlasSlabAllocator.js"],"sourcesContent":["import { getActiveWindow } from '../../../../base/browser/dom.js';\nimport { BugIndicatingError } from '../../../../base/common/errors.js';\nimport { NKeyMap } from '../../../../base/common/map.js';\nimport { ensureNonNullable } from '../gpuUtils.js';\n\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n/**\n * The slab allocator is a more complex allocator that places glyphs in square slabs of a fixed\n * size. Slabs are defined by a small range of glyphs sizes they can house, this places like-sized\n * glyphs in the same slab which reduces wasted space.\n *\n * Slabs also may contain \"unused\" regions on the left and bottom depending on the size of the\n * glyphs they include. This space is used to place very thin or short glyphs, which would otherwise\n * waste a lot of space in their own slab.\n */\nclass TextureAtlasSlabAllocator {\n    constructor(_canvas, _textureIndex, options) {\n        this._canvas = _canvas;\n        this._textureIndex = _textureIndex;\n        this._slabs = [];\n        this._activeSlabsByDims = new NKeyMap();\n        this._unusedRects = [];\n        this._openRegionsByHeight = new Map();\n        this._openRegionsByWidth = new Map();\n        /** A set of all glyphs allocated, this is only tracked to enable debug related functionality */\n        this._allocatedGlyphs = new Set();\n        this._nextIndex = 0;\n        this._ctx = ensureNonNullable(this._canvas.getContext('2d', {\n            willReadFrequently: true\n        }));\n        this._slabW = Math.min(options?.slabW ?? (64 << Math.max(Math.floor(getActiveWindow().devicePixelRatio) - 1, 0)), this._canvas.width);\n        this._slabH = Math.min(options?.slabH ?? this._slabW, this._canvas.height);\n        this._slabsPerRow = Math.floor(this._canvas.width / this._slabW);\n        this._slabsPerColumn = Math.floor(this._canvas.height / this._slabH);\n    }\n    allocate(rasterizedGlyph) {\n        // Find ideal slab, creating it if there is none suitable\n        const glyphWidth = rasterizedGlyph.boundingBox.right - rasterizedGlyph.boundingBox.left + 1;\n        const glyphHeight = rasterizedGlyph.boundingBox.bottom - rasterizedGlyph.boundingBox.top + 1;\n        // The glyph does not fit into the atlas page, glyphs should never be this large in practice\n        if (glyphWidth > this._canvas.width || glyphHeight > this._canvas.height) {\n            throw new BugIndicatingError('Glyph is too large for the atlas page');\n        }\n        // The glyph does not fit into a slab\n        if (glyphWidth > this._slabW || glyphHeight > this._slabH) {\n            // Only if this is the allocator's first glyph, resize the slab size to fit the glyph.\n            if (this._allocatedGlyphs.size > 0) {\n                return undefined;\n            }\n            // Find the largest power of 2 devisor that the glyph fits into, this ensure there is no\n            // wasted space outside the allocated slabs.\n            let sizeCandidate = this._canvas.width;\n            while (glyphWidth < sizeCandidate / 2 && glyphHeight < sizeCandidate / 2) {\n                sizeCandidate /= 2;\n            }\n            this._slabW = sizeCandidate;\n            this._slabH = sizeCandidate;\n            this._slabsPerRow = Math.floor(this._canvas.width / this._slabW);\n            this._slabsPerColumn = Math.floor(this._canvas.height / this._slabH);\n        }\n        // const dpr = getActiveWindow().devicePixelRatio;\n        // TODO: Include font size as well as DPR in nearestXPixels calculation\n        // Round slab glyph dimensions to the nearest x pixels, where x scaled with device pixel ratio\n        // const nearestXPixels = Math.max(1, Math.floor(dpr / 0.5));\n        // const nearestXPixels = Math.max(1, Math.floor(dpr));\n        const desiredSlabSize = {\n            // Nearest square number\n            // TODO: This can probably be optimized\n            // w: 1 << Math.ceil(Math.sqrt(glyphWidth)),\n            // h: 1 << Math.ceil(Math.sqrt(glyphHeight)),\n            // Nearest x px\n            // w: Math.ceil(glyphWidth / nearestXPixels) * nearestXPixels,\n            // h: Math.ceil(glyphHeight / nearestXPixels) * nearestXPixels,\n            // Round odd numbers up\n            // w: glyphWidth % 0 === 1 ? glyphWidth + 1 : glyphWidth,\n            // h: glyphHeight % 0 === 1 ? glyphHeight + 1 : glyphHeight,\n            // Exact number only\n            w: glyphWidth,\n            h: glyphHeight,\n        };\n        // Get any existing slab\n        let slab = this._activeSlabsByDims.get(desiredSlabSize.w, desiredSlabSize.h);\n        // Check if the slab is full\n        if (slab) {\n            const glyphsPerSlab = Math.floor(this._slabW / slab.entryW) * Math.floor(this._slabH / slab.entryH);\n            if (slab.count >= glyphsPerSlab) {\n                slab = undefined;\n            }\n        }\n        let dx;\n        let dy;\n        // Search for suitable space in unused rectangles\n        if (!slab) {\n            // Only check availability for the smallest side\n            if (glyphWidth < glyphHeight) {\n                const openRegions = this._openRegionsByWidth.get(glyphWidth);\n                if (openRegions?.length) {\n                    // TODO: Don't search everything?\n                    // Search from the end so we can typically pop it off the stack\n                    for (let i = openRegions.length - 1; i >= 0; i--) {\n                        const r = openRegions[i];\n                        if (r.w >= glyphWidth && r.h >= glyphHeight) {\n                            dx = r.x;\n                            dy = r.y;\n                            if (glyphWidth < r.w) {\n                                this._unusedRects.push({\n                                    x: r.x + glyphWidth,\n                                    y: r.y,\n                                    w: r.w - glyphWidth,\n                                    h: glyphHeight\n                                });\n                            }\n                            r.y += glyphHeight;\n                            r.h -= glyphHeight;\n                            if (r.h === 0) {\n                                if (i === openRegions.length - 1) {\n                                    openRegions.pop();\n                                }\n                                else {\n                                    this._unusedRects.splice(i, 1);\n                                }\n                            }\n                            break;\n                        }\n                    }\n                }\n            }\n            else {\n                const openRegions = this._openRegionsByHeight.get(glyphHeight);\n                if (openRegions?.length) {\n                    // TODO: Don't search everything?\n                    // Search from the end so we can typically pop it off the stack\n                    for (let i = openRegions.length - 1; i >= 0; i--) {\n                        const r = openRegions[i];\n                        if (r.w >= glyphWidth && r.h >= glyphHeight) {\n                            dx = r.x;\n                            dy = r.y;\n                            if (glyphHeight < r.h) {\n                                this._unusedRects.push({\n                                    x: r.x,\n                                    y: r.y + glyphHeight,\n                                    w: glyphWidth,\n                                    h: r.h - glyphHeight\n                                });\n                            }\n                            r.x += glyphWidth;\n                            r.w -= glyphWidth;\n                            if (r.h === 0) {\n                                if (i === openRegions.length - 1) {\n                                    openRegions.pop();\n                                }\n                                else {\n                                    this._unusedRects.splice(i, 1);\n                                }\n                            }\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n        // Create a new slab\n        if (dx === undefined || dy === undefined) {\n            if (!slab) {\n                if (this._slabs.length >= this._slabsPerRow * this._slabsPerColumn) {\n                    return undefined;\n                }\n                slab = {\n                    x: Math.floor(this._slabs.length % this._slabsPerRow) * this._slabW,\n                    y: Math.floor(this._slabs.length / this._slabsPerRow) * this._slabH,\n                    entryW: desiredSlabSize.w,\n                    entryH: desiredSlabSize.h,\n                    count: 0\n                };\n                // Track unused regions to use for small glyphs\n                // +-------------+----+\n                // |             |    |\n                // |             |    | <- Unused W region\n                // |             |    |\n                // |-------------+----+\n                // |                  | <- Unused H region\n                // +------------------+\n                const unusedW = this._slabW % slab.entryW;\n                const unusedH = this._slabH % slab.entryH;\n                if (unusedW) {\n                    addEntryToMapArray(this._openRegionsByWidth, unusedW, {\n                        x: slab.x + this._slabW - unusedW,\n                        w: unusedW,\n                        y: slab.y,\n                        h: this._slabH - (unusedH ?? 0)\n                    });\n                }\n                if (unusedH) {\n                    addEntryToMapArray(this._openRegionsByHeight, unusedH, {\n                        x: slab.x,\n                        w: this._slabW,\n                        y: slab.y + this._slabH - unusedH,\n                        h: unusedH\n                    });\n                }\n                this._slabs.push(slab);\n                this._activeSlabsByDims.set(slab, desiredSlabSize.w, desiredSlabSize.h);\n            }\n            const glyphsPerRow = Math.floor(this._slabW / slab.entryW);\n            dx = slab.x + Math.floor(slab.count % glyphsPerRow) * slab.entryW;\n            dy = slab.y + Math.floor(slab.count / glyphsPerRow) * slab.entryH;\n            // Shift current row\n            slab.count++;\n        }\n        // Draw glyph\n        this._ctx.drawImage(rasterizedGlyph.source, \n        // source\n        rasterizedGlyph.boundingBox.left, rasterizedGlyph.boundingBox.top, glyphWidth, glyphHeight, \n        // destination\n        dx, dy, glyphWidth, glyphHeight);\n        // Create glyph object\n        const glyph = {\n            pageIndex: this._textureIndex,\n            glyphIndex: this._nextIndex++,\n            x: dx,\n            y: dy,\n            w: glyphWidth,\n            h: glyphHeight,\n            originOffsetX: rasterizedGlyph.originOffset.x,\n            originOffsetY: rasterizedGlyph.originOffset.y,\n            fontBoundingBoxAscent: rasterizedGlyph.fontBoundingBoxAscent,\n            fontBoundingBoxDescent: rasterizedGlyph.fontBoundingBoxDescent,\n        };\n        // Set the glyph\n        this._allocatedGlyphs.add(glyph);\n        return glyph;\n    }\n    getUsagePreview() {\n        const w = this._canvas.width;\n        const h = this._canvas.height;\n        const canvas = new OffscreenCanvas(w, h);\n        const ctx = ensureNonNullable(canvas.getContext('2d'));\n        ctx.fillStyle = \"#808080\" /* UsagePreviewColors.Unused */;\n        ctx.fillRect(0, 0, w, h);\n        let slabEntryPixels = 0;\n        let usedPixels = 0;\n        let restrictedPixels = 0;\n        const slabW = 64 << (Math.floor(getActiveWindow().devicePixelRatio) - 1);\n        const slabH = slabW;\n        // Draw wasted underneath glyphs first\n        for (const slab of this._slabs) {\n            let x = 0;\n            let y = 0;\n            for (let i = 0; i < slab.count; i++) {\n                if (x + slab.entryW > slabW) {\n                    x = 0;\n                    y += slab.entryH;\n                }\n                ctx.fillStyle = \"#FF0000\" /* UsagePreviewColors.Wasted */;\n                ctx.fillRect(slab.x + x, slab.y + y, slab.entryW, slab.entryH);\n                slabEntryPixels += slab.entryW * slab.entryH;\n                x += slab.entryW;\n            }\n            const entriesPerRow = Math.floor(slabW / slab.entryW);\n            const entriesPerCol = Math.floor(slabH / slab.entryH);\n            slab.entryW * entriesPerRow * slab.entryH * entriesPerCol;\n        }\n        // Draw glyphs\n        for (const g of this._allocatedGlyphs) {\n            usedPixels += g.w * g.h;\n            ctx.fillStyle = \"#4040FF\" /* UsagePreviewColors.Used */;\n            ctx.fillRect(g.x, g.y, g.w, g.h);\n        }\n        // Draw unused space on side\n        const unusedRegions = Array.from(this._openRegionsByWidth.values()).flat().concat(Array.from(this._openRegionsByHeight.values()).flat());\n        for (const r of unusedRegions) {\n            ctx.fillStyle = \"#FF000088\" /* UsagePreviewColors.Restricted */;\n            ctx.fillRect(r.x, r.y, r.w, r.h);\n            restrictedPixels += r.w * r.h;\n        }\n        // Overlay actual glyphs on top\n        ctx.globalAlpha = 0.5;\n        ctx.drawImage(this._canvas, 0, 0);\n        ctx.globalAlpha = 1;\n        return canvas.convertToBlob();\n    }\n    getStats() {\n        const w = this._canvas.width;\n        const h = this._canvas.height;\n        let slabEntryPixels = 0;\n        let usedPixels = 0;\n        let slabEdgePixels = 0;\n        let wastedPixels = 0;\n        let restrictedPixels = 0;\n        const totalPixels = w * h;\n        const slabW = 64 << (Math.floor(getActiveWindow().devicePixelRatio) - 1);\n        const slabH = slabW;\n        // Draw wasted underneath glyphs first\n        for (const slab of this._slabs) {\n            let x = 0;\n            let y = 0;\n            for (let i = 0; i < slab.count; i++) {\n                if (x + slab.entryW > slabW) {\n                    x = 0;\n                    y += slab.entryH;\n                }\n                slabEntryPixels += slab.entryW * slab.entryH;\n                x += slab.entryW;\n            }\n            const entriesPerRow = Math.floor(slabW / slab.entryW);\n            const entriesPerCol = Math.floor(slabH / slab.entryH);\n            const thisSlabPixels = slab.entryW * entriesPerRow * slab.entryH * entriesPerCol;\n            slabEdgePixels += (slabW * slabH) - thisSlabPixels;\n        }\n        // Draw glyphs\n        for (const g of this._allocatedGlyphs) {\n            usedPixels += g.w * g.h;\n        }\n        // Draw unused space on side\n        const unusedRegions = Array.from(this._openRegionsByWidth.values()).flat().concat(Array.from(this._openRegionsByHeight.values()).flat());\n        for (const r of unusedRegions) {\n            restrictedPixels += r.w * r.h;\n        }\n        const edgeUsedPixels = slabEdgePixels - restrictedPixels;\n        wastedPixels = slabEntryPixels - (usedPixels - edgeUsedPixels);\n        // usedPixels += slabEdgePixels - restrictedPixels;\n        const efficiency = usedPixels / (usedPixels + wastedPixels + restrictedPixels);\n        return [\n            `page[${this._textureIndex}]:`,\n            `     Total: ${totalPixels}px (${w}x${h})`,\n            `      Used: ${usedPixels}px (${((usedPixels / totalPixels) * 100).toFixed(2)}%)`,\n            `    Wasted: ${wastedPixels}px (${((wastedPixels / totalPixels) * 100).toFixed(2)}%)`,\n            `Restricted: ${restrictedPixels}px (${((restrictedPixels / totalPixels) * 100).toFixed(2)}%) (hard to allocate)`,\n            `Efficiency: ${efficiency === 1 ? '100' : (efficiency * 100).toFixed(2)}%`,\n            `     Slabs: ${this._slabs.length} of ${Math.floor(this._canvas.width / slabW) * Math.floor(this._canvas.height / slabH)}`\n        ].join('\\n');\n    }\n}\nfunction addEntryToMapArray(map, key, entry) {\n    let list = map.get(key);\n    if (!list) {\n        list = [];\n        map.set(key, list);\n    }\n    list.push(entry);\n}\n\nexport { TextureAtlasSlabAllocator };\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 981, "column": 0}, "map": {"version":3,"sources":["file:///D:/real-time-code-editor%20%282%29/node_modules/.pnpm/monaco-editor%400.55.1/node_modules/monaco-editor/esm/vs/editor/browser/gpu/atlas/textureAtlasPage.js"],"sourcesContent":["import { Disposable, toDisposable } from '../../../../base/common/lifecycle.js';\nimport { NKeyMap } from '../../../../base/common/map.js';\nimport { LogLevel, ILogService } from '../../../../platform/log/common/log.js';\nimport { IThemeService } from '../../../../platform/theme/common/themeService.js';\nimport { TextureAtlasShelfAllocator } from './textureAtlasShelfAllocator.js';\nimport { TextureAtlasSlabAllocator } from './textureAtlasSlabAllocator.js';\n\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (undefined && undefined.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nvar TextureAtlasPage_1;\nlet TextureAtlasPage = class TextureAtlasPage extends Disposable {\n    static { TextureAtlasPage_1 = this; }\n    get version() { return this._version; }\n    /**\n     * The maximum number of glyphs that can be drawn to the page. This is currently a hard static\n     * cap that must not be reached as it will cause the GPU buffer to overflow.\n     */\n    static { this.maximumGlyphCount = 5_000; }\n    get usedArea() { return this._usedArea; }\n    get source() { return this._canvas; }\n    get glyphs() {\n        return this._glyphInOrderSet.values();\n    }\n    constructor(textureIndex, pageSize, allocatorType, _logService, themeService) {\n        super();\n        this._logService = _logService;\n        this._version = 0;\n        this._usedArea = { left: 0, top: 0, right: 0, bottom: 0 };\n        this._glyphMap = new NKeyMap();\n        this._glyphInOrderSet = new Set();\n        this._canvas = new OffscreenCanvas(pageSize, pageSize);\n        this._colorMap = themeService.getColorTheme().tokenColorMap;\n        switch (allocatorType) {\n            case 'shelf':\n                this._allocator = new TextureAtlasShelfAllocator(this._canvas, textureIndex);\n                break;\n            case 'slab':\n                this._allocator = new TextureAtlasSlabAllocator(this._canvas, textureIndex);\n                break;\n            default:\n                this._allocator = allocatorType(this._canvas, textureIndex);\n                break;\n        }\n        // Reduce impact of a memory leak if this object is not released\n        this._register(toDisposable(() => {\n            this._canvas.width = 1;\n            this._canvas.height = 1;\n        }));\n    }\n    getGlyph(rasterizer, chars, tokenMetadata, decorationStyleSetId) {\n        // IMPORTANT: There are intentionally no intermediate variables here to aid in runtime\n        // optimization as it's a very hot function\n        return this._glyphMap.get(chars, tokenMetadata, decorationStyleSetId, rasterizer.cacheKey) ?? this._createGlyph(rasterizer, chars, tokenMetadata, decorationStyleSetId);\n    }\n    _createGlyph(rasterizer, chars, tokenMetadata, decorationStyleSetId) {\n        // Ensure the glyph can fit on the page\n        if (this._glyphInOrderSet.size >= TextureAtlasPage_1.maximumGlyphCount) {\n            return undefined;\n        }\n        // Rasterize and allocate the glyph\n        const rasterizedGlyph = rasterizer.rasterizeGlyph(chars, tokenMetadata, decorationStyleSetId, this._colorMap);\n        const glyph = this._allocator.allocate(rasterizedGlyph);\n        // Ensure the glyph was allocated\n        if (glyph === undefined) {\n            // TODO: undefined here can mean the glyph was too large for a slab on the page, this\n            // can lead to big problems if we don't handle it properly https://github.com/microsoft/vscode/issues/232984\n            return undefined;\n        }\n        // Save the glyph\n        this._glyphMap.set(glyph, chars, tokenMetadata, decorationStyleSetId, rasterizer.cacheKey);\n        this._glyphInOrderSet.add(glyph);\n        // Update page version and it's tracked used area\n        this._version++;\n        this._usedArea.right = Math.max(this._usedArea.right, glyph.x + glyph.w - 1);\n        this._usedArea.bottom = Math.max(this._usedArea.bottom, glyph.y + glyph.h - 1);\n        if (this._logService.getLevel() === LogLevel.Trace) {\n            this._logService.trace('New glyph', {\n                chars,\n                tokenMetadata,\n                decorationStyleSetId,\n                rasterizedGlyph,\n                glyph\n            });\n        }\n        return glyph;\n    }\n    getUsagePreview() {\n        return this._allocator.getUsagePreview();\n    }\n    getStats() {\n        return this._allocator.getStats();\n    }\n};\nTextureAtlasPage = TextureAtlasPage_1 = __decorate([\n    __param(3, ILogService),\n    __param(4, IThemeService)\n], TextureAtlasPage);\n\nexport { TextureAtlasPage };\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1118, "column": 0}, "map": {"version":3,"sources":["file:///D:/real-time-code-editor%20%282%29/node_modules/.pnpm/monaco-editor%400.55.1/node_modules/monaco-editor/esm/vs/editor/browser/gpu/atlas/textureAtlas.js"],"sourcesContent":["import { getActiveWindow } from '../../../../base/browser/dom.js';\nimport { BugIndicatingError } from '../../../../base/common/errors.js';\nimport { Emitter, Event } from '../../../../base/common/event.js';\nimport { Disposable, MutableDisposable, toDisposable, dispose } from '../../../../base/common/lifecycle.js';\nimport { NKeyMap } from '../../../../base/common/map.js';\nimport { IInstantiationService } from '../../../../platform/instantiation/common/instantiation.js';\nimport { IThemeService } from '../../../../platform/theme/common/themeService.js';\nimport { GlyphRasterizer } from '../raster/glyphRasterizer.js';\nimport { IdleTaskQueue } from '../taskQueue.js';\nimport { TextureAtlasPage } from './textureAtlasPage.js';\n\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (undefined && undefined.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nvar TextureAtlas_1;\nlet TextureAtlas = class TextureAtlas extends Disposable {\n    static { TextureAtlas_1 = this; }\n    /**\n     * The maximum number of texture atlas pages. This is currently a hard static cap that must not\n     * be reached.\n     */\n    static { this.maximumPageCount = 16; }\n    get pages() { return this._pages; }\n    constructor(\n    /** The maximum texture size supported by the GPU. */\n    _maxTextureSize, options, _decorationStyleCache, _themeService, _instantiationService) {\n        super();\n        this._maxTextureSize = _maxTextureSize;\n        this._decorationStyleCache = _decorationStyleCache;\n        this._themeService = _themeService;\n        this._instantiationService = _instantiationService;\n        this._warmUpTask = this._register(new MutableDisposable());\n        this._warmedUpRasterizers = new Set();\n        /**\n         * The main texture atlas pages which are both larger textures and more efficiently packed\n         * relative to the scratch page. The idea is the main pages are drawn to and uploaded to the GPU\n         * much less frequently so as to not drop frames.\n         */\n        this._pages = [];\n        /**\n         * A maps of glyph keys to the page to start searching for the glyph. This is set before\n         * searching to have as little runtime overhead (branching, intermediate variables) as possible,\n         * so it is not guaranteed to be the actual page the glyph is on. But it is guaranteed that all\n         * pages with a lower index do not contain the glyph.\n         */\n        this._glyphPageIndex = new NKeyMap();\n        this._onDidDeleteGlyphs = this._register(new Emitter());\n        this.onDidDeleteGlyphs = this._onDidDeleteGlyphs.event;\n        this._allocatorType = options?.allocatorType ?? 'slab';\n        this._register(Event.runAndSubscribe(this._themeService.onDidColorThemeChange, () => {\n            if (this._colorMap) {\n                this.clear();\n            }\n            this._colorMap = this._themeService.getColorTheme().tokenColorMap;\n        }));\n        const dprFactor = Math.max(1, Math.floor(getActiveWindow().devicePixelRatio));\n        this.pageSize = Math.min(1024 * dprFactor, this._maxTextureSize);\n        this._initFirstPage();\n        this._register(toDisposable(() => dispose(this._pages)));\n    }\n    _initFirstPage() {\n        const firstPage = this._instantiationService.createInstance(TextureAtlasPage, 0, this.pageSize, this._allocatorType);\n        this._pages.push(firstPage);\n        // IMPORTANT: The first glyph on the first page must be an empty glyph such that zeroed out\n        // cells end up rendering nothing\n        // TODO: This currently means the first slab is for 0x0 glyphs and is wasted\n        const nullRasterizer = new GlyphRasterizer(1, '', 1, this._decorationStyleCache);\n        firstPage.getGlyph(nullRasterizer, '', 0, 0);\n        nullRasterizer.dispose();\n    }\n    clear() {\n        // Clear all pages\n        for (const page of this._pages) {\n            page.dispose();\n        }\n        this._pages.length = 0;\n        this._glyphPageIndex.clear();\n        this._warmedUpRasterizers.clear();\n        this._warmUpTask.clear();\n        // Recreate first\n        this._initFirstPage();\n        // Tell listeners\n        this._onDidDeleteGlyphs.fire();\n    }\n    getGlyph(rasterizer, chars, tokenMetadata, decorationStyleSetId, x) {\n        // TODO: Encode font size and family into key\n        // Ignore metadata that doesn't affect the glyph\n        tokenMetadata &= -2048;\n        // Add x offset for sub-pixel rendering to the unused portion or tokenMetadata. This\n        // converts the decimal part of the x to a range from 0 to 9, where 0 = 0.0px x offset,\n        // 9 = 0.9px x offset\n        tokenMetadata |= Math.floor((x % 1) * 10);\n        // Warm up common glyphs\n        if (!this._warmedUpRasterizers.has(rasterizer.id)) {\n            this._warmUpAtlas(rasterizer);\n            this._warmedUpRasterizers.add(rasterizer.id);\n        }\n        // Try get the glyph, overflowing to a new page if necessary\n        return this._tryGetGlyph(this._glyphPageIndex.get(chars, tokenMetadata, decorationStyleSetId, rasterizer.cacheKey) ?? 0, rasterizer, chars, tokenMetadata, decorationStyleSetId);\n    }\n    _tryGetGlyph(pageIndex, rasterizer, chars, tokenMetadata, decorationStyleSetId) {\n        this._glyphPageIndex.set(pageIndex, chars, tokenMetadata, decorationStyleSetId, rasterizer.cacheKey);\n        return (this._pages[pageIndex].getGlyph(rasterizer, chars, tokenMetadata, decorationStyleSetId)\n            ?? (pageIndex + 1 < this._pages.length\n                ? this._tryGetGlyph(pageIndex + 1, rasterizer, chars, tokenMetadata, decorationStyleSetId)\n                : undefined)\n            ?? this._getGlyphFromNewPage(rasterizer, chars, tokenMetadata, decorationStyleSetId));\n    }\n    _getGlyphFromNewPage(rasterizer, chars, tokenMetadata, decorationStyleSetId) {\n        if (this._pages.length >= TextureAtlas_1.maximumPageCount) {\n            throw new Error(`Attempt to create a texture atlas page past the limit ${TextureAtlas_1.maximumPageCount}`);\n        }\n        this._pages.push(this._instantiationService.createInstance(TextureAtlasPage, this._pages.length, this.pageSize, this._allocatorType));\n        this._glyphPageIndex.set(this._pages.length - 1, chars, tokenMetadata, decorationStyleSetId, rasterizer.cacheKey);\n        return this._pages[this._pages.length - 1].getGlyph(rasterizer, chars, tokenMetadata, decorationStyleSetId);\n    }\n    getStats() {\n        return this._pages.map(e => e.getStats());\n    }\n    /**\n     * Warms up the atlas by rasterizing all printable ASCII characters for each token color. This\n     * is distrubuted over multiple idle callbacks to avoid blocking the main thread.\n     */\n    _warmUpAtlas(rasterizer) {\n        const colorMap = this._colorMap;\n        if (!colorMap) {\n            throw new BugIndicatingError('Cannot warm atlas without color map');\n        }\n        this._warmUpTask.value?.clear();\n        const taskQueue = this._warmUpTask.value = this._instantiationService.createInstance(IdleTaskQueue);\n        // Warm up using roughly the larger glyphs first to help optimize atlas allocation\n        // A-Z\n        for (let code = 65 /* CharCode.A */; code <= 90 /* CharCode.Z */; code++) {\n            for (const fgColor of colorMap.keys()) {\n                taskQueue.enqueue(() => {\n                    for (let x = 0; x < 1; x += 0.1) {\n                        this.getGlyph(rasterizer, String.fromCharCode(code), (fgColor << 15 /* MetadataConsts.FOREGROUND_OFFSET */) & 16744448 /* MetadataConsts.FOREGROUND_MASK */, 0, x);\n                    }\n                });\n            }\n        }\n        // a-z\n        for (let code = 97 /* CharCode.a */; code <= 122 /* CharCode.z */; code++) {\n            for (const fgColor of colorMap.keys()) {\n                taskQueue.enqueue(() => {\n                    for (let x = 0; x < 1; x += 0.1) {\n                        this.getGlyph(rasterizer, String.fromCharCode(code), (fgColor << 15 /* MetadataConsts.FOREGROUND_OFFSET */) & 16744448 /* MetadataConsts.FOREGROUND_MASK */, 0, x);\n                    }\n                });\n            }\n        }\n        // Remaining ascii\n        for (let code = 33 /* CharCode.ExclamationMark */; code <= 126 /* CharCode.Tilde */; code++) {\n            for (const fgColor of colorMap.keys()) {\n                taskQueue.enqueue(() => {\n                    for (let x = 0; x < 1; x += 0.1) {\n                        this.getGlyph(rasterizer, String.fromCharCode(code), (fgColor << 15 /* MetadataConsts.FOREGROUND_OFFSET */) & 16744448 /* MetadataConsts.FOREGROUND_MASK */, 0, x);\n                    }\n                });\n            }\n        }\n    }\n};\nTextureAtlas = TextureAtlas_1 = __decorate([\n    __param(3, IThemeService),\n    __param(4, IInstantiationService)\n], TextureAtlas);\n\nexport { TextureAtlas };\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1310, "column": 0}, "map": {"version":3,"sources":["file:///D:/real-time-code-editor%20%282%29/node_modules/.pnpm/monaco-editor%400.55.1/node_modules/monaco-editor/esm/vs/editor/browser/gpu/gpuDisposable.js"],"sourcesContent":["import { isFunction } from '../../../base/common/types.js';\n\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar GPULifecycle;\n(function (GPULifecycle) {\n    async function requestDevice(fallback) {\n        try {\n            if (!navigator.gpu) {\n                throw new Error('This browser does not support WebGPU');\n            }\n            const adapter = (await navigator.gpu.requestAdapter());\n            if (!adapter) {\n                throw new Error('This browser supports WebGPU but it appears to be disabled');\n            }\n            return wrapDestroyableInDisposable(await adapter.requestDevice());\n        }\n        catch (e) {\n            if (fallback) {\n                fallback(e.message);\n            }\n            throw e;\n        }\n    }\n    GPULifecycle.requestDevice = requestDevice;\n    function createBuffer(device, descriptor, initialValues) {\n        const buffer = device.createBuffer(descriptor);\n        if (initialValues) {\n            device.queue.writeBuffer(buffer, 0, (isFunction(initialValues) ? initialValues() : initialValues));\n        }\n        return wrapDestroyableInDisposable(buffer);\n    }\n    GPULifecycle.createBuffer = createBuffer;\n    function createTexture(device, descriptor) {\n        return wrapDestroyableInDisposable(device.createTexture(descriptor));\n    }\n    GPULifecycle.createTexture = createTexture;\n})(GPULifecycle || (GPULifecycle = {}));\nfunction wrapDestroyableInDisposable(value) {\n    return {\n        object: value,\n        dispose: () => value.destroy()\n    };\n}\n\nexport { GPULifecycle };\n"],"names":[],"mappings":";;;;AAAA;;AAEA;;;8FAG8F,GAC9F,IAAI;AACJ,CAAC,SAAU,YAAY;IACnB,eAAe,cAAc,QAAQ;QACjC,IAAI;YACA,IAAI,CAAC,UAAU,GAAG,EAAE;gBAChB,MAAM,IAAI,MAAM;YACpB;YACA,MAAM,UAAW,MAAM,UAAU,GAAG,CAAC,cAAc;YACnD,IAAI,CAAC,SAAS;gBACV,MAAM,IAAI,MAAM;YACpB;YACA,OAAO,4BAA4B,MAAM,QAAQ,aAAa;QAClE,EACA,OAAO,GAAG;YACN,IAAI,UAAU;gBACV,SAAS,EAAE,OAAO;YACtB;YACA,MAAM;QACV;IACJ;IACA,aAAa,aAAa,GAAG;IAC7B,SAAS,aAAa,MAAM,EAAE,UAAU,EAAE,aAAa;QACnD,MAAM,SAAS,OAAO,YAAY,CAAC;QACnC,IAAI,eAAe;YACf,OAAO,KAAK,CAAC,WAAW,CAAC,QAAQ,GAAI,IAAA,uPAAU,EAAC,iBAAiB,kBAAkB;QACvF;QACA,OAAO,4BAA4B;IACvC;IACA,aAAa,YAAY,GAAG;IAC5B,SAAS,cAAc,MAAM,EAAE,UAAU;QACrC,OAAO,4BAA4B,OAAO,aAAa,CAAC;IAC5D;IACA,aAAa,aAAa,GAAG;AACjC,CAAC,EAAE,gBAAgB,CAAC,eAAe,CAAC,CAAC;AACrC,SAAS,4BAA4B,KAAK;IACtC,OAAO;QACH,QAAQ;QACR,SAAS,IAAM,MAAM,OAAO;IAChC;AACJ","ignoreList":[0]}},
    {"offset": {"line": 1363, "column": 0}, "map": {"version":3,"sources":["file:///D:/real-time-code-editor%20%282%29/node_modules/.pnpm/monaco-editor%400.55.1/node_modules/monaco-editor/esm/vs/editor/browser/gpu/bufferDirtyTracker.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n/**\n * A simple tracker for dirty regions in a buffer.\n */\nclass BufferDirtyTracker {\n    get dataOffset() {\n        return this._startIndex;\n    }\n    get dirtySize() {\n        if (this._startIndex === undefined || this._endIndex === undefined) {\n            return undefined;\n        }\n        return this._endIndex - this._startIndex + 1;\n    }\n    get isDirty() { return this._startIndex !== undefined; }\n    /**\n     * Flag the index(es) as modified. Returns the index flagged.\n     * @param index An index to flag.\n     * @param length An optional length to flag. Defaults to 1.\n     */\n    flag(index, length = 1) {\n        this._flag(index);\n        if (length > 1) {\n            this._flag(index + length - 1);\n        }\n        return index;\n    }\n    _flag(index) {\n        if (this._startIndex === undefined || index < this._startIndex) {\n            this._startIndex = index;\n        }\n        if (this._endIndex === undefined || index > this._endIndex) {\n            this._endIndex = index;\n        }\n    }\n    clear() {\n        this._startIndex = undefined;\n        this._endIndex = undefined;\n    }\n}\n\nexport { BufferDirtyTracker };\n"],"names":[],"mappings":"AAAA;;;8FAG8F,GAC9F;;CAEC;;;;AACD,MAAM;IACF,IAAI,aAAa;QACb,OAAO,IAAI,CAAC,WAAW;IAC3B;IACA,IAAI,YAAY;QACZ,IAAI,IAAI,CAAC,WAAW,KAAK,aAAa,IAAI,CAAC,SAAS,KAAK,WAAW;YAChE,OAAO;QACX;QACA,OAAO,IAAI,CAAC,SAAS,GAAG,IAAI,CAAC,WAAW,GAAG;IAC/C;IACA,IAAI,UAAU;QAAE,OAAO,IAAI,CAAC,WAAW,KAAK;IAAW;IACvD;;;;KAIC,GACD,KAAK,KAAK,EAAE,SAAS,CAAC,EAAE;QACpB,IAAI,CAAC,KAAK,CAAC;QACX,IAAI,SAAS,GAAG;YACZ,IAAI,CAAC,KAAK,CAAC,QAAQ,SAAS;QAChC;QACA,OAAO;IACX;IACA,MAAM,KAAK,EAAE;QACT,IAAI,IAAI,CAAC,WAAW,KAAK,aAAa,QAAQ,IAAI,CAAC,WAAW,EAAE;YAC5D,IAAI,CAAC,WAAW,GAAG;QACvB;QACA,IAAI,IAAI,CAAC,SAAS,KAAK,aAAa,QAAQ,IAAI,CAAC,SAAS,EAAE;YACxD,IAAI,CAAC,SAAS,GAAG;QACrB;IACJ;IACA,QAAQ;QACJ,IAAI,CAAC,WAAW,GAAG;QACnB,IAAI,CAAC,SAAS,GAAG;IACrB;AACJ","ignoreList":[0]}},
    {"offset": {"line": 1414, "column": 0}, "map": {"version":3,"sources":["file:///D:/real-time-code-editor%20%282%29/node_modules/.pnpm/monaco-editor%400.55.1/node_modules/monaco-editor/esm/vs/editor/browser/gpu/objectCollectionBuffer.js"],"sourcesContent":["import { Emitter, Event } from '../../../base/common/event.js';\nimport { Disposable, toDisposable, dispose } from '../../../base/common/lifecycle.js';\nimport { LinkedList } from '../../../base/common/linkedList.js';\nimport { BufferDirtyTracker } from './bufferDirtyTracker.js';\n\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nfunction createObjectCollectionBuffer(propertySpecs, capacity) {\n    return new ObjectCollectionBuffer(propertySpecs, capacity);\n}\nclass ObjectCollectionBuffer extends Disposable {\n    get entryCount() {\n        return this._entries.size;\n    }\n    get dirtyTracker() { return this._dirtyTracker; }\n    constructor(propertySpecs, capacity) {\n        super();\n        this.propertySpecs = propertySpecs;\n        this.capacity = capacity;\n        this._dirtyTracker = new BufferDirtyTracker();\n        this._propertySpecsMap = new Map();\n        this._entries = new LinkedList();\n        this._onDidChange = this._register(new Emitter());\n        this._onDidChangeBuffer = this._register(new Emitter());\n        this.onDidChangeBuffer = this._onDidChangeBuffer.event;\n        this.view = new Float32Array(capacity * propertySpecs.length);\n        this.buffer = this.view.buffer;\n        this._entrySize = propertySpecs.length;\n        for (let i = 0; i < propertySpecs.length; i++) {\n            const spec = {\n                offset: i,\n                ...propertySpecs[i]\n            };\n            this._propertySpecsMap.set(spec.name, spec);\n        }\n        this._register(toDisposable(() => dispose(this._entries)));\n    }\n    createEntry(data) {\n        if (this._entries.size === this.capacity) {\n            this._expandBuffer();\n            this._onDidChangeBuffer.fire();\n        }\n        const value = new ObjectCollectionBufferEntry(this.view, this._propertySpecsMap, this._dirtyTracker, this._entries.size, data);\n        const removeFromEntries = this._entries.push(value);\n        const listeners = [];\n        listeners.push(Event.forward(value.onDidChange, this._onDidChange));\n        listeners.push(value.onWillDispose(() => {\n            const deletedEntryIndex = value.i;\n            removeFromEntries();\n            // Shift all entries after the deleted entry to the left\n            this.view.set(this.view.subarray(deletedEntryIndex * this._entrySize + 2, this._entries.size * this._entrySize + 2), deletedEntryIndex * this._entrySize);\n            // Update entries to reflect the new i\n            for (const entry of this._entries) {\n                if (entry.i > deletedEntryIndex) {\n                    entry.i--;\n                }\n            }\n            this._dirtyTracker.flag(deletedEntryIndex, (this._entries.size - deletedEntryIndex) * this._entrySize);\n            dispose(listeners);\n        }));\n        return value;\n    }\n    _expandBuffer() {\n        this.capacity *= 2;\n        const newView = new Float32Array(this.capacity * this._entrySize);\n        newView.set(this.view);\n        this.view = newView;\n        this.buffer = this.view.buffer;\n    }\n}\nclass ObjectCollectionBufferEntry extends Disposable {\n    constructor(_view, _propertySpecsMap, _dirtyTracker, i, data) {\n        super();\n        this._view = _view;\n        this._propertySpecsMap = _propertySpecsMap;\n        this._dirtyTracker = _dirtyTracker;\n        this.i = i;\n        this._onDidChange = this._register(new Emitter());\n        this.onDidChange = this._onDidChange.event;\n        this._onWillDispose = this._register(new Emitter());\n        this.onWillDispose = this._onWillDispose.event;\n        for (const propertySpec of this._propertySpecsMap.values()) {\n            this._view[this.i * this._propertySpecsMap.size + propertySpec.offset] = data[propertySpec.name];\n        }\n        this._dirtyTracker.flag(this.i * this._propertySpecsMap.size, this._propertySpecsMap.size);\n    }\n    dispose() {\n        this._onWillDispose.fire();\n        super.dispose();\n    }\n    setRaw(data) {\n        if (data.length !== this._propertySpecsMap.size) {\n            throw new Error(`Data length ${data.length} does not match the number of properties in the collection (${this._propertySpecsMap.size})`);\n        }\n        this._view.set(data, this.i * this._propertySpecsMap.size);\n        this._dirtyTracker.flag(this.i * this._propertySpecsMap.size, this._propertySpecsMap.size);\n    }\n}\n\nexport { createObjectCollectionBuffer };\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1527, "column": 0}, "map": {"version":3,"sources":["file:///D:/real-time-code-editor%20%282%29/node_modules/.pnpm/monaco-editor%400.55.1/node_modules/monaco-editor/esm/vs/editor/browser/gpu/rectangleRenderer.wgsl.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nconst rectangleRendererWgsl = /*wgsl*/ `\n\nstruct Vertex {\n\t@location(0) position: vec2f,\n};\n\nstruct LayoutInfo {\n\tcanvasDims: vec2f,\n\tviewportOffset: vec2f,\n\tviewportDims: vec2f,\n}\n\nstruct ScrollOffset {\n\toffset: vec2f,\n}\n\nstruct Shape {\n\tposition: vec2f,\n\tsize: vec2f,\n\tcolor: vec4f,\n};\n\nstruct VSOutput {\n\t@builtin(position) position: vec4f,\n\t@location(1)       color:    vec4f,\n};\n\n// Uniforms\n@group(0) @binding(${1 /* RectangleRendererBindingId.LayoutInfoUniform */}) var<uniform>       layoutInfo:      LayoutInfo;\n\n// Storage buffers\n@group(0) @binding(${0 /* RectangleRendererBindingId.Shapes */})            var<storage, read> shapes:          array<Shape>;\n@group(0) @binding(${2 /* RectangleRendererBindingId.ScrollOffset */})      var<uniform>       scrollOffset:    ScrollOffset;\n\n@vertex fn vs(\n\tvert: Vertex,\n\t@builtin(instance_index) instanceIndex: u32,\n\t@builtin(vertex_index) vertexIndex : u32\n) -> VSOutput {\n\tlet shape = shapes[instanceIndex];\n\n\tvar vsOut: VSOutput;\n\tvsOut.position = vec4f(\n\t\t(\n\t\t\t// Top left corner\n\t\t\tvec2f(-1,  1) +\n\t\t\t// Convert pixel position to clipspace\n\t\t\tvec2f( 2, -2) / layoutInfo.canvasDims *\n\t\t\t// Shape position and size\n\t\t\t(layoutInfo.viewportOffset - scrollOffset.offset + shape.position + vert.position * shape.size)\n\t\t),\n\t\t0.0,\n\t\t1.0\n\t);\n\tvsOut.color = shape.color;\n\treturn vsOut;\n}\n\n@fragment fn fs(vsOut: VSOutput) -> @location(0) vec4f {\n\treturn vsOut.color;\n}\n`;\n\nexport { rectangleRendererWgsl };\n"],"names":[],"mappings":"AAAA;;;8FAG8F;;;;AAC9F,MAAM,wBAAwB,MAAM,GAAG,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;mBA4BrB,EAAE,EAAE,gDAAgD,IAAG;;;mBAGvD,EAAE,EAAE,qCAAqC,IAAG;mBAC5C,EAAE,EAAE,2CAA2C,IAAG;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA6BrE,CAAC","ignoreList":[0]}},
    {"offset": {"line": 1601, "column": 0}, "map": {"version":3,"sources":["file:///D:/real-time-code-editor%20%282%29/node_modules/.pnpm/monaco-editor%400.55.1/node_modules/monaco-editor/esm/vs/editor/browser/gpu/rectangleRenderer.js"],"sourcesContent":["import { getActiveWindow } from '../../../base/browser/dom.js';\nimport { Event } from '../../../base/common/event.js';\nimport { MutableDisposable } from '../../../base/common/lifecycle.js';\nimport { ViewEventHandler } from '../../common/viewEventHandler.js';\nimport { GPULifecycle } from './gpuDisposable.js';\nimport { observeDevicePixelDimensions, quadVertices } from './gpuUtils.js';\nimport { createObjectCollectionBuffer } from './objectCollectionBuffer.js';\nimport { rectangleRendererWgsl } from './rectangleRenderer.wgsl.js';\n\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nclass RectangleRenderer extends ViewEventHandler {\n    constructor(_context, _contentLeft, _devicePixelRatio, _canvas, _ctx, device) {\n        super();\n        this._context = _context;\n        this._contentLeft = _contentLeft;\n        this._devicePixelRatio = _devicePixelRatio;\n        this._canvas = _canvas;\n        this._ctx = _ctx;\n        this._shapeBindBuffer = this._register(new MutableDisposable());\n        this._initialized = false;\n        this._shapeCollection = this._register(createObjectCollectionBuffer([\n            { name: 'x' },\n            { name: 'y' },\n            { name: 'width' },\n            { name: 'height' },\n            { name: 'red' },\n            { name: 'green' },\n            { name: 'blue' },\n            { name: 'alpha' },\n        ], 32));\n        this._context.addEventHandler(this);\n        this._initWebgpu(device);\n    }\n    async _initWebgpu(device) {\n        // #region General\n        this._device = await device;\n        if (this._store.isDisposed) {\n            return;\n        }\n        const presentationFormat = navigator.gpu.getPreferredCanvasFormat();\n        this._ctx.configure({\n            device: this._device,\n            format: presentationFormat,\n            alphaMode: 'premultiplied',\n        });\n        this._renderPassColorAttachment = {\n            view: null, // Will be filled at render time\n            loadOp: 'load',\n            storeOp: 'store',\n        };\n        this._renderPassDescriptor = {\n            label: 'Monaco rectangle renderer render pass',\n            colorAttachments: [this._renderPassColorAttachment],\n        };\n        // #endregion General\n        // #region Uniforms\n        let layoutInfoUniformBuffer;\n        {\n            const bufferValues = new Float32Array(6 /* Info.FloatsPerEntry */);\n            const updateBufferValues = (canvasDevicePixelWidth = this._canvas.width, canvasDevicePixelHeight = this._canvas.height) => {\n                bufferValues[0 /* Info.Offset_CanvasWidth____ */] = canvasDevicePixelWidth;\n                bufferValues[1 /* Info.Offset_CanvasHeight___ */] = canvasDevicePixelHeight;\n                bufferValues[2 /* Info.Offset_ViewportOffsetX */] = Math.ceil(this._context.configuration.options.get(165 /* EditorOption.layoutInfo */).contentLeft * getActiveWindow().devicePixelRatio);\n                bufferValues[3 /* Info.Offset_ViewportOffsetY */] = 0;\n                bufferValues[4 /* Info.Offset_ViewportWidth__ */] = bufferValues[0 /* Info.Offset_CanvasWidth____ */] - bufferValues[2 /* Info.Offset_ViewportOffsetX */];\n                bufferValues[5 /* Info.Offset_ViewportHeight_ */] = bufferValues[1 /* Info.Offset_CanvasHeight___ */] - bufferValues[3 /* Info.Offset_ViewportOffsetY */];\n                return bufferValues;\n            };\n            layoutInfoUniformBuffer = this._register(GPULifecycle.createBuffer(this._device, {\n                label: 'Monaco rectangle renderer uniform buffer',\n                size: 24 /* Info.BytesPerEntry */,\n                usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,\n            }, () => updateBufferValues())).object;\n            this._register(observeDevicePixelDimensions(this._canvas, getActiveWindow(), (w, h) => {\n                this._device.queue.writeBuffer(layoutInfoUniformBuffer, 0, updateBufferValues(w, h));\n            }));\n        }\n        const scrollOffsetBufferSize = 2;\n        this._scrollOffsetBindBuffer = this._register(GPULifecycle.createBuffer(this._device, {\n            label: 'Monaco rectangle renderer scroll offset buffer',\n            size: scrollOffsetBufferSize * Float32Array.BYTES_PER_ELEMENT,\n            usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,\n        })).object;\n        this._scrollOffsetValueBuffer = new Float32Array(scrollOffsetBufferSize);\n        // #endregion Uniforms\n        // #region Storage buffers\n        const createShapeBindBuffer = () => {\n            return GPULifecycle.createBuffer(this._device, {\n                label: 'Monaco rectangle renderer shape buffer',\n                size: this._shapeCollection.buffer.byteLength,\n                usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,\n            });\n        };\n        this._shapeBindBuffer.value = createShapeBindBuffer();\n        this._register(Event.runAndSubscribe(this._shapeCollection.onDidChangeBuffer, () => {\n            this._shapeBindBuffer.value = createShapeBindBuffer();\n            if (this._pipeline) {\n                this._updateBindGroup(this._pipeline, layoutInfoUniformBuffer);\n            }\n        }));\n        // #endregion Storage buffers\n        // #region Vertex buffer\n        this._vertexBuffer = this._register(GPULifecycle.createBuffer(this._device, {\n            label: 'Monaco rectangle renderer vertex buffer',\n            size: quadVertices.byteLength,\n            usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,\n        }, quadVertices)).object;\n        // #endregion Vertex buffer\n        // #region Shader module\n        const module = this._device.createShaderModule({\n            label: 'Monaco rectangle renderer shader module',\n            code: rectangleRendererWgsl,\n        });\n        // #endregion Shader module\n        // #region Pipeline\n        this._pipeline = this._device.createRenderPipeline({\n            label: 'Monaco rectangle renderer render pipeline',\n            layout: 'auto',\n            vertex: {\n                module,\n                buffers: [\n                    {\n                        arrayStride: 2 * Float32Array.BYTES_PER_ELEMENT, // 2 floats, 4 bytes each\n                        attributes: [\n                            { shaderLocation: 0, offset: 0, format: 'float32x2' }, // position\n                        ],\n                    }\n                ]\n            },\n            fragment: {\n                module,\n                targets: [\n                    {\n                        format: presentationFormat,\n                        blend: {\n                            color: {\n                                srcFactor: 'src-alpha',\n                                dstFactor: 'one-minus-src-alpha'\n                            },\n                            alpha: {\n                                srcFactor: 'src-alpha',\n                                dstFactor: 'one-minus-src-alpha'\n                            },\n                        },\n                    }\n                ],\n            },\n        });\n        // #endregion Pipeline\n        // #region Bind group\n        this._updateBindGroup(this._pipeline, layoutInfoUniformBuffer);\n        // endregion Bind group\n        this._initialized = true;\n    }\n    _updateBindGroup(pipeline, layoutInfoUniformBuffer) {\n        this._bindGroup = this._device.createBindGroup({\n            label: 'Monaco rectangle renderer bind group',\n            layout: pipeline.getBindGroupLayout(0),\n            entries: [\n                { binding: 0 /* RectangleRendererBindingId.Shapes */, resource: { buffer: this._shapeBindBuffer.value.object } },\n                { binding: 1 /* RectangleRendererBindingId.LayoutInfoUniform */, resource: { buffer: layoutInfoUniformBuffer } },\n                { binding: 2 /* RectangleRendererBindingId.ScrollOffset */, resource: { buffer: this._scrollOffsetBindBuffer } },\n            ],\n        });\n    }\n    register(x, y, width, height, red, green, blue, alpha) {\n        return this._shapeCollection.createEntry({ x, y, width, height, red, green, blue, alpha });\n    }\n    // #region Event handlers\n    onScrollChanged(e) {\n        if (this._device) {\n            const dpr = getActiveWindow().devicePixelRatio;\n            this._scrollOffsetValueBuffer[0] = this._context.viewLayout.getCurrentScrollLeft() * dpr;\n            this._scrollOffsetValueBuffer[1] = this._context.viewLayout.getCurrentScrollTop() * dpr;\n            this._device.queue.writeBuffer(this._scrollOffsetBindBuffer, 0, this._scrollOffsetValueBuffer);\n        }\n        return true;\n    }\n    // #endregion\n    _update() {\n        if (!this._device) {\n            return;\n        }\n        const shapes = this._shapeCollection;\n        if (shapes.dirtyTracker.isDirty) {\n            this._device.queue.writeBuffer(this._shapeBindBuffer.value.object, 0, shapes.buffer, shapes.dirtyTracker.dataOffset, shapes.dirtyTracker.dirtySize * shapes.view.BYTES_PER_ELEMENT);\n            shapes.dirtyTracker.clear();\n        }\n    }\n    draw(viewportData) {\n        if (!this._initialized) {\n            return;\n        }\n        this._update();\n        const encoder = this._device.createCommandEncoder({ label: 'Monaco rectangle renderer command encoder' });\n        this._renderPassColorAttachment.view = this._ctx.getCurrentTexture().createView();\n        const pass = encoder.beginRenderPass(this._renderPassDescriptor);\n        pass.setPipeline(this._pipeline);\n        pass.setVertexBuffer(0, this._vertexBuffer);\n        pass.setBindGroup(0, this._bindGroup);\n        // Only draw the content area\n        const contentLeft = Math.ceil(this._contentLeft.get() * this._devicePixelRatio.get());\n        pass.setScissorRect(contentLeft, 0, this._canvas.width - contentLeft, this._canvas.height);\n        pass.draw(quadVertices.length / 2, this._shapeCollection.entryCount);\n        pass.end();\n        const commandBuffer = encoder.finish();\n        this._device.queue.submit([commandBuffer]);\n    }\n}\n\nexport { RectangleRenderer };\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1878, "column": 0}, "map": {"version":3,"sources":["file:///D:/real-time-code-editor%20%282%29/node_modules/.pnpm/monaco-editor%400.55.1/node_modules/monaco-editor/esm/vs/editor/browser/gpu/css/decorationCssRuleExtractor.js"],"sourcesContent":["import { $, getActiveDocument } from '../../../../base/browser/dom.js';\nimport { Disposable, toDisposable } from '../../../../base/common/lifecycle.js';\nimport './media/decorationCssRuleExtractor.css';\n\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n/**\n * Extracts CSS rules that would be applied to certain decoration classes.\n */\nclass DecorationCssRuleExtractor extends Disposable {\n    constructor() {\n        super();\n        this._ruleCache = new Map();\n        this._container = $('div.monaco-decoration-css-rule-extractor');\n        this._dummyElement = $('span');\n        this._container.appendChild(this._dummyElement);\n        this._register(toDisposable(() => this._container.remove()));\n    }\n    getStyleRules(canvas, decorationClassName) {\n        // Check cache\n        const existing = this._ruleCache.get(decorationClassName);\n        if (existing) {\n            return existing;\n        }\n        // Set up DOM\n        this._dummyElement.className = decorationClassName;\n        canvas.appendChild(this._container);\n        // Get rules\n        const rules = this._getStyleRules(decorationClassName);\n        this._ruleCache.set(decorationClassName, rules);\n        // Tear down DOM\n        canvas.removeChild(this._container);\n        return rules;\n    }\n    _getStyleRules(className) {\n        // Iterate through all stylesheets and imported stylesheets to find matching rules\n        const rules = [];\n        const doc = getActiveDocument();\n        const stylesheets = [...doc.styleSheets];\n        for (let i = 0; i < stylesheets.length; i++) {\n            const stylesheet = stylesheets[i];\n            for (const rule of stylesheet.cssRules) {\n                if (rule instanceof CSSImportRule) {\n                    if (rule.styleSheet) {\n                        stylesheets.push(rule.styleSheet);\n                    }\n                }\n                else if (rule instanceof CSSStyleRule) {\n                    // Note that originally `.matches(rule.selectorText)` was used but this would\n                    // not pick up pseudo-classes which are important to determine support of the\n                    // returned styles.\n                    //\n                    // Since a selector could contain a class name lookup that is simple a prefix of\n                    // the class name we are looking for, we need to also check the character after\n                    // it.\n                    const searchTerm = `.${className}`;\n                    const index = rule.selectorText.indexOf(searchTerm);\n                    if (index !== -1) {\n                        const endOfResult = index + searchTerm.length;\n                        if (rule.selectorText.length === endOfResult || rule.selectorText.substring(endOfResult, endOfResult + 1).match(/[ :]/)) {\n                            rules.push(rule);\n                        }\n                    }\n                }\n            }\n        }\n        return rules;\n    }\n}\n\nexport { DecorationCssRuleExtractor };\n"],"names":[],"mappings":";;;;AAAA;AACA;;;;AAGA;;;8FAG8F,GAC9F;;CAEC,GACD,MAAM,mCAAmC,2PAAU;IAC/C,aAAc;QACV,KAAK;QACL,IAAI,CAAC,UAAU,GAAG,IAAI;QACtB,IAAI,CAAC,UAAU,GAAG,IAAA,6OAAC,EAAC;QACpB,IAAI,CAAC,aAAa,GAAG,IAAA,6OAAC,EAAC;QACvB,IAAI,CAAC,UAAU,CAAC,WAAW,CAAC,IAAI,CAAC,aAAa;QAC9C,IAAI,CAAC,SAAS,CAAC,IAAA,6PAAY,EAAC,IAAM,IAAI,CAAC,UAAU,CAAC,MAAM;IAC5D;IACA,cAAc,MAAM,EAAE,mBAAmB,EAAE;QACvC,cAAc;QACd,MAAM,WAAW,IAAI,CAAC,UAAU,CAAC,GAAG,CAAC;QACrC,IAAI,UAAU;YACV,OAAO;QACX;QACA,aAAa;QACb,IAAI,CAAC,aAAa,CAAC,SAAS,GAAG;QAC/B,OAAO,WAAW,CAAC,IAAI,CAAC,UAAU;QAClC,YAAY;QACZ,MAAM,QAAQ,IAAI,CAAC,cAAc,CAAC;QAClC,IAAI,CAAC,UAAU,CAAC,GAAG,CAAC,qBAAqB;QACzC,gBAAgB;QAChB,OAAO,WAAW,CAAC,IAAI,CAAC,UAAU;QAClC,OAAO;IACX;IACA,eAAe,SAAS,EAAE;QACtB,kFAAkF;QAClF,MAAM,QAAQ,EAAE;QAChB,MAAM,MAAM,IAAA,6PAAiB;QAC7B,MAAM,cAAc;eAAI,IAAI,WAAW;SAAC;QACxC,IAAK,IAAI,IAAI,GAAG,IAAI,YAAY,MAAM,EAAE,IAAK;YACzC,MAAM,aAAa,WAAW,CAAC,EAAE;YACjC,KAAK,MAAM,QAAQ,WAAW,QAAQ,CAAE;gBACpC,IAAI,gBAAgB,eAAe;oBAC/B,IAAI,KAAK,UAAU,EAAE;wBACjB,YAAY,IAAI,CAAC,KAAK,UAAU;oBACpC;gBACJ,OACK,IAAI,gBAAgB,cAAc;oBACnC,6EAA6E;oBAC7E,6EAA6E;oBAC7E,mBAAmB;oBACnB,EAAE;oBACF,gFAAgF;oBAChF,+EAA+E;oBAC/E,MAAM;oBACN,MAAM,aAAa,CAAC,CAAC,EAAE,WAAW;oBAClC,MAAM,QAAQ,KAAK,YAAY,CAAC,OAAO,CAAC;oBACxC,IAAI,UAAU,CAAC,GAAG;wBACd,MAAM,cAAc,QAAQ,WAAW,MAAM;wBAC7C,IAAI,KAAK,YAAY,CAAC,MAAM,KAAK,eAAe,KAAK,YAAY,CAAC,SAAS,CAAC,aAAa,cAAc,GAAG,KAAK,CAAC,SAAS;4BACrH,MAAM,IAAI,CAAC;wBACf;oBACJ;gBACJ;YACJ;QACJ;QACA,OAAO;IACX;AACJ","ignoreList":[0]}},
    {"offset": {"line": 1958, "column": 0}, "map": {"version":3,"sources":["file:///D:/real-time-code-editor%20%282%29/node_modules/.pnpm/monaco-editor%400.55.1/node_modules/monaco-editor/esm/vs/editor/browser/gpu/css/decorationStyleCache.js"],"sourcesContent":["import { NKeyMap } from '../../../../base/common/map.js';\n\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nclass DecorationStyleCache {\n    constructor() {\n        this._nextId = 1;\n        this._cacheById = new Map();\n        this._cacheByStyle = new NKeyMap();\n    }\n    getOrCreateEntry(color, bold, opacity) {\n        if (color === undefined && bold === undefined && opacity === undefined) {\n            return 0;\n        }\n        const result = this._cacheByStyle.get(color ?? 0, bold ? 1 : 0, opacity === undefined ? '' : opacity.toFixed(2));\n        if (result) {\n            return result.id;\n        }\n        const id = this._nextId++;\n        const entry = {\n            id,\n            color,\n            bold,\n            opacity,\n        };\n        this._cacheById.set(id, entry);\n        this._cacheByStyle.set(entry, color ?? 0, bold ? 1 : 0, opacity === undefined ? '' : opacity.toFixed(2));\n        return id;\n    }\n    getStyleSet(id) {\n        if (id === 0) {\n            return undefined;\n        }\n        return this._cacheById.get(id);\n    }\n}\n\nexport { DecorationStyleCache };\n"],"names":[],"mappings":";;;;AAAA;;AAEA;;;8FAG8F,GAC9F,MAAM;IACF,aAAc;QACV,IAAI,CAAC,OAAO,GAAG;QACf,IAAI,CAAC,UAAU,GAAG,IAAI;QACtB,IAAI,CAAC,aAAa,GAAG,IAAI,kPAAO;IACpC;IACA,iBAAiB,KAAK,EAAE,IAAI,EAAE,OAAO,EAAE;QACnC,IAAI,UAAU,aAAa,SAAS,aAAa,YAAY,WAAW;YACpE,OAAO;QACX;QACA,MAAM,SAAS,IAAI,CAAC,aAAa,CAAC,GAAG,CAAC,SAAS,GAAG,OAAO,IAAI,GAAG,YAAY,YAAY,KAAK,QAAQ,OAAO,CAAC;QAC7G,IAAI,QAAQ;YACR,OAAO,OAAO,EAAE;QACpB;QACA,MAAM,KAAK,IAAI,CAAC,OAAO;QACvB,MAAM,QAAQ;YACV;YACA;YACA;YACA;QACJ;QACA,IAAI,CAAC,UAAU,CAAC,GAAG,CAAC,IAAI;QACxB,IAAI,CAAC,aAAa,CAAC,GAAG,CAAC,OAAO,SAAS,GAAG,OAAO,IAAI,GAAG,YAAY,YAAY,KAAK,QAAQ,OAAO,CAAC;QACrG,OAAO;IACX;IACA,YAAY,EAAE,EAAE;QACZ,IAAI,OAAO,GAAG;YACV,OAAO;QACX;QACA,OAAO,IAAI,CAAC,UAAU,CAAC,GAAG,CAAC;IAC/B;AACJ","ignoreList":[0]}},
    {"offset": {"line": 2004, "column": 0}, "map": {"version":3,"sources":["file:///D:/real-time-code-editor%20%282%29/node_modules/.pnpm/monaco-editor%400.55.1/node_modules/monaco-editor/esm/vs/editor/browser/gpu/viewGpuContext.js"],"sourcesContent":["import { localize } from '../../../nls.js';\nimport { getActiveWindow, addDisposableListener } from '../../../base/browser/dom.js';\nimport { createFastDomNode } from '../../../base/browser/fastDomNode.js';\nimport { BugIndicatingError } from '../../../base/common/errors.js';\nimport { Disposable } from '../../../base/common/lifecycle.js';\nimport '../../../base/common/observableInternal/index.js';\nimport { IInstantiationService } from '../../../platform/instantiation/common/instantiation.js';\nimport { TextureAtlas } from './atlas/textureAtlas.js';\nimport { IConfigurationService } from '../../../platform/configuration/common/configuration.js';\nimport { Severity, INotificationService } from '../../../platform/notification/common/notification.js';\nimport { GPULifecycle } from './gpuDisposable.js';\nimport { ensureNonNullable, observeDevicePixelDimensions } from './gpuUtils.js';\nimport { RectangleRenderer } from './rectangleRenderer.js';\nimport { DecorationCssRuleExtractor } from './css/decorationCssRuleExtractor.js';\nimport { Event } from '../../../base/common/event.js';\nimport { DecorationStyleCache } from './css/decorationStyleCache.js';\nimport { runOnChange } from '../../../base/common/observableInternal/utils/runOnChange.js';\nimport { observableValue } from '../../../base/common/observableInternal/observables/observableValue.js';\n\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (undefined && undefined.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nvar ViewGpuContext_1;\nlet ViewGpuContext = class ViewGpuContext extends Disposable {\n    static { ViewGpuContext_1 = this; }\n    static { this._decorationCssRuleExtractor = new DecorationCssRuleExtractor(); }\n    static get decorationCssRuleExtractor() {\n        return ViewGpuContext_1._decorationCssRuleExtractor;\n    }\n    static { this._decorationStyleCache = new DecorationStyleCache(); }\n    static get decorationStyleCache() {\n        return ViewGpuContext_1._decorationStyleCache;\n    }\n    /**\n     * The shared texture atlas to use across all views.\n     *\n     * @throws if called before the GPU device is resolved\n     */\n    static get atlas() {\n        if (!ViewGpuContext_1._atlas) {\n            throw new BugIndicatingError('Cannot call ViewGpuContext.textureAtlas before device is resolved');\n        }\n        return ViewGpuContext_1._atlas;\n    }\n    /**\n     * The shared texture atlas to use across all views. This is a convenience alias for\n     * {@link ViewGpuContext.atlas}.\n     *\n     * @throws if called before the GPU device is resolved\n     */\n    get atlas() {\n        return ViewGpuContext_1.atlas;\n    }\n    constructor(context, _instantiationService, _notificationService, configurationService) {\n        super();\n        this._instantiationService = _instantiationService;\n        this._notificationService = _notificationService;\n        this.configurationService = configurationService;\n        /**\n         * The hard cap for line columns rendered by the GPU renderer.\n         */\n        this.maxGpuCols = 2000;\n        this.canvas = createFastDomNode(document.createElement('canvas'));\n        this.canvas.setClassName('editorCanvas');\n        // Adjust the canvas size to avoid drawing under the scroll bar\n        this._register(Event.runAndSubscribe(configurationService.onDidChangeConfiguration, e => {\n            if (!e || e.affectsConfiguration('editor.scrollbar.verticalScrollbarSize')) {\n                const verticalScrollbarSize = configurationService.getValue('editor').scrollbar?.verticalScrollbarSize ?? 14;\n                this.canvas.domNode.style.boxSizing = 'border-box';\n                this.canvas.domNode.style.paddingRight = `${verticalScrollbarSize}px`;\n            }\n        }));\n        this.ctx = ensureNonNullable(this.canvas.domNode.getContext('webgpu'));\n        // Request the GPU device, we only want to do this a single time per window as it's async\n        // and can delay the initial render.\n        if (!ViewGpuContext_1.device) {\n            ViewGpuContext_1.device = GPULifecycle.requestDevice((message) => {\n                const choices = [{\n                        label: localize(78, \"Use DOM-based rendering\"),\n                        run: () => this.configurationService.updateValue('editor.experimentalGpuAcceleration', 'off'),\n                    }];\n                this._notificationService.prompt(Severity.Warning, message, choices);\n            }).then(ref => {\n                ViewGpuContext_1.deviceSync = ref.object;\n                if (!ViewGpuContext_1._atlas) {\n                    ViewGpuContext_1._atlas = this._instantiationService.createInstance(TextureAtlas, ref.object.limits.maxTextureDimension2D, undefined, ViewGpuContext_1.decorationStyleCache);\n                }\n                return ref.object;\n            });\n        }\n        const dprObs = observableValue(this, getActiveWindow().devicePixelRatio);\n        this._register(addDisposableListener(getActiveWindow(), 'resize', () => {\n            dprObs.set(getActiveWindow().devicePixelRatio, undefined);\n        }));\n        this.devicePixelRatio = dprObs;\n        this._register(runOnChange(this.devicePixelRatio, () => ViewGpuContext_1.atlas?.clear()));\n        const canvasDevicePixelDimensions = observableValue(this, { width: this.canvas.domNode.width, height: this.canvas.domNode.height });\n        this._register(observeDevicePixelDimensions(this.canvas.domNode, getActiveWindow(), (width, height) => {\n            this.canvas.domNode.width = width;\n            this.canvas.domNode.height = height;\n            canvasDevicePixelDimensions.set({ width, height }, undefined);\n        }));\n        this.canvasDevicePixelDimensions = canvasDevicePixelDimensions;\n        const contentLeft = observableValue(this, 0);\n        this._register(this.configurationService.onDidChangeConfiguration(e => {\n            contentLeft.set(context.configuration.options.get(165 /* EditorOption.layoutInfo */).contentLeft, undefined);\n        }));\n        this.contentLeft = contentLeft;\n        this.rectangleRenderer = this._instantiationService.createInstance(RectangleRenderer, context, this.contentLeft, this.devicePixelRatio, this.canvas.domNode, this.ctx, ViewGpuContext_1.device);\n    }\n    /**\n     * This method determines which lines can be and are allowed to be rendered using the GPU\n     * renderer. Eventually this should trend all lines, except maybe exceptional cases like\n     * decorations that use class names.\n     */\n    canRender(options, viewportData, lineNumber) {\n        const data = viewportData.getViewLineRenderingData(lineNumber);\n        // Check if the line has simple attributes that aren't supported\n        if (data.containsRTL ||\n            data.maxColumn > this.maxGpuCols) {\n            return false;\n        }\n        // Check if all inline decorations are supported\n        if (data.inlineDecorations.length > 0) {\n            let supported = true;\n            for (const decoration of data.inlineDecorations) {\n                if (decoration.type !== 0 /* InlineDecorationType.Regular */) {\n                    supported = false;\n                    break;\n                }\n                const styleRules = ViewGpuContext_1._decorationCssRuleExtractor.getStyleRules(this.canvas.domNode, decoration.inlineClassName);\n                supported &&= styleRules.every(rule => {\n                    // Pseudo classes aren't supported currently\n                    if (rule.selectorText.includes(':')) {\n                        return false;\n                    }\n                    for (const r of rule.style) {\n                        if (!supportsCssRule(r, rule.style)) {\n                            return false;\n                        }\n                    }\n                    return true;\n                });\n                if (!supported) {\n                    break;\n                }\n            }\n            return supported;\n        }\n        return true;\n    }\n    /**\n     * Like {@link canRender} but returns detailed information about why the line cannot be rendered.\n     */\n    canRenderDetailed(options, viewportData, lineNumber) {\n        const data = viewportData.getViewLineRenderingData(lineNumber);\n        const reasons = [];\n        if (data.containsRTL) {\n            reasons.push('containsRTL');\n        }\n        if (data.maxColumn > this.maxGpuCols) {\n            reasons.push('maxColumn > maxGpuCols');\n        }\n        if (data.inlineDecorations.length > 0) {\n            let supported = true;\n            const problemTypes = [];\n            const problemSelectors = [];\n            const problemRules = [];\n            for (const decoration of data.inlineDecorations) {\n                if (decoration.type !== 0 /* InlineDecorationType.Regular */) {\n                    problemTypes.push(decoration.type);\n                    supported = false;\n                    continue;\n                }\n                const styleRules = ViewGpuContext_1._decorationCssRuleExtractor.getStyleRules(this.canvas.domNode, decoration.inlineClassName);\n                supported &&= styleRules.every(rule => {\n                    // Pseudo classes aren't supported currently\n                    if (rule.selectorText.includes(':')) {\n                        problemSelectors.push(rule.selectorText);\n                        return false;\n                    }\n                    for (const r of rule.style) {\n                        if (!supportsCssRule(r, rule.style)) {\n                            // eslint-disable-next-line local/code-no-any-casts, @typescript-eslint/no-explicit-any\n                            problemRules.push(`${r}: ${rule.style[r]}`);\n                            return false;\n                        }\n                    }\n                    return true;\n                });\n                if (!supported) {\n                    continue;\n                }\n            }\n            if (problemTypes.length > 0) {\n                reasons.push(`inlineDecorations with unsupported types (${problemTypes.map(e => `\\`${e}\\``).join(', ')})`);\n            }\n            if (problemRules.length > 0) {\n                reasons.push(`inlineDecorations with unsupported CSS rules (${problemRules.map(e => `\\`${e}\\``).join(', ')})`);\n            }\n            if (problemSelectors.length > 0) {\n                reasons.push(`inlineDecorations with unsupported CSS selectors (${problemSelectors.map(e => `\\`${e}\\``).join(', ')})`);\n            }\n        }\n        return reasons;\n    }\n};\nViewGpuContext = ViewGpuContext_1 = __decorate([\n    __param(1, IInstantiationService),\n    __param(2, INotificationService),\n    __param(3, IConfigurationService)\n], ViewGpuContext);\n/**\n * A list of supported decoration CSS rules that can be used in the GPU renderer.\n */\nconst gpuSupportedDecorationCssRules = [\n    'color',\n    'font-weight',\n    'opacity',\n];\nfunction supportsCssRule(rule, style) {\n    if (!gpuSupportedDecorationCssRules.includes(rule)) {\n        return false;\n    }\n    // Check for values that aren't supported\n    switch (rule) {\n        default: return true;\n    }\n}\n\nexport { ViewGpuContext };\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 2278, "column": 0}, "map": {"version":3,"sources":["file:///D:/real-time-code-editor%20%282%29/node_modules/.pnpm/monaco-editor%400.55.1/node_modules/monaco-editor/esm/vs/editor/browser/gpu/contentSegmenter.js"],"sourcesContent":["import { safeIntl } from '../../../base/common/date.js';\n\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nfunction createContentSegmenter(lineData, options) {\n    if (lineData.isBasicASCII && options.useMonospaceOptimizations) {\n        return new AsciiContentSegmenter(lineData);\n    }\n    return new GraphemeContentSegmenter(lineData);\n}\nclass AsciiContentSegmenter {\n    constructor(lineData) {\n        this._content = lineData.content;\n    }\n    getSegmentAtIndex(index) {\n        return this._content[index];\n    }\n}\n/**\n * This is a more modern version of {@link GraphemeIterator}, relying on browser APIs instead of a\n * manual table approach.\n */\nclass GraphemeContentSegmenter {\n    constructor(lineData) {\n        this._segments = [];\n        const content = lineData.content;\n        const segmenter = safeIntl.Segmenter(undefined, { granularity: 'grapheme' }).value;\n        const segmentedContent = Array.from(segmenter.segment(content));\n        let segmenterIndex = 0;\n        for (let x = 0; x < content.length; x++) {\n            const segment = segmentedContent[segmenterIndex];\n            // No more segments in the string (eg. an emoji is the last segment)\n            if (!segment) {\n                break;\n            }\n            // The segment isn't renderable (eg. the tail end of an emoji)\n            if (segment.index !== x) {\n                this._segments.push(undefined);\n                continue;\n            }\n            segmenterIndex++;\n            this._segments.push(segment);\n        }\n    }\n    getSegmentAtIndex(index) {\n        return this._segments[index]?.segment;\n    }\n}\n\nexport { createContentSegmenter };\n"],"names":[],"mappings":";;;;AAAA;;AAEA;;;8FAG8F,GAC9F,SAAS,uBAAuB,QAAQ,EAAE,OAAO;IAC7C,IAAI,SAAS,YAAY,IAAI,QAAQ,yBAAyB,EAAE;QAC5D,OAAO,IAAI,sBAAsB;IACrC;IACA,OAAO,IAAI,yBAAyB;AACxC;AACA,MAAM;IACF,YAAY,QAAQ,CAAE;QAClB,IAAI,CAAC,QAAQ,GAAG,SAAS,OAAO;IACpC;IACA,kBAAkB,KAAK,EAAE;QACrB,OAAO,IAAI,CAAC,QAAQ,CAAC,MAAM;IAC/B;AACJ;AACA;;;CAGC,GACD,MAAM;IACF,YAAY,QAAQ,CAAE;QAClB,IAAI,CAAC,SAAS,GAAG,EAAE;QACnB,MAAM,UAAU,SAAS,OAAO;QAChC,MAAM,YAAY,oPAAQ,CAAC,SAAS,CAAC,WAAW;YAAE,aAAa;QAAW,GAAG,KAAK;QAClF,MAAM,mBAAmB,MAAM,IAAI,CAAC,UAAU,OAAO,CAAC;QACtD,IAAI,iBAAiB;QACrB,IAAK,IAAI,IAAI,GAAG,IAAI,QAAQ,MAAM,EAAE,IAAK;YACrC,MAAM,UAAU,gBAAgB,CAAC,eAAe;YAChD,oEAAoE;YACpE,IAAI,CAAC,SAAS;gBACV;YACJ;YACA,8DAA8D;YAC9D,IAAI,QAAQ,KAAK,KAAK,GAAG;gBACrB,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC;gBACpB;YACJ;YACA;YACA,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC;QACxB;IACJ;IACA,kBAAkB,KAAK,EAAE;QACrB,OAAO,IAAI,CAAC,SAAS,CAAC,MAAM,EAAE;IAClC;AACJ","ignoreList":[0]}},
    {"offset": {"line": 2337, "column": 0}, "map": {"version":3,"sources":["file:///D:/real-time-code-editor%20%282%29/node_modules/.pnpm/monaco-editor%400.55.1/node_modules/monaco-editor/esm/vs/editor/browser/gpu/renderStrategy/baseRenderStrategy.js"],"sourcesContent":["import { ViewEventHandler } from '../../../common/viewEventHandler.js';\n\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nclass BaseRenderStrategy extends ViewEventHandler {\n    get glyphRasterizer() { return this._glyphRasterizer.value; }\n    constructor(_context, _viewGpuContext, _device, _glyphRasterizer) {\n        super();\n        this._context = _context;\n        this._viewGpuContext = _viewGpuContext;\n        this._device = _device;\n        this._glyphRasterizer = _glyphRasterizer;\n        this._context.addEventHandler(this);\n    }\n}\n\nexport { BaseRenderStrategy };\n"],"names":[],"mappings":";;;;AAAA;;AAEA;;;8FAG8F,GAC9F,MAAM,2BAA2B,0QAAgB;IAC7C,IAAI,kBAAkB;QAAE,OAAO,IAAI,CAAC,gBAAgB,CAAC,KAAK;IAAE;IAC5D,YAAY,QAAQ,EAAE,eAAe,EAAE,OAAO,EAAE,gBAAgB,CAAE;QAC9D,KAAK;QACL,IAAI,CAAC,QAAQ,GAAG;QAChB,IAAI,CAAC,eAAe,GAAG;QACvB,IAAI,CAAC,OAAO,GAAG;QACf,IAAI,CAAC,gBAAgB,GAAG;QACxB,IAAI,CAAC,QAAQ,CAAC,eAAe,CAAC,IAAI;IACtC;AACJ","ignoreList":[0]}},
    {"offset": {"line": 2364, "column": 0}, "map": {"version":3,"sources":["file:///D:/real-time-code-editor%20%282%29/node_modules/.pnpm/monaco-editor%400.55.1/node_modules/monaco-editor/esm/vs/editor/browser/gpu/renderStrategy/fullFileRenderStrategy.wgsl.js"],"sourcesContent":["import { TextureAtlas } from '../atlas/textureAtlas.js';\nimport { TextureAtlasPage } from '../atlas/textureAtlasPage.js';\n\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nconst fullFileRenderStrategyWgsl = /*wgsl*/ `\nstruct GlyphInfo {\n\tposition: vec2f,\n\tsize: vec2f,\n\torigin: vec2f,\n};\n\nstruct Vertex {\n\t@location(0) position: vec2f,\n};\n\nstruct Cell {\n\tposition: vec2f,\n\tunused1: vec2f,\n\tglyphIndex: f32,\n\ttextureIndex: f32\n};\n\nstruct LayoutInfo {\n\tcanvasDims: vec2f,\n\tviewportOffset: vec2f,\n\tviewportDims: vec2f,\n}\n\nstruct ScrollOffset {\n\toffset: vec2f\n}\n\nstruct VSOutput {\n\t@builtin(position) position:   vec4f,\n\t@location(1)       layerIndex: f32,\n\t@location(0)       texcoord:   vec2f,\n};\n\n// Uniforms\n@group(0) @binding(${4 /* BindingId.LayoutInfoUniform */})       var<uniform>       layoutInfo:      LayoutInfo;\n@group(0) @binding(${5 /* BindingId.AtlasDimensionsUniform */})  var<uniform>       atlasDims:       vec2f;\n@group(0) @binding(${6 /* BindingId.ScrollOffset */})            var<uniform>       scrollOffset:    ScrollOffset;\n\n// Storage buffers\n@group(0) @binding(${0 /* BindingId.GlyphInfo */})               var<storage, read> glyphInfo:       array<array<GlyphInfo, ${TextureAtlasPage.maximumGlyphCount}>, ${TextureAtlas.maximumPageCount}>;\n@group(0) @binding(${1 /* BindingId.Cells */})                   var<storage, read> cells:           array<Cell>;\n\n@vertex fn vs(\n\tvert: Vertex,\n\t@builtin(instance_index) instanceIndex: u32,\n\t@builtin(vertex_index) vertexIndex : u32\n) -> VSOutput {\n\tlet cell = cells[instanceIndex];\n\tvar glyph = glyphInfo[u32(cell.textureIndex)][u32(cell.glyphIndex)];\n\n\tvar vsOut: VSOutput;\n\t// Multiple vert.position by 2,-2 to get it into clipspace which ranged from -1 to 1\n\tvsOut.position = vec4f(\n\t\t// Make everything relative to top left instead of center\n\t\tvec2f(-1, 1) +\n\t\t((vert.position * vec2f(2, -2)) / layoutInfo.canvasDims) * glyph.size +\n\t\t((cell.position * vec2f(2, -2)) / layoutInfo.canvasDims) +\n\t\t((glyph.origin * vec2f(2, -2)) / layoutInfo.canvasDims) +\n\t\t(((layoutInfo.viewportOffset - scrollOffset.offset * vec2(1, -1)) * 2) / layoutInfo.canvasDims),\n\t\t0.0,\n\t\t1.0\n\t);\n\n\tvsOut.layerIndex = cell.textureIndex;\n\t// Textures are flipped from natural direction on the y-axis, so flip it back\n\tvsOut.texcoord = vert.position;\n\tvsOut.texcoord = (\n\t\t// Glyph offset (0-1)\n\t\t(glyph.position / atlasDims) +\n\t\t// Glyph coordinate (0-1)\n\t\t(vsOut.texcoord * (glyph.size / atlasDims))\n\t);\n\n\treturn vsOut;\n}\n\n@group(0) @binding(${2 /* BindingId.TextureSampler */}) var ourSampler: sampler;\n@group(0) @binding(${3 /* BindingId.Texture */})        var ourTexture: texture_2d_array<f32>;\n\n@fragment fn fs(vsOut: VSOutput) -> @location(0) vec4f {\n\treturn textureSample(ourTexture, ourSampler, vsOut.texcoord, u32(vsOut.layerIndex));\n}\n`;\n\nexport { fullFileRenderStrategyWgsl };\n"],"names":[],"mappings":";;;;AAAA;AACA;;;AAEA;;;8FAG8F,GAC9F,MAAM,6BAA6B,MAAM,GAAG,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;mBAmC1B,EAAE,EAAE,+BAA+B,IAAG;mBACtC,EAAE,EAAE,oCAAoC,IAAG;mBAC3C,EAAE,EAAE,0BAA0B,IAAG;;;mBAGjC,EAAE,EAAE,uBAAuB,IAAG,2EAA2E,EAAE,2RAAgB,CAAC,iBAAiB,CAAC,GAAG,EAAE,mRAAY,CAAC,gBAAgB,CAAC;mBACjL,EAAE,EAAE,mBAAmB,IAAG;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;mBAoC1B,EAAE,EAAE,4BAA4B,IAAG;mBACnC,EAAE,EAAE,qBAAqB,IAAG;;;;;AAK/C,CAAC","ignoreList":[0]}},
    {"offset": {"line": 2464, "column": 0}, "map": {"version":3,"sources":["file:///D:/real-time-code-editor%20%282%29/node_modules/.pnpm/monaco-editor%400.55.1/node_modules/monaco-editor/esm/vs/editor/browser/gpu/renderStrategy/viewportRenderStrategy.js"],"sourcesContent":["import { getActiveWindow } from '../../../../base/browser/dom.js';\nimport { Color } from '../../../../base/common/color.js';\nimport { BugIndicatingError } from '../../../../base/common/errors.js';\nimport { Emitter } from '../../../../base/common/event.js';\nimport { CursorColumns } from '../../../common/core/cursorColumns.js';\nimport { createContentSegmenter } from '../contentSegmenter.js';\nimport { GPULifecycle } from '../gpuDisposable.js';\nimport { quadVertices } from '../gpuUtils.js';\nimport { ViewGpuContext } from '../viewGpuContext.js';\nimport { BaseRenderStrategy } from './baseRenderStrategy.js';\nimport { fullFileRenderStrategyWgsl } from './fullFileRenderStrategy.wgsl.js';\n\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n/**\n * A render strategy that uploads the content of the entire viewport every frame.\n */\nclass ViewportRenderStrategy extends BaseRenderStrategy {\n    /**\n     * The hard cap for line columns that can be rendered by the GPU renderer.\n     */\n    static { this.maxSupportedColumns = 2000; }\n    get bindGroupEntries() {\n        return [\n            { binding: 1 /* BindingId.Cells */, resource: { buffer: this._cellBindBuffer } },\n            { binding: 6 /* BindingId.ScrollOffset */, resource: { buffer: this._scrollOffsetBindBuffer } }\n        ];\n    }\n    constructor(context, viewGpuContext, device, glyphRasterizer) {\n        super(context, viewGpuContext, device, glyphRasterizer);\n        this.type = 'viewport';\n        this.wgsl = fullFileRenderStrategyWgsl;\n        this._cellBindBufferLineCapacity = 63 /* Constants.CellBindBufferInitialCapacity */;\n        this._activeDoubleBufferIndex = 0;\n        this._visibleObjectCount = 0;\n        this._scrollInitialized = false;\n        this._onDidChangeBindGroupEntries = this._register(new Emitter());\n        this.onDidChangeBindGroupEntries = this._onDidChangeBindGroupEntries.event;\n        this._rebuildCellBuffer(this._cellBindBufferLineCapacity);\n        const scrollOffsetBufferSize = 2;\n        this._scrollOffsetBindBuffer = this._register(GPULifecycle.createBuffer(this._device, {\n            label: 'Monaco scroll offset buffer',\n            size: scrollOffsetBufferSize * Float32Array.BYTES_PER_ELEMENT,\n            usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,\n        })).object;\n        this._scrollOffsetValueBuffer = new Float32Array(scrollOffsetBufferSize);\n    }\n    _rebuildCellBuffer(lineCount) {\n        this._cellBindBuffer?.destroy();\n        // Increase in chunks so resizing a window by hand doesn't keep allocating and throwing away\n        const lineCountWithIncrement = (Math.floor(lineCount / 32 /* Constants.CellBindBufferCapacityIncrement */) + 1) * 32 /* Constants.CellBindBufferCapacityIncrement */;\n        const bufferSize = lineCountWithIncrement * ViewportRenderStrategy.maxSupportedColumns * 6 /* Constants.IndicesPerCell */ * Float32Array.BYTES_PER_ELEMENT;\n        this._cellBindBuffer = this._register(GPULifecycle.createBuffer(this._device, {\n            label: 'Monaco full file cell buffer',\n            size: bufferSize,\n            usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,\n        })).object;\n        this._cellValueBuffers = [\n            new ArrayBuffer(bufferSize),\n            new ArrayBuffer(bufferSize),\n        ];\n        this._cellBindBufferLineCapacity = lineCountWithIncrement;\n        this._onDidChangeBindGroupEntries.fire();\n    }\n    // #region Event handlers\n    // The primary job of these handlers is to:\n    // 1. Invalidate the up to date line cache, which will cause the line to be re-rendered when\n    //    it's _within the viewport_.\n    // 2. Pass relevant events on to the render function so it can force certain line ranges to be\n    //    re-rendered even if they're not in the viewport. For example when a view zone is added,\n    //    there are lines that used to be visible but are no longer, so those ranges must be\n    //    cleared and uploaded to the GPU.\n    onConfigurationChanged(e) {\n        return true;\n    }\n    onDecorationsChanged(e) {\n        return true;\n    }\n    onTokensChanged(e) {\n        return true;\n    }\n    onLinesDeleted(e) {\n        return true;\n    }\n    onLinesInserted(e) {\n        return true;\n    }\n    onLinesChanged(e) {\n        return true;\n    }\n    onScrollChanged(e) {\n        const dpr = getActiveWindow().devicePixelRatio;\n        this._scrollOffsetValueBuffer[0] = (e?.scrollLeft ?? this._context.viewLayout.getCurrentScrollLeft()) * dpr;\n        this._scrollOffsetValueBuffer[1] = (e?.scrollTop ?? this._context.viewLayout.getCurrentScrollTop()) * dpr;\n        this._device.queue.writeBuffer(this._scrollOffsetBindBuffer, 0, this._scrollOffsetValueBuffer);\n        return true;\n    }\n    onThemeChanged(e) {\n        return true;\n    }\n    onLineMappingChanged(e) {\n        return true;\n    }\n    onZonesChanged(e) {\n        return true;\n    }\n    // #endregion\n    reset() {\n        for (const bufferIndex of [0, 1]) {\n            // Zero out buffer and upload to GPU to prevent stale rows from rendering\n            const buffer = new Float32Array(this._cellValueBuffers[bufferIndex]);\n            buffer.fill(0, 0, buffer.length);\n            this._device.queue.writeBuffer(this._cellBindBuffer, 0, buffer.buffer, 0, buffer.byteLength);\n        }\n    }\n    update(viewportData, viewLineOptions) {\n        // IMPORTANT: This is a hot function. Variables are pre-allocated and shared within the\n        // loop. This is done so we don't need to trust the JIT compiler to do this optimization to\n        // avoid potential additional blocking time in garbage collector which is a common cause of\n        // dropped frames.\n        let chars = '';\n        let segment;\n        let charWidth = 0;\n        let y = 0;\n        let x = 0;\n        let absoluteOffsetX = 0;\n        let absoluteOffsetY = 0;\n        let tabXOffset = 0;\n        let glyph;\n        let cellIndex = 0;\n        let tokenStartIndex = 0;\n        let tokenEndIndex = 0;\n        let tokenMetadata = 0;\n        let decorationStyleSetBold;\n        let decorationStyleSetColor;\n        let decorationStyleSetOpacity;\n        let lineData;\n        let decoration;\n        let fillStartIndex = 0;\n        let fillEndIndex = 0;\n        let tokens;\n        const dpr = getActiveWindow().devicePixelRatio;\n        let contentSegmenter;\n        if (!this._scrollInitialized) {\n            this.onScrollChanged();\n            this._scrollInitialized = true;\n        }\n        // Zero out cell buffer or rebuild if needed\n        if (this._cellBindBufferLineCapacity < viewportData.endLineNumber - viewportData.startLineNumber + 1) {\n            this._rebuildCellBuffer(viewportData.endLineNumber - viewportData.startLineNumber + 1);\n        }\n        const cellBuffer = new Float32Array(this._cellValueBuffers[this._activeDoubleBufferIndex]);\n        cellBuffer.fill(0);\n        const lineIndexCount = ViewportRenderStrategy.maxSupportedColumns * 6 /* Constants.IndicesPerCell */;\n        for (y = viewportData.startLineNumber; y <= viewportData.endLineNumber; y++) {\n            // Only attempt to render lines that the GPU renderer can handle\n            if (!this._viewGpuContext.canRender(viewLineOptions, viewportData, y)) {\n                continue;\n            }\n            lineData = viewportData.getViewLineRenderingData(y);\n            tabXOffset = 0;\n            contentSegmenter = createContentSegmenter(lineData, viewLineOptions);\n            charWidth = viewLineOptions.spaceWidth * dpr;\n            absoluteOffsetX = 0;\n            tokens = lineData.tokens;\n            tokenStartIndex = lineData.minColumn - 1;\n            tokenEndIndex = 0;\n            for (let tokenIndex = 0, tokensLen = tokens.getCount(); tokenIndex < tokensLen; tokenIndex++) {\n                tokenEndIndex = tokens.getEndOffset(tokenIndex);\n                if (tokenEndIndex <= tokenStartIndex) {\n                    // The faux indent part of the line should have no token type\n                    continue;\n                }\n                tokenMetadata = tokens.getMetadata(tokenIndex);\n                for (x = tokenStartIndex; x < tokenEndIndex; x++) {\n                    // Only render lines that do not exceed maximum columns\n                    if (x > ViewportRenderStrategy.maxSupportedColumns) {\n                        break;\n                    }\n                    segment = contentSegmenter.getSegmentAtIndex(x);\n                    if (segment === undefined) {\n                        continue;\n                    }\n                    chars = segment;\n                    if (!(lineData.isBasicASCII && viewLineOptions.useMonospaceOptimizations)) {\n                        charWidth = this.glyphRasterizer.getTextMetrics(chars).width;\n                    }\n                    decorationStyleSetColor = undefined;\n                    decorationStyleSetBold = undefined;\n                    decorationStyleSetOpacity = undefined;\n                    // Apply supported inline decoration styles to the cell metadata\n                    for (decoration of lineData.inlineDecorations) {\n                        // This is Range.strictContainsPosition except it works at the cell level,\n                        // it's also inlined to avoid overhead.\n                        if ((y < decoration.range.startLineNumber || y > decoration.range.endLineNumber) ||\n                            (y === decoration.range.startLineNumber && x < decoration.range.startColumn - 1) ||\n                            (y === decoration.range.endLineNumber && x >= decoration.range.endColumn - 1)) {\n                            continue;\n                        }\n                        const rules = ViewGpuContext.decorationCssRuleExtractor.getStyleRules(this._viewGpuContext.canvas.domNode, decoration.inlineClassName);\n                        for (const rule of rules) {\n                            for (const r of rule.style) {\n                                const value = rule.styleMap.get(r)?.toString() ?? '';\n                                switch (r) {\n                                    case 'color': {\n                                        // TODO: This parsing and error handling should move into canRender so fallback\n                                        //       to DOM works\n                                        const parsedColor = Color.Format.CSS.parse(value);\n                                        if (!parsedColor) {\n                                            throw new BugIndicatingError('Invalid color format ' + value);\n                                        }\n                                        decorationStyleSetColor = parsedColor.toNumber32Bit();\n                                        break;\n                                    }\n                                    case 'font-weight': {\n                                        const parsedValue = parseCssFontWeight(value);\n                                        if (parsedValue >= 400) {\n                                            decorationStyleSetBold = true;\n                                            // TODO: Set bold (https://github.com/microsoft/vscode/issues/237584)\n                                        }\n                                        else {\n                                            decorationStyleSetBold = false;\n                                            // TODO: Set normal (https://github.com/microsoft/vscode/issues/237584)\n                                        }\n                                        break;\n                                    }\n                                    case 'opacity': {\n                                        const parsedValue = parseCssOpacity(value);\n                                        decorationStyleSetOpacity = parsedValue;\n                                        break;\n                                    }\n                                    default: throw new BugIndicatingError('Unexpected inline decoration style');\n                                }\n                            }\n                        }\n                    }\n                    if (chars === ' ' || chars === '\\t') {\n                        // Zero out glyph to ensure it doesn't get rendered\n                        cellIndex = ((y - 1) * ViewportRenderStrategy.maxSupportedColumns + x) * 6 /* Constants.IndicesPerCell */;\n                        cellBuffer.fill(0, cellIndex, cellIndex + 6 /* CellBufferInfo.FloatsPerEntry */);\n                        // Adjust xOffset for tab stops\n                        if (chars === '\\t') {\n                            // Find the pixel offset between the current position and the next tab stop\n                            const offsetBefore = x + tabXOffset;\n                            tabXOffset = CursorColumns.nextRenderTabStop(x + tabXOffset, lineData.tabSize);\n                            absoluteOffsetX += charWidth * (tabXOffset - offsetBefore);\n                            // Convert back to offset excluding x and the current character\n                            tabXOffset -= x + 1;\n                        }\n                        else {\n                            absoluteOffsetX += charWidth;\n                        }\n                        continue;\n                    }\n                    const decorationStyleSetId = ViewGpuContext.decorationStyleCache.getOrCreateEntry(decorationStyleSetColor, decorationStyleSetBold, decorationStyleSetOpacity);\n                    glyph = this._viewGpuContext.atlas.getGlyph(this.glyphRasterizer, chars, tokenMetadata, decorationStyleSetId, absoluteOffsetX);\n                    absoluteOffsetY = Math.round(\n                    // Top of layout box (includes line height)\n                    viewportData.relativeVerticalOffset[y - viewportData.startLineNumber] * dpr +\n                        // Delta from top of layout box (includes line height) to top of the inline box (no line height)\n                        Math.floor((viewportData.lineHeight * dpr - (glyph.fontBoundingBoxAscent + glyph.fontBoundingBoxDescent)) / 2) +\n                        // Delta from top of inline box (no line height) to top of glyph origin. If the glyph was drawn\n                        // with a top baseline for example, this ends up drawing the glyph correctly using the alphabetical\n                        // baseline.\n                        glyph.fontBoundingBoxAscent);\n                    cellIndex = ((y - viewportData.startLineNumber) * ViewportRenderStrategy.maxSupportedColumns + x) * 6 /* Constants.IndicesPerCell */;\n                    cellBuffer[cellIndex + 0 /* CellBufferInfo.Offset_X */] = Math.floor(absoluteOffsetX);\n                    cellBuffer[cellIndex + 1 /* CellBufferInfo.Offset_Y */] = absoluteOffsetY;\n                    cellBuffer[cellIndex + 4 /* CellBufferInfo.GlyphIndex */] = glyph.glyphIndex;\n                    cellBuffer[cellIndex + 5 /* CellBufferInfo.TextureIndex */] = glyph.pageIndex;\n                    // Adjust the x pixel offset for the next character\n                    absoluteOffsetX += charWidth;\n                }\n                tokenStartIndex = tokenEndIndex;\n            }\n            // Clear to end of line\n            fillStartIndex = ((y - viewportData.startLineNumber) * ViewportRenderStrategy.maxSupportedColumns + tokenEndIndex) * 6 /* Constants.IndicesPerCell */;\n            fillEndIndex = ((y - viewportData.startLineNumber) * ViewportRenderStrategy.maxSupportedColumns) * 6 /* Constants.IndicesPerCell */;\n            cellBuffer.fill(0, fillStartIndex, fillEndIndex);\n        }\n        const visibleObjectCount = (viewportData.endLineNumber - viewportData.startLineNumber + 1) * lineIndexCount;\n        // This render strategy always uploads the whole viewport\n        this._device.queue.writeBuffer(this._cellBindBuffer, 0, cellBuffer.buffer, 0, (viewportData.endLineNumber - viewportData.startLineNumber) * lineIndexCount * Float32Array.BYTES_PER_ELEMENT);\n        this._activeDoubleBufferIndex = this._activeDoubleBufferIndex ? 0 : 1;\n        this._visibleObjectCount = visibleObjectCount;\n        return visibleObjectCount;\n    }\n    draw(pass, viewportData) {\n        if (this._visibleObjectCount <= 0) {\n            throw new BugIndicatingError('Attempt to draw 0 objects');\n        }\n        pass.draw(quadVertices.length / 2, this._visibleObjectCount);\n    }\n}\nfunction parseCssFontWeight(value) {\n    switch (value) {\n        case 'lighter':\n        case 'normal': return 400;\n        case 'bolder':\n        case 'bold': return 700;\n    }\n    return parseInt(value);\n}\nfunction parseCssOpacity(value) {\n    if (value.endsWith('%')) {\n        return parseFloat(value.substring(0, value.length - 1)) / 100;\n    }\n    if (value.match(/^\\d+(?:\\.\\d*)/)) {\n        return parseFloat(value);\n    }\n    return 1;\n}\n\nexport { ViewportRenderStrategy };\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 2807, "column": 0}, "map": {"version":3,"sources":["file:///D:/real-time-code-editor%20%282%29/node_modules/.pnpm/monaco-editor%400.55.1/node_modules/monaco-editor/esm/vs/editor/browser/gpu/renderStrategy/fullFileRenderStrategy.js"],"sourcesContent":["import { getActiveWindow } from '../../../../base/browser/dom.js';\nimport { Color } from '../../../../base/common/color.js';\nimport { BugIndicatingError } from '../../../../base/common/errors.js';\nimport { CursorColumns } from '../../../common/core/cursorColumns.js';\nimport { createContentSegmenter } from '../contentSegmenter.js';\nimport { fullFileRenderStrategyWgsl } from './fullFileRenderStrategy.wgsl.js';\nimport { GPULifecycle } from '../gpuDisposable.js';\nimport { quadVertices } from '../gpuUtils.js';\nimport { ViewGpuContext } from '../viewGpuContext.js';\nimport { BaseRenderStrategy } from './baseRenderStrategy.js';\n\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n/**\n * A render strategy that tracks a large buffer, uploading only dirty lines as they change and\n * leveraging heavy caching. This is the most performant strategy but has limitations around long\n * lines and too many lines.\n */\nclass FullFileRenderStrategy extends BaseRenderStrategy {\n    /**\n     * The hard cap for line count that can be rendered by the GPU renderer.\n     */\n    static { this.maxSupportedLines = 3000; }\n    /**\n     * The hard cap for line columns that can be rendered by the GPU renderer.\n     */\n    static { this.maxSupportedColumns = 200; }\n    get bindGroupEntries() {\n        return [\n            { binding: 1 /* BindingId.Cells */, resource: { buffer: this._cellBindBuffer } },\n            { binding: 6 /* BindingId.ScrollOffset */, resource: { buffer: this._scrollOffsetBindBuffer } }\n        ];\n    }\n    constructor(context, viewGpuContext, device, glyphRasterizer) {\n        super(context, viewGpuContext, device, glyphRasterizer);\n        this.type = 'fullfile';\n        this.wgsl = fullFileRenderStrategyWgsl;\n        this._activeDoubleBufferIndex = 0;\n        this._upToDateLines = [new Set(), new Set()];\n        this._visibleObjectCount = 0;\n        this._finalRenderedLine = 0;\n        this._scrollInitialized = false;\n        this._queuedBufferUpdates = [[], []];\n        const bufferSize = FullFileRenderStrategy.maxSupportedLines * FullFileRenderStrategy.maxSupportedColumns * 6 /* Constants.IndicesPerCell */ * Float32Array.BYTES_PER_ELEMENT;\n        this._cellBindBuffer = this._register(GPULifecycle.createBuffer(this._device, {\n            label: 'Monaco full file cell buffer',\n            size: bufferSize,\n            usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,\n        })).object;\n        this._cellValueBuffers = [\n            new ArrayBuffer(bufferSize),\n            new ArrayBuffer(bufferSize),\n        ];\n        const scrollOffsetBufferSize = 2;\n        this._scrollOffsetBindBuffer = this._register(GPULifecycle.createBuffer(this._device, {\n            label: 'Monaco scroll offset buffer',\n            size: scrollOffsetBufferSize * Float32Array.BYTES_PER_ELEMENT,\n            usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,\n        })).object;\n        this._scrollOffsetValueBuffer = new Float32Array(scrollOffsetBufferSize);\n    }\n    // #region Event handlers\n    // The primary job of these handlers is to:\n    // 1. Invalidate the up to date line cache, which will cause the line to be re-rendered when\n    //    it's _within the viewport_.\n    // 2. Pass relevant events on to the render function so it can force certain line ranges to be\n    //    re-rendered even if they're not in the viewport. For example when a view zone is added,\n    //    there are lines that used to be visible but are no longer, so those ranges must be\n    //    cleared and uploaded to the GPU.\n    onConfigurationChanged(e) {\n        this._invalidateAllLines();\n        this._queueBufferUpdate(e);\n        return true;\n    }\n    onDecorationsChanged(e) {\n        this._invalidateAllLines();\n        return true;\n    }\n    onTokensChanged(e) {\n        // TODO: This currently fires for the entire viewport whenever scrolling stops\n        //       https://github.com/microsoft/vscode/issues/233942\n        for (const range of e.ranges) {\n            this._invalidateLineRange(range.fromLineNumber, range.toLineNumber);\n        }\n        return true;\n    }\n    onLinesDeleted(e) {\n        // TODO: This currently invalidates everything after the deleted line, it could shift the\n        //       line data up to retain some up to date lines\n        // TODO: This does not invalidate lines that are no longer in the file\n        this._invalidateLinesFrom(e.fromLineNumber);\n        this._queueBufferUpdate(e);\n        return true;\n    }\n    onLinesInserted(e) {\n        // TODO: This currently invalidates everything after the deleted line, it could shift the\n        //       line data up to retain some up to date lines\n        this._invalidateLinesFrom(e.fromLineNumber);\n        return true;\n    }\n    onLinesChanged(e) {\n        this._invalidateLineRange(e.fromLineNumber, e.fromLineNumber + e.count);\n        return true;\n    }\n    onScrollChanged(e) {\n        const dpr = getActiveWindow().devicePixelRatio;\n        this._scrollOffsetValueBuffer[0] = (e?.scrollLeft ?? this._context.viewLayout.getCurrentScrollLeft()) * dpr;\n        this._scrollOffsetValueBuffer[1] = (e?.scrollTop ?? this._context.viewLayout.getCurrentScrollTop()) * dpr;\n        this._device.queue.writeBuffer(this._scrollOffsetBindBuffer, 0, this._scrollOffsetValueBuffer);\n        return true;\n    }\n    onThemeChanged(e) {\n        this._invalidateAllLines();\n        return true;\n    }\n    onLineMappingChanged(e) {\n        this._invalidateAllLines();\n        this._queueBufferUpdate(e);\n        return true;\n    }\n    onZonesChanged(e) {\n        this._invalidateAllLines();\n        this._queueBufferUpdate(e);\n        return true;\n    }\n    // #endregion\n    _invalidateAllLines() {\n        this._upToDateLines[0].clear();\n        this._upToDateLines[1].clear();\n    }\n    _invalidateLinesFrom(lineNumber) {\n        for (const i of [0, 1]) {\n            const upToDateLines = this._upToDateLines[i];\n            for (const upToDateLine of upToDateLines) {\n                if (upToDateLine >= lineNumber) {\n                    upToDateLines.delete(upToDateLine);\n                }\n            }\n        }\n    }\n    _invalidateLineRange(fromLineNumber, toLineNumber) {\n        for (let i = fromLineNumber; i <= toLineNumber; i++) {\n            this._upToDateLines[0].delete(i);\n            this._upToDateLines[1].delete(i);\n        }\n    }\n    reset() {\n        this._invalidateAllLines();\n        for (const bufferIndex of [0, 1]) {\n            // Zero out buffer and upload to GPU to prevent stale rows from rendering\n            const buffer = new Float32Array(this._cellValueBuffers[bufferIndex]);\n            buffer.fill(0, 0, buffer.length);\n            this._device.queue.writeBuffer(this._cellBindBuffer, 0, buffer.buffer, 0, buffer.byteLength);\n        }\n        this._finalRenderedLine = 0;\n    }\n    update(viewportData, viewLineOptions) {\n        // IMPORTANT: This is a hot function. Variables are pre-allocated and shared within the\n        // loop. This is done so we don't need to trust the JIT compiler to do this optimization to\n        // avoid potential additional blocking time in garbage collector which is a common cause of\n        // dropped frames.\n        let chars = '';\n        let segment;\n        let charWidth = 0;\n        let y = 0;\n        let x = 0;\n        let absoluteOffsetX = 0;\n        let absoluteOffsetY = 0;\n        let tabXOffset = 0;\n        let glyph;\n        let cellIndex = 0;\n        let tokenStartIndex = 0;\n        let tokenEndIndex = 0;\n        let tokenMetadata = 0;\n        let decorationStyleSetBold;\n        let decorationStyleSetColor;\n        let decorationStyleSetOpacity;\n        let lineData;\n        let decoration;\n        let fillStartIndex = 0;\n        let fillEndIndex = 0;\n        let tokens;\n        const dpr = getActiveWindow().devicePixelRatio;\n        let contentSegmenter;\n        if (!this._scrollInitialized) {\n            this.onScrollChanged();\n            this._scrollInitialized = true;\n        }\n        // Update cell data\n        const cellBuffer = new Float32Array(this._cellValueBuffers[this._activeDoubleBufferIndex]);\n        const lineIndexCount = FullFileRenderStrategy.maxSupportedColumns * 6 /* Constants.IndicesPerCell */;\n        const upToDateLines = this._upToDateLines[this._activeDoubleBufferIndex];\n        let dirtyLineStart = 3000;\n        let dirtyLineEnd = 0;\n        // Handle any queued buffer updates\n        const queuedBufferUpdates = this._queuedBufferUpdates[this._activeDoubleBufferIndex];\n        while (queuedBufferUpdates.length) {\n            const e = queuedBufferUpdates.shift();\n            switch (e.type) {\n                // TODO: Refine these cases so we're not throwing away everything\n                case 2 /* ViewEventType.ViewConfigurationChanged */:\n                case 8 /* ViewEventType.ViewLineMappingChanged */:\n                case 17 /* ViewEventType.ViewZonesChanged */: {\n                    cellBuffer.fill(0);\n                    dirtyLineStart = 1;\n                    dirtyLineEnd = Math.max(dirtyLineEnd, this._finalRenderedLine);\n                    this._finalRenderedLine = 0;\n                    break;\n                }\n                case 10 /* ViewEventType.ViewLinesDeleted */: {\n                    // Shift content below deleted line up\n                    const deletedLineContentStartIndex = (e.fromLineNumber - 1) * FullFileRenderStrategy.maxSupportedColumns * 6 /* Constants.IndicesPerCell */;\n                    const deletedLineContentEndIndex = (e.toLineNumber) * FullFileRenderStrategy.maxSupportedColumns * 6 /* Constants.IndicesPerCell */;\n                    const nullContentStartIndex = (this._finalRenderedLine - (e.toLineNumber - e.fromLineNumber + 1)) * FullFileRenderStrategy.maxSupportedColumns * 6 /* Constants.IndicesPerCell */;\n                    cellBuffer.set(cellBuffer.subarray(deletedLineContentEndIndex), deletedLineContentStartIndex);\n                    // Zero out content on lines that are no longer valid\n                    cellBuffer.fill(0, nullContentStartIndex);\n                    // Update dirty lines and final rendered line\n                    dirtyLineStart = Math.min(dirtyLineStart, e.fromLineNumber);\n                    dirtyLineEnd = Math.max(dirtyLineEnd, this._finalRenderedLine);\n                    this._finalRenderedLine -= e.toLineNumber - e.fromLineNumber + 1;\n                    break;\n                }\n            }\n        }\n        for (y = viewportData.startLineNumber; y <= viewportData.endLineNumber; y++) {\n            // Only attempt to render lines that the GPU renderer can handle\n            if (!this._viewGpuContext.canRender(viewLineOptions, viewportData, y)) {\n                fillStartIndex = ((y - 1) * FullFileRenderStrategy.maxSupportedColumns) * 6 /* Constants.IndicesPerCell */;\n                fillEndIndex = (y * FullFileRenderStrategy.maxSupportedColumns) * 6 /* Constants.IndicesPerCell */;\n                cellBuffer.fill(0, fillStartIndex, fillEndIndex);\n                dirtyLineStart = Math.min(dirtyLineStart, y);\n                dirtyLineEnd = Math.max(dirtyLineEnd, y);\n                continue;\n            }\n            // Skip updating the line if it's already up to date\n            if (upToDateLines.has(y)) {\n                continue;\n            }\n            dirtyLineStart = Math.min(dirtyLineStart, y);\n            dirtyLineEnd = Math.max(dirtyLineEnd, y);\n            lineData = viewportData.getViewLineRenderingData(y);\n            tabXOffset = 0;\n            contentSegmenter = createContentSegmenter(lineData, viewLineOptions);\n            charWidth = viewLineOptions.spaceWidth * dpr;\n            absoluteOffsetX = 0;\n            tokens = lineData.tokens;\n            tokenStartIndex = lineData.minColumn - 1;\n            tokenEndIndex = 0;\n            for (let tokenIndex = 0, tokensLen = tokens.getCount(); tokenIndex < tokensLen; tokenIndex++) {\n                tokenEndIndex = tokens.getEndOffset(tokenIndex);\n                if (tokenEndIndex <= tokenStartIndex) {\n                    // The faux indent part of the line should have no token type\n                    continue;\n                }\n                tokenMetadata = tokens.getMetadata(tokenIndex);\n                for (x = tokenStartIndex; x < tokenEndIndex; x++) {\n                    // Only render lines that do not exceed maximum columns\n                    if (x > FullFileRenderStrategy.maxSupportedColumns) {\n                        break;\n                    }\n                    segment = contentSegmenter.getSegmentAtIndex(x);\n                    if (segment === undefined) {\n                        continue;\n                    }\n                    chars = segment;\n                    if (!(lineData.isBasicASCII && viewLineOptions.useMonospaceOptimizations)) {\n                        charWidth = this.glyphRasterizer.getTextMetrics(chars).width;\n                    }\n                    decorationStyleSetColor = undefined;\n                    decorationStyleSetBold = undefined;\n                    decorationStyleSetOpacity = undefined;\n                    // Apply supported inline decoration styles to the cell metadata\n                    for (decoration of lineData.inlineDecorations) {\n                        // This is Range.strictContainsPosition except it works at the cell level,\n                        // it's also inlined to avoid overhead.\n                        if ((y < decoration.range.startLineNumber || y > decoration.range.endLineNumber) ||\n                            (y === decoration.range.startLineNumber && x < decoration.range.startColumn - 1) ||\n                            (y === decoration.range.endLineNumber && x >= decoration.range.endColumn - 1)) {\n                            continue;\n                        }\n                        const rules = ViewGpuContext.decorationCssRuleExtractor.getStyleRules(this._viewGpuContext.canvas.domNode, decoration.inlineClassName);\n                        for (const rule of rules) {\n                            for (const r of rule.style) {\n                                const value = rule.styleMap.get(r)?.toString() ?? '';\n                                switch (r) {\n                                    case 'color': {\n                                        // TODO: This parsing and error handling should move into canRender so fallback\n                                        //       to DOM works\n                                        const parsedColor = Color.Format.CSS.parse(value);\n                                        if (!parsedColor) {\n                                            throw new BugIndicatingError('Invalid color format ' + value);\n                                        }\n                                        decorationStyleSetColor = parsedColor.toNumber32Bit();\n                                        break;\n                                    }\n                                    case 'font-weight': {\n                                        const parsedValue = parseCssFontWeight(value);\n                                        if (parsedValue >= 400) {\n                                            decorationStyleSetBold = true;\n                                            // TODO: Set bold (https://github.com/microsoft/vscode/issues/237584)\n                                        }\n                                        else {\n                                            decorationStyleSetBold = false;\n                                            // TODO: Set normal (https://github.com/microsoft/vscode/issues/237584)\n                                        }\n                                        break;\n                                    }\n                                    case 'opacity': {\n                                        const parsedValue = parseCssOpacity(value);\n                                        decorationStyleSetOpacity = parsedValue;\n                                        break;\n                                    }\n                                    default: throw new BugIndicatingError('Unexpected inline decoration style');\n                                }\n                            }\n                        }\n                    }\n                    if (chars === ' ' || chars === '\\t') {\n                        // Zero out glyph to ensure it doesn't get rendered\n                        cellIndex = ((y - 1) * FullFileRenderStrategy.maxSupportedColumns + x) * 6 /* Constants.IndicesPerCell */;\n                        cellBuffer.fill(0, cellIndex, cellIndex + 6 /* CellBufferInfo.FloatsPerEntry */);\n                        // Adjust xOffset for tab stops\n                        if (chars === '\\t') {\n                            // Find the pixel offset between the current position and the next tab stop\n                            const offsetBefore = x + tabXOffset;\n                            tabXOffset = CursorColumns.nextRenderTabStop(x + tabXOffset, lineData.tabSize);\n                            absoluteOffsetX += charWidth * (tabXOffset - offsetBefore);\n                            // Convert back to offset excluding x and the current character\n                            tabXOffset -= x + 1;\n                        }\n                        else {\n                            absoluteOffsetX += charWidth;\n                        }\n                        continue;\n                    }\n                    const decorationStyleSetId = ViewGpuContext.decorationStyleCache.getOrCreateEntry(decorationStyleSetColor, decorationStyleSetBold, decorationStyleSetOpacity);\n                    glyph = this._viewGpuContext.atlas.getGlyph(this.glyphRasterizer, chars, tokenMetadata, decorationStyleSetId, absoluteOffsetX);\n                    absoluteOffsetY = Math.round(\n                    // Top of layout box (includes line height)\n                    viewportData.relativeVerticalOffset[y - viewportData.startLineNumber] * dpr +\n                        // Delta from top of layout box (includes line height) to top of the inline box (no line height)\n                        Math.floor((viewportData.lineHeight * dpr - (glyph.fontBoundingBoxAscent + glyph.fontBoundingBoxDescent)) / 2) +\n                        // Delta from top of inline box (no line height) to top of glyph origin. If the glyph was drawn\n                        // with a top baseline for example, this ends up drawing the glyph correctly using the alphabetical\n                        // baseline.\n                        glyph.fontBoundingBoxAscent);\n                    cellIndex = ((y - 1) * FullFileRenderStrategy.maxSupportedColumns + x) * 6 /* Constants.IndicesPerCell */;\n                    cellBuffer[cellIndex + 0 /* CellBufferInfo.Offset_X */] = Math.floor(absoluteOffsetX);\n                    cellBuffer[cellIndex + 1 /* CellBufferInfo.Offset_Y */] = absoluteOffsetY;\n                    cellBuffer[cellIndex + 4 /* CellBufferInfo.GlyphIndex */] = glyph.glyphIndex;\n                    cellBuffer[cellIndex + 5 /* CellBufferInfo.TextureIndex */] = glyph.pageIndex;\n                    // Adjust the x pixel offset for the next character\n                    absoluteOffsetX += charWidth;\n                }\n                tokenStartIndex = tokenEndIndex;\n            }\n            // Clear to end of line\n            fillStartIndex = ((y - 1) * FullFileRenderStrategy.maxSupportedColumns + tokenEndIndex) * 6 /* Constants.IndicesPerCell */;\n            fillEndIndex = (y * FullFileRenderStrategy.maxSupportedColumns) * 6 /* Constants.IndicesPerCell */;\n            cellBuffer.fill(0, fillStartIndex, fillEndIndex);\n            upToDateLines.add(y);\n        }\n        const visibleObjectCount = (viewportData.endLineNumber - viewportData.startLineNumber + 1) * lineIndexCount;\n        // Only write when there is changed data\n        dirtyLineStart = Math.min(dirtyLineStart, FullFileRenderStrategy.maxSupportedLines);\n        dirtyLineEnd = Math.min(dirtyLineEnd, FullFileRenderStrategy.maxSupportedLines);\n        if (dirtyLineStart <= dirtyLineEnd) {\n            // Write buffer and swap it out to unblock writes\n            this._device.queue.writeBuffer(this._cellBindBuffer, (dirtyLineStart - 1) * lineIndexCount * Float32Array.BYTES_PER_ELEMENT, cellBuffer.buffer, (dirtyLineStart - 1) * lineIndexCount * Float32Array.BYTES_PER_ELEMENT, (dirtyLineEnd - dirtyLineStart + 1) * lineIndexCount * Float32Array.BYTES_PER_ELEMENT);\n        }\n        this._finalRenderedLine = Math.max(this._finalRenderedLine, dirtyLineEnd);\n        this._activeDoubleBufferIndex = this._activeDoubleBufferIndex ? 0 : 1;\n        this._visibleObjectCount = visibleObjectCount;\n        return visibleObjectCount;\n    }\n    draw(pass, viewportData) {\n        if (this._visibleObjectCount <= 0) {\n            throw new BugIndicatingError('Attempt to draw 0 objects');\n        }\n        pass.draw(quadVertices.length / 2, this._visibleObjectCount, undefined, (viewportData.startLineNumber - 1) * FullFileRenderStrategy.maxSupportedColumns);\n    }\n    /**\n     * Queue updates that need to happen on the active buffer, not just the cache. This will be\n     * deferred to when the actual cell buffer is changed since the active buffer could be locked by\n     * the GPU which would block the main thread.\n     */\n    _queueBufferUpdate(e) {\n        this._queuedBufferUpdates[0].push(e);\n        this._queuedBufferUpdates[1].push(e);\n    }\n}\nfunction parseCssFontWeight(value) {\n    switch (value) {\n        case 'lighter':\n        case 'normal': return 400;\n        case 'bolder':\n        case 'bold': return 700;\n    }\n    return parseInt(value);\n}\nfunction parseCssOpacity(value) {\n    if (value.endsWith('%')) {\n        return parseFloat(value.substring(0, value.length - 1)) / 100;\n    }\n    if (value.match(/^\\d+(?:\\.\\d*)/)) {\n        return parseFloat(value);\n    }\n    return 1;\n}\n\nexport { FullFileRenderStrategy };\n"],"names":[],"mappings":"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","ignoreList":[0]}}]
}