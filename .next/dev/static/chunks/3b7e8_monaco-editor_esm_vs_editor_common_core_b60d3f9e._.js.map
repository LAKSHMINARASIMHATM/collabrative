{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///D:/real-time-code-editor%20%282%29/node_modules/.pnpm/monaco-editor%400.55.1/node_modules/monaco-editor/esm/vs/editor/common/core/misc/textModelDefaults.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nconst EDITOR_MODEL_DEFAULTS = {\n    tabSize: 4,\n    indentSize: 4,\n    insertSpaces: true,\n    detectIndentation: true,\n    trimAutoWhitespace: true,\n    largeFileOptimizations: true,\n    bracketPairColorizationOptions: {\n        enabled: true,\n        independentColorPoolPerBracketType: false,\n    },\n};\n\nexport { EDITOR_MODEL_DEFAULTS };\n"],"names":[],"mappings":"AAAA;;;8FAG8F;;;;AAC9F,MAAM,wBAAwB;IAC1B,SAAS;IACT,YAAY;IACZ,cAAc;IACd,mBAAmB;IACnB,oBAAoB;IACpB,wBAAwB;IACxB,gCAAgC;QAC5B,SAAS;QACT,oCAAoC;IACxC;AACJ","ignoreList":[0]}},
    {"offset": {"line": 28, "column": 0}, "map": {"version":3,"sources":["file:///D:/real-time-code-editor%20%282%29/node_modules/.pnpm/monaco-editor%400.55.1/node_modules/monaco-editor/esm/vs/editor/common/core/wordHelper.js"],"sourcesContent":["import { Iterable } from '../../../base/common/iterator.js';\nimport { LinkedList } from '../../../base/common/linkedList.js';\n\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nconst USUAL_WORD_SEPARATORS = '`~!@#$%^&*()-=+[{]}\\\\|;:\\'\",.<>/?';\n/**\n * Create a word definition regular expression based on default word separators.\n * Optionally provide allowed separators that should be included in words.\n *\n * The default would look like this:\n * /(-?\\d*\\.\\d\\w*)|([^\\`\\~\\!\\@\\#\\$\\%\\^\\&\\*\\(\\)\\-\\=\\+\\[\\{\\]\\}\\\\\\|\\;\\:\\'\\\"\\,\\.\\<\\>\\/\\?\\s]+)/g\n */\nfunction createWordRegExp(allowInWords = '') {\n    let source = '(-?\\\\d*\\\\.\\\\d\\\\w*)|([^';\n    for (const sep of USUAL_WORD_SEPARATORS) {\n        if (allowInWords.indexOf(sep) >= 0) {\n            continue;\n        }\n        source += '\\\\' + sep;\n    }\n    source += '\\\\s]+)';\n    return new RegExp(source, 'g');\n}\n// catches numbers (including floating numbers) in the first group, and alphanum in the second\nconst DEFAULT_WORD_REGEXP = createWordRegExp();\nfunction ensureValidWordDefinition(wordDefinition) {\n    let result = DEFAULT_WORD_REGEXP;\n    if (wordDefinition && (wordDefinition instanceof RegExp)) {\n        if (!wordDefinition.global) {\n            let flags = 'g';\n            if (wordDefinition.ignoreCase) {\n                flags += 'i';\n            }\n            if (wordDefinition.multiline) {\n                flags += 'm';\n            }\n            if (wordDefinition.unicode) {\n                flags += 'u';\n            }\n            result = new RegExp(wordDefinition.source, flags);\n        }\n        else {\n            result = wordDefinition;\n        }\n    }\n    result.lastIndex = 0;\n    return result;\n}\nconst _defaultConfig = new LinkedList();\n_defaultConfig.unshift({\n    maxLen: 1000,\n    windowSize: 15,\n    timeBudget: 150\n});\nfunction getWordAtText(column, wordDefinition, text, textOffset, config) {\n    // Ensure the regex has the 'g' flag, otherwise this will loop forever\n    wordDefinition = ensureValidWordDefinition(wordDefinition);\n    if (!config) {\n        config = Iterable.first(_defaultConfig);\n    }\n    if (text.length > config.maxLen) {\n        // don't throw strings that long at the regexp\n        // but use a sub-string in which a word must occur\n        let start = column - config.maxLen / 2;\n        if (start < 0) {\n            start = 0;\n        }\n        else {\n            textOffset += start;\n        }\n        text = text.substring(start, column + config.maxLen / 2);\n        return getWordAtText(column, wordDefinition, text, textOffset, config);\n    }\n    const t1 = Date.now();\n    const pos = column - 1 - textOffset;\n    let prevRegexIndex = -1;\n    let match = null;\n    for (let i = 1;; i++) {\n        // check time budget\n        if (Date.now() - t1 >= config.timeBudget) {\n            break;\n        }\n        // reset the index at which the regexp should start matching, also know where it\n        // should stop so that subsequent search don't repeat previous searches\n        const regexIndex = pos - config.windowSize * i;\n        wordDefinition.lastIndex = Math.max(0, regexIndex);\n        const thisMatch = _findRegexMatchEnclosingPosition(wordDefinition, text, pos, prevRegexIndex);\n        if (!thisMatch && match) {\n            // stop: we have something\n            break;\n        }\n        match = thisMatch;\n        // stop: searched at start\n        if (regexIndex <= 0) {\n            break;\n        }\n        prevRegexIndex = regexIndex;\n    }\n    if (match) {\n        const result = {\n            word: match[0],\n            startColumn: textOffset + 1 + match.index,\n            endColumn: textOffset + 1 + match.index + match[0].length\n        };\n        wordDefinition.lastIndex = 0;\n        return result;\n    }\n    return null;\n}\nfunction _findRegexMatchEnclosingPosition(wordDefinition, text, pos, stopPos) {\n    let match;\n    while (match = wordDefinition.exec(text)) {\n        const matchIndex = match.index || 0;\n        if (matchIndex <= pos && wordDefinition.lastIndex >= pos) {\n            return match;\n        }\n        else if (stopPos > 0 && matchIndex > stopPos) {\n            return null;\n        }\n    }\n    return null;\n}\n\nexport { DEFAULT_WORD_REGEXP, USUAL_WORD_SEPARATORS, ensureValidWordDefinition, getWordAtText };\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 163, "column": 0}, "map": {"version":3,"sources":["file:///D:/real-time-code-editor%20%282%29/node_modules/.pnpm/monaco-editor%400.55.1/node_modules/monaco-editor/esm/vs/editor/common/core/position.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n/**\n * A position in the editor.\n */\nclass Position {\n    constructor(lineNumber, column) {\n        this.lineNumber = lineNumber;\n        this.column = column;\n    }\n    /**\n     * Create a new position from this position.\n     *\n     * @param newLineNumber new line number\n     * @param newColumn new column\n     */\n    with(newLineNumber = this.lineNumber, newColumn = this.column) {\n        if (newLineNumber === this.lineNumber && newColumn === this.column) {\n            return this;\n        }\n        else {\n            return new Position(newLineNumber, newColumn);\n        }\n    }\n    /**\n     * Derive a new position from this position.\n     *\n     * @param deltaLineNumber line number delta\n     * @param deltaColumn column delta\n     */\n    delta(deltaLineNumber = 0, deltaColumn = 0) {\n        return this.with(Math.max(1, this.lineNumber + deltaLineNumber), Math.max(1, this.column + deltaColumn));\n    }\n    /**\n     * Test if this position equals other position\n     */\n    equals(other) {\n        return Position.equals(this, other);\n    }\n    /**\n     * Test if position `a` equals position `b`\n     */\n    static equals(a, b) {\n        if (!a && !b) {\n            return true;\n        }\n        return (!!a &&\n            !!b &&\n            a.lineNumber === b.lineNumber &&\n            a.column === b.column);\n    }\n    /**\n     * Test if this position is before other position.\n     * If the two positions are equal, the result will be false.\n     */\n    isBefore(other) {\n        return Position.isBefore(this, other);\n    }\n    /**\n     * Test if position `a` is before position `b`.\n     * If the two positions are equal, the result will be false.\n     */\n    static isBefore(a, b) {\n        if (a.lineNumber < b.lineNumber) {\n            return true;\n        }\n        if (b.lineNumber < a.lineNumber) {\n            return false;\n        }\n        return a.column < b.column;\n    }\n    /**\n     * Test if this position is before other position.\n     * If the two positions are equal, the result will be true.\n     */\n    isBeforeOrEqual(other) {\n        return Position.isBeforeOrEqual(this, other);\n    }\n    /**\n     * Test if position `a` is before position `b`.\n     * If the two positions are equal, the result will be true.\n     */\n    static isBeforeOrEqual(a, b) {\n        if (a.lineNumber < b.lineNumber) {\n            return true;\n        }\n        if (b.lineNumber < a.lineNumber) {\n            return false;\n        }\n        return a.column <= b.column;\n    }\n    /**\n     * A function that compares positions, useful for sorting\n     */\n    static compare(a, b) {\n        const aLineNumber = a.lineNumber | 0;\n        const bLineNumber = b.lineNumber | 0;\n        if (aLineNumber === bLineNumber) {\n            const aColumn = a.column | 0;\n            const bColumn = b.column | 0;\n            return aColumn - bColumn;\n        }\n        return aLineNumber - bLineNumber;\n    }\n    /**\n     * Clone this position.\n     */\n    clone() {\n        return new Position(this.lineNumber, this.column);\n    }\n    /**\n     * Convert to a human-readable representation.\n     */\n    toString() {\n        return '(' + this.lineNumber + ',' + this.column + ')';\n    }\n    // ---\n    /**\n     * Create a `Position` from an `IPosition`.\n     */\n    static lift(pos) {\n        return new Position(pos.lineNumber, pos.column);\n    }\n    /**\n     * Test if `obj` is an `IPosition`.\n     */\n    static isIPosition(obj) {\n        return (!!obj\n            && (typeof obj.lineNumber === 'number')\n            && (typeof obj.column === 'number'));\n    }\n    toJSON() {\n        return {\n            lineNumber: this.lineNumber,\n            column: this.column\n        };\n    }\n}\n\nexport { Position };\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 291, "column": 0}, "map": {"version":3,"sources":["file:///D:/real-time-code-editor%20%282%29/node_modules/.pnpm/monaco-editor%400.55.1/node_modules/monaco-editor/esm/vs/editor/common/core/range.js"],"sourcesContent":["import { Position } from './position.js';\n\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n/**\n * A range in the editor. (startLineNumber,startColumn) is <= (endLineNumber,endColumn)\n */\nclass Range {\n    constructor(startLineNumber, startColumn, endLineNumber, endColumn) {\n        if ((startLineNumber > endLineNumber) || (startLineNumber === endLineNumber && startColumn > endColumn)) {\n            this.startLineNumber = endLineNumber;\n            this.startColumn = endColumn;\n            this.endLineNumber = startLineNumber;\n            this.endColumn = startColumn;\n        }\n        else {\n            this.startLineNumber = startLineNumber;\n            this.startColumn = startColumn;\n            this.endLineNumber = endLineNumber;\n            this.endColumn = endColumn;\n        }\n    }\n    /**\n     * Test if this range is empty.\n     */\n    isEmpty() {\n        return Range.isEmpty(this);\n    }\n    /**\n     * Test if `range` is empty.\n     */\n    static isEmpty(range) {\n        return (range.startLineNumber === range.endLineNumber && range.startColumn === range.endColumn);\n    }\n    /**\n     * Test if position is in this range. If the position is at the edges, will return true.\n     */\n    containsPosition(position) {\n        return Range.containsPosition(this, position);\n    }\n    /**\n     * Test if `position` is in `range`. If the position is at the edges, will return true.\n     */\n    static containsPosition(range, position) {\n        if (position.lineNumber < range.startLineNumber || position.lineNumber > range.endLineNumber) {\n            return false;\n        }\n        if (position.lineNumber === range.startLineNumber && position.column < range.startColumn) {\n            return false;\n        }\n        if (position.lineNumber === range.endLineNumber && position.column > range.endColumn) {\n            return false;\n        }\n        return true;\n    }\n    /**\n     * Test if `position` is in `range`. If the position is at the edges, will return false.\n     * @internal\n     */\n    static strictContainsPosition(range, position) {\n        if (position.lineNumber < range.startLineNumber || position.lineNumber > range.endLineNumber) {\n            return false;\n        }\n        if (position.lineNumber === range.startLineNumber && position.column <= range.startColumn) {\n            return false;\n        }\n        if (position.lineNumber === range.endLineNumber && position.column >= range.endColumn) {\n            return false;\n        }\n        return true;\n    }\n    /**\n     * Test if range is in this range. If the range is equal to this range, will return true.\n     */\n    containsRange(range) {\n        return Range.containsRange(this, range);\n    }\n    /**\n     * Test if `otherRange` is in `range`. If the ranges are equal, will return true.\n     */\n    static containsRange(range, otherRange) {\n        if (otherRange.startLineNumber < range.startLineNumber || otherRange.endLineNumber < range.startLineNumber) {\n            return false;\n        }\n        if (otherRange.startLineNumber > range.endLineNumber || otherRange.endLineNumber > range.endLineNumber) {\n            return false;\n        }\n        if (otherRange.startLineNumber === range.startLineNumber && otherRange.startColumn < range.startColumn) {\n            return false;\n        }\n        if (otherRange.endLineNumber === range.endLineNumber && otherRange.endColumn > range.endColumn) {\n            return false;\n        }\n        return true;\n    }\n    /**\n     * Test if `range` is strictly in this range. `range` must start after and end before this range for the result to be true.\n     */\n    strictContainsRange(range) {\n        return Range.strictContainsRange(this, range);\n    }\n    /**\n     * Test if `otherRange` is strictly in `range` (must start after, and end before). If the ranges are equal, will return false.\n     */\n    static strictContainsRange(range, otherRange) {\n        if (otherRange.startLineNumber < range.startLineNumber || otherRange.endLineNumber < range.startLineNumber) {\n            return false;\n        }\n        if (otherRange.startLineNumber > range.endLineNumber || otherRange.endLineNumber > range.endLineNumber) {\n            return false;\n        }\n        if (otherRange.startLineNumber === range.startLineNumber && otherRange.startColumn <= range.startColumn) {\n            return false;\n        }\n        if (otherRange.endLineNumber === range.endLineNumber && otherRange.endColumn >= range.endColumn) {\n            return false;\n        }\n        return true;\n    }\n    /**\n     * A reunion of the two ranges.\n     * The smallest position will be used as the start point, and the largest one as the end point.\n     */\n    plusRange(range) {\n        return Range.plusRange(this, range);\n    }\n    /**\n     * A reunion of the two ranges.\n     * The smallest position will be used as the start point, and the largest one as the end point.\n     */\n    static plusRange(a, b) {\n        let startLineNumber;\n        let startColumn;\n        let endLineNumber;\n        let endColumn;\n        if (b.startLineNumber < a.startLineNumber) {\n            startLineNumber = b.startLineNumber;\n            startColumn = b.startColumn;\n        }\n        else if (b.startLineNumber === a.startLineNumber) {\n            startLineNumber = b.startLineNumber;\n            startColumn = Math.min(b.startColumn, a.startColumn);\n        }\n        else {\n            startLineNumber = a.startLineNumber;\n            startColumn = a.startColumn;\n        }\n        if (b.endLineNumber > a.endLineNumber) {\n            endLineNumber = b.endLineNumber;\n            endColumn = b.endColumn;\n        }\n        else if (b.endLineNumber === a.endLineNumber) {\n            endLineNumber = b.endLineNumber;\n            endColumn = Math.max(b.endColumn, a.endColumn);\n        }\n        else {\n            endLineNumber = a.endLineNumber;\n            endColumn = a.endColumn;\n        }\n        return new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n    }\n    /**\n     * A intersection of the two ranges.\n     */\n    intersectRanges(range) {\n        return Range.intersectRanges(this, range);\n    }\n    /**\n     * A intersection of the two ranges.\n     */\n    static intersectRanges(a, b) {\n        let resultStartLineNumber = a.startLineNumber;\n        let resultStartColumn = a.startColumn;\n        let resultEndLineNumber = a.endLineNumber;\n        let resultEndColumn = a.endColumn;\n        const otherStartLineNumber = b.startLineNumber;\n        const otherStartColumn = b.startColumn;\n        const otherEndLineNumber = b.endLineNumber;\n        const otherEndColumn = b.endColumn;\n        if (resultStartLineNumber < otherStartLineNumber) {\n            resultStartLineNumber = otherStartLineNumber;\n            resultStartColumn = otherStartColumn;\n        }\n        else if (resultStartLineNumber === otherStartLineNumber) {\n            resultStartColumn = Math.max(resultStartColumn, otherStartColumn);\n        }\n        if (resultEndLineNumber > otherEndLineNumber) {\n            resultEndLineNumber = otherEndLineNumber;\n            resultEndColumn = otherEndColumn;\n        }\n        else if (resultEndLineNumber === otherEndLineNumber) {\n            resultEndColumn = Math.min(resultEndColumn, otherEndColumn);\n        }\n        // Check if selection is now empty\n        if (resultStartLineNumber > resultEndLineNumber) {\n            return null;\n        }\n        if (resultStartLineNumber === resultEndLineNumber && resultStartColumn > resultEndColumn) {\n            return null;\n        }\n        return new Range(resultStartLineNumber, resultStartColumn, resultEndLineNumber, resultEndColumn);\n    }\n    /**\n     * Test if this range equals other.\n     */\n    equalsRange(other) {\n        return Range.equalsRange(this, other);\n    }\n    /**\n     * Test if range `a` equals `b`.\n     */\n    static equalsRange(a, b) {\n        if (!a && !b) {\n            return true;\n        }\n        return (!!a &&\n            !!b &&\n            a.startLineNumber === b.startLineNumber &&\n            a.startColumn === b.startColumn &&\n            a.endLineNumber === b.endLineNumber &&\n            a.endColumn === b.endColumn);\n    }\n    /**\n     * Return the end position (which will be after or equal to the start position)\n     */\n    getEndPosition() {\n        return Range.getEndPosition(this);\n    }\n    /**\n     * Return the end position (which will be after or equal to the start position)\n     */\n    static getEndPosition(range) {\n        return new Position(range.endLineNumber, range.endColumn);\n    }\n    /**\n     * Return the start position (which will be before or equal to the end position)\n     */\n    getStartPosition() {\n        return Range.getStartPosition(this);\n    }\n    /**\n     * Return the start position (which will be before or equal to the end position)\n     */\n    static getStartPosition(range) {\n        return new Position(range.startLineNumber, range.startColumn);\n    }\n    /**\n     * Transform to a user presentable string representation.\n     */\n    toString() {\n        return '[' + this.startLineNumber + ',' + this.startColumn + ' -> ' + this.endLineNumber + ',' + this.endColumn + ']';\n    }\n    /**\n     * Create a new range using this range's start position, and using endLineNumber and endColumn as the end position.\n     */\n    setEndPosition(endLineNumber, endColumn) {\n        return new Range(this.startLineNumber, this.startColumn, endLineNumber, endColumn);\n    }\n    /**\n     * Create a new range using this range's end position, and using startLineNumber and startColumn as the start position.\n     */\n    setStartPosition(startLineNumber, startColumn) {\n        return new Range(startLineNumber, startColumn, this.endLineNumber, this.endColumn);\n    }\n    /**\n     * Create a new empty range using this range's start position.\n     */\n    collapseToStart() {\n        return Range.collapseToStart(this);\n    }\n    /**\n     * Create a new empty range using this range's start position.\n     */\n    static collapseToStart(range) {\n        return new Range(range.startLineNumber, range.startColumn, range.startLineNumber, range.startColumn);\n    }\n    /**\n     * Create a new empty range using this range's end position.\n     */\n    collapseToEnd() {\n        return Range.collapseToEnd(this);\n    }\n    /**\n     * Create a new empty range using this range's end position.\n     */\n    static collapseToEnd(range) {\n        return new Range(range.endLineNumber, range.endColumn, range.endLineNumber, range.endColumn);\n    }\n    /**\n     * Moves the range by the given amount of lines.\n     */\n    delta(lineCount) {\n        return new Range(this.startLineNumber + lineCount, this.startColumn, this.endLineNumber + lineCount, this.endColumn);\n    }\n    isSingleLine() {\n        return this.startLineNumber === this.endLineNumber;\n    }\n    // ---\n    static fromPositions(start, end = start) {\n        return new Range(start.lineNumber, start.column, end.lineNumber, end.column);\n    }\n    static lift(range) {\n        if (!range) {\n            return null;\n        }\n        return new Range(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn);\n    }\n    /**\n     * Test if `obj` is an `IRange`.\n     */\n    static isIRange(obj) {\n        return (!!obj\n            && (typeof obj.startLineNumber === 'number')\n            && (typeof obj.startColumn === 'number')\n            && (typeof obj.endLineNumber === 'number')\n            && (typeof obj.endColumn === 'number'));\n    }\n    /**\n     * Test if the two ranges are touching in any way.\n     */\n    static areIntersectingOrTouching(a, b) {\n        // Check if `a` is before `b`\n        if (a.endLineNumber < b.startLineNumber || (a.endLineNumber === b.startLineNumber && a.endColumn < b.startColumn)) {\n            return false;\n        }\n        // Check if `b` is before `a`\n        if (b.endLineNumber < a.startLineNumber || (b.endLineNumber === a.startLineNumber && b.endColumn < a.startColumn)) {\n            return false;\n        }\n        // These ranges must intersect\n        return true;\n    }\n    /**\n     * Test if the two ranges are intersecting. If the ranges are touching it returns true.\n     */\n    static areIntersecting(a, b) {\n        // Check if `a` is before `b`\n        if (a.endLineNumber < b.startLineNumber || (a.endLineNumber === b.startLineNumber && a.endColumn <= b.startColumn)) {\n            return false;\n        }\n        // Check if `b` is before `a`\n        if (b.endLineNumber < a.startLineNumber || (b.endLineNumber === a.startLineNumber && b.endColumn <= a.startColumn)) {\n            return false;\n        }\n        // These ranges must intersect\n        return true;\n    }\n    /**\n     * Test if the two ranges are intersecting, but not touching at all.\n     */\n    static areOnlyIntersecting(a, b) {\n        // Check if `a` is before `b`\n        if (a.endLineNumber < (b.startLineNumber - 1) || (a.endLineNumber === b.startLineNumber && a.endColumn < (b.startColumn - 1))) {\n            return false;\n        }\n        // Check if `b` is before `a`\n        if (b.endLineNumber < (a.startLineNumber - 1) || (b.endLineNumber === a.startLineNumber && b.endColumn < (a.startColumn - 1))) {\n            return false;\n        }\n        // These ranges must intersect\n        return true;\n    }\n    /**\n     * A function that compares ranges, useful for sorting ranges\n     * It will first compare ranges on the startPosition and then on the endPosition\n     */\n    static compareRangesUsingStarts(a, b) {\n        if (a && b) {\n            const aStartLineNumber = a.startLineNumber | 0;\n            const bStartLineNumber = b.startLineNumber | 0;\n            if (aStartLineNumber === bStartLineNumber) {\n                const aStartColumn = a.startColumn | 0;\n                const bStartColumn = b.startColumn | 0;\n                if (aStartColumn === bStartColumn) {\n                    const aEndLineNumber = a.endLineNumber | 0;\n                    const bEndLineNumber = b.endLineNumber | 0;\n                    if (aEndLineNumber === bEndLineNumber) {\n                        const aEndColumn = a.endColumn | 0;\n                        const bEndColumn = b.endColumn | 0;\n                        return aEndColumn - bEndColumn;\n                    }\n                    return aEndLineNumber - bEndLineNumber;\n                }\n                return aStartColumn - bStartColumn;\n            }\n            return aStartLineNumber - bStartLineNumber;\n        }\n        const aExists = (a ? 1 : 0);\n        const bExists = (b ? 1 : 0);\n        return aExists - bExists;\n    }\n    /**\n     * A function that compares ranges, useful for sorting ranges\n     * It will first compare ranges on the endPosition and then on the startPosition\n     */\n    static compareRangesUsingEnds(a, b) {\n        if (a.endLineNumber === b.endLineNumber) {\n            if (a.endColumn === b.endColumn) {\n                if (a.startLineNumber === b.startLineNumber) {\n                    return a.startColumn - b.startColumn;\n                }\n                return a.startLineNumber - b.startLineNumber;\n            }\n            return a.endColumn - b.endColumn;\n        }\n        return a.endLineNumber - b.endLineNumber;\n    }\n    /**\n     * Test if the range spans multiple lines.\n     */\n    static spansMultipleLines(range) {\n        return range.endLineNumber > range.startLineNumber;\n    }\n    toJSON() {\n        return this;\n    }\n}\n\nexport { Range };\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 667, "column": 0}, "map": {"version":3,"sources":["file:///D:/real-time-code-editor%20%282%29/node_modules/.pnpm/monaco-editor%400.55.1/node_modules/monaco-editor/esm/vs/editor/common/core/selection.js"],"sourcesContent":["import { Position } from './position.js';\nimport { Range } from './range.js';\n\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n/**\n * A selection in the editor.\n * The selection is a range that has an orientation.\n */\nclass Selection extends Range {\n    constructor(selectionStartLineNumber, selectionStartColumn, positionLineNumber, positionColumn) {\n        super(selectionStartLineNumber, selectionStartColumn, positionLineNumber, positionColumn);\n        this.selectionStartLineNumber = selectionStartLineNumber;\n        this.selectionStartColumn = selectionStartColumn;\n        this.positionLineNumber = positionLineNumber;\n        this.positionColumn = positionColumn;\n    }\n    /**\n     * Transform to a human-readable representation.\n     */\n    toString() {\n        return '[' + this.selectionStartLineNumber + ',' + this.selectionStartColumn + ' -> ' + this.positionLineNumber + ',' + this.positionColumn + ']';\n    }\n    /**\n     * Test if equals other selection.\n     */\n    equalsSelection(other) {\n        return (Selection.selectionsEqual(this, other));\n    }\n    /**\n     * Test if the two selections are equal.\n     */\n    static selectionsEqual(a, b) {\n        return (a.selectionStartLineNumber === b.selectionStartLineNumber &&\n            a.selectionStartColumn === b.selectionStartColumn &&\n            a.positionLineNumber === b.positionLineNumber &&\n            a.positionColumn === b.positionColumn);\n    }\n    /**\n     * Get directions (LTR or RTL).\n     */\n    getDirection() {\n        if (this.selectionStartLineNumber === this.startLineNumber && this.selectionStartColumn === this.startColumn) {\n            return 0 /* SelectionDirection.LTR */;\n        }\n        return 1 /* SelectionDirection.RTL */;\n    }\n    /**\n     * Create a new selection with a different `positionLineNumber` and `positionColumn`.\n     */\n    setEndPosition(endLineNumber, endColumn) {\n        if (this.getDirection() === 0 /* SelectionDirection.LTR */) {\n            return new Selection(this.startLineNumber, this.startColumn, endLineNumber, endColumn);\n        }\n        return new Selection(endLineNumber, endColumn, this.startLineNumber, this.startColumn);\n    }\n    /**\n     * Get the position at `positionLineNumber` and `positionColumn`.\n     */\n    getPosition() {\n        return new Position(this.positionLineNumber, this.positionColumn);\n    }\n    /**\n     * Get the position at the start of the selection.\n    */\n    getSelectionStart() {\n        return new Position(this.selectionStartLineNumber, this.selectionStartColumn);\n    }\n    /**\n     * Create a new selection with a different `selectionStartLineNumber` and `selectionStartColumn`.\n     */\n    setStartPosition(startLineNumber, startColumn) {\n        if (this.getDirection() === 0 /* SelectionDirection.LTR */) {\n            return new Selection(startLineNumber, startColumn, this.endLineNumber, this.endColumn);\n        }\n        return new Selection(this.endLineNumber, this.endColumn, startLineNumber, startColumn);\n    }\n    // ----\n    /**\n     * Create a `Selection` from one or two positions\n     */\n    static fromPositions(start, end = start) {\n        return new Selection(start.lineNumber, start.column, end.lineNumber, end.column);\n    }\n    /**\n     * Creates a `Selection` from a range, given a direction.\n     */\n    static fromRange(range, direction) {\n        if (direction === 0 /* SelectionDirection.LTR */) {\n            return new Selection(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn);\n        }\n        else {\n            return new Selection(range.endLineNumber, range.endColumn, range.startLineNumber, range.startColumn);\n        }\n    }\n    /**\n     * Create a `Selection` from an `ISelection`.\n     */\n    static liftSelection(sel) {\n        return new Selection(sel.selectionStartLineNumber, sel.selectionStartColumn, sel.positionLineNumber, sel.positionColumn);\n    }\n    /**\n     * `a` equals `b`.\n     */\n    static selectionsArrEqual(a, b) {\n        if (a && !b || !a && b) {\n            return false;\n        }\n        if (!a && !b) {\n            return true;\n        }\n        if (a.length !== b.length) {\n            return false;\n        }\n        for (let i = 0, len = a.length; i < len; i++) {\n            if (!this.selectionsEqual(a[i], b[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n    /**\n     * Test if `obj` is an `ISelection`.\n     */\n    static isISelection(obj) {\n        return (!!obj\n            && (typeof obj.selectionStartLineNumber === 'number')\n            && (typeof obj.selectionStartColumn === 'number')\n            && (typeof obj.positionLineNumber === 'number')\n            && (typeof obj.positionColumn === 'number'));\n    }\n    /**\n     * Create with a direction.\n     */\n    static createWithDirection(startLineNumber, startColumn, endLineNumber, endColumn, direction) {\n        if (direction === 0 /* SelectionDirection.LTR */) {\n            return new Selection(startLineNumber, startColumn, endLineNumber, endColumn);\n        }\n        return new Selection(endLineNumber, endColumn, startLineNumber, startColumn);\n    }\n}\n\nexport { Selection };\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 796, "column": 0}, "map": {"version":3,"sources":["file:///D:/real-time-code-editor%20%282%29/node_modules/.pnpm/monaco-editor%400.55.1/node_modules/monaco-editor/esm/vs/editor/common/core/stringBuilder.js"],"sourcesContent":["import { isHighSurrogate } from '../../../base/common/strings.js';\nimport { isLittleEndian } from '../../../base/common/platform.js';\nimport { readUInt16LE } from '../../../base/common/buffer.js';\n\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nlet _utf16LE_TextDecoder;\nfunction getUTF16LE_TextDecoder() {\n    if (!_utf16LE_TextDecoder) {\n        _utf16LE_TextDecoder = new TextDecoder('UTF-16LE');\n    }\n    return _utf16LE_TextDecoder;\n}\nlet _utf16BE_TextDecoder;\nfunction getUTF16BE_TextDecoder() {\n    if (!_utf16BE_TextDecoder) {\n        _utf16BE_TextDecoder = new TextDecoder('UTF-16BE');\n    }\n    return _utf16BE_TextDecoder;\n}\nlet _platformTextDecoder;\nfunction getPlatformTextDecoder() {\n    if (!_platformTextDecoder) {\n        _platformTextDecoder = isLittleEndian() ? getUTF16LE_TextDecoder() : getUTF16BE_TextDecoder();\n    }\n    return _platformTextDecoder;\n}\nfunction decodeUTF16LE(source, offset, len) {\n    const view = new Uint16Array(source.buffer, offset, len);\n    if (len > 0 && (view[0] === 0xFEFF || view[0] === 0xFFFE)) {\n        // UTF16 sometimes starts with a BOM https://de.wikipedia.org/wiki/Byte_Order_Mark\n        // It looks like TextDecoder.decode will eat up a leading BOM (0xFEFF or 0xFFFE)\n        // We don't want that behavior because we know the string is UTF16LE and the BOM should be maintained\n        // So we use the manual decoder\n        return compatDecodeUTF16LE(source, offset, len);\n    }\n    return getUTF16LE_TextDecoder().decode(view);\n}\nfunction compatDecodeUTF16LE(source, offset, len) {\n    const result = [];\n    let resultLen = 0;\n    for (let i = 0; i < len; i++) {\n        const charCode = readUInt16LE(source, offset);\n        offset += 2;\n        result[resultLen++] = String.fromCharCode(charCode);\n    }\n    return result.join('');\n}\nclass StringBuilder {\n    constructor(capacity) {\n        this._capacity = capacity | 0;\n        this._buffer = new Uint16Array(this._capacity);\n        this._completedStrings = null;\n        this._bufferLength = 0;\n    }\n    reset() {\n        this._completedStrings = null;\n        this._bufferLength = 0;\n    }\n    build() {\n        if (this._completedStrings !== null) {\n            this._flushBuffer();\n            return this._completedStrings.join('');\n        }\n        return this._buildBuffer();\n    }\n    _buildBuffer() {\n        if (this._bufferLength === 0) {\n            return '';\n        }\n        const view = new Uint16Array(this._buffer.buffer, 0, this._bufferLength);\n        return getPlatformTextDecoder().decode(view);\n    }\n    _flushBuffer() {\n        const bufferString = this._buildBuffer();\n        this._bufferLength = 0;\n        if (this._completedStrings === null) {\n            this._completedStrings = [bufferString];\n        }\n        else {\n            this._completedStrings[this._completedStrings.length] = bufferString;\n        }\n    }\n    /**\n     * Append a char code (<2^16)\n     */\n    appendCharCode(charCode) {\n        const remainingSpace = this._capacity - this._bufferLength;\n        if (remainingSpace <= 1) {\n            if (remainingSpace === 0 || isHighSurrogate(charCode)) {\n                this._flushBuffer();\n            }\n        }\n        this._buffer[this._bufferLength++] = charCode;\n    }\n    /**\n     * Append an ASCII char code (<2^8)\n     */\n    appendASCIICharCode(charCode) {\n        if (this._bufferLength === this._capacity) {\n            // buffer is full\n            this._flushBuffer();\n        }\n        this._buffer[this._bufferLength++] = charCode;\n    }\n    appendString(str) {\n        const strLen = str.length;\n        if (this._bufferLength + strLen >= this._capacity) {\n            // This string does not fit in the remaining buffer space\n            this._flushBuffer();\n            this._completedStrings[this._completedStrings.length] = str;\n            return;\n        }\n        for (let i = 0; i < strLen; i++) {\n            this._buffer[this._bufferLength++] = str.charCodeAt(i);\n        }\n    }\n}\n\nexport { StringBuilder, decodeUTF16LE, getPlatformTextDecoder };\n"],"names":[],"mappings":";;;;;;;;AAAA;AACA;AACA;;;;AAEA;;;8FAG8F,GAC9F,IAAI;AACJ,SAAS;IACL,IAAI,CAAC,sBAAsB;QACvB,uBAAuB,IAAI,YAAY;IAC3C;IACA,OAAO;AACX;AACA,IAAI;AACJ,SAAS;IACL,IAAI,CAAC,sBAAsB;QACvB,uBAAuB,IAAI,YAAY;IAC3C;IACA,OAAO;AACX;AACA,IAAI;AACJ,SAAS;IACL,IAAI,CAAC,sBAAsB;QACvB,uBAAuB,IAAA,8PAAc,MAAK,2BAA2B;IACzE;IACA,OAAO;AACX;AACA,SAAS,cAAc,MAAM,EAAE,MAAM,EAAE,GAAG;IACtC,MAAM,OAAO,IAAI,YAAY,OAAO,MAAM,EAAE,QAAQ;IACpD,IAAI,MAAM,KAAK,CAAC,IAAI,CAAC,EAAE,KAAK,UAAU,IAAI,CAAC,EAAE,KAAK,MAAM,GAAG;QACvD,kFAAkF;QAClF,gFAAgF;QAChF,qGAAqG;QACrG,+BAA+B;QAC/B,OAAO,oBAAoB,QAAQ,QAAQ;IAC/C;IACA,OAAO,yBAAyB,MAAM,CAAC;AAC3C;AACA,SAAS,oBAAoB,MAAM,EAAE,MAAM,EAAE,GAAG;IAC5C,MAAM,SAAS,EAAE;IACjB,IAAI,YAAY;IAChB,IAAK,IAAI,IAAI,GAAG,IAAI,KAAK,IAAK;QAC1B,MAAM,WAAW,IAAA,0PAAY,EAAC,QAAQ;QACtC,UAAU;QACV,MAAM,CAAC,YAAY,GAAG,OAAO,YAAY,CAAC;IAC9C;IACA,OAAO,OAAO,IAAI,CAAC;AACvB;AACA,MAAM;IACF,YAAY,QAAQ,CAAE;QAClB,IAAI,CAAC,SAAS,GAAG,WAAW;QAC5B,IAAI,CAAC,OAAO,GAAG,IAAI,YAAY,IAAI,CAAC,SAAS;QAC7C,IAAI,CAAC,iBAAiB,GAAG;QACzB,IAAI,CAAC,aAAa,GAAG;IACzB;IACA,QAAQ;QACJ,IAAI,CAAC,iBAAiB,GAAG;QACzB,IAAI,CAAC,aAAa,GAAG;IACzB;IACA,QAAQ;QACJ,IAAI,IAAI,CAAC,iBAAiB,KAAK,MAAM;YACjC,IAAI,CAAC,YAAY;YACjB,OAAO,IAAI,CAAC,iBAAiB,CAAC,IAAI,CAAC;QACvC;QACA,OAAO,IAAI,CAAC,YAAY;IAC5B;IACA,eAAe;QACX,IAAI,IAAI,CAAC,aAAa,KAAK,GAAG;YAC1B,OAAO;QACX;QACA,MAAM,OAAO,IAAI,YAAY,IAAI,CAAC,OAAO,CAAC,MAAM,EAAE,GAAG,IAAI,CAAC,aAAa;QACvE,OAAO,yBAAyB,MAAM,CAAC;IAC3C;IACA,eAAe;QACX,MAAM,eAAe,IAAI,CAAC,YAAY;QACtC,IAAI,CAAC,aAAa,GAAG;QACrB,IAAI,IAAI,CAAC,iBAAiB,KAAK,MAAM;YACjC,IAAI,CAAC,iBAAiB,GAAG;gBAAC;aAAa;QAC3C,OACK;YACD,IAAI,CAAC,iBAAiB,CAAC,IAAI,CAAC,iBAAiB,CAAC,MAAM,CAAC,GAAG;QAC5D;IACJ;IACA;;KAEC,GACD,eAAe,QAAQ,EAAE;QACrB,MAAM,iBAAiB,IAAI,CAAC,SAAS,GAAG,IAAI,CAAC,aAAa;QAC1D,IAAI,kBAAkB,GAAG;YACrB,IAAI,mBAAmB,KAAK,IAAA,8PAAe,EAAC,WAAW;gBACnD,IAAI,CAAC,YAAY;YACrB;QACJ;QACA,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,aAAa,GAAG,GAAG;IACzC;IACA;;KAEC,GACD,oBAAoB,QAAQ,EAAE;QAC1B,IAAI,IAAI,CAAC,aAAa,KAAK,IAAI,CAAC,SAAS,EAAE;YACvC,iBAAiB;YACjB,IAAI,CAAC,YAAY;QACrB;QACA,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,aAAa,GAAG,GAAG;IACzC;IACA,aAAa,GAAG,EAAE;QACd,MAAM,SAAS,IAAI,MAAM;QACzB,IAAI,IAAI,CAAC,aAAa,GAAG,UAAU,IAAI,CAAC,SAAS,EAAE;YAC/C,yDAAyD;YACzD,IAAI,CAAC,YAAY;YACjB,IAAI,CAAC,iBAAiB,CAAC,IAAI,CAAC,iBAAiB,CAAC,MAAM,CAAC,GAAG;YACxD;QACJ;QACA,IAAK,IAAI,IAAI,GAAG,IAAI,QAAQ,IAAK;YAC7B,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,aAAa,GAAG,GAAG,IAAI,UAAU,CAAC;QACxD;IACJ;AACJ","ignoreList":[0]}},
    {"offset": {"line": 929, "column": 0}, "map": {"version":3,"sources":["file:///D:/real-time-code-editor%20%282%29/node_modules/.pnpm/monaco-editor%400.55.1/node_modules/monaco-editor/esm/vs/editor/common/core/characterClassifier.js"],"sourcesContent":["import { toUint8 } from '../../../base/common/uint.js';\n\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n/**\n * A fast character classifier that uses a compact array for ASCII values.\n */\nclass CharacterClassifier {\n    constructor(_defaultValue) {\n        const defaultValue = toUint8(_defaultValue);\n        this._defaultValue = defaultValue;\n        this._asciiMap = CharacterClassifier._createAsciiMap(defaultValue);\n        this._map = new Map();\n    }\n    static _createAsciiMap(defaultValue) {\n        const asciiMap = new Uint8Array(256);\n        asciiMap.fill(defaultValue);\n        return asciiMap;\n    }\n    set(charCode, _value) {\n        const value = toUint8(_value);\n        if (charCode >= 0 && charCode < 256) {\n            this._asciiMap[charCode] = value;\n        }\n        else {\n            this._map.set(charCode, value);\n        }\n    }\n    get(charCode) {\n        if (charCode >= 0 && charCode < 256) {\n            return this._asciiMap[charCode];\n        }\n        else {\n            return (this._map.get(charCode) || this._defaultValue);\n        }\n    }\n    clear() {\n        this._asciiMap.fill(this._defaultValue);\n        this._map.clear();\n    }\n}\nclass CharacterSet {\n    constructor() {\n        this._actual = new CharacterClassifier(0 /* Boolean.False */);\n    }\n    add(charCode) {\n        this._actual.set(charCode, 1 /* Boolean.True */);\n    }\n    has(charCode) {\n        return (this._actual.get(charCode) === 1 /* Boolean.True */);\n    }\n    clear() {\n        return this._actual.clear();\n    }\n}\n\nexport { CharacterClassifier, CharacterSet };\n"],"names":[],"mappings":";;;;;;AAAA;;AAEA;;;8FAG8F,GAC9F;;CAEC,GACD,MAAM;IACF,YAAY,aAAa,CAAE;QACvB,MAAM,eAAe,IAAA,mPAAO,EAAC;QAC7B,IAAI,CAAC,aAAa,GAAG;QACrB,IAAI,CAAC,SAAS,GAAG,oBAAoB,eAAe,CAAC;QACrD,IAAI,CAAC,IAAI,GAAG,IAAI;IACpB;IACA,OAAO,gBAAgB,YAAY,EAAE;QACjC,MAAM,WAAW,IAAI,WAAW;QAChC,SAAS,IAAI,CAAC;QACd,OAAO;IACX;IACA,IAAI,QAAQ,EAAE,MAAM,EAAE;QAClB,MAAM,QAAQ,IAAA,mPAAO,EAAC;QACtB,IAAI,YAAY,KAAK,WAAW,KAAK;YACjC,IAAI,CAAC,SAAS,CAAC,SAAS,GAAG;QAC/B,OACK;YACD,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,UAAU;QAC5B;IACJ;IACA,IAAI,QAAQ,EAAE;QACV,IAAI,YAAY,KAAK,WAAW,KAAK;YACjC,OAAO,IAAI,CAAC,SAAS,CAAC,SAAS;QACnC,OACK;YACD,OAAQ,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,aAAa,IAAI,CAAC,aAAa;QACzD;IACJ;IACA,QAAQ;QACJ,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,IAAI,CAAC,aAAa;QACtC,IAAI,CAAC,IAAI,CAAC,KAAK;IACnB;AACJ;AACA,MAAM;IACF,aAAc;QACV,IAAI,CAAC,OAAO,GAAG,IAAI,oBAAoB,EAAE,iBAAiB;IAC9D;IACA,IAAI,QAAQ,EAAE;QACV,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,UAAU,EAAE,gBAAgB;IACjD;IACA,IAAI,QAAQ,EAAE;QACV,OAAQ,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,cAAc,EAAE,gBAAgB;IAC7D;IACA,QAAQ;QACJ,OAAO,IAAI,CAAC,OAAO,CAAC,KAAK;IAC7B;AACJ","ignoreList":[0]}},
    {"offset": {"line": 993, "column": 0}, "map": {"version":3,"sources":["file:///D:/real-time-code-editor%20%282%29/node_modules/.pnpm/monaco-editor%400.55.1/node_modules/monaco-editor/esm/vs/editor/common/core/wordCharacterClassifier.js"],"sourcesContent":["import { safeIntl } from '../../../base/common/date.js';\nimport { LRUCache } from '../../../base/common/map.js';\nimport { CharacterClassifier } from './characterClassifier.js';\n\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nclass WordCharacterClassifier extends CharacterClassifier {\n    constructor(wordSeparators, intlSegmenterLocales) {\n        super(0 /* WordCharacterClass.Regular */);\n        this._segmenter = null;\n        this._cachedLine = null;\n        this._cachedSegments = [];\n        this.intlSegmenterLocales = intlSegmenterLocales;\n        if (this.intlSegmenterLocales.length > 0) {\n            this._segmenter = safeIntl.Segmenter(this.intlSegmenterLocales, { granularity: 'word' });\n        }\n        else {\n            this._segmenter = null;\n        }\n        for (let i = 0, len = wordSeparators.length; i < len; i++) {\n            this.set(wordSeparators.charCodeAt(i), 2 /* WordCharacterClass.WordSeparator */);\n        }\n        this.set(32 /* CharCode.Space */, 1 /* WordCharacterClass.Whitespace */);\n        this.set(9 /* CharCode.Tab */, 1 /* WordCharacterClass.Whitespace */);\n    }\n    findPrevIntlWordBeforeOrAtOffset(line, offset) {\n        let candidate = null;\n        for (const segment of this._getIntlSegmenterWordsOnLine(line)) {\n            if (segment.index > offset) {\n                break;\n            }\n            candidate = segment;\n        }\n        return candidate;\n    }\n    findNextIntlWordAtOrAfterOffset(lineContent, offset) {\n        for (const segment of this._getIntlSegmenterWordsOnLine(lineContent)) {\n            if (segment.index < offset) {\n                continue;\n            }\n            return segment;\n        }\n        return null;\n    }\n    _getIntlSegmenterWordsOnLine(line) {\n        if (!this._segmenter) {\n            return [];\n        }\n        // Check if the line has changed from the previous call\n        if (this._cachedLine === line) {\n            return this._cachedSegments;\n        }\n        // Update the cache with the new line\n        this._cachedLine = line;\n        this._cachedSegments = this._filterWordSegments(this._segmenter.value.segment(line));\n        return this._cachedSegments;\n    }\n    _filterWordSegments(segments) {\n        const result = [];\n        for (const segment of segments) {\n            if (this._isWordLike(segment)) {\n                result.push(segment);\n            }\n        }\n        return result;\n    }\n    _isWordLike(segment) {\n        if (segment.isWordLike) {\n            return true;\n        }\n        return false;\n    }\n}\nconst wordClassifierCache = new LRUCache(10);\nfunction getMapForWordSeparators(wordSeparators, intlSegmenterLocales) {\n    const key = `${wordSeparators}/${intlSegmenterLocales.join(',')}`;\n    let result = wordClassifierCache.get(key);\n    if (!result) {\n        result = new WordCharacterClassifier(wordSeparators, intlSegmenterLocales);\n        wordClassifierCache.set(key, result);\n    }\n    return result;\n}\n\nexport { WordCharacterClassifier, getMapForWordSeparators };\n"],"names":[],"mappings":";;;;;;AAAA;AACA;AACA;;;;AAEA;;;8FAG8F,GAC9F,MAAM,gCAAgC,wRAAmB;IACrD,YAAY,cAAc,EAAE,oBAAoB,CAAE;QAC9C,KAAK,CAAC,EAAE,8BAA8B;QACtC,IAAI,CAAC,UAAU,GAAG;QAClB,IAAI,CAAC,WAAW,GAAG;QACnB,IAAI,CAAC,eAAe,GAAG,EAAE;QACzB,IAAI,CAAC,oBAAoB,GAAG;QAC5B,IAAI,IAAI,CAAC,oBAAoB,CAAC,MAAM,GAAG,GAAG;YACtC,IAAI,CAAC,UAAU,GAAG,oPAAQ,CAAC,SAAS,CAAC,IAAI,CAAC,oBAAoB,EAAE;gBAAE,aAAa;YAAO;QAC1F,OACK;YACD,IAAI,CAAC,UAAU,GAAG;QACtB;QACA,IAAK,IAAI,IAAI,GAAG,MAAM,eAAe,MAAM,EAAE,IAAI,KAAK,IAAK;YACvD,IAAI,CAAC,GAAG,CAAC,eAAe,UAAU,CAAC,IAAI,EAAE,oCAAoC;QACjF;QACA,IAAI,CAAC,GAAG,CAAC,GAAG,kBAAkB,KAAI,EAAE,iCAAiC;QACrE,IAAI,CAAC,GAAG,CAAC,EAAE,gBAAgB,KAAI,EAAE,iCAAiC;IACtE;IACA,iCAAiC,IAAI,EAAE,MAAM,EAAE;QAC3C,IAAI,YAAY;QAChB,KAAK,MAAM,WAAW,IAAI,CAAC,4BAA4B,CAAC,MAAO;YAC3D,IAAI,QAAQ,KAAK,GAAG,QAAQ;gBACxB;YACJ;YACA,YAAY;QAChB;QACA,OAAO;IACX;IACA,gCAAgC,WAAW,EAAE,MAAM,EAAE;QACjD,KAAK,MAAM,WAAW,IAAI,CAAC,4BAA4B,CAAC,aAAc;YAClE,IAAI,QAAQ,KAAK,GAAG,QAAQ;gBACxB;YACJ;YACA,OAAO;QACX;QACA,OAAO;IACX;IACA,6BAA6B,IAAI,EAAE;QAC/B,IAAI,CAAC,IAAI,CAAC,UAAU,EAAE;YAClB,OAAO,EAAE;QACb;QACA,uDAAuD;QACvD,IAAI,IAAI,CAAC,WAAW,KAAK,MAAM;YAC3B,OAAO,IAAI,CAAC,eAAe;QAC/B;QACA,qCAAqC;QACrC,IAAI,CAAC,WAAW,GAAG;QACnB,IAAI,CAAC,eAAe,GAAG,IAAI,CAAC,mBAAmB,CAAC,IAAI,CAAC,UAAU,CAAC,KAAK,CAAC,OAAO,CAAC;QAC9E,OAAO,IAAI,CAAC,eAAe;IAC/B;IACA,oBAAoB,QAAQ,EAAE;QAC1B,MAAM,SAAS,EAAE;QACjB,KAAK,MAAM,WAAW,SAAU;YAC5B,IAAI,IAAI,CAAC,WAAW,CAAC,UAAU;gBAC3B,OAAO,IAAI,CAAC;YAChB;QACJ;QACA,OAAO;IACX;IACA,YAAY,OAAO,EAAE;QACjB,IAAI,QAAQ,UAAU,EAAE;YACpB,OAAO;QACX;QACA,OAAO;IACX;AACJ;AACA,MAAM,sBAAsB,IAAI,mPAAQ,CAAC;AACzC,SAAS,wBAAwB,cAAc,EAAE,oBAAoB;IACjE,MAAM,MAAM,GAAG,eAAe,CAAC,EAAE,qBAAqB,IAAI,CAAC,MAAM;IACjE,IAAI,SAAS,oBAAoB,GAAG,CAAC;IACrC,IAAI,CAAC,QAAQ;QACT,SAAS,IAAI,wBAAwB,gBAAgB;QACrD,oBAAoB,GAAG,CAAC,KAAK;IACjC;IACA,OAAO;AACX","ignoreList":[0]}},
    {"offset": {"line": 1091, "column": 0}, "map": {"version":3,"sources":["file:///D:/real-time-code-editor%20%282%29/node_modules/.pnpm/monaco-editor%400.55.1/node_modules/monaco-editor/esm/vs/editor/common/core/ranges/offsetRange.js"],"sourcesContent":["import { BugIndicatingError } from '../../../../base/common/errors.js';\n\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n/**\n * A range of offsets (0-based).\n*/\nclass OffsetRange {\n    static fromTo(start, endExclusive) {\n        return new OffsetRange(start, endExclusive);\n    }\n    static addRange(range, sortedRanges) {\n        let i = 0;\n        while (i < sortedRanges.length && sortedRanges[i].endExclusive < range.start) {\n            i++;\n        }\n        let j = i;\n        while (j < sortedRanges.length && sortedRanges[j].start <= range.endExclusive) {\n            j++;\n        }\n        if (i === j) {\n            sortedRanges.splice(i, 0, range);\n        }\n        else {\n            const start = Math.min(range.start, sortedRanges[i].start);\n            const end = Math.max(range.endExclusive, sortedRanges[j - 1].endExclusive);\n            sortedRanges.splice(i, j - i, new OffsetRange(start, end));\n        }\n    }\n    static tryCreate(start, endExclusive) {\n        if (start > endExclusive) {\n            return undefined;\n        }\n        return new OffsetRange(start, endExclusive);\n    }\n    static ofLength(length) {\n        return new OffsetRange(0, length);\n    }\n    static ofStartAndLength(start, length) {\n        return new OffsetRange(start, start + length);\n    }\n    static emptyAt(offset) {\n        return new OffsetRange(offset, offset);\n    }\n    constructor(start, endExclusive) {\n        this.start = start;\n        this.endExclusive = endExclusive;\n        if (start > endExclusive) {\n            throw new BugIndicatingError(`Invalid range: ${this.toString()}`);\n        }\n    }\n    get isEmpty() {\n        return this.start === this.endExclusive;\n    }\n    delta(offset) {\n        return new OffsetRange(this.start + offset, this.endExclusive + offset);\n    }\n    deltaStart(offset) {\n        return new OffsetRange(this.start + offset, this.endExclusive);\n    }\n    deltaEnd(offset) {\n        return new OffsetRange(this.start, this.endExclusive + offset);\n    }\n    get length() {\n        return this.endExclusive - this.start;\n    }\n    toString() {\n        return `[${this.start}, ${this.endExclusive})`;\n    }\n    equals(other) {\n        return this.start === other.start && this.endExclusive === other.endExclusive;\n    }\n    contains(offset) {\n        return this.start <= offset && offset < this.endExclusive;\n    }\n    /**\n     * for all numbers n: range1.contains(n) or range2.contains(n) => range1.join(range2).contains(n)\n     * The joined range is the smallest range that contains both ranges.\n     */\n    join(other) {\n        return new OffsetRange(Math.min(this.start, other.start), Math.max(this.endExclusive, other.endExclusive));\n    }\n    /**\n     * for all numbers n: range1.contains(n) and range2.contains(n) <=> range1.intersect(range2).contains(n)\n     *\n     * The resulting range is empty if the ranges do not intersect, but touch.\n     * If the ranges don't even touch, the result is undefined.\n     */\n    intersect(other) {\n        const start = Math.max(this.start, other.start);\n        const end = Math.min(this.endExclusive, other.endExclusive);\n        if (start <= end) {\n            return new OffsetRange(start, end);\n        }\n        return undefined;\n    }\n    intersectionLength(range) {\n        const start = Math.max(this.start, range.start);\n        const end = Math.min(this.endExclusive, range.endExclusive);\n        return Math.max(0, end - start);\n    }\n    intersects(other) {\n        const start = Math.max(this.start, other.start);\n        const end = Math.min(this.endExclusive, other.endExclusive);\n        return start < end;\n    }\n    intersectsOrTouches(other) {\n        const start = Math.max(this.start, other.start);\n        const end = Math.min(this.endExclusive, other.endExclusive);\n        return start <= end;\n    }\n    isBefore(other) {\n        return this.endExclusive <= other.start;\n    }\n    isAfter(other) {\n        return this.start >= other.endExclusive;\n    }\n    slice(arr) {\n        return arr.slice(this.start, this.endExclusive);\n    }\n    substring(str) {\n        return str.substring(this.start, this.endExclusive);\n    }\n    /**\n     * Returns the given value if it is contained in this instance, otherwise the closest value that is contained.\n     * The range must not be empty.\n     */\n    clip(value) {\n        if (this.isEmpty) {\n            throw new BugIndicatingError(`Invalid clipping range: ${this.toString()}`);\n        }\n        return Math.max(this.start, Math.min(this.endExclusive - 1, value));\n    }\n    /**\n     * Returns `r := value + k * length` such that `r` is contained in this range.\n     * The range must not be empty.\n     *\n     * E.g. `[5, 10).clipCyclic(10) === 5`, `[5, 10).clipCyclic(11) === 6` and `[5, 10).clipCyclic(4) === 9`.\n     */\n    clipCyclic(value) {\n        if (this.isEmpty) {\n            throw new BugIndicatingError(`Invalid clipping range: ${this.toString()}`);\n        }\n        if (value < this.start) {\n            return this.endExclusive - ((this.start - value) % this.length);\n        }\n        if (value >= this.endExclusive) {\n            return this.start + ((value - this.start) % this.length);\n        }\n        return value;\n    }\n    forEach(f) {\n        for (let i = this.start; i < this.endExclusive; i++) {\n            f(i);\n        }\n    }\n    /**\n     * this: [ 5, 10), range: [10, 15) => [5, 15)]\n     * Throws if the ranges are not touching.\n    */\n    joinRightTouching(range) {\n        if (this.endExclusive !== range.start) {\n            throw new BugIndicatingError(`Invalid join: ${this.toString()} and ${range.toString()}`);\n        }\n        return new OffsetRange(this.start, range.endExclusive);\n    }\n}\nclass OffsetRangeSet {\n    constructor() {\n        this._sortedRanges = [];\n    }\n    addRange(range) {\n        let i = 0;\n        while (i < this._sortedRanges.length && this._sortedRanges[i].endExclusive < range.start) {\n            i++;\n        }\n        let j = i;\n        while (j < this._sortedRanges.length && this._sortedRanges[j].start <= range.endExclusive) {\n            j++;\n        }\n        if (i === j) {\n            this._sortedRanges.splice(i, 0, range);\n        }\n        else {\n            const start = Math.min(range.start, this._sortedRanges[i].start);\n            const end = Math.max(range.endExclusive, this._sortedRanges[j - 1].endExclusive);\n            this._sortedRanges.splice(i, j - i, new OffsetRange(start, end));\n        }\n    }\n    toString() {\n        return this._sortedRanges.map(r => r.toString()).join(', ');\n    }\n    /**\n     * Returns of there is a value that is contained in this instance and the given range.\n     */\n    intersectsStrict(other) {\n        // TODO use binary search\n        let i = 0;\n        while (i < this._sortedRanges.length && this._sortedRanges[i].endExclusive <= other.start) {\n            i++;\n        }\n        return i < this._sortedRanges.length && this._sortedRanges[i].start < other.endExclusive;\n    }\n    intersectWithRange(other) {\n        // TODO use binary search + slice\n        const result = new OffsetRangeSet();\n        for (const range of this._sortedRanges) {\n            const intersection = range.intersect(other);\n            if (intersection) {\n                result.addRange(intersection);\n            }\n        }\n        return result;\n    }\n    intersectWithRangeLength(other) {\n        return this.intersectWithRange(other).length;\n    }\n    get length() {\n        return this._sortedRanges.reduce((prev, cur) => prev + cur.length, 0);\n    }\n}\n\nexport { OffsetRange, OffsetRangeSet };\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1315, "column": 0}, "map": {"version":3,"sources":["file:///D:/real-time-code-editor%20%282%29/node_modules/.pnpm/monaco-editor%400.55.1/node_modules/monaco-editor/esm/vs/editor/common/core/ranges/lineRange.js"],"sourcesContent":["import { BugIndicatingError } from '../../../../base/common/errors.js';\nimport { OffsetRange } from './offsetRange.js';\nimport { Range } from '../range.js';\nimport { findFirstIdxMonotonousOrArrLen, findLastIdxMonotonous, findLastMonotonous } from '../../../../base/common/arraysFind.js';\nimport { compareBy, numberComparator } from '../../../../base/common/arrays.js';\n\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n/**\n * A range of lines (1-based).\n */\nclass LineRange {\n    static ofLength(startLineNumber, length) {\n        return new LineRange(startLineNumber, startLineNumber + length);\n    }\n    static fromRange(range) {\n        return new LineRange(range.startLineNumber, range.endLineNumber);\n    }\n    static fromRangeInclusive(range) {\n        return new LineRange(range.startLineNumber, range.endLineNumber + 1);\n    }\n    static { this.compareByStart = compareBy(l => l.startLineNumber, numberComparator); }\n    /**\n     * @param lineRanges An array of arrays of of sorted line ranges.\n     */\n    static joinMany(lineRanges) {\n        if (lineRanges.length === 0) {\n            return [];\n        }\n        let result = new LineRangeSet(lineRanges[0].slice());\n        for (let i = 1; i < lineRanges.length; i++) {\n            result = result.getUnion(new LineRangeSet(lineRanges[i].slice()));\n        }\n        return result.ranges;\n    }\n    static join(lineRanges) {\n        if (lineRanges.length === 0) {\n            throw new BugIndicatingError('lineRanges cannot be empty');\n        }\n        let startLineNumber = lineRanges[0].startLineNumber;\n        let endLineNumberExclusive = lineRanges[0].endLineNumberExclusive;\n        for (let i = 1; i < lineRanges.length; i++) {\n            startLineNumber = Math.min(startLineNumber, lineRanges[i].startLineNumber);\n            endLineNumberExclusive = Math.max(endLineNumberExclusive, lineRanges[i].endLineNumberExclusive);\n        }\n        return new LineRange(startLineNumber, endLineNumberExclusive);\n    }\n    /**\n     * @internal\n     */\n    static deserialize(lineRange) {\n        return new LineRange(lineRange[0], lineRange[1]);\n    }\n    constructor(startLineNumber, endLineNumberExclusive) {\n        if (startLineNumber > endLineNumberExclusive) {\n            throw new BugIndicatingError(`startLineNumber ${startLineNumber} cannot be after endLineNumberExclusive ${endLineNumberExclusive}`);\n        }\n        this.startLineNumber = startLineNumber;\n        this.endLineNumberExclusive = endLineNumberExclusive;\n    }\n    /**\n     * Indicates if this line range contains the given line number.\n     */\n    contains(lineNumber) {\n        return this.startLineNumber <= lineNumber && lineNumber < this.endLineNumberExclusive;\n    }\n    /**\n     * Indicates if this line range is empty.\n     */\n    get isEmpty() {\n        return this.startLineNumber === this.endLineNumberExclusive;\n    }\n    /**\n     * Moves this line range by the given offset of line numbers.\n     */\n    delta(offset) {\n        return new LineRange(this.startLineNumber + offset, this.endLineNumberExclusive + offset);\n    }\n    deltaLength(offset) {\n        return new LineRange(this.startLineNumber, this.endLineNumberExclusive + offset);\n    }\n    /**\n     * The number of lines this line range spans.\n     */\n    get length() {\n        return this.endLineNumberExclusive - this.startLineNumber;\n    }\n    /**\n     * Creates a line range that combines this and the given line range.\n     */\n    join(other) {\n        return new LineRange(Math.min(this.startLineNumber, other.startLineNumber), Math.max(this.endLineNumberExclusive, other.endLineNumberExclusive));\n    }\n    toString() {\n        return `[${this.startLineNumber},${this.endLineNumberExclusive})`;\n    }\n    /**\n     * The resulting range is empty if the ranges do not intersect, but touch.\n     * If the ranges don't even touch, the result is undefined.\n     */\n    intersect(other) {\n        const startLineNumber = Math.max(this.startLineNumber, other.startLineNumber);\n        const endLineNumberExclusive = Math.min(this.endLineNumberExclusive, other.endLineNumberExclusive);\n        if (startLineNumber <= endLineNumberExclusive) {\n            return new LineRange(startLineNumber, endLineNumberExclusive);\n        }\n        return undefined;\n    }\n    intersectsStrict(other) {\n        return this.startLineNumber < other.endLineNumberExclusive && other.startLineNumber < this.endLineNumberExclusive;\n    }\n    intersectsOrTouches(other) {\n        return this.startLineNumber <= other.endLineNumberExclusive && other.startLineNumber <= this.endLineNumberExclusive;\n    }\n    equals(b) {\n        return this.startLineNumber === b.startLineNumber && this.endLineNumberExclusive === b.endLineNumberExclusive;\n    }\n    toInclusiveRange() {\n        if (this.isEmpty) {\n            return null;\n        }\n        return new Range(this.startLineNumber, 1, this.endLineNumberExclusive - 1, Number.MAX_SAFE_INTEGER);\n    }\n    /**\n     * @deprecated Using this function is discouraged because it might lead to bugs: The end position is not guaranteed to be a valid position!\n    */\n    toExclusiveRange() {\n        return new Range(this.startLineNumber, 1, this.endLineNumberExclusive, 1);\n    }\n    mapToLineArray(f) {\n        const result = [];\n        for (let lineNumber = this.startLineNumber; lineNumber < this.endLineNumberExclusive; lineNumber++) {\n            result.push(f(lineNumber));\n        }\n        return result;\n    }\n    forEach(f) {\n        for (let lineNumber = this.startLineNumber; lineNumber < this.endLineNumberExclusive; lineNumber++) {\n            f(lineNumber);\n        }\n    }\n    /**\n     * @internal\n     */\n    serialize() {\n        return [this.startLineNumber, this.endLineNumberExclusive];\n    }\n    /**\n     * Converts this 1-based line range to a 0-based offset range (subtracts 1!).\n     * @internal\n     */\n    toOffsetRange() {\n        return new OffsetRange(this.startLineNumber - 1, this.endLineNumberExclusive - 1);\n    }\n    addMargin(marginTop, marginBottom) {\n        return new LineRange(this.startLineNumber - marginTop, this.endLineNumberExclusive + marginBottom);\n    }\n}\nclass LineRangeSet {\n    constructor(\n    /**\n     * Sorted by start line number.\n     * No two line ranges are touching or intersecting.\n     */\n    _normalizedRanges = []) {\n        this._normalizedRanges = _normalizedRanges;\n    }\n    get ranges() {\n        return this._normalizedRanges;\n    }\n    addRange(range) {\n        if (range.length === 0) {\n            return;\n        }\n        // Idea: Find joinRange such that:\n        // replaceRange = _normalizedRanges.replaceRange(joinRange, range.joinAll(joinRange.map(idx => this._normalizedRanges[idx])))\n        // idx of first element that touches range or that is after range\n        const joinRangeStartIdx = findFirstIdxMonotonousOrArrLen(this._normalizedRanges, r => r.endLineNumberExclusive >= range.startLineNumber);\n        // idx of element after { last element that touches range or that is before range }\n        const joinRangeEndIdxExclusive = findLastIdxMonotonous(this._normalizedRanges, r => r.startLineNumber <= range.endLineNumberExclusive) + 1;\n        if (joinRangeStartIdx === joinRangeEndIdxExclusive) {\n            // If there is no element that touches range, then joinRangeStartIdx === joinRangeEndIdxExclusive and that value is the index of the element after range\n            this._normalizedRanges.splice(joinRangeStartIdx, 0, range);\n        }\n        else if (joinRangeStartIdx === joinRangeEndIdxExclusive - 1) {\n            // Else, there is an element that touches range and in this case it is both the first and last element. Thus we can replace it\n            const joinRange = this._normalizedRanges[joinRangeStartIdx];\n            this._normalizedRanges[joinRangeStartIdx] = joinRange.join(range);\n        }\n        else {\n            // First and last element are different - we need to replace the entire range\n            const joinRange = this._normalizedRanges[joinRangeStartIdx].join(this._normalizedRanges[joinRangeEndIdxExclusive - 1]).join(range);\n            this._normalizedRanges.splice(joinRangeStartIdx, joinRangeEndIdxExclusive - joinRangeStartIdx, joinRange);\n        }\n    }\n    contains(lineNumber) {\n        const rangeThatStartsBeforeEnd = findLastMonotonous(this._normalizedRanges, r => r.startLineNumber <= lineNumber);\n        return !!rangeThatStartsBeforeEnd && rangeThatStartsBeforeEnd.endLineNumberExclusive > lineNumber;\n    }\n    intersects(range) {\n        const rangeThatStartsBeforeEnd = findLastMonotonous(this._normalizedRanges, r => r.startLineNumber < range.endLineNumberExclusive);\n        return !!rangeThatStartsBeforeEnd && rangeThatStartsBeforeEnd.endLineNumberExclusive > range.startLineNumber;\n    }\n    getUnion(other) {\n        if (this._normalizedRanges.length === 0) {\n            return other;\n        }\n        if (other._normalizedRanges.length === 0) {\n            return this;\n        }\n        const result = [];\n        let i1 = 0;\n        let i2 = 0;\n        let current = null;\n        while (i1 < this._normalizedRanges.length || i2 < other._normalizedRanges.length) {\n            let next = null;\n            if (i1 < this._normalizedRanges.length && i2 < other._normalizedRanges.length) {\n                const lineRange1 = this._normalizedRanges[i1];\n                const lineRange2 = other._normalizedRanges[i2];\n                if (lineRange1.startLineNumber < lineRange2.startLineNumber) {\n                    next = lineRange1;\n                    i1++;\n                }\n                else {\n                    next = lineRange2;\n                    i2++;\n                }\n            }\n            else if (i1 < this._normalizedRanges.length) {\n                next = this._normalizedRanges[i1];\n                i1++;\n            }\n            else {\n                next = other._normalizedRanges[i2];\n                i2++;\n            }\n            if (current === null) {\n                current = next;\n            }\n            else {\n                if (current.endLineNumberExclusive >= next.startLineNumber) {\n                    // merge\n                    current = new LineRange(current.startLineNumber, Math.max(current.endLineNumberExclusive, next.endLineNumberExclusive));\n                }\n                else {\n                    // push\n                    result.push(current);\n                    current = next;\n                }\n            }\n        }\n        if (current !== null) {\n            result.push(current);\n        }\n        return new LineRangeSet(result);\n    }\n    /**\n     * Subtracts all ranges in this set from `range` and returns the result.\n     */\n    subtractFrom(range) {\n        // idx of first element that touches range or that is after range\n        const joinRangeStartIdx = findFirstIdxMonotonousOrArrLen(this._normalizedRanges, r => r.endLineNumberExclusive >= range.startLineNumber);\n        // idx of element after { last element that touches range or that is before range }\n        const joinRangeEndIdxExclusive = findLastIdxMonotonous(this._normalizedRanges, r => r.startLineNumber <= range.endLineNumberExclusive) + 1;\n        if (joinRangeStartIdx === joinRangeEndIdxExclusive) {\n            return new LineRangeSet([range]);\n        }\n        const result = [];\n        let startLineNumber = range.startLineNumber;\n        for (let i = joinRangeStartIdx; i < joinRangeEndIdxExclusive; i++) {\n            const r = this._normalizedRanges[i];\n            if (r.startLineNumber > startLineNumber) {\n                result.push(new LineRange(startLineNumber, r.startLineNumber));\n            }\n            startLineNumber = r.endLineNumberExclusive;\n        }\n        if (startLineNumber < range.endLineNumberExclusive) {\n            result.push(new LineRange(startLineNumber, range.endLineNumberExclusive));\n        }\n        return new LineRangeSet(result);\n    }\n    toString() {\n        return this._normalizedRanges.map(r => r.toString()).join(', ');\n    }\n    getIntersection(other) {\n        const result = [];\n        let i1 = 0;\n        let i2 = 0;\n        while (i1 < this._normalizedRanges.length && i2 < other._normalizedRanges.length) {\n            const r1 = this._normalizedRanges[i1];\n            const r2 = other._normalizedRanges[i2];\n            const i = r1.intersect(r2);\n            if (i && !i.isEmpty) {\n                result.push(i);\n            }\n            if (r1.endLineNumberExclusive < r2.endLineNumberExclusive) {\n                i1++;\n            }\n            else {\n                i2++;\n            }\n        }\n        return new LineRangeSet(result);\n    }\n    getWithDelta(value) {\n        return new LineRangeSet(this._normalizedRanges.map(r => r.delta(value)));\n    }\n}\n\nexport { LineRange, LineRangeSet };\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1623, "column": 0}, "map": {"version":3,"sources":["file:///D:/real-time-code-editor%20%282%29/node_modules/.pnpm/monaco-editor%400.55.1/node_modules/monaco-editor/esm/vs/editor/common/core/text/textLength.js"],"sourcesContent":["import { LineRange } from '../ranges/lineRange.js';\nimport { Position } from '../position.js';\nimport { Range } from '../range.js';\n\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n/**\n * Represents a non-negative length of text in terms of line and column count.\n*/\nclass TextLength {\n    static { this.zero = new TextLength(0, 0); }\n    static betweenPositions(position1, position2) {\n        if (position1.lineNumber === position2.lineNumber) {\n            return new TextLength(0, position2.column - position1.column);\n        }\n        else {\n            return new TextLength(position2.lineNumber - position1.lineNumber, position2.column - 1);\n        }\n    }\n    static fromPosition(pos) {\n        return new TextLength(pos.lineNumber - 1, pos.column - 1);\n    }\n    static ofRange(range) {\n        return TextLength.betweenPositions(range.getStartPosition(), range.getEndPosition());\n    }\n    static ofText(text) {\n        let line = 0;\n        let column = 0;\n        for (const c of text) {\n            if (c === '\\n') {\n                line++;\n                column = 0;\n            }\n            else {\n                column++;\n            }\n        }\n        return new TextLength(line, column);\n    }\n    constructor(lineCount, columnCount) {\n        this.lineCount = lineCount;\n        this.columnCount = columnCount;\n    }\n    isGreaterThanOrEqualTo(other) {\n        if (this.lineCount !== other.lineCount) {\n            return this.lineCount > other.lineCount;\n        }\n        return this.columnCount >= other.columnCount;\n    }\n    add(other) {\n        if (other.lineCount === 0) {\n            return new TextLength(this.lineCount, this.columnCount + other.columnCount);\n        }\n        else {\n            return new TextLength(this.lineCount + other.lineCount, other.columnCount);\n        }\n    }\n    createRange(startPosition) {\n        if (this.lineCount === 0) {\n            return new Range(startPosition.lineNumber, startPosition.column, startPosition.lineNumber, startPosition.column + this.columnCount);\n        }\n        else {\n            return new Range(startPosition.lineNumber, startPosition.column, startPosition.lineNumber + this.lineCount, this.columnCount + 1);\n        }\n    }\n    toRange() {\n        return new Range(1, 1, this.lineCount + 1, this.columnCount + 1);\n    }\n    toLineRange() {\n        return LineRange.ofLength(1, this.lineCount + 1);\n    }\n    addToPosition(position) {\n        if (this.lineCount === 0) {\n            return new Position(position.lineNumber, position.column + this.columnCount);\n        }\n        else {\n            return new Position(position.lineNumber + this.lineCount, this.columnCount + 1);\n        }\n    }\n    toString() {\n        return `${this.lineCount},${this.columnCount}`;\n    }\n}\n\nexport { TextLength };\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;;;;AAEA;;;8FAG8F,GAC9F;;AAEA,GACA,MAAM;IACF,MAAO;QAAE,IAAI,CAAC,IAAI,GAAG,IAAI,WAAW,GAAG;IAAI,CAAC;IAC5C,OAAO,iBAAiB,SAAS,EAAE,SAAS,EAAE;QAC1C,IAAI,UAAU,UAAU,KAAK,UAAU,UAAU,EAAE;YAC/C,OAAO,IAAI,WAAW,GAAG,UAAU,MAAM,GAAG,UAAU,MAAM;QAChE,OACK;YACD,OAAO,IAAI,WAAW,UAAU,UAAU,GAAG,UAAU,UAAU,EAAE,UAAU,MAAM,GAAG;QAC1F;IACJ;IACA,OAAO,aAAa,GAAG,EAAE;QACrB,OAAO,IAAI,WAAW,IAAI,UAAU,GAAG,GAAG,IAAI,MAAM,GAAG;IAC3D;IACA,OAAO,QAAQ,KAAK,EAAE;QAClB,OAAO,WAAW,gBAAgB,CAAC,MAAM,gBAAgB,IAAI,MAAM,cAAc;IACrF;IACA,OAAO,OAAO,IAAI,EAAE;QAChB,IAAI,OAAO;QACX,IAAI,SAAS;QACb,KAAK,MAAM,KAAK,KAAM;YAClB,IAAI,MAAM,MAAM;gBACZ;gBACA,SAAS;YACb,OACK;gBACD;YACJ;QACJ;QACA,OAAO,IAAI,WAAW,MAAM;IAChC;IACA,YAAY,SAAS,EAAE,WAAW,CAAE;QAChC,IAAI,CAAC,SAAS,GAAG;QACjB,IAAI,CAAC,WAAW,GAAG;IACvB;IACA,uBAAuB,KAAK,EAAE;QAC1B,IAAI,IAAI,CAAC,SAAS,KAAK,MAAM,SAAS,EAAE;YACpC,OAAO,IAAI,CAAC,SAAS,GAAG,MAAM,SAAS;QAC3C;QACA,OAAO,IAAI,CAAC,WAAW,IAAI,MAAM,WAAW;IAChD;IACA,IAAI,KAAK,EAAE;QACP,IAAI,MAAM,SAAS,KAAK,GAAG;YACvB,OAAO,IAAI,WAAW,IAAI,CAAC,SAAS,EAAE,IAAI,CAAC,WAAW,GAAG,MAAM,WAAW;QAC9E,OACK;YACD,OAAO,IAAI,WAAW,IAAI,CAAC,SAAS,GAAG,MAAM,SAAS,EAAE,MAAM,WAAW;QAC7E;IACJ;IACA,YAAY,aAAa,EAAE;QACvB,IAAI,IAAI,CAAC,SAAS,KAAK,GAAG;YACtB,OAAO,IAAI,4PAAK,CAAC,cAAc,UAAU,EAAE,cAAc,MAAM,EAAE,cAAc,UAAU,EAAE,cAAc,MAAM,GAAG,IAAI,CAAC,WAAW;QACtI,OACK;YACD,OAAO,IAAI,4PAAK,CAAC,cAAc,UAAU,EAAE,cAAc,MAAM,EAAE,cAAc,UAAU,GAAG,IAAI,CAAC,SAAS,EAAE,IAAI,CAAC,WAAW,GAAG;QACnI;IACJ;IACA,UAAU;QACN,OAAO,IAAI,4PAAK,CAAC,GAAG,GAAG,IAAI,CAAC,SAAS,GAAG,GAAG,IAAI,CAAC,WAAW,GAAG;IAClE;IACA,cAAc;QACV,OAAO,8QAAS,CAAC,QAAQ,CAAC,GAAG,IAAI,CAAC,SAAS,GAAG;IAClD;IACA,cAAc,QAAQ,EAAE;QACpB,IAAI,IAAI,CAAC,SAAS,KAAK,GAAG;YACtB,OAAO,IAAI,kQAAQ,CAAC,SAAS,UAAU,EAAE,SAAS,MAAM,GAAG,IAAI,CAAC,WAAW;QAC/E,OACK;YACD,OAAO,IAAI,kQAAQ,CAAC,SAAS,UAAU,GAAG,IAAI,CAAC,SAAS,EAAE,IAAI,CAAC,WAAW,GAAG;QACjF;IACJ;IACA,WAAW;QACP,OAAO,GAAG,IAAI,CAAC,SAAS,CAAC,CAAC,EAAE,IAAI,CAAC,WAAW,EAAE;IAClD;AACJ","ignoreList":[0]}},
    {"offset": {"line": 1714, "column": 0}, "map": {"version":3,"sources":["file:///D:/real-time-code-editor%20%282%29/node_modules/.pnpm/monaco-editor%400.55.1/node_modules/monaco-editor/esm/vs/editor/common/core/text/positionToOffsetImpl.js"],"sourcesContent":["import { findLastIdxMonotonous } from '../../../../base/common/arraysFind.js';\nimport { OffsetRange } from '../ranges/offsetRange.js';\nimport { Position } from '../position.js';\nimport { Range } from '../range.js';\n\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nclass PositionOffsetTransformerBase {\n    getOffsetRange(range) {\n        return new OffsetRange(this.getOffset(range.getStartPosition()), this.getOffset(range.getEndPosition()));\n    }\n    getRange(offsetRange) {\n        return Range.fromPositions(this.getPosition(offsetRange.start), this.getPosition(offsetRange.endExclusive));\n    }\n    getStringReplacement(edit) {\n        return new Deps.deps.StringReplacement(this.getOffsetRange(edit.range), edit.text);\n    }\n    getTextReplacement(edit) {\n        return new Deps.deps.TextReplacement(this.getRange(edit.replaceRange), edit.newText);\n    }\n    getTextEdit(edit) {\n        const edits = edit.replacements.map(e => this.getTextReplacement(e));\n        return new Deps.deps.TextEdit(edits);\n    }\n}\nclass Deps {\n    static { this._deps = undefined; }\n    static get deps() {\n        if (!this._deps) {\n            throw new Error('Dependencies not set. Call _setDependencies first.');\n        }\n        return this._deps;\n    }\n}\n/** This is to break circular module dependencies. */\nfunction _setPositionOffsetTransformerDependencies(deps) {\n    Deps._deps = deps;\n}\nclass PositionOffsetTransformer extends PositionOffsetTransformerBase {\n    constructor(text) {\n        super();\n        this.text = text;\n        this.lineStartOffsetByLineIdx = [];\n        this.lineEndOffsetByLineIdx = [];\n        this.lineStartOffsetByLineIdx.push(0);\n        for (let i = 0; i < text.length; i++) {\n            if (text.charAt(i) === '\\n') {\n                this.lineStartOffsetByLineIdx.push(i + 1);\n                if (i > 0 && text.charAt(i - 1) === '\\r') {\n                    this.lineEndOffsetByLineIdx.push(i - 1);\n                }\n                else {\n                    this.lineEndOffsetByLineIdx.push(i);\n                }\n            }\n        }\n        this.lineEndOffsetByLineIdx.push(text.length);\n    }\n    getOffset(position) {\n        const valPos = this._validatePosition(position);\n        return this.lineStartOffsetByLineIdx[valPos.lineNumber - 1] + valPos.column - 1;\n    }\n    _validatePosition(position) {\n        if (position.lineNumber < 1) {\n            return new Position(1, 1);\n        }\n        const lineCount = this.textLength.lineCount + 1;\n        if (position.lineNumber > lineCount) {\n            const lineLength = this.getLineLength(lineCount);\n            return new Position(lineCount, lineLength + 1);\n        }\n        if (position.column < 1) {\n            return new Position(position.lineNumber, 1);\n        }\n        const lineLength = this.getLineLength(position.lineNumber);\n        if (position.column - 1 > lineLength) {\n            return new Position(position.lineNumber, lineLength + 1);\n        }\n        return position;\n    }\n    getPosition(offset) {\n        const idx = findLastIdxMonotonous(this.lineStartOffsetByLineIdx, i => i <= offset);\n        const lineNumber = idx + 1;\n        const column = offset - this.lineStartOffsetByLineIdx[idx] + 1;\n        return new Position(lineNumber, column);\n    }\n    get textLength() {\n        const lineIdx = this.lineStartOffsetByLineIdx.length - 1;\n        return new Deps.deps.TextLength(lineIdx, this.text.length - this.lineStartOffsetByLineIdx[lineIdx]);\n    }\n    getLineLength(lineNumber) {\n        return this.lineEndOffsetByLineIdx[lineNumber - 1] - this.lineStartOffsetByLineIdx[lineNumber - 1];\n    }\n}\n\nexport { PositionOffsetTransformer, PositionOffsetTransformerBase, _setPositionOffsetTransformerDependencies };\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1825, "column": 0}, "map": {"version":3,"sources":["file:///D:/real-time-code-editor%20%282%29/node_modules/.pnpm/monaco-editor%400.55.1/node_modules/monaco-editor/esm/vs/editor/common/core/text/abstractText.js"],"sourcesContent":["import { assert } from '../../../../base/common/assert.js';\nimport { Position } from '../position.js';\nimport { Range } from '../range.js';\nimport { TextLength } from './textLength.js';\nimport { PositionOffsetTransformer } from './positionToOffsetImpl.js';\n\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nclass AbstractText {\n    constructor() {\n        this._transformer = undefined;\n    }\n    get endPositionExclusive() {\n        return this.length.addToPosition(new Position(1, 1));\n    }\n    get lineRange() {\n        return this.length.toLineRange();\n    }\n    getValue() {\n        return this.getValueOfRange(this.length.toRange());\n    }\n    getValueOfOffsetRange(range) {\n        return this.getValueOfRange(this.getTransformer().getRange(range));\n    }\n    getLineLength(lineNumber) {\n        return this.getValueOfRange(new Range(lineNumber, 1, lineNumber, Number.MAX_SAFE_INTEGER)).length;\n    }\n    getTransformer() {\n        if (!this._transformer) {\n            this._transformer = new PositionOffsetTransformer(this.getValue());\n        }\n        return this._transformer;\n    }\n    getLineAt(lineNumber) {\n        return this.getValueOfRange(new Range(lineNumber, 1, lineNumber, Number.MAX_SAFE_INTEGER));\n    }\n}\nclass LineBasedText extends AbstractText {\n    constructor(_getLineContent, _lineCount) {\n        assert(_lineCount >= 1);\n        super();\n        this._getLineContent = _getLineContent;\n        this._lineCount = _lineCount;\n    }\n    getValueOfRange(range) {\n        if (range.startLineNumber === range.endLineNumber) {\n            return this._getLineContent(range.startLineNumber).substring(range.startColumn - 1, range.endColumn - 1);\n        }\n        let result = this._getLineContent(range.startLineNumber).substring(range.startColumn - 1);\n        for (let i = range.startLineNumber + 1; i < range.endLineNumber; i++) {\n            result += '\\n' + this._getLineContent(i);\n        }\n        result += '\\n' + this._getLineContent(range.endLineNumber).substring(0, range.endColumn - 1);\n        return result;\n    }\n    getLineLength(lineNumber) {\n        return this._getLineContent(lineNumber).length;\n    }\n    get length() {\n        const lastLine = this._getLineContent(this._lineCount);\n        return new TextLength(this._lineCount - 1, lastLine.length);\n    }\n}\nclass ArrayText extends LineBasedText {\n    constructor(lines) {\n        super(lineNumber => lines[lineNumber - 1], lines.length);\n    }\n}\nclass StringText extends AbstractText {\n    constructor(value) {\n        super();\n        this.value = value;\n        this._t = new PositionOffsetTransformer(this.value);\n    }\n    getValueOfRange(range) {\n        return this._t.getOffsetRange(range).substring(this.value);\n    }\n    get length() {\n        return this._t.textLength;\n    }\n    // Override the getTransformer method to return the cached transformer\n    getTransformer() {\n        return this._t;\n    }\n}\n\nexport { AbstractText, ArrayText, LineBasedText, StringText };\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1930, "column": 0}, "map": {"version":3,"sources":["file:///D:/real-time-code-editor%20%282%29/node_modules/.pnpm/monaco-editor%400.55.1/node_modules/monaco-editor/esm/vs/editor/common/core/edits/textEdit.js"],"sourcesContent":["import { compareBy } from '../../../../base/common/arrays.js';\nimport { assertFn, checkAdjacentItems } from '../../../../base/common/assert.js';\nimport { BugIndicatingError } from '../../../../base/common/errors.js';\nimport { commonPrefixLength, commonSuffixLength } from '../../../../base/common/strings.js';\nimport { Position } from '../position.js';\nimport { Range } from '../range.js';\nimport { TextLength } from '../text/textLength.js';\nimport { StringText } from '../text/abstractText.js';\n\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nclass TextEdit {\n    static fromStringEdit(edit, initialState) {\n        const edits = edit.replacements.map(e => TextReplacement.fromStringReplacement(e, initialState));\n        return new TextEdit(edits);\n    }\n    static fromParallelReplacementsUnsorted(replacements) {\n        const r = replacements.slice().sort(compareBy(i => i.range, Range.compareRangesUsingStarts));\n        return new TextEdit(r);\n    }\n    constructor(replacements) {\n        this.replacements = replacements;\n        assertFn(() => checkAdjacentItems(replacements, (a, b) => a.range.getEndPosition().isBeforeOrEqual(b.range.getStartPosition())));\n    }\n    mapPosition(position) {\n        let lineDelta = 0;\n        let curLine = 0;\n        let columnDeltaInCurLine = 0;\n        for (const replacement of this.replacements) {\n            const start = replacement.range.getStartPosition();\n            if (position.isBeforeOrEqual(start)) {\n                break;\n            }\n            const end = replacement.range.getEndPosition();\n            const len = TextLength.ofText(replacement.text);\n            if (position.isBefore(end)) {\n                const startPos = new Position(start.lineNumber + lineDelta, start.column + (start.lineNumber + lineDelta === curLine ? columnDeltaInCurLine : 0));\n                const endPos = len.addToPosition(startPos);\n                return rangeFromPositions(startPos, endPos);\n            }\n            if (start.lineNumber + lineDelta !== curLine) {\n                columnDeltaInCurLine = 0;\n            }\n            lineDelta += len.lineCount - (replacement.range.endLineNumber - replacement.range.startLineNumber);\n            if (len.lineCount === 0) {\n                if (end.lineNumber !== start.lineNumber) {\n                    columnDeltaInCurLine += len.columnCount - (end.column - 1);\n                }\n                else {\n                    columnDeltaInCurLine += len.columnCount - (end.column - start.column);\n                }\n            }\n            else {\n                columnDeltaInCurLine = len.columnCount;\n            }\n            curLine = end.lineNumber + lineDelta;\n        }\n        return new Position(position.lineNumber + lineDelta, position.column + (position.lineNumber + lineDelta === curLine ? columnDeltaInCurLine : 0));\n    }\n    mapRange(range) {\n        function getStart(p) {\n            return p instanceof Position ? p : p.getStartPosition();\n        }\n        function getEnd(p) {\n            return p instanceof Position ? p : p.getEndPosition();\n        }\n        const start = getStart(this.mapPosition(range.getStartPosition()));\n        const end = getEnd(this.mapPosition(range.getEndPosition()));\n        return rangeFromPositions(start, end);\n    }\n    apply(text) {\n        let result = '';\n        let lastEditEnd = new Position(1, 1);\n        for (const replacement of this.replacements) {\n            const editRange = replacement.range;\n            const editStart = editRange.getStartPosition();\n            const editEnd = editRange.getEndPosition();\n            const r = rangeFromPositions(lastEditEnd, editStart);\n            if (!r.isEmpty()) {\n                result += text.getValueOfRange(r);\n            }\n            result += replacement.text;\n            lastEditEnd = editEnd;\n        }\n        const r = rangeFromPositions(lastEditEnd, text.endPositionExclusive);\n        if (!r.isEmpty()) {\n            result += text.getValueOfRange(r);\n        }\n        return result;\n    }\n    applyToString(str) {\n        const strText = new StringText(str);\n        return this.apply(strText);\n    }\n    getNewRanges() {\n        const newRanges = [];\n        let previousEditEndLineNumber = 0;\n        let lineOffset = 0;\n        let columnOffset = 0;\n        for (const replacement of this.replacements) {\n            const textLength = TextLength.ofText(replacement.text);\n            const newRangeStart = Position.lift({\n                lineNumber: replacement.range.startLineNumber + lineOffset,\n                column: replacement.range.startColumn + (replacement.range.startLineNumber === previousEditEndLineNumber ? columnOffset : 0)\n            });\n            const newRange = textLength.createRange(newRangeStart);\n            newRanges.push(newRange);\n            lineOffset = newRange.endLineNumber - replacement.range.endLineNumber;\n            columnOffset = newRange.endColumn - replacement.range.endColumn;\n            previousEditEndLineNumber = replacement.range.endLineNumber;\n        }\n        return newRanges;\n    }\n    toReplacement(text) {\n        if (this.replacements.length === 0) {\n            throw new BugIndicatingError();\n        }\n        if (this.replacements.length === 1) {\n            return this.replacements[0];\n        }\n        const startPos = this.replacements[0].range.getStartPosition();\n        const endPos = this.replacements[this.replacements.length - 1].range.getEndPosition();\n        let newText = '';\n        for (let i = 0; i < this.replacements.length; i++) {\n            const curEdit = this.replacements[i];\n            newText += curEdit.text;\n            if (i < this.replacements.length - 1) {\n                const nextEdit = this.replacements[i + 1];\n                const gapRange = Range.fromPositions(curEdit.range.getEndPosition(), nextEdit.range.getStartPosition());\n                const gapText = text.getValueOfRange(gapRange);\n                newText += gapText;\n            }\n        }\n        return new TextReplacement(Range.fromPositions(startPos, endPos), newText);\n    }\n    toString(text) {\n        if (text === undefined) {\n            return this.replacements.map(edit => edit.toString()).join('\\n');\n        }\n        if (typeof text === 'string') {\n            return this.toString(new StringText(text));\n        }\n        if (this.replacements.length === 0) {\n            return '';\n        }\n        return this.replacements.map(r => {\n            const maxLength = 10;\n            const originalText = text.getValueOfRange(r.range);\n            // Get text before the edit\n            const beforeRange = Range.fromPositions(new Position(Math.max(1, r.range.startLineNumber - 1), 1), r.range.getStartPosition());\n            let beforeText = text.getValueOfRange(beforeRange);\n            if (beforeText.length > maxLength) {\n                beforeText = '...' + beforeText.substring(beforeText.length - maxLength);\n            }\n            // Get text after the edit\n            const afterRange = Range.fromPositions(r.range.getEndPosition(), new Position(r.range.endLineNumber + 1, 1));\n            let afterText = text.getValueOfRange(afterRange);\n            if (afterText.length > maxLength) {\n                afterText = afterText.substring(0, maxLength) + '...';\n            }\n            // Format the replaced text\n            let replacedText = originalText;\n            if (replacedText.length > maxLength) {\n                const halfMax = Math.floor(maxLength / 2);\n                replacedText = replacedText.substring(0, halfMax) + '...' +\n                    replacedText.substring(replacedText.length - halfMax);\n            }\n            // Format the new text\n            let newText = r.text;\n            if (newText.length > maxLength) {\n                const halfMax = Math.floor(maxLength / 2);\n                newText = newText.substring(0, halfMax) + '...' +\n                    newText.substring(newText.length - halfMax);\n            }\n            if (replacedText.length === 0) {\n                // allow-any-unicode-next-line\n                return `${beforeText}${newText}${afterText}`;\n            }\n            // allow-any-unicode-next-line\n            return `${beforeText}${replacedText}${newText}${afterText}`;\n        }).join('\\n');\n    }\n}\nclass TextReplacement {\n    static joinReplacements(replacements, initialValue) {\n        if (replacements.length === 0) {\n            throw new BugIndicatingError();\n        }\n        if (replacements.length === 1) {\n            return replacements[0];\n        }\n        const startPos = replacements[0].range.getStartPosition();\n        const endPos = replacements[replacements.length - 1].range.getEndPosition();\n        let newText = '';\n        for (let i = 0; i < replacements.length; i++) {\n            const curEdit = replacements[i];\n            newText += curEdit.text;\n            if (i < replacements.length - 1) {\n                const nextEdit = replacements[i + 1];\n                const gapRange = Range.fromPositions(curEdit.range.getEndPosition(), nextEdit.range.getStartPosition());\n                const gapText = initialValue.getValueOfRange(gapRange);\n                newText += gapText;\n            }\n        }\n        return new TextReplacement(Range.fromPositions(startPos, endPos), newText);\n    }\n    static fromStringReplacement(replacement, initialState) {\n        return new TextReplacement(initialState.getTransformer().getRange(replacement.replaceRange), replacement.newText);\n    }\n    static delete(range) {\n        return new TextReplacement(range, '');\n    }\n    constructor(range, text) {\n        this.range = range;\n        this.text = text;\n    }\n    get isEmpty() {\n        return this.range.isEmpty() && this.text.length === 0;\n    }\n    static equals(first, second) {\n        return first.range.equalsRange(second.range) && first.text === second.text;\n    }\n    equals(other) {\n        return TextReplacement.equals(this, other);\n    }\n    removeCommonPrefixAndSuffix(text) {\n        const prefix = this.removeCommonPrefix(text);\n        const suffix = prefix.removeCommonSuffix(text);\n        return suffix;\n    }\n    removeCommonPrefix(text) {\n        const normalizedOriginalText = text.getValueOfRange(this.range).replaceAll('\\r\\n', '\\n');\n        const normalizedModifiedText = this.text.replaceAll('\\r\\n', '\\n');\n        const commonPrefixLen = commonPrefixLength(normalizedOriginalText, normalizedModifiedText);\n        const start = TextLength.ofText(normalizedOriginalText.substring(0, commonPrefixLen))\n            .addToPosition(this.range.getStartPosition());\n        const newText = normalizedModifiedText.substring(commonPrefixLen);\n        const range = Range.fromPositions(start, this.range.getEndPosition());\n        return new TextReplacement(range, newText);\n    }\n    removeCommonSuffix(text) {\n        const normalizedOriginalText = text.getValueOfRange(this.range).replaceAll('\\r\\n', '\\n');\n        const normalizedModifiedText = this.text.replaceAll('\\r\\n', '\\n');\n        const commonSuffixLen = commonSuffixLength(normalizedOriginalText, normalizedModifiedText);\n        const end = TextLength.ofText(normalizedOriginalText.substring(0, normalizedOriginalText.length - commonSuffixLen))\n            .addToPosition(this.range.getStartPosition());\n        const newText = normalizedModifiedText.substring(0, normalizedModifiedText.length - commonSuffixLen);\n        const range = Range.fromPositions(this.range.getStartPosition(), end);\n        return new TextReplacement(range, newText);\n    }\n    toString() {\n        const start = this.range.getStartPosition();\n        const end = this.range.getEndPosition();\n        return `(${start.lineNumber},${start.column} -> ${end.lineNumber},${end.column}): \"${this.text}\"`;\n    }\n}\nfunction rangeFromPositions(start, end) {\n    if (start.lineNumber === end.lineNumber && start.column === Number.MAX_SAFE_INTEGER) {\n        return Range.fromPositions(end, end);\n    }\n    else if (!start.isBeforeOrEqual(end)) {\n        throw new BugIndicatingError('start must be before end');\n    }\n    return new Range(start.lineNumber, start.column, end.lineNumber, end.column);\n}\n\nexport { TextEdit, TextReplacement };\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 2207, "column": 0}, "map": {"version":3,"sources":["file:///D:/real-time-code-editor%20%282%29/node_modules/.pnpm/monaco-editor%400.55.1/node_modules/monaco-editor/esm/vs/editor/common/core/cursorColumns.js"],"sourcesContent":["import { isFullWidthCharacter, isEmojiImprecise, GraphemeIterator, getNextCodePoint } from '../../../base/common/strings.js';\n\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n/**\n * A column in a position is the gap between two adjacent characters. The methods here\n * work with a concept called \"visible column\". A visible column is a very rough approximation\n * of the horizontal screen position of a column. For example, using a tab size of 4:\n * ```txt\n * |<TAB>|<TAB>|T|ext\n * |     |     | \\---- column = 4, visible column = 9\n * |     |     \\------ column = 3, visible column = 8\n * |     \\------------ column = 2, visible column = 4\n * \\------------------ column = 1, visible column = 0\n * ```\n *\n * **NOTE**: Visual columns do not work well for RTL text or variable-width fonts or characters.\n *\n * **NOTE**: These methods work and make sense both on the model and on the view model.\n */\nclass CursorColumns {\n    static _nextVisibleColumn(codePoint, visibleColumn, tabSize) {\n        if (codePoint === 9 /* CharCode.Tab */) {\n            return CursorColumns.nextRenderTabStop(visibleColumn, tabSize);\n        }\n        if (isFullWidthCharacter(codePoint) || isEmojiImprecise(codePoint)) {\n            return visibleColumn + 2;\n        }\n        return visibleColumn + 1;\n    }\n    /**\n     * Returns a visible column from a column.\n     * @see {@link CursorColumns}\n     */\n    static visibleColumnFromColumn(lineContent, column, tabSize) {\n        const textLen = Math.min(column - 1, lineContent.length);\n        const text = lineContent.substring(0, textLen);\n        const iterator = new GraphemeIterator(text);\n        let result = 0;\n        while (!iterator.eol()) {\n            const codePoint = getNextCodePoint(text, textLen, iterator.offset);\n            iterator.nextGraphemeLength();\n            result = this._nextVisibleColumn(codePoint, result, tabSize);\n        }\n        return result;\n    }\n    /**\n     * Returns a column from a visible column.\n     * @see {@link CursorColumns}\n     */\n    static columnFromVisibleColumn(lineContent, visibleColumn, tabSize) {\n        if (visibleColumn <= 0) {\n            return 1;\n        }\n        const lineContentLength = lineContent.length;\n        const iterator = new GraphemeIterator(lineContent);\n        let beforeVisibleColumn = 0;\n        let beforeColumn = 1;\n        while (!iterator.eol()) {\n            const codePoint = getNextCodePoint(lineContent, lineContentLength, iterator.offset);\n            iterator.nextGraphemeLength();\n            const afterVisibleColumn = this._nextVisibleColumn(codePoint, beforeVisibleColumn, tabSize);\n            const afterColumn = iterator.offset + 1;\n            if (afterVisibleColumn >= visibleColumn) {\n                const beforeDelta = visibleColumn - beforeVisibleColumn;\n                const afterDelta = afterVisibleColumn - visibleColumn;\n                if (afterDelta < beforeDelta) {\n                    return afterColumn;\n                }\n                else {\n                    return beforeColumn;\n                }\n            }\n            beforeVisibleColumn = afterVisibleColumn;\n            beforeColumn = afterColumn;\n        }\n        // walked the entire string\n        return lineContentLength + 1;\n    }\n    /**\n     * ATTENTION: This works with 0-based columns (as opposed to the regular 1-based columns)\n     * @see {@link CursorColumns}\n     */\n    static nextRenderTabStop(visibleColumn, tabSize) {\n        return visibleColumn + tabSize - visibleColumn % tabSize;\n    }\n    /**\n     * ATTENTION: This works with 0-based columns (as opposed to the regular 1-based columns)\n     * @see {@link CursorColumns}\n     */\n    static nextIndentTabStop(visibleColumn, indentSize) {\n        return CursorColumns.nextRenderTabStop(visibleColumn, indentSize);\n    }\n    /**\n     * ATTENTION: This works with 0-based columns (as opposed to the regular 1-based columns)\n     * @see {@link CursorColumns}\n     */\n    static prevRenderTabStop(column, tabSize) {\n        return Math.max(0, column - 1 - (column - 1) % tabSize);\n    }\n    /**\n     * ATTENTION: This works with 0-based columns (as opposed to the regular 1-based columns)\n     * @see {@link CursorColumns}\n     */\n    static prevIndentTabStop(column, indentSize) {\n        return CursorColumns.prevRenderTabStop(column, indentSize);\n    }\n}\n\nexport { CursorColumns };\n"],"names":[],"mappings":";;;;AAAA;;AAEA;;;8FAG8F,GAC9F;;;;;;;;;;;;;;;CAeC,GACD,MAAM;IACF,OAAO,mBAAmB,SAAS,EAAE,aAAa,EAAE,OAAO,EAAE;QACzD,IAAI,cAAc,EAAE,gBAAgB,KAAI;YACpC,OAAO,cAAc,iBAAiB,CAAC,eAAe;QAC1D;QACA,IAAI,IAAA,mQAAoB,EAAC,cAAc,IAAA,+PAAgB,EAAC,YAAY;YAChE,OAAO,gBAAgB;QAC3B;QACA,OAAO,gBAAgB;IAC3B;IACA;;;KAGC,GACD,OAAO,wBAAwB,WAAW,EAAE,MAAM,EAAE,OAAO,EAAE;QACzD,MAAM,UAAU,KAAK,GAAG,CAAC,SAAS,GAAG,YAAY,MAAM;QACvD,MAAM,OAAO,YAAY,SAAS,CAAC,GAAG;QACtC,MAAM,WAAW,IAAI,+PAAgB,CAAC;QACtC,IAAI,SAAS;QACb,MAAO,CAAC,SAAS,GAAG,GAAI;YACpB,MAAM,YAAY,IAAA,+PAAgB,EAAC,MAAM,SAAS,SAAS,MAAM;YACjE,SAAS,kBAAkB;YAC3B,SAAS,IAAI,CAAC,kBAAkB,CAAC,WAAW,QAAQ;QACxD;QACA,OAAO;IACX;IACA;;;KAGC,GACD,OAAO,wBAAwB,WAAW,EAAE,aAAa,EAAE,OAAO,EAAE;QAChE,IAAI,iBAAiB,GAAG;YACpB,OAAO;QACX;QACA,MAAM,oBAAoB,YAAY,MAAM;QAC5C,MAAM,WAAW,IAAI,+PAAgB,CAAC;QACtC,IAAI,sBAAsB;QAC1B,IAAI,eAAe;QACnB,MAAO,CAAC,SAAS,GAAG,GAAI;YACpB,MAAM,YAAY,IAAA,+PAAgB,EAAC,aAAa,mBAAmB,SAAS,MAAM;YAClF,SAAS,kBAAkB;YAC3B,MAAM,qBAAqB,IAAI,CAAC,kBAAkB,CAAC,WAAW,qBAAqB;YACnF,MAAM,cAAc,SAAS,MAAM,GAAG;YACtC,IAAI,sBAAsB,eAAe;gBACrC,MAAM,cAAc,gBAAgB;gBACpC,MAAM,aAAa,qBAAqB;gBACxC,IAAI,aAAa,aAAa;oBAC1B,OAAO;gBACX,OACK;oBACD,OAAO;gBACX;YACJ;YACA,sBAAsB;YACtB,eAAe;QACnB;QACA,2BAA2B;QAC3B,OAAO,oBAAoB;IAC/B;IACA;;;KAGC,GACD,OAAO,kBAAkB,aAAa,EAAE,OAAO,EAAE;QAC7C,OAAO,gBAAgB,UAAU,gBAAgB;IACrD;IACA;;;KAGC,GACD,OAAO,kBAAkB,aAAa,EAAE,UAAU,EAAE;QAChD,OAAO,cAAc,iBAAiB,CAAC,eAAe;IAC1D;IACA;;;KAGC,GACD,OAAO,kBAAkB,MAAM,EAAE,OAAO,EAAE;QACtC,OAAO,KAAK,GAAG,CAAC,GAAG,SAAS,IAAI,CAAC,SAAS,CAAC,IAAI;IACnD;IACA;;;KAGC,GACD,OAAO,kBAAkB,MAAM,EAAE,UAAU,EAAE;QACzC,OAAO,cAAc,iBAAiB,CAAC,QAAQ;IACnD;AACJ","ignoreList":[0]}},
    {"offset": {"line": 2317, "column": 0}, "map": {"version":3,"sources":["file:///D:/real-time-code-editor%20%282%29/node_modules/.pnpm/monaco-editor%400.55.1/node_modules/monaco-editor/esm/vs/editor/common/core/misc/indentation.js"],"sourcesContent":["import { firstNonWhitespaceIndex } from '../../../../base/common/strings.js';\nimport { CursorColumns } from '../cursorColumns.js';\n\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nfunction _normalizeIndentationFromWhitespace(str, indentSize, insertSpaces) {\n    let spacesCnt = 0;\n    for (let i = 0; i < str.length; i++) {\n        if (str.charAt(i) === '\\t') {\n            spacesCnt = CursorColumns.nextIndentTabStop(spacesCnt, indentSize);\n        }\n        else {\n            spacesCnt++;\n        }\n    }\n    let result = '';\n    if (!insertSpaces) {\n        const tabsCnt = Math.floor(spacesCnt / indentSize);\n        spacesCnt = spacesCnt % indentSize;\n        for (let i = 0; i < tabsCnt; i++) {\n            result += '\\t';\n        }\n    }\n    for (let i = 0; i < spacesCnt; i++) {\n        result += ' ';\n    }\n    return result;\n}\nfunction normalizeIndentation(str, indentSize, insertSpaces) {\n    let firstNonWhitespaceIndex$1 = firstNonWhitespaceIndex(str);\n    if (firstNonWhitespaceIndex$1 === -1) {\n        firstNonWhitespaceIndex$1 = str.length;\n    }\n    return _normalizeIndentationFromWhitespace(str.substring(0, firstNonWhitespaceIndex$1), indentSize, insertSpaces) + str.substring(firstNonWhitespaceIndex$1);\n}\n\nexport { normalizeIndentation };\n"],"names":[],"mappings":";;;;AAAA;AACA;;;AAEA;;;8FAG8F,GAC9F,SAAS,oCAAoC,GAAG,EAAE,UAAU,EAAE,YAAY;IACtE,IAAI,YAAY;IAChB,IAAK,IAAI,IAAI,GAAG,IAAI,IAAI,MAAM,EAAE,IAAK;QACjC,IAAI,IAAI,MAAM,CAAC,OAAO,MAAM;YACxB,YAAY,4QAAa,CAAC,iBAAiB,CAAC,WAAW;QAC3D,OACK;YACD;QACJ;IACJ;IACA,IAAI,SAAS;IACb,IAAI,CAAC,cAAc;QACf,MAAM,UAAU,KAAK,KAAK,CAAC,YAAY;QACvC,YAAY,YAAY;QACxB,IAAK,IAAI,IAAI,GAAG,IAAI,SAAS,IAAK;YAC9B,UAAU;QACd;IACJ;IACA,IAAK,IAAI,IAAI,GAAG,IAAI,WAAW,IAAK;QAChC,UAAU;IACd;IACA,OAAO;AACX;AACA,SAAS,qBAAqB,GAAG,EAAE,UAAU,EAAE,YAAY;IACvD,IAAI,4BAA4B,IAAA,sQAAuB,EAAC;IACxD,IAAI,8BAA8B,CAAC,GAAG;QAClC,4BAA4B,IAAI,MAAM;IAC1C;IACA,OAAO,oCAAoC,IAAI,SAAS,CAAC,GAAG,4BAA4B,YAAY,gBAAgB,IAAI,SAAS,CAAC;AACtI","ignoreList":[0]}},
    {"offset": {"line": 2362, "column": 0}, "map": {"version":3,"sources":["file:///D:/real-time-code-editor%20%282%29/node_modules/.pnpm/monaco-editor%400.55.1/node_modules/monaco-editor/esm/vs/editor/common/core/editorColorRegistry.js"],"sourcesContent":["import { localize } from '../../../nls.js';\nimport { Color, RGBA } from '../../../base/common/color.js';\nimport { registerColor } from '../../../platform/theme/common/colorUtils.js';\nimport { contrastBorder, activeContrastBorder } from '../../../platform/theme/common/colors/baseColors.js';\nimport '../../../platform/theme/common/colors/chartsColors.js';\nimport { editorFindMatchHighlight, editorBackground, editorWarningBorder, editorWarningForeground, editorInfoBorder, editorInfoForeground, editorWarningBackground } from '../../../platform/theme/common/colors/editorColors.js';\nimport '../../../platform/theme/common/colors/inputColors.js';\nimport '../../../platform/theme/common/colors/listColors.js';\nimport '../../../platform/theme/common/colors/menuColors.js';\nimport '../../../platform/theme/common/colors/minimapColors.js';\nimport '../../../platform/theme/common/colors/miscColors.js';\nimport '../../../platform/theme/common/colors/quickpickColors.js';\nimport '../../../platform/theme/common/colors/searchColors.js';\nimport { registerThemingParticipant } from '../../../platform/theme/common/themeService.js';\n\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n/**\n * Definition of the editor colors\n */\nconst editorLineHighlight = registerColor('editor.lineHighlightBackground', null, localize(610, 'Background color for the highlight of line at the cursor position.'));\nconst editorLineHighlightBorder = registerColor('editor.lineHighlightBorder', { dark: '#282828', light: '#eeeeee', hcDark: '#f38518', hcLight: contrastBorder }, localize(611, 'Background color for the border around the line at the cursor position.'));\nregisterColor('editor.rangeHighlightBackground', { dark: '#ffffff0b', light: '#fdff0033', hcDark: null, hcLight: null }, localize(612, 'Background color of highlighted ranges, like by quick open and find features. The color must not be opaque so as not to hide underlying decorations.'), true);\nregisterColor('editor.rangeHighlightBorder', { dark: null, light: null, hcDark: activeContrastBorder, hcLight: activeContrastBorder }, localize(613, 'Background color of the border around highlighted ranges.'));\nregisterColor('editor.symbolHighlightBackground', { dark: editorFindMatchHighlight, light: editorFindMatchHighlight, hcDark: null, hcLight: null }, localize(614, 'Background color of highlighted symbol, like for go to definition or go next/previous symbol. The color must not be opaque so as not to hide underlying decorations.'), true);\nregisterColor('editor.symbolHighlightBorder', { dark: null, light: null, hcDark: activeContrastBorder, hcLight: activeContrastBorder }, localize(615, 'Background color of the border around highlighted symbols.'));\nconst editorCursorForeground = registerColor('editorCursor.foreground', { dark: '#AEAFAD', light: Color.black, hcDark: Color.white, hcLight: '#0F4A85' }, localize(616, 'Color of the editor cursor.'));\nconst editorCursorBackground = registerColor('editorCursor.background', null, localize(617, 'The background color of the editor cursor. Allows customizing the color of a character overlapped by a block cursor.'));\nconst editorMultiCursorPrimaryForeground = registerColor('editorMultiCursor.primary.foreground', editorCursorForeground, localize(618, 'Color of the primary editor cursor when multiple cursors are present.'));\nconst editorMultiCursorPrimaryBackground = registerColor('editorMultiCursor.primary.background', editorCursorBackground, localize(619, 'The background color of the primary editor cursor when multiple cursors are present. Allows customizing the color of a character overlapped by a block cursor.'));\nconst editorMultiCursorSecondaryForeground = registerColor('editorMultiCursor.secondary.foreground', editorCursorForeground, localize(620, 'Color of secondary editor cursors when multiple cursors are present.'));\nconst editorMultiCursorSecondaryBackground = registerColor('editorMultiCursor.secondary.background', editorCursorBackground, localize(621, 'The background color of secondary editor cursors when multiple cursors are present. Allows customizing the color of a character overlapped by a block cursor.'));\nconst editorWhitespaces = registerColor('editorWhitespace.foreground', { dark: '#e3e4e229', light: '#33333333', hcDark: '#e3e4e229', hcLight: '#CCCCCC' }, localize(622, 'Color of whitespace characters in the editor.'));\nconst editorLineNumbers = registerColor('editorLineNumber.foreground', { dark: '#858585', light: '#237893', hcDark: Color.white, hcLight: '#292929' }, localize(623, 'Color of editor line numbers.'));\nconst deprecatedEditorIndentGuides = registerColor('editorIndentGuide.background', editorWhitespaces, localize(624, 'Color of the editor indentation guides.'), false, localize(625, '\\'editorIndentGuide.background\\' is deprecated. Use \\'editorIndentGuide.background1\\' instead.'));\nconst deprecatedEditorActiveIndentGuides = registerColor('editorIndentGuide.activeBackground', editorWhitespaces, localize(626, 'Color of the active editor indentation guides.'), false, localize(627, '\\'editorIndentGuide.activeBackground\\' is deprecated. Use \\'editorIndentGuide.activeBackground1\\' instead.'));\nconst editorIndentGuide1 = registerColor('editorIndentGuide.background1', deprecatedEditorIndentGuides, localize(628, 'Color of the editor indentation guides (1).'));\nconst editorIndentGuide2 = registerColor('editorIndentGuide.background2', '#00000000', localize(629, 'Color of the editor indentation guides (2).'));\nconst editorIndentGuide3 = registerColor('editorIndentGuide.background3', '#00000000', localize(630, 'Color of the editor indentation guides (3).'));\nconst editorIndentGuide4 = registerColor('editorIndentGuide.background4', '#00000000', localize(631, 'Color of the editor indentation guides (4).'));\nconst editorIndentGuide5 = registerColor('editorIndentGuide.background5', '#00000000', localize(632, 'Color of the editor indentation guides (5).'));\nconst editorIndentGuide6 = registerColor('editorIndentGuide.background6', '#00000000', localize(633, 'Color of the editor indentation guides (6).'));\nconst editorActiveIndentGuide1 = registerColor('editorIndentGuide.activeBackground1', deprecatedEditorActiveIndentGuides, localize(634, 'Color of the active editor indentation guides (1).'));\nconst editorActiveIndentGuide2 = registerColor('editorIndentGuide.activeBackground2', '#00000000', localize(635, 'Color of the active editor indentation guides (2).'));\nconst editorActiveIndentGuide3 = registerColor('editorIndentGuide.activeBackground3', '#00000000', localize(636, 'Color of the active editor indentation guides (3).'));\nconst editorActiveIndentGuide4 = registerColor('editorIndentGuide.activeBackground4', '#00000000', localize(637, 'Color of the active editor indentation guides (4).'));\nconst editorActiveIndentGuide5 = registerColor('editorIndentGuide.activeBackground5', '#00000000', localize(638, 'Color of the active editor indentation guides (5).'));\nconst editorActiveIndentGuide6 = registerColor('editorIndentGuide.activeBackground6', '#00000000', localize(639, 'Color of the active editor indentation guides (6).'));\nconst deprecatedEditorActiveLineNumber = registerColor('editorActiveLineNumber.foreground', { dark: '#c6c6c6', light: '#0B216F', hcDark: activeContrastBorder, hcLight: activeContrastBorder }, localize(640, 'Color of editor active line number'), false, localize(641, 'Id is deprecated. Use \\'editorLineNumber.activeForeground\\' instead.'));\nregisterColor('editorLineNumber.activeForeground', deprecatedEditorActiveLineNumber, localize(642, 'Color of editor active line number'));\nconst editorDimmedLineNumber = registerColor('editorLineNumber.dimmedForeground', null, localize(643, 'Color of the final editor line when editor.renderFinalNewline is set to dimmed.'));\nconst editorRuler = registerColor('editorRuler.foreground', { dark: '#5A5A5A', light: Color.lightgrey, hcDark: Color.white, hcLight: '#292929' }, localize(644, 'Color of the editor rulers.'));\nregisterColor('editorCodeLens.foreground', { dark: '#999999', light: '#919191', hcDark: '#999999', hcLight: '#292929' }, localize(645, 'Foreground color of editor CodeLens'));\nregisterColor('editorBracketMatch.background', { dark: '#0064001a', light: '#0064001a', hcDark: '#0064001a', hcLight: '#0000' }, localize(646, 'Background color behind matching brackets'));\nregisterColor('editorBracketMatch.border', { dark: '#888', light: '#B9B9B9', hcDark: contrastBorder, hcLight: contrastBorder }, localize(647, 'Color for matching brackets boxes'));\nconst editorOverviewRulerBorder = registerColor('editorOverviewRuler.border', { dark: '#7f7f7f4d', light: '#7f7f7f4d', hcDark: '#7f7f7f4d', hcLight: '#666666' }, localize(648, 'Color of the overview ruler border.'));\nconst editorOverviewRulerBackground = registerColor('editorOverviewRuler.background', null, localize(649, 'Background color of the editor overview ruler.'));\nregisterColor('editorGutter.background', editorBackground, localize(650, 'Background color of the editor gutter. The gutter contains the glyph margins and the line numbers.'));\nregisterColor('editorUnnecessaryCode.border', { dark: null, light: null, hcDark: Color.fromHex('#fff').transparent(0.8), hcLight: contrastBorder }, localize(651, 'Border color of unnecessary (unused) source code in the editor.'));\nconst editorUnnecessaryCodeOpacity = registerColor('editorUnnecessaryCode.opacity', { dark: Color.fromHex('#000a'), light: Color.fromHex('#0007'), hcDark: null, hcLight: null }, localize(652, 'Opacity of unnecessary (unused) source code in the editor. For example, \"#000000c0\" will render the code with 75% opacity. For high contrast themes, use the  \\'editorUnnecessaryCode.border\\' theme color to underline unnecessary code instead of fading it out.'));\nregisterColor('editorGhostText.border', { dark: null, light: null, hcDark: Color.fromHex('#fff').transparent(0.8), hcLight: Color.fromHex('#292929').transparent(0.8) }, localize(653, 'Border color of ghost text in the editor.'));\nconst ghostTextForeground = registerColor('editorGhostText.foreground', { dark: Color.fromHex('#ffffff56'), light: Color.fromHex('#0007'), hcDark: null, hcLight: null }, localize(654, 'Foreground color of the ghost text in the editor.'));\nregisterColor('editorGhostText.background', null, localize(655, 'Background color of the ghost text in the editor.'));\nconst rulerRangeDefault = new Color(new RGBA(0, 122, 204, 0.6));\nconst overviewRulerRangeHighlight = registerColor('editorOverviewRuler.rangeHighlightForeground', rulerRangeDefault, localize(656, 'Overview ruler marker color for range highlights. The color must not be opaque so as not to hide underlying decorations.'), true);\nconst overviewRulerError = registerColor('editorOverviewRuler.errorForeground', { dark: new Color(new RGBA(255, 18, 18, 0.7)), light: new Color(new RGBA(255, 18, 18, 0.7)), hcDark: new Color(new RGBA(255, 50, 50, 1)), hcLight: '#B5200D' }, localize(657, 'Overview ruler marker color for errors.'));\nconst overviewRulerWarning = registerColor('editorOverviewRuler.warningForeground', { dark: editorWarningForeground, light: editorWarningForeground, hcDark: editorWarningBorder, hcLight: editorWarningBorder }, localize(658, 'Overview ruler marker color for warnings.'));\nconst overviewRulerInfo = registerColor('editorOverviewRuler.infoForeground', { dark: editorInfoForeground, light: editorInfoForeground, hcDark: editorInfoBorder, hcLight: editorInfoBorder }, localize(659, 'Overview ruler marker color for infos.'));\nconst editorBracketHighlightingForeground1 = registerColor('editorBracketHighlight.foreground1', { dark: '#FFD700', light: '#0431FAFF', hcDark: '#FFD700', hcLight: '#0431FAFF' }, localize(660, 'Foreground color of brackets (1). Requires enabling bracket pair colorization.'));\nconst editorBracketHighlightingForeground2 = registerColor('editorBracketHighlight.foreground2', { dark: '#DA70D6', light: '#319331FF', hcDark: '#DA70D6', hcLight: '#319331FF' }, localize(661, 'Foreground color of brackets (2). Requires enabling bracket pair colorization.'));\nconst editorBracketHighlightingForeground3 = registerColor('editorBracketHighlight.foreground3', { dark: '#179FFF', light: '#7B3814FF', hcDark: '#87CEFA', hcLight: '#7B3814FF' }, localize(662, 'Foreground color of brackets (3). Requires enabling bracket pair colorization.'));\nconst editorBracketHighlightingForeground4 = registerColor('editorBracketHighlight.foreground4', '#00000000', localize(663, 'Foreground color of brackets (4). Requires enabling bracket pair colorization.'));\nconst editorBracketHighlightingForeground5 = registerColor('editorBracketHighlight.foreground5', '#00000000', localize(664, 'Foreground color of brackets (5). Requires enabling bracket pair colorization.'));\nconst editorBracketHighlightingForeground6 = registerColor('editorBracketHighlight.foreground6', '#00000000', localize(665, 'Foreground color of brackets (6). Requires enabling bracket pair colorization.'));\nconst editorBracketHighlightingUnexpectedBracketForeground = registerColor('editorBracketHighlight.unexpectedBracket.foreground', { dark: new Color(new RGBA(255, 18, 18, 0.8)), light: new Color(new RGBA(255, 18, 18, 0.8)), hcDark: new Color(new RGBA(255, 50, 50, 1)), hcLight: '#B5200D' }, localize(666, 'Foreground color of unexpected brackets.'));\nconst editorBracketPairGuideBackground1 = registerColor('editorBracketPairGuide.background1', '#00000000', localize(667, 'Background color of inactive bracket pair guides (1). Requires enabling bracket pair guides.'));\nconst editorBracketPairGuideBackground2 = registerColor('editorBracketPairGuide.background2', '#00000000', localize(668, 'Background color of inactive bracket pair guides (2). Requires enabling bracket pair guides.'));\nconst editorBracketPairGuideBackground3 = registerColor('editorBracketPairGuide.background3', '#00000000', localize(669, 'Background color of inactive bracket pair guides (3). Requires enabling bracket pair guides.'));\nconst editorBracketPairGuideBackground4 = registerColor('editorBracketPairGuide.background4', '#00000000', localize(670, 'Background color of inactive bracket pair guides (4). Requires enabling bracket pair guides.'));\nconst editorBracketPairGuideBackground5 = registerColor('editorBracketPairGuide.background5', '#00000000', localize(671, 'Background color of inactive bracket pair guides (5). Requires enabling bracket pair guides.'));\nconst editorBracketPairGuideBackground6 = registerColor('editorBracketPairGuide.background6', '#00000000', localize(672, 'Background color of inactive bracket pair guides (6). Requires enabling bracket pair guides.'));\nconst editorBracketPairGuideActiveBackground1 = registerColor('editorBracketPairGuide.activeBackground1', '#00000000', localize(673, 'Background color of active bracket pair guides (1). Requires enabling bracket pair guides.'));\nconst editorBracketPairGuideActiveBackground2 = registerColor('editorBracketPairGuide.activeBackground2', '#00000000', localize(674, 'Background color of active bracket pair guides (2). Requires enabling bracket pair guides.'));\nconst editorBracketPairGuideActiveBackground3 = registerColor('editorBracketPairGuide.activeBackground3', '#00000000', localize(675, 'Background color of active bracket pair guides (3). Requires enabling bracket pair guides.'));\nconst editorBracketPairGuideActiveBackground4 = registerColor('editorBracketPairGuide.activeBackground4', '#00000000', localize(676, 'Background color of active bracket pair guides (4). Requires enabling bracket pair guides.'));\nconst editorBracketPairGuideActiveBackground5 = registerColor('editorBracketPairGuide.activeBackground5', '#00000000', localize(677, 'Background color of active bracket pair guides (5). Requires enabling bracket pair guides.'));\nconst editorBracketPairGuideActiveBackground6 = registerColor('editorBracketPairGuide.activeBackground6', '#00000000', localize(678, 'Background color of active bracket pair guides (6). Requires enabling bracket pair guides.'));\nregisterColor('editorUnicodeHighlight.border', editorWarningForeground, localize(679, 'Border color used to highlight unicode characters.'));\nregisterColor('editorUnicodeHighlight.background', editorWarningBackground, localize(680, 'Background color used to highlight unicode characters.'));\n// contains all color rules that used to defined in editor/browser/widget/editor.css\nregisterThemingParticipant((theme, collector) => {\n    const background = theme.getColor(editorBackground);\n    const lineHighlight = theme.getColor(editorLineHighlight);\n    const imeBackground = (lineHighlight && !lineHighlight.isTransparent() ? lineHighlight : background);\n    if (imeBackground) {\n        collector.addRule(`.monaco-editor .inputarea.ime-input { background-color: ${imeBackground}; }`);\n    }\n});\n\nexport { deprecatedEditorActiveIndentGuides, deprecatedEditorIndentGuides, editorActiveIndentGuide1, editorActiveIndentGuide2, editorActiveIndentGuide3, editorActiveIndentGuide4, editorActiveIndentGuide5, editorActiveIndentGuide6, editorBracketHighlightingForeground1, editorBracketHighlightingForeground2, editorBracketHighlightingForeground3, editorBracketHighlightingForeground4, editorBracketHighlightingForeground5, editorBracketHighlightingForeground6, editorBracketHighlightingUnexpectedBracketForeground, editorBracketPairGuideActiveBackground1, editorBracketPairGuideActiveBackground2, editorBracketPairGuideActiveBackground3, editorBracketPairGuideActiveBackground4, editorBracketPairGuideActiveBackground5, editorBracketPairGuideActiveBackground6, editorBracketPairGuideBackground1, editorBracketPairGuideBackground2, editorBracketPairGuideBackground3, editorBracketPairGuideBackground4, editorBracketPairGuideBackground5, editorBracketPairGuideBackground6, editorCursorBackground, editorCursorForeground, editorDimmedLineNumber, editorIndentGuide1, editorIndentGuide2, editorIndentGuide3, editorIndentGuide4, editorIndentGuide5, editorIndentGuide6, editorLineHighlight, editorLineHighlightBorder, editorLineNumbers, editorMultiCursorPrimaryBackground, editorMultiCursorPrimaryForeground, editorMultiCursorSecondaryBackground, editorMultiCursorSecondaryForeground, editorOverviewRulerBackground, editorOverviewRulerBorder, editorRuler, editorUnnecessaryCodeOpacity, editorWhitespaces, ghostTextForeground, overviewRulerError, overviewRulerInfo, overviewRulerRangeHighlight, overviewRulerWarning };\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 2711, "column": 0}, "map": {"version":3,"sources":["file:///D:/real-time-code-editor%20%282%29/node_modules/.pnpm/monaco-editor%400.55.1/node_modules/monaco-editor/esm/vs/editor/common/core/misc/rgba.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n/**\n * A very VM friendly rgba datastructure.\n * Please don't touch unless you take a look at the IR.\n */\nclass RGBA8 {\n    static { this.Empty = new RGBA8(0, 0, 0, 0); }\n    constructor(r, g, b, a) {\n        this._rgba8Brand = undefined;\n        this.r = RGBA8._clamp(r);\n        this.g = RGBA8._clamp(g);\n        this.b = RGBA8._clamp(b);\n        this.a = RGBA8._clamp(a);\n    }\n    equals(other) {\n        return (this.r === other.r\n            && this.g === other.g\n            && this.b === other.b\n            && this.a === other.a);\n    }\n    static _clamp(c) {\n        if (c < 0) {\n            return 0;\n        }\n        if (c > 255) {\n            return 255;\n        }\n        return c | 0;\n    }\n}\n\nexport { RGBA8 };\n"],"names":[],"mappings":"AAAA;;;8FAG8F,GAC9F;;;CAGC;;;;AACD,MAAM;IACF,MAAO;QAAE,IAAI,CAAC,KAAK,GAAG,IAAI,MAAM,GAAG,GAAG,GAAG;IAAI,CAAC;IAC9C,YAAY,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAE;QACpB,IAAI,CAAC,WAAW,GAAG;QACnB,IAAI,CAAC,CAAC,GAAG,MAAM,MAAM,CAAC;QACtB,IAAI,CAAC,CAAC,GAAG,MAAM,MAAM,CAAC;QACtB,IAAI,CAAC,CAAC,GAAG,MAAM,MAAM,CAAC;QACtB,IAAI,CAAC,CAAC,GAAG,MAAM,MAAM,CAAC;IAC1B;IACA,OAAO,KAAK,EAAE;QACV,OAAQ,IAAI,CAAC,CAAC,KAAK,MAAM,CAAC,IACnB,IAAI,CAAC,CAAC,KAAK,MAAM,CAAC,IAClB,IAAI,CAAC,CAAC,KAAK,MAAM,CAAC,IAClB,IAAI,CAAC,CAAC,KAAK,MAAM,CAAC;IAC7B;IACA,OAAO,OAAO,CAAC,EAAE;QACb,IAAI,IAAI,GAAG;YACP,OAAO;QACX;QACA,IAAI,IAAI,KAAK;YACT,OAAO;QACX;QACA,OAAO,IAAI;IACf;AACJ","ignoreList":[0]}},
    {"offset": {"line": 2750, "column": 0}, "map": {"version":3,"sources":["file:///D:/real-time-code-editor%20%282%29/node_modules/.pnpm/monaco-editor%400.55.1/node_modules/monaco-editor/esm/vs/editor/common/core/edits/edit.js"],"sourcesContent":["import { BugIndicatingError } from '../../../../base/common/errors.js';\nimport { OffsetRange } from '../ranges/offsetRange.js';\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nclass BaseEdit {\n    constructor(replacements) {\n        this.replacements = replacements;\n        let lastEndEx = -1;\n        for (const replacement of replacements) {\n            if (!(replacement.replaceRange.start >= lastEndEx)) {\n                throw new BugIndicatingError(`Edits must be disjoint and sorted. Found ${replacement} after ${lastEndEx}`);\n            }\n            lastEndEx = replacement.replaceRange.endExclusive;\n        }\n    }\n    toString() {\n        const edits = this.replacements.map(e => e.toString()).join(', ');\n        return `[${edits}]`;\n    }\n    /**\n     * Normalizes the edit by removing empty replacements and joining touching replacements (if the replacements allow joining).\n     * Two edits have an equal normalized edit if and only if they have the same effect on any input.\n     *\n     * ![](https://raw.githubusercontent.com/microsoft/vscode/refs/heads/main/src/vs/editor/common/core/edits/docs/BaseEdit_normalize.drawio.png)\n     *\n     * Invariant:\n     * ```\n     * (forall base: TEdit.apply(base).equals(other.apply(base))) <-> this.normalize().equals(other.normalize())\n     * ```\n     * and\n     * ```\n     * forall base: TEdit.apply(base).equals(this.normalize().apply(base))\n     * ```\n     *\n     */\n    normalize() {\n        const newReplacements = [];\n        let lastReplacement;\n        for (const r of this.replacements) {\n            if (r.getNewLength() === 0 && r.replaceRange.length === 0) {\n                continue;\n            }\n            if (lastReplacement && lastReplacement.replaceRange.endExclusive === r.replaceRange.start) {\n                const joined = lastReplacement.tryJoinTouching(r);\n                if (joined) {\n                    lastReplacement = joined;\n                    continue;\n                }\n            }\n            if (lastReplacement) {\n                newReplacements.push(lastReplacement);\n            }\n            lastReplacement = r;\n        }\n        if (lastReplacement) {\n            newReplacements.push(lastReplacement);\n        }\n        return this._createNew(newReplacements);\n    }\n    /**\n     * Combines two edits into one with the same effect.\n     *\n     * ![](https://raw.githubusercontent.com/microsoft/vscode/refs/heads/main/src/vs/editor/common/core/edits/docs/BaseEdit_compose.drawio.png)\n     *\n     * Invariant:\n     * ```\n     * other.apply(this.apply(s0)) = this.compose(other).apply(s0)\n     * ```\n     */\n    compose(other) {\n        const edits1 = this.normalize();\n        const edits2 = other.normalize();\n        if (edits1.isEmpty()) {\n            return edits2;\n        }\n        if (edits2.isEmpty()) {\n            return edits1;\n        }\n        const edit1Queue = [...edits1.replacements];\n        const result = [];\n        let edit1ToEdit2 = 0;\n        for (const r2 of edits2.replacements) {\n            // Copy over edit1 unmodified until it touches edit2.\n            while (true) {\n                const r1 = edit1Queue[0];\n                if (!r1 || r1.replaceRange.start + edit1ToEdit2 + r1.getNewLength() >= r2.replaceRange.start) {\n                    break;\n                }\n                edit1Queue.shift();\n                result.push(r1);\n                edit1ToEdit2 += r1.getNewLength() - r1.replaceRange.length;\n            }\n            const firstEdit1ToEdit2 = edit1ToEdit2;\n            let firstIntersecting; // or touching\n            let lastIntersecting; // or touching\n            while (true) {\n                const r1 = edit1Queue[0];\n                if (!r1 || r1.replaceRange.start + edit1ToEdit2 > r2.replaceRange.endExclusive) {\n                    break;\n                }\n                // else we intersect, because the new end of edit1 is after or equal to our start\n                if (!firstIntersecting) {\n                    firstIntersecting = r1;\n                }\n                lastIntersecting = r1;\n                edit1Queue.shift();\n                edit1ToEdit2 += r1.getNewLength() - r1.replaceRange.length;\n            }\n            if (!firstIntersecting) {\n                result.push(r2.delta(-edit1ToEdit2));\n            }\n            else {\n                const newReplaceRangeStart = Math.min(firstIntersecting.replaceRange.start, r2.replaceRange.start - firstEdit1ToEdit2);\n                const prefixLength = r2.replaceRange.start - (firstIntersecting.replaceRange.start + firstEdit1ToEdit2);\n                if (prefixLength > 0) {\n                    const prefix = firstIntersecting.slice(OffsetRange.emptyAt(newReplaceRangeStart), new OffsetRange(0, prefixLength));\n                    result.push(prefix);\n                }\n                if (!lastIntersecting) {\n                    throw new BugIndicatingError(`Invariant violation: lastIntersecting is undefined`);\n                }\n                const suffixLength = (lastIntersecting.replaceRange.endExclusive + edit1ToEdit2) - r2.replaceRange.endExclusive;\n                if (suffixLength > 0) {\n                    const e = lastIntersecting.slice(OffsetRange.ofStartAndLength(lastIntersecting.replaceRange.endExclusive, 0), new OffsetRange(lastIntersecting.getNewLength() - suffixLength, lastIntersecting.getNewLength()));\n                    edit1Queue.unshift(e);\n                    edit1ToEdit2 -= e.getNewLength() - e.replaceRange.length;\n                }\n                const newReplaceRange = new OffsetRange(newReplaceRangeStart, r2.replaceRange.endExclusive - edit1ToEdit2);\n                const middle = r2.slice(newReplaceRange, new OffsetRange(0, r2.getNewLength()));\n                result.push(middle);\n            }\n        }\n        while (true) {\n            const item = edit1Queue.shift();\n            if (!item) {\n                break;\n            }\n            result.push(item);\n        }\n        return this._createNew(result).normalize();\n    }\n    /**\n     * Returns the range of each replacement in the applied value.\n    */\n    getNewRanges() {\n        const ranges = [];\n        let offset = 0;\n        for (const e of this.replacements) {\n            ranges.push(OffsetRange.ofStartAndLength(e.replaceRange.start + offset, e.getNewLength()));\n            offset += e.getLengthDelta();\n        }\n        return ranges;\n    }\n    isEmpty() {\n        return this.replacements.length === 0;\n    }\n}\nclass BaseReplacement {\n    constructor(\n    /**\n     * The range to be replaced.\n    */\n    replaceRange) {\n        this.replaceRange = replaceRange;\n    }\n    delta(offset) {\n        return this.slice(this.replaceRange.delta(offset), new OffsetRange(0, this.getNewLength()));\n    }\n    getLengthDelta() {\n        return this.getNewLength() - this.replaceRange.length;\n    }\n    toString() {\n        return `{ ${this.replaceRange.toString()} -> ${this.getNewLength()} }`;\n    }\n    get isEmpty() {\n        return this.getNewLength() === 0 && this.replaceRange.length === 0;\n    }\n    getRangeAfterReplace() {\n        return new OffsetRange(this.replaceRange.start, this.replaceRange.start + this.getNewLength());\n    }\n}\n\nexport { BaseEdit, BaseReplacement };\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 2939, "column": 0}, "map": {"version":3,"sources":["file:///D:/real-time-code-editor%20%282%29/node_modules/.pnpm/monaco-editor%400.55.1/node_modules/monaco-editor/esm/vs/editor/common/core/edits/stringEdit.js"],"sourcesContent":["import { commonPrefixLength, commonSuffixLength } from '../../../../base/common/strings.js';\nimport { OffsetRange } from '../ranges/offsetRange.js';\nimport { BaseEdit, BaseReplacement } from './edit.js';\n\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nclass BaseStringEdit extends BaseEdit {\n    apply(base) {\n        const resultText = [];\n        let pos = 0;\n        for (const edit of this.replacements) {\n            resultText.push(base.substring(pos, edit.replaceRange.start));\n            resultText.push(edit.newText);\n            pos = edit.replaceRange.endExclusive;\n        }\n        resultText.push(base.substring(pos));\n        return resultText.join('');\n    }\n}\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nclass BaseStringReplacement extends BaseReplacement {\n    constructor(range, newText) {\n        super(range);\n        this.newText = newText;\n    }\n    getNewLength() { return this.newText.length; }\n    toString() {\n        return `${this.replaceRange} -> ${JSON.stringify(this.newText)}`;\n    }\n    replace(str) {\n        return str.substring(0, this.replaceRange.start) + this.newText + str.substring(this.replaceRange.endExclusive);\n    }\n    removeCommonSuffixPrefix(originalText) {\n        const oldText = originalText.substring(this.replaceRange.start, this.replaceRange.endExclusive);\n        const prefixLen = commonPrefixLength(oldText, this.newText);\n        const suffixLen = Math.min(oldText.length - prefixLen, this.newText.length - prefixLen, commonSuffixLength(oldText, this.newText));\n        const replaceRange = new OffsetRange(this.replaceRange.start + prefixLen, this.replaceRange.endExclusive - suffixLen);\n        const newText = this.newText.substring(prefixLen, this.newText.length - suffixLen);\n        return new StringReplacement(replaceRange, newText);\n    }\n    removeCommonSuffixAndPrefix(source) {\n        return this.removeCommonSuffix(source).removeCommonPrefix(source);\n    }\n    removeCommonPrefix(source) {\n        const oldText = this.replaceRange.substring(source);\n        const prefixLen = commonPrefixLength(oldText, this.newText);\n        if (prefixLen === 0) {\n            return this;\n        }\n        return this.slice(this.replaceRange.deltaStart(prefixLen), new OffsetRange(prefixLen, this.newText.length));\n    }\n    removeCommonSuffix(source) {\n        const oldText = this.replaceRange.substring(source);\n        const suffixLen = commonSuffixLength(oldText, this.newText);\n        if (suffixLen === 0) {\n            return this;\n        }\n        return this.slice(this.replaceRange.deltaEnd(-suffixLen), new OffsetRange(0, this.newText.length - suffixLen));\n    }\n    toJson() {\n        return ({\n            txt: this.newText,\n            pos: this.replaceRange.start,\n            len: this.replaceRange.length,\n        });\n    }\n}\n/**\n * Represents a set of replacements to a string.\n * All these replacements are applied at once.\n*/\nclass StringEdit extends BaseStringEdit {\n    static { this.empty = new StringEdit([]); }\n    static compose(edits) {\n        if (edits.length === 0) {\n            return StringEdit.empty;\n        }\n        let result = edits[0];\n        for (let i = 1; i < edits.length; i++) {\n            result = result.compose(edits[i]);\n        }\n        return result;\n    }\n    constructor(replacements) {\n        super(replacements);\n    }\n    _createNew(replacements) {\n        return new StringEdit(replacements);\n    }\n}\nclass StringReplacement extends BaseStringReplacement {\n    static insert(offset, text) {\n        return new StringReplacement(OffsetRange.emptyAt(offset), text);\n    }\n    static replace(range, text) {\n        return new StringReplacement(range, text);\n    }\n    equals(other) {\n        return this.replaceRange.equals(other.replaceRange) && this.newText === other.newText;\n    }\n    tryJoinTouching(other) {\n        return new StringReplacement(this.replaceRange.joinRightTouching(other.replaceRange), this.newText + other.newText);\n    }\n    slice(range, rangeInReplacement) {\n        return new StringReplacement(range, rangeInReplacement ? rangeInReplacement.substring(this.newText) : this.newText);\n    }\n}\nfunction applyEditsToRanges(sortedRanges, edit) {\n    sortedRanges = sortedRanges.slice();\n    // treat edits as deletion of the replace range and then as insertion that extends the first range\n    const result = [];\n    let offset = 0;\n    for (const e of edit.replacements) {\n        while (true) {\n            // ranges before the current edit\n            const r = sortedRanges[0];\n            if (!r || r.endExclusive >= e.replaceRange.start) {\n                break;\n            }\n            sortedRanges.shift();\n            result.push(r.delta(offset));\n        }\n        const intersecting = [];\n        while (true) {\n            const r = sortedRanges[0];\n            if (!r || !r.intersectsOrTouches(e.replaceRange)) {\n                break;\n            }\n            sortedRanges.shift();\n            intersecting.push(r);\n        }\n        for (let i = intersecting.length - 1; i >= 0; i--) {\n            let r = intersecting[i];\n            const overlap = r.intersect(e.replaceRange).length;\n            r = r.deltaEnd(-overlap + (i === 0 ? e.newText.length : 0));\n            const rangeAheadOfReplaceRange = r.start - e.replaceRange.start;\n            if (rangeAheadOfReplaceRange > 0) {\n                r = r.delta(-rangeAheadOfReplaceRange);\n            }\n            if (i !== 0) {\n                r = r.delta(e.newText.length);\n            }\n            // We already took our offset into account.\n            // Because we add r back to the queue (which then adds offset again),\n            // we have to remove it here.\n            r = r.delta(-(e.newText.length - e.replaceRange.length));\n            sortedRanges.unshift(r);\n        }\n        offset += e.newText.length - e.replaceRange.length;\n    }\n    while (true) {\n        const r = sortedRanges[0];\n        if (!r) {\n            break;\n        }\n        sortedRanges.shift();\n        result.push(r.delta(offset));\n    }\n    return result;\n}\n\nexport { BaseStringEdit, BaseStringReplacement, StringEdit, StringReplacement, applyEditsToRanges };\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 3123, "column": 0}, "map": {"version":3,"sources":["file:///D:/real-time-code-editor%20%282%29/node_modules/.pnpm/monaco-editor%400.55.1/node_modules/monaco-editor/esm/vs/editor/common/core/text/positionToOffset.js"],"sourcesContent":["import { StringReplacement, StringEdit } from '../edits/stringEdit.js';\nimport { TextEdit, TextReplacement } from '../edits/textEdit.js';\nimport { _setPositionOffsetTransformerDependencies } from './positionToOffsetImpl.js';\nexport { PositionOffsetTransformer, PositionOffsetTransformerBase } from './positionToOffsetImpl.js';\nimport { TextLength } from './textLength.js';\n\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n_setPositionOffsetTransformerDependencies({\n    StringEdit: StringEdit,\n    StringReplacement: StringReplacement,\n    TextReplacement: TextReplacement,\n    TextEdit: TextEdit,\n    TextLength: TextLength,\n});\n"],"names":[],"mappings":";AAAA;AACA;AACA;AAEA;;;;;;AAEA;;;8FAG8F,GAC9F,IAAA,uTAAyC,EAAC;IACtC,YAAY,+QAAU;IACtB,mBAAmB,sRAAiB;IACpC,iBAAiB,kRAAe;IAChC,UAAU,2QAAQ;IAClB,YAAY,8QAAU;AAC1B","ignoreList":[0]}},
    {"offset": {"line": 3147, "column": 0}, "map": {"version":3,"sources":["file:///D:/real-time-code-editor%20%282%29/node_modules/.pnpm/monaco-editor%400.55.1/node_modules/monaco-editor/esm/vs/editor/common/core/misc/eolCounter.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nfunction countEOL(text) {\n    let eolCount = 0;\n    let firstLineLength = 0;\n    let lastLineStart = 0;\n    let eol = 0 /* StringEOL.Unknown */;\n    for (let i = 0, len = text.length; i < len; i++) {\n        const chr = text.charCodeAt(i);\n        if (chr === 13 /* CharCode.CarriageReturn */) {\n            if (eolCount === 0) {\n                firstLineLength = i;\n            }\n            eolCount++;\n            if (i + 1 < len && text.charCodeAt(i + 1) === 10 /* CharCode.LineFeed */) {\n                // \\r\\n... case\n                eol |= 2 /* StringEOL.CRLF */;\n                i++; // skip \\n\n            }\n            else {\n                // \\r... case\n                eol |= 3 /* StringEOL.Invalid */;\n            }\n            lastLineStart = i + 1;\n        }\n        else if (chr === 10 /* CharCode.LineFeed */) {\n            // \\n... case\n            eol |= 1 /* StringEOL.LF */;\n            if (eolCount === 0) {\n                firstLineLength = i;\n            }\n            eolCount++;\n            lastLineStart = i + 1;\n        }\n    }\n    if (eolCount === 0) {\n        firstLineLength = text.length;\n    }\n    return [eolCount, firstLineLength, text.length - lastLineStart, eol];\n}\n\nexport { countEOL };\n"],"names":[],"mappings":"AAAA;;;8FAG8F;;;;AAC9F,SAAS,SAAS,IAAI;IAClB,IAAI,WAAW;IACf,IAAI,kBAAkB;IACtB,IAAI,gBAAgB;IACpB,IAAI,MAAM,EAAE,qBAAqB;IACjC,IAAK,IAAI,IAAI,GAAG,MAAM,KAAK,MAAM,EAAE,IAAI,KAAK,IAAK;QAC7C,MAAM,MAAM,KAAK,UAAU,CAAC;QAC5B,IAAI,QAAQ,GAAG,2BAA2B,KAAI;YAC1C,IAAI,aAAa,GAAG;gBAChB,kBAAkB;YACtB;YACA;YACA,IAAI,IAAI,IAAI,OAAO,KAAK,UAAU,CAAC,IAAI,OAAO,GAAG,qBAAqB,KAAI;gBACtE,eAAe;gBACf,OAAO,EAAE,kBAAkB;gBAC3B,KAAK,UAAU;YACnB,OACK;gBACD,aAAa;gBACb,OAAO,EAAE,qBAAqB;YAClC;YACA,gBAAgB,IAAI;QACxB,OACK,IAAI,QAAQ,GAAG,qBAAqB,KAAI;YACzC,aAAa;YACb,OAAO,EAAE,gBAAgB;YACzB,IAAI,aAAa,GAAG;gBAChB,kBAAkB;YACtB;YACA;YACA,gBAAgB,IAAI;QACxB;IACJ;IACA,IAAI,aAAa,GAAG;QAChB,kBAAkB,KAAK,MAAM;IACjC;IACA,OAAO;QAAC;QAAU;QAAiB,KAAK,MAAM,GAAG;QAAe;KAAI;AACxE","ignoreList":[0]}},
    {"offset": {"line": 3200, "column": 0}, "map": {"version":3,"sources":["file:///D:/real-time-code-editor%20%282%29/node_modules/.pnpm/monaco-editor%400.55.1/node_modules/monaco-editor/esm/vs/editor/common/core/textChange.js"],"sourcesContent":["import { writeUInt32BE, writeUInt16LE, readUInt32BE } from '../../../base/common/buffer.js';\nimport { decodeUTF16LE } from './stringBuilder.js';\n\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nfunction escapeNewLine(str) {\n    return (str\n        .replace(/\\n/g, '\\\\n')\n        .replace(/\\r/g, '\\\\r'));\n}\nclass TextChange {\n    get oldLength() {\n        return this.oldText.length;\n    }\n    get oldEnd() {\n        return this.oldPosition + this.oldText.length;\n    }\n    get newLength() {\n        return this.newText.length;\n    }\n    get newEnd() {\n        return this.newPosition + this.newText.length;\n    }\n    constructor(oldPosition, oldText, newPosition, newText) {\n        this.oldPosition = oldPosition;\n        this.oldText = oldText;\n        this.newPosition = newPosition;\n        this.newText = newText;\n    }\n    toString() {\n        if (this.oldText.length === 0) {\n            return `(insert@${this.oldPosition} \"${escapeNewLine(this.newText)}\")`;\n        }\n        if (this.newText.length === 0) {\n            return `(delete@${this.oldPosition} \"${escapeNewLine(this.oldText)}\")`;\n        }\n        return `(replace@${this.oldPosition} \"${escapeNewLine(this.oldText)}\" with \"${escapeNewLine(this.newText)}\")`;\n    }\n    static _writeStringSize(str) {\n        return (4 + 2 * str.length);\n    }\n    static _writeString(b, str, offset) {\n        const len = str.length;\n        writeUInt32BE(b, len, offset);\n        offset += 4;\n        for (let i = 0; i < len; i++) {\n            writeUInt16LE(b, str.charCodeAt(i), offset);\n            offset += 2;\n        }\n        return offset;\n    }\n    static _readString(b, offset) {\n        const len = readUInt32BE(b, offset);\n        offset += 4;\n        return decodeUTF16LE(b, offset, len);\n    }\n    writeSize() {\n        return (4 // oldPosition\n            + 4 // newPosition\n            + TextChange._writeStringSize(this.oldText)\n            + TextChange._writeStringSize(this.newText));\n    }\n    write(b, offset) {\n        writeUInt32BE(b, this.oldPosition, offset);\n        offset += 4;\n        writeUInt32BE(b, this.newPosition, offset);\n        offset += 4;\n        offset = TextChange._writeString(b, this.oldText, offset);\n        offset = TextChange._writeString(b, this.newText, offset);\n        return offset;\n    }\n    static read(b, offset, dest) {\n        const oldPosition = readUInt32BE(b, offset);\n        offset += 4;\n        const newPosition = readUInt32BE(b, offset);\n        offset += 4;\n        const oldText = TextChange._readString(b, offset);\n        offset += TextChange._writeStringSize(oldText);\n        const newText = TextChange._readString(b, offset);\n        offset += TextChange._writeStringSize(newText);\n        dest.push(new TextChange(oldPosition, oldText, newPosition, newText));\n        return offset;\n    }\n}\nfunction compressConsecutiveTextChanges(prevEdits, currEdits) {\n    if (prevEdits === null || prevEdits.length === 0) {\n        return currEdits;\n    }\n    const compressor = new TextChangeCompressor(prevEdits, currEdits);\n    return compressor.compress();\n}\nclass TextChangeCompressor {\n    constructor(prevEdits, currEdits) {\n        this._prevEdits = prevEdits;\n        this._currEdits = currEdits;\n        this._result = [];\n        this._resultLen = 0;\n        this._prevLen = this._prevEdits.length;\n        this._prevDeltaOffset = 0;\n        this._currLen = this._currEdits.length;\n        this._currDeltaOffset = 0;\n    }\n    compress() {\n        let prevIndex = 0;\n        let currIndex = 0;\n        let prevEdit = this._getPrev(prevIndex);\n        let currEdit = this._getCurr(currIndex);\n        while (prevIndex < this._prevLen || currIndex < this._currLen) {\n            if (prevEdit === null) {\n                this._acceptCurr(currEdit);\n                currEdit = this._getCurr(++currIndex);\n                continue;\n            }\n            if (currEdit === null) {\n                this._acceptPrev(prevEdit);\n                prevEdit = this._getPrev(++prevIndex);\n                continue;\n            }\n            if (currEdit.oldEnd <= prevEdit.newPosition) {\n                this._acceptCurr(currEdit);\n                currEdit = this._getCurr(++currIndex);\n                continue;\n            }\n            if (prevEdit.newEnd <= currEdit.oldPosition) {\n                this._acceptPrev(prevEdit);\n                prevEdit = this._getPrev(++prevIndex);\n                continue;\n            }\n            if (currEdit.oldPosition < prevEdit.newPosition) {\n                const [e1, e2] = TextChangeCompressor._splitCurr(currEdit, prevEdit.newPosition - currEdit.oldPosition);\n                this._acceptCurr(e1);\n                currEdit = e2;\n                continue;\n            }\n            if (prevEdit.newPosition < currEdit.oldPosition) {\n                const [e1, e2] = TextChangeCompressor._splitPrev(prevEdit, currEdit.oldPosition - prevEdit.newPosition);\n                this._acceptPrev(e1);\n                prevEdit = e2;\n                continue;\n            }\n            // At this point, currEdit.oldPosition === prevEdit.newPosition\n            let mergePrev;\n            let mergeCurr;\n            if (currEdit.oldEnd === prevEdit.newEnd) {\n                mergePrev = prevEdit;\n                mergeCurr = currEdit;\n                prevEdit = this._getPrev(++prevIndex);\n                currEdit = this._getCurr(++currIndex);\n            }\n            else if (currEdit.oldEnd < prevEdit.newEnd) {\n                const [e1, e2] = TextChangeCompressor._splitPrev(prevEdit, currEdit.oldLength);\n                mergePrev = e1;\n                mergeCurr = currEdit;\n                prevEdit = e2;\n                currEdit = this._getCurr(++currIndex);\n            }\n            else {\n                const [e1, e2] = TextChangeCompressor._splitCurr(currEdit, prevEdit.newLength);\n                mergePrev = prevEdit;\n                mergeCurr = e1;\n                prevEdit = this._getPrev(++prevIndex);\n                currEdit = e2;\n            }\n            this._result[this._resultLen++] = new TextChange(mergePrev.oldPosition, mergePrev.oldText, mergeCurr.newPosition, mergeCurr.newText);\n            this._prevDeltaOffset += mergePrev.newLength - mergePrev.oldLength;\n            this._currDeltaOffset += mergeCurr.newLength - mergeCurr.oldLength;\n        }\n        const merged = TextChangeCompressor._merge(this._result);\n        const cleaned = TextChangeCompressor._removeNoOps(merged);\n        return cleaned;\n    }\n    _acceptCurr(currEdit) {\n        this._result[this._resultLen++] = TextChangeCompressor._rebaseCurr(this._prevDeltaOffset, currEdit);\n        this._currDeltaOffset += currEdit.newLength - currEdit.oldLength;\n    }\n    _getCurr(currIndex) {\n        return (currIndex < this._currLen ? this._currEdits[currIndex] : null);\n    }\n    _acceptPrev(prevEdit) {\n        this._result[this._resultLen++] = TextChangeCompressor._rebasePrev(this._currDeltaOffset, prevEdit);\n        this._prevDeltaOffset += prevEdit.newLength - prevEdit.oldLength;\n    }\n    _getPrev(prevIndex) {\n        return (prevIndex < this._prevLen ? this._prevEdits[prevIndex] : null);\n    }\n    static _rebaseCurr(prevDeltaOffset, currEdit) {\n        return new TextChange(currEdit.oldPosition - prevDeltaOffset, currEdit.oldText, currEdit.newPosition, currEdit.newText);\n    }\n    static _rebasePrev(currDeltaOffset, prevEdit) {\n        return new TextChange(prevEdit.oldPosition, prevEdit.oldText, prevEdit.newPosition + currDeltaOffset, prevEdit.newText);\n    }\n    static _splitPrev(edit, offset) {\n        const preText = edit.newText.substr(0, offset);\n        const postText = edit.newText.substr(offset);\n        return [\n            new TextChange(edit.oldPosition, edit.oldText, edit.newPosition, preText),\n            new TextChange(edit.oldEnd, '', edit.newPosition + offset, postText)\n        ];\n    }\n    static _splitCurr(edit, offset) {\n        const preText = edit.oldText.substr(0, offset);\n        const postText = edit.oldText.substr(offset);\n        return [\n            new TextChange(edit.oldPosition, preText, edit.newPosition, edit.newText),\n            new TextChange(edit.oldPosition + offset, postText, edit.newEnd, '')\n        ];\n    }\n    static _merge(edits) {\n        if (edits.length === 0) {\n            return edits;\n        }\n        const result = [];\n        let resultLen = 0;\n        let prev = edits[0];\n        for (let i = 1; i < edits.length; i++) {\n            const curr = edits[i];\n            if (prev.oldEnd === curr.oldPosition) {\n                // Merge into `prev`\n                prev = new TextChange(prev.oldPosition, prev.oldText + curr.oldText, prev.newPosition, prev.newText + curr.newText);\n            }\n            else {\n                result[resultLen++] = prev;\n                prev = curr;\n            }\n        }\n        result[resultLen++] = prev;\n        return result;\n    }\n    static _removeNoOps(edits) {\n        if (edits.length === 0) {\n            return edits;\n        }\n        const result = [];\n        let resultLen = 0;\n        for (let i = 0; i < edits.length; i++) {\n            const edit = edits[i];\n            if (edit.oldText === edit.newText) {\n                continue;\n            }\n            result[resultLen++] = edit;\n        }\n        return result;\n    }\n}\n\nexport { TextChange, compressConsecutiveTextChanges };\n"],"names":[],"mappings":";;;;;;AAAA;AACA;;;AAEA;;;8FAG8F,GAC9F,SAAS,cAAc,GAAG;IACtB,OAAQ,IACH,OAAO,CAAC,OAAO,OACf,OAAO,CAAC,OAAO;AACxB;AACA,MAAM;IACF,IAAI,YAAY;QACZ,OAAO,IAAI,CAAC,OAAO,CAAC,MAAM;IAC9B;IACA,IAAI,SAAS;QACT,OAAO,IAAI,CAAC,WAAW,GAAG,IAAI,CAAC,OAAO,CAAC,MAAM;IACjD;IACA,IAAI,YAAY;QACZ,OAAO,IAAI,CAAC,OAAO,CAAC,MAAM;IAC9B;IACA,IAAI,SAAS;QACT,OAAO,IAAI,CAAC,WAAW,GAAG,IAAI,CAAC,OAAO,CAAC,MAAM;IACjD;IACA,YAAY,WAAW,EAAE,OAAO,EAAE,WAAW,EAAE,OAAO,CAAE;QACpD,IAAI,CAAC,WAAW,GAAG;QACnB,IAAI,CAAC,OAAO,GAAG;QACf,IAAI,CAAC,WAAW,GAAG;QACnB,IAAI,CAAC,OAAO,GAAG;IACnB;IACA,WAAW;QACP,IAAI,IAAI,CAAC,OAAO,CAAC,MAAM,KAAK,GAAG;YAC3B,OAAO,CAAC,QAAQ,EAAE,IAAI,CAAC,WAAW,CAAC,EAAE,EAAE,cAAc,IAAI,CAAC,OAAO,EAAE,EAAE,CAAC;QAC1E;QACA,IAAI,IAAI,CAAC,OAAO,CAAC,MAAM,KAAK,GAAG;YAC3B,OAAO,CAAC,QAAQ,EAAE,IAAI,CAAC,WAAW,CAAC,EAAE,EAAE,cAAc,IAAI,CAAC,OAAO,EAAE,EAAE,CAAC;QAC1E;QACA,OAAO,CAAC,SAAS,EAAE,IAAI,CAAC,WAAW,CAAC,EAAE,EAAE,cAAc,IAAI,CAAC,OAAO,EAAE,QAAQ,EAAE,cAAc,IAAI,CAAC,OAAO,EAAE,EAAE,CAAC;IACjH;IACA,OAAO,iBAAiB,GAAG,EAAE;QACzB,OAAQ,IAAI,IAAI,IAAI,MAAM;IAC9B;IACA,OAAO,aAAa,CAAC,EAAE,GAAG,EAAE,MAAM,EAAE;QAChC,MAAM,MAAM,IAAI,MAAM;QACtB,IAAA,2PAAa,EAAC,GAAG,KAAK;QACtB,UAAU;QACV,IAAK,IAAI,IAAI,GAAG,IAAI,KAAK,IAAK;YAC1B,IAAA,2PAAa,EAAC,GAAG,IAAI,UAAU,CAAC,IAAI;YACpC,UAAU;QACd;QACA,OAAO;IACX;IACA,OAAO,YAAY,CAAC,EAAE,MAAM,EAAE;QAC1B,MAAM,MAAM,IAAA,0PAAY,EAAC,GAAG;QAC5B,UAAU;QACV,OAAO,IAAA,4QAAa,EAAC,GAAG,QAAQ;IACpC;IACA,YAAY;QACR,OAAQ,EAAE,cAAc;WAClB,EAAE,cAAc;WAChB,WAAW,gBAAgB,CAAC,IAAI,CAAC,OAAO,IACxC,WAAW,gBAAgB,CAAC,IAAI,CAAC,OAAO;IAClD;IACA,MAAM,CAAC,EAAE,MAAM,EAAE;QACb,IAAA,2PAAa,EAAC,GAAG,IAAI,CAAC,WAAW,EAAE;QACnC,UAAU;QACV,IAAA,2PAAa,EAAC,GAAG,IAAI,CAAC,WAAW,EAAE;QACnC,UAAU;QACV,SAAS,WAAW,YAAY,CAAC,GAAG,IAAI,CAAC,OAAO,EAAE;QAClD,SAAS,WAAW,YAAY,CAAC,GAAG,IAAI,CAAC,OAAO,EAAE;QAClD,OAAO;IACX;IACA,OAAO,KAAK,CAAC,EAAE,MAAM,EAAE,IAAI,EAAE;QACzB,MAAM,cAAc,IAAA,0PAAY,EAAC,GAAG;QACpC,UAAU;QACV,MAAM,cAAc,IAAA,0PAAY,EAAC,GAAG;QACpC,UAAU;QACV,MAAM,UAAU,WAAW,WAAW,CAAC,GAAG;QAC1C,UAAU,WAAW,gBAAgB,CAAC;QACtC,MAAM,UAAU,WAAW,WAAW,CAAC,GAAG;QAC1C,UAAU,WAAW,gBAAgB,CAAC;QACtC,KAAK,IAAI,CAAC,IAAI,WAAW,aAAa,SAAS,aAAa;QAC5D,OAAO;IACX;AACJ;AACA,SAAS,+BAA+B,SAAS,EAAE,SAAS;IACxD,IAAI,cAAc,QAAQ,UAAU,MAAM,KAAK,GAAG;QAC9C,OAAO;IACX;IACA,MAAM,aAAa,IAAI,qBAAqB,WAAW;IACvD,OAAO,WAAW,QAAQ;AAC9B;AACA,MAAM;IACF,YAAY,SAAS,EAAE,SAAS,CAAE;QAC9B,IAAI,CAAC,UAAU,GAAG;QAClB,IAAI,CAAC,UAAU,GAAG;QAClB,IAAI,CAAC,OAAO,GAAG,EAAE;QACjB,IAAI,CAAC,UAAU,GAAG;QAClB,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC,UAAU,CAAC,MAAM;QACtC,IAAI,CAAC,gBAAgB,GAAG;QACxB,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC,UAAU,CAAC,MAAM;QACtC,IAAI,CAAC,gBAAgB,GAAG;IAC5B;IACA,WAAW;QACP,IAAI,YAAY;QAChB,IAAI,YAAY;QAChB,IAAI,WAAW,IAAI,CAAC,QAAQ,CAAC;QAC7B,IAAI,WAAW,IAAI,CAAC,QAAQ,CAAC;QAC7B,MAAO,YAAY,IAAI,CAAC,QAAQ,IAAI,YAAY,IAAI,CAAC,QAAQ,CAAE;YAC3D,IAAI,aAAa,MAAM;gBACnB,IAAI,CAAC,WAAW,CAAC;gBACjB,WAAW,IAAI,CAAC,QAAQ,CAAC,EAAE;gBAC3B;YACJ;YACA,IAAI,aAAa,MAAM;gBACnB,IAAI,CAAC,WAAW,CAAC;gBACjB,WAAW,IAAI,CAAC,QAAQ,CAAC,EAAE;gBAC3B;YACJ;YACA,IAAI,SAAS,MAAM,IAAI,SAAS,WAAW,EAAE;gBACzC,IAAI,CAAC,WAAW,CAAC;gBACjB,WAAW,IAAI,CAAC,QAAQ,CAAC,EAAE;gBAC3B;YACJ;YACA,IAAI,SAAS,MAAM,IAAI,SAAS,WAAW,EAAE;gBACzC,IAAI,CAAC,WAAW,CAAC;gBACjB,WAAW,IAAI,CAAC,QAAQ,CAAC,EAAE;gBAC3B;YACJ;YACA,IAAI,SAAS,WAAW,GAAG,SAAS,WAAW,EAAE;gBAC7C,MAAM,CAAC,IAAI,GAAG,GAAG,qBAAqB,UAAU,CAAC,UAAU,SAAS,WAAW,GAAG,SAAS,WAAW;gBACtG,IAAI,CAAC,WAAW,CAAC;gBACjB,WAAW;gBACX;YACJ;YACA,IAAI,SAAS,WAAW,GAAG,SAAS,WAAW,EAAE;gBAC7C,MAAM,CAAC,IAAI,GAAG,GAAG,qBAAqB,UAAU,CAAC,UAAU,SAAS,WAAW,GAAG,SAAS,WAAW;gBACtG,IAAI,CAAC,WAAW,CAAC;gBACjB,WAAW;gBACX;YACJ;YACA,+DAA+D;YAC/D,IAAI;YACJ,IAAI;YACJ,IAAI,SAAS,MAAM,KAAK,SAAS,MAAM,EAAE;gBACrC,YAAY;gBACZ,YAAY;gBACZ,WAAW,IAAI,CAAC,QAAQ,CAAC,EAAE;gBAC3B,WAAW,IAAI,CAAC,QAAQ,CAAC,EAAE;YAC/B,OACK,IAAI,SAAS,MAAM,GAAG,SAAS,MAAM,EAAE;gBACxC,MAAM,CAAC,IAAI,GAAG,GAAG,qBAAqB,UAAU,CAAC,UAAU,SAAS,SAAS;gBAC7E,YAAY;gBACZ,YAAY;gBACZ,WAAW;gBACX,WAAW,IAAI,CAAC,QAAQ,CAAC,EAAE;YAC/B,OACK;gBACD,MAAM,CAAC,IAAI,GAAG,GAAG,qBAAqB,UAAU,CAAC,UAAU,SAAS,SAAS;gBAC7E,YAAY;gBACZ,YAAY;gBACZ,WAAW,IAAI,CAAC,QAAQ,CAAC,EAAE;gBAC3B,WAAW;YACf;YACA,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,UAAU,GAAG,GAAG,IAAI,WAAW,UAAU,WAAW,EAAE,UAAU,OAAO,EAAE,UAAU,WAAW,EAAE,UAAU,OAAO;YACnI,IAAI,CAAC,gBAAgB,IAAI,UAAU,SAAS,GAAG,UAAU,SAAS;YAClE,IAAI,CAAC,gBAAgB,IAAI,UAAU,SAAS,GAAG,UAAU,SAAS;QACtE;QACA,MAAM,SAAS,qBAAqB,MAAM,CAAC,IAAI,CAAC,OAAO;QACvD,MAAM,UAAU,qBAAqB,YAAY,CAAC;QAClD,OAAO;IACX;IACA,YAAY,QAAQ,EAAE;QAClB,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,UAAU,GAAG,GAAG,qBAAqB,WAAW,CAAC,IAAI,CAAC,gBAAgB,EAAE;QAC1F,IAAI,CAAC,gBAAgB,IAAI,SAAS,SAAS,GAAG,SAAS,SAAS;IACpE;IACA,SAAS,SAAS,EAAE;QAChB,OAAQ,YAAY,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC,UAAU,CAAC,UAAU,GAAG;IACrE;IACA,YAAY,QAAQ,EAAE;QAClB,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,UAAU,GAAG,GAAG,qBAAqB,WAAW,CAAC,IAAI,CAAC,gBAAgB,EAAE;QAC1F,IAAI,CAAC,gBAAgB,IAAI,SAAS,SAAS,GAAG,SAAS,SAAS;IACpE;IACA,SAAS,SAAS,EAAE;QAChB,OAAQ,YAAY,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC,UAAU,CAAC,UAAU,GAAG;IACrE;IACA,OAAO,YAAY,eAAe,EAAE,QAAQ,EAAE;QAC1C,OAAO,IAAI,WAAW,SAAS,WAAW,GAAG,iBAAiB,SAAS,OAAO,EAAE,SAAS,WAAW,EAAE,SAAS,OAAO;IAC1H;IACA,OAAO,YAAY,eAAe,EAAE,QAAQ,EAAE;QAC1C,OAAO,IAAI,WAAW,SAAS,WAAW,EAAE,SAAS,OAAO,EAAE,SAAS,WAAW,GAAG,iBAAiB,SAAS,OAAO;IAC1H;IACA,OAAO,WAAW,IAAI,EAAE,MAAM,EAAE;QAC5B,MAAM,UAAU,KAAK,OAAO,CAAC,MAAM,CAAC,GAAG;QACvC,MAAM,WAAW,KAAK,OAAO,CAAC,MAAM,CAAC;QACrC,OAAO;YACH,IAAI,WAAW,KAAK,WAAW,EAAE,KAAK,OAAO,EAAE,KAAK,WAAW,EAAE;YACjE,IAAI,WAAW,KAAK,MAAM,EAAE,IAAI,KAAK,WAAW,GAAG,QAAQ;SAC9D;IACL;IACA,OAAO,WAAW,IAAI,EAAE,MAAM,EAAE;QAC5B,MAAM,UAAU,KAAK,OAAO,CAAC,MAAM,CAAC,GAAG;QACvC,MAAM,WAAW,KAAK,OAAO,CAAC,MAAM,CAAC;QACrC,OAAO;YACH,IAAI,WAAW,KAAK,WAAW,EAAE,SAAS,KAAK,WAAW,EAAE,KAAK,OAAO;YACxE,IAAI,WAAW,KAAK,WAAW,GAAG,QAAQ,UAAU,KAAK,MAAM,EAAE;SACpE;IACL;IACA,OAAO,OAAO,KAAK,EAAE;QACjB,IAAI,MAAM,MAAM,KAAK,GAAG;YACpB,OAAO;QACX;QACA,MAAM,SAAS,EAAE;QACjB,IAAI,YAAY;QAChB,IAAI,OAAO,KAAK,CAAC,EAAE;QACnB,IAAK,IAAI,IAAI,GAAG,IAAI,MAAM,MAAM,EAAE,IAAK;YACnC,MAAM,OAAO,KAAK,CAAC,EAAE;YACrB,IAAI,KAAK,MAAM,KAAK,KAAK,WAAW,EAAE;gBAClC,oBAAoB;gBACpB,OAAO,IAAI,WAAW,KAAK,WAAW,EAAE,KAAK,OAAO,GAAG,KAAK,OAAO,EAAE,KAAK,WAAW,EAAE,KAAK,OAAO,GAAG,KAAK,OAAO;YACtH,OACK;gBACD,MAAM,CAAC,YAAY,GAAG;gBACtB,OAAO;YACX;QACJ;QACA,MAAM,CAAC,YAAY,GAAG;QACtB,OAAO;IACX;IACA,OAAO,aAAa,KAAK,EAAE;QACvB,IAAI,MAAM,MAAM,KAAK,GAAG;YACpB,OAAO;QACX;QACA,MAAM,SAAS,EAAE;QACjB,IAAI,YAAY;QAChB,IAAK,IAAI,IAAI,GAAG,IAAI,MAAM,MAAM,EAAE,IAAK;YACnC,MAAM,OAAO,KAAK,CAAC,EAAE;YACrB,IAAI,KAAK,OAAO,KAAK,KAAK,OAAO,EAAE;gBAC/B;YACJ;YACA,MAAM,CAAC,YAAY,GAAG;QAC1B;QACA,OAAO;IACX;AACJ","ignoreList":[0]}},
    {"offset": {"line": 3451, "column": 0}, "map": {"version":3,"sources":["file:///D:/real-time-code-editor%20%282%29/node_modules/.pnpm/monaco-editor%400.55.1/node_modules/monaco-editor/esm/vs/editor/common/core/editOperation.js"],"sourcesContent":["import { Range } from './range.js';\n\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nclass EditOperation {\n    static insert(position, text) {\n        return {\n            range: new Range(position.lineNumber, position.column, position.lineNumber, position.column),\n            text: text,\n            forceMoveMarkers: true\n        };\n    }\n    static delete(range) {\n        return {\n            range: range,\n            text: null\n        };\n    }\n    static replace(range, text) {\n        return {\n            range: range,\n            text: text\n        };\n    }\n    static replaceMove(range, text) {\n        return {\n            range: range,\n            text: text,\n            forceMoveMarkers: true\n        };\n    }\n}\n\nexport { EditOperation };\n"],"names":[],"mappings":";;;;AAAA;;AAEA;;;8FAG8F,GAC9F,MAAM;IACF,OAAO,OAAO,QAAQ,EAAE,IAAI,EAAE;QAC1B,OAAO;YACH,OAAO,IAAI,4PAAK,CAAC,SAAS,UAAU,EAAE,SAAS,MAAM,EAAE,SAAS,UAAU,EAAE,SAAS,MAAM;YAC3F,MAAM;YACN,kBAAkB;QACtB;IACJ;IACA,OAAO,OAAO,KAAK,EAAE;QACjB,OAAO;YACH,OAAO;YACP,MAAM;QACV;IACJ;IACA,OAAO,QAAQ,KAAK,EAAE,IAAI,EAAE;QACxB,OAAO;YACH,OAAO;YACP,MAAM;QACV;IACJ;IACA,OAAO,YAAY,KAAK,EAAE,IAAI,EAAE;QAC5B,OAAO;YACH,OAAO;YACP,MAAM;YACN,kBAAkB;QACtB;IACJ;AACJ","ignoreList":[0]}},
    {"offset": {"line": 3493, "column": 0}, "map": {"version":3,"sources":["file:///D:/real-time-code-editor%20%282%29/node_modules/.pnpm/monaco-editor%400.55.1/node_modules/monaco-editor/esm/vs/editor/common/core/2d/point.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nclass Point {\n    static equals(a, b) {\n        return a.x === b.x && a.y === b.y;\n    }\n    constructor(x, y) {\n        this.x = x;\n        this.y = y;\n    }\n    add(other) {\n        return new Point(this.x + other.x, this.y + other.y);\n    }\n    deltaX(delta) {\n        return new Point(this.x + delta, this.y);\n    }\n    deltaY(delta) {\n        return new Point(this.x, this.y + delta);\n    }\n    toString() {\n        return `(${this.x},${this.y})`;\n    }\n    subtract(other) {\n        return new Point(this.x - other.x, this.y - other.y);\n    }\n    scale(factor) {\n        return new Point(this.x * factor, this.y * factor);\n    }\n    mapComponents(map) {\n        return new Point(map(this.x), map(this.y));\n    }\n    isZero() {\n        return this.x === 0 && this.y === 0;\n    }\n    withThreshold(threshold) {\n        return this.mapComponents(axisVal => {\n            if (axisVal > threshold) {\n                return axisVal - threshold;\n            }\n            else if (axisVal < -threshold) {\n                return axisVal + threshold;\n            }\n            return 0;\n        });\n    }\n}\n\nexport { Point };\n"],"names":[],"mappings":"AAAA;;;8FAG8F;;;;AAC9F,MAAM;IACF,OAAO,OAAO,CAAC,EAAE,CAAC,EAAE;QAChB,OAAO,EAAE,CAAC,KAAK,EAAE,CAAC,IAAI,EAAE,CAAC,KAAK,EAAE,CAAC;IACrC;IACA,YAAY,CAAC,EAAE,CAAC,CAAE;QACd,IAAI,CAAC,CAAC,GAAG;QACT,IAAI,CAAC,CAAC,GAAG;IACb;IACA,IAAI,KAAK,EAAE;QACP,OAAO,IAAI,MAAM,IAAI,CAAC,CAAC,GAAG,MAAM,CAAC,EAAE,IAAI,CAAC,CAAC,GAAG,MAAM,CAAC;IACvD;IACA,OAAO,KAAK,EAAE;QACV,OAAO,IAAI,MAAM,IAAI,CAAC,CAAC,GAAG,OAAO,IAAI,CAAC,CAAC;IAC3C;IACA,OAAO,KAAK,EAAE;QACV,OAAO,IAAI,MAAM,IAAI,CAAC,CAAC,EAAE,IAAI,CAAC,CAAC,GAAG;IACtC;IACA,WAAW;QACP,OAAO,CAAC,CAAC,EAAE,IAAI,CAAC,CAAC,CAAC,CAAC,EAAE,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC;IAClC;IACA,SAAS,KAAK,EAAE;QACZ,OAAO,IAAI,MAAM,IAAI,CAAC,CAAC,GAAG,MAAM,CAAC,EAAE,IAAI,CAAC,CAAC,GAAG,MAAM,CAAC;IACvD;IACA,MAAM,MAAM,EAAE;QACV,OAAO,IAAI,MAAM,IAAI,CAAC,CAAC,GAAG,QAAQ,IAAI,CAAC,CAAC,GAAG;IAC/C;IACA,cAAc,GAAG,EAAE;QACf,OAAO,IAAI,MAAM,IAAI,IAAI,CAAC,CAAC,GAAG,IAAI,IAAI,CAAC,CAAC;IAC5C;IACA,SAAS;QACL,OAAO,IAAI,CAAC,CAAC,KAAK,KAAK,IAAI,CAAC,CAAC,KAAK;IACtC;IACA,cAAc,SAAS,EAAE;QACrB,OAAO,IAAI,CAAC,aAAa,CAAC,CAAA;YACtB,IAAI,UAAU,WAAW;gBACrB,OAAO,UAAU;YACrB,OACK,IAAI,UAAU,CAAC,WAAW;gBAC3B,OAAO,UAAU;YACrB;YACA,OAAO;QACX;IACJ;AACJ","ignoreList":[0]}}]
}