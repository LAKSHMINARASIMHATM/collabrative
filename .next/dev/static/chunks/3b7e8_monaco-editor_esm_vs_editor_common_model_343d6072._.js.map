{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///D:/real-time-code-editor%20%282%29/node_modules/.pnpm/monaco-editor%400.55.1/node_modules/monaco-editor/esm/vs/editor/common/model/textModelSearch.js"],"sourcesContent":["import { createRegExp, getNextCodePoint } from '../../../base/common/strings.js';\nimport { getMapForWordSeparators } from '../core/wordCharacterClassifier.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport { SearchData, FindMatch } from '../model.js';\n\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nconst LIMIT_FIND_COUNT = 999;\nclass SearchParams {\n    constructor(searchString, isRegex, matchCase, wordSeparators) {\n        this.searchString = searchString;\n        this.isRegex = isRegex;\n        this.matchCase = matchCase;\n        this.wordSeparators = wordSeparators;\n    }\n    parseSearchRequest() {\n        if (this.searchString === '') {\n            return null;\n        }\n        // Try to create a RegExp out of the params\n        let multiline;\n        if (this.isRegex) {\n            multiline = isMultilineRegexSource(this.searchString);\n        }\n        else {\n            multiline = (this.searchString.indexOf('\\n') >= 0);\n        }\n        let regex = null;\n        try {\n            regex = createRegExp(this.searchString, this.isRegex, {\n                matchCase: this.matchCase,\n                wholeWord: false,\n                multiline: multiline,\n                global: true,\n                unicode: true\n            });\n        }\n        catch (err) {\n            return null;\n        }\n        if (!regex) {\n            return null;\n        }\n        let canUseSimpleSearch = (!this.isRegex && !multiline);\n        if (canUseSimpleSearch && this.searchString.toLowerCase() !== this.searchString.toUpperCase()) {\n            // casing might make a difference\n            canUseSimpleSearch = this.matchCase;\n        }\n        return new SearchData(regex, this.wordSeparators ? getMapForWordSeparators(this.wordSeparators, []) : null, canUseSimpleSearch ? this.searchString : null);\n    }\n}\nfunction isMultilineRegexSource(searchString) {\n    if (!searchString || searchString.length === 0) {\n        return false;\n    }\n    for (let i = 0, len = searchString.length; i < len; i++) {\n        const chCode = searchString.charCodeAt(i);\n        if (chCode === 10 /* CharCode.LineFeed */) {\n            return true;\n        }\n        if (chCode === 92 /* CharCode.Backslash */) {\n            // move to next char\n            i++;\n            if (i >= len) {\n                // string ends with a \\\n                break;\n            }\n            const nextChCode = searchString.charCodeAt(i);\n            if (nextChCode === 110 /* CharCode.n */ || nextChCode === 114 /* CharCode.r */ || nextChCode === 87 /* CharCode.W */) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\nfunction createFindMatch(range, rawMatches, captureMatches) {\n    if (!captureMatches) {\n        return new FindMatch(range, null);\n    }\n    const matches = [];\n    for (let i = 0, len = rawMatches.length; i < len; i++) {\n        matches[i] = rawMatches[i];\n    }\n    return new FindMatch(range, matches);\n}\nclass LineFeedCounter {\n    constructor(text) {\n        const lineFeedsOffsets = [];\n        let lineFeedsOffsetsLen = 0;\n        for (let i = 0, textLen = text.length; i < textLen; i++) {\n            if (text.charCodeAt(i) === 10 /* CharCode.LineFeed */) {\n                lineFeedsOffsets[lineFeedsOffsetsLen++] = i;\n            }\n        }\n        this._lineFeedsOffsets = lineFeedsOffsets;\n    }\n    findLineFeedCountBeforeOffset(offset) {\n        const lineFeedsOffsets = this._lineFeedsOffsets;\n        let min = 0;\n        let max = lineFeedsOffsets.length - 1;\n        if (max === -1) {\n            // no line feeds\n            return 0;\n        }\n        if (offset <= lineFeedsOffsets[0]) {\n            // before first line feed\n            return 0;\n        }\n        while (min < max) {\n            const mid = min + ((max - min) / 2 >> 0);\n            if (lineFeedsOffsets[mid] >= offset) {\n                max = mid - 1;\n            }\n            else {\n                if (lineFeedsOffsets[mid + 1] >= offset) {\n                    // bingo!\n                    min = mid;\n                    max = mid;\n                }\n                else {\n                    min = mid + 1;\n                }\n            }\n        }\n        return min + 1;\n    }\n}\nclass TextModelSearch {\n    static findMatches(model, searchParams, searchRange, captureMatches, limitResultCount) {\n        const searchData = searchParams.parseSearchRequest();\n        if (!searchData) {\n            return [];\n        }\n        if (searchData.regex.multiline) {\n            return this._doFindMatchesMultiline(model, searchRange, new Searcher(searchData.wordSeparators, searchData.regex), captureMatches, limitResultCount);\n        }\n        return this._doFindMatchesLineByLine(model, searchRange, searchData, captureMatches, limitResultCount);\n    }\n    /**\n     * Multiline search always executes on the lines concatenated with \\n.\n     * We must therefore compensate for the count of \\n in case the model is CRLF\n     */\n    static _getMultilineMatchRange(model, deltaOffset, text, lfCounter, matchIndex, match0) {\n        let startOffset;\n        let lineFeedCountBeforeMatch = 0;\n        if (lfCounter) {\n            lineFeedCountBeforeMatch = lfCounter.findLineFeedCountBeforeOffset(matchIndex);\n            startOffset = deltaOffset + matchIndex + lineFeedCountBeforeMatch /* add as many \\r as there were \\n */;\n        }\n        else {\n            startOffset = deltaOffset + matchIndex;\n        }\n        let endOffset;\n        if (lfCounter) {\n            const lineFeedCountBeforeEndOfMatch = lfCounter.findLineFeedCountBeforeOffset(matchIndex + match0.length);\n            const lineFeedCountInMatch = lineFeedCountBeforeEndOfMatch - lineFeedCountBeforeMatch;\n            endOffset = startOffset + match0.length + lineFeedCountInMatch /* add as many \\r as there were \\n */;\n        }\n        else {\n            endOffset = startOffset + match0.length;\n        }\n        const startPosition = model.getPositionAt(startOffset);\n        const endPosition = model.getPositionAt(endOffset);\n        return new Range(startPosition.lineNumber, startPosition.column, endPosition.lineNumber, endPosition.column);\n    }\n    static _doFindMatchesMultiline(model, searchRange, searcher, captureMatches, limitResultCount) {\n        const deltaOffset = model.getOffsetAt(searchRange.getStartPosition());\n        // We always execute multiline search over the lines joined with \\n\n        // This makes it that \\n will match the EOL for both CRLF and LF models\n        // We compensate for offset errors in `_getMultilineMatchRange`\n        const text = model.getValueInRange(searchRange, 1 /* EndOfLinePreference.LF */);\n        const lfCounter = (model.getEOL() === '\\r\\n' ? new LineFeedCounter(text) : null);\n        const result = [];\n        let counter = 0;\n        let m;\n        searcher.reset(0);\n        while ((m = searcher.next(text))) {\n            result[counter++] = createFindMatch(this._getMultilineMatchRange(model, deltaOffset, text, lfCounter, m.index, m[0]), m, captureMatches);\n            if (counter >= limitResultCount) {\n                return result;\n            }\n        }\n        return result;\n    }\n    static _doFindMatchesLineByLine(model, searchRange, searchData, captureMatches, limitResultCount) {\n        const result = [];\n        let resultLen = 0;\n        // Early case for a search range that starts & stops on the same line number\n        if (searchRange.startLineNumber === searchRange.endLineNumber) {\n            const text = model.getLineContent(searchRange.startLineNumber).substring(searchRange.startColumn - 1, searchRange.endColumn - 1);\n            resultLen = this._findMatchesInLine(searchData, text, searchRange.startLineNumber, searchRange.startColumn - 1, resultLen, result, captureMatches, limitResultCount);\n            return result;\n        }\n        // Collect results from first line\n        const text = model.getLineContent(searchRange.startLineNumber).substring(searchRange.startColumn - 1);\n        resultLen = this._findMatchesInLine(searchData, text, searchRange.startLineNumber, searchRange.startColumn - 1, resultLen, result, captureMatches, limitResultCount);\n        // Collect results from middle lines\n        for (let lineNumber = searchRange.startLineNumber + 1; lineNumber < searchRange.endLineNumber && resultLen < limitResultCount; lineNumber++) {\n            resultLen = this._findMatchesInLine(searchData, model.getLineContent(lineNumber), lineNumber, 0, resultLen, result, captureMatches, limitResultCount);\n        }\n        // Collect results from last line\n        if (resultLen < limitResultCount) {\n            const text = model.getLineContent(searchRange.endLineNumber).substring(0, searchRange.endColumn - 1);\n            resultLen = this._findMatchesInLine(searchData, text, searchRange.endLineNumber, 0, resultLen, result, captureMatches, limitResultCount);\n        }\n        return result;\n    }\n    static _findMatchesInLine(searchData, text, lineNumber, deltaOffset, resultLen, result, captureMatches, limitResultCount) {\n        const wordSeparators = searchData.wordSeparators;\n        if (!captureMatches && searchData.simpleSearch) {\n            const searchString = searchData.simpleSearch;\n            const searchStringLen = searchString.length;\n            const textLength = text.length;\n            let lastMatchIndex = -searchStringLen;\n            while ((lastMatchIndex = text.indexOf(searchString, lastMatchIndex + searchStringLen)) !== -1) {\n                if (!wordSeparators || isValidMatch(wordSeparators, text, textLength, lastMatchIndex, searchStringLen)) {\n                    result[resultLen++] = new FindMatch(new Range(lineNumber, lastMatchIndex + 1 + deltaOffset, lineNumber, lastMatchIndex + 1 + searchStringLen + deltaOffset), null);\n                    if (resultLen >= limitResultCount) {\n                        return resultLen;\n                    }\n                }\n            }\n            return resultLen;\n        }\n        const searcher = new Searcher(searchData.wordSeparators, searchData.regex);\n        let m;\n        // Reset regex to search from the beginning\n        searcher.reset(0);\n        do {\n            m = searcher.next(text);\n            if (m) {\n                result[resultLen++] = createFindMatch(new Range(lineNumber, m.index + 1 + deltaOffset, lineNumber, m.index + 1 + m[0].length + deltaOffset), m, captureMatches);\n                if (resultLen >= limitResultCount) {\n                    return resultLen;\n                }\n            }\n        } while (m);\n        return resultLen;\n    }\n    static findNextMatch(model, searchParams, searchStart, captureMatches) {\n        const searchData = searchParams.parseSearchRequest();\n        if (!searchData) {\n            return null;\n        }\n        const searcher = new Searcher(searchData.wordSeparators, searchData.regex);\n        if (searchData.regex.multiline) {\n            return this._doFindNextMatchMultiline(model, searchStart, searcher, captureMatches);\n        }\n        return this._doFindNextMatchLineByLine(model, searchStart, searcher, captureMatches);\n    }\n    static _doFindNextMatchMultiline(model, searchStart, searcher, captureMatches) {\n        const searchTextStart = new Position(searchStart.lineNumber, 1);\n        const deltaOffset = model.getOffsetAt(searchTextStart);\n        const lineCount = model.getLineCount();\n        // We always execute multiline search over the lines joined with \\n\n        // This makes it that \\n will match the EOL for both CRLF and LF models\n        // We compensate for offset errors in `_getMultilineMatchRange`\n        const text = model.getValueInRange(new Range(searchTextStart.lineNumber, searchTextStart.column, lineCount, model.getLineMaxColumn(lineCount)), 1 /* EndOfLinePreference.LF */);\n        const lfCounter = (model.getEOL() === '\\r\\n' ? new LineFeedCounter(text) : null);\n        searcher.reset(searchStart.column - 1);\n        const m = searcher.next(text);\n        if (m) {\n            return createFindMatch(this._getMultilineMatchRange(model, deltaOffset, text, lfCounter, m.index, m[0]), m, captureMatches);\n        }\n        if (searchStart.lineNumber !== 1 || searchStart.column !== 1) {\n            // Try again from the top\n            return this._doFindNextMatchMultiline(model, new Position(1, 1), searcher, captureMatches);\n        }\n        return null;\n    }\n    static _doFindNextMatchLineByLine(model, searchStart, searcher, captureMatches) {\n        const lineCount = model.getLineCount();\n        const startLineNumber = searchStart.lineNumber;\n        // Look in first line\n        const text = model.getLineContent(startLineNumber);\n        const r = this._findFirstMatchInLine(searcher, text, startLineNumber, searchStart.column, captureMatches);\n        if (r) {\n            return r;\n        }\n        for (let i = 1; i <= lineCount; i++) {\n            const lineIndex = (startLineNumber + i - 1) % lineCount;\n            const text = model.getLineContent(lineIndex + 1);\n            const r = this._findFirstMatchInLine(searcher, text, lineIndex + 1, 1, captureMatches);\n            if (r) {\n                return r;\n            }\n        }\n        return null;\n    }\n    static _findFirstMatchInLine(searcher, text, lineNumber, fromColumn, captureMatches) {\n        // Set regex to search from column\n        searcher.reset(fromColumn - 1);\n        const m = searcher.next(text);\n        if (m) {\n            return createFindMatch(new Range(lineNumber, m.index + 1, lineNumber, m.index + 1 + m[0].length), m, captureMatches);\n        }\n        return null;\n    }\n    static findPreviousMatch(model, searchParams, searchStart, captureMatches) {\n        const searchData = searchParams.parseSearchRequest();\n        if (!searchData) {\n            return null;\n        }\n        const searcher = new Searcher(searchData.wordSeparators, searchData.regex);\n        if (searchData.regex.multiline) {\n            return this._doFindPreviousMatchMultiline(model, searchStart, searcher, captureMatches);\n        }\n        return this._doFindPreviousMatchLineByLine(model, searchStart, searcher, captureMatches);\n    }\n    static _doFindPreviousMatchMultiline(model, searchStart, searcher, captureMatches) {\n        const matches = this._doFindMatchesMultiline(model, new Range(1, 1, searchStart.lineNumber, searchStart.column), searcher, captureMatches, 10 * LIMIT_FIND_COUNT);\n        if (matches.length > 0) {\n            return matches[matches.length - 1];\n        }\n        const lineCount = model.getLineCount();\n        if (searchStart.lineNumber !== lineCount || searchStart.column !== model.getLineMaxColumn(lineCount)) {\n            // Try again with all content\n            return this._doFindPreviousMatchMultiline(model, new Position(lineCount, model.getLineMaxColumn(lineCount)), searcher, captureMatches);\n        }\n        return null;\n    }\n    static _doFindPreviousMatchLineByLine(model, searchStart, searcher, captureMatches) {\n        const lineCount = model.getLineCount();\n        const startLineNumber = searchStart.lineNumber;\n        // Look in first line\n        const text = model.getLineContent(startLineNumber).substring(0, searchStart.column - 1);\n        const r = this._findLastMatchInLine(searcher, text, startLineNumber, captureMatches);\n        if (r) {\n            return r;\n        }\n        for (let i = 1; i <= lineCount; i++) {\n            const lineIndex = (lineCount + startLineNumber - i - 1) % lineCount;\n            const text = model.getLineContent(lineIndex + 1);\n            const r = this._findLastMatchInLine(searcher, text, lineIndex + 1, captureMatches);\n            if (r) {\n                return r;\n            }\n        }\n        return null;\n    }\n    static _findLastMatchInLine(searcher, text, lineNumber, captureMatches) {\n        let bestResult = null;\n        let m;\n        searcher.reset(0);\n        while ((m = searcher.next(text))) {\n            bestResult = createFindMatch(new Range(lineNumber, m.index + 1, lineNumber, m.index + 1 + m[0].length), m, captureMatches);\n        }\n        return bestResult;\n    }\n}\nfunction leftIsWordBounday(wordSeparators, text, textLength, matchStartIndex, matchLength) {\n    if (matchStartIndex === 0) {\n        // Match starts at start of string\n        return true;\n    }\n    const charBefore = text.charCodeAt(matchStartIndex - 1);\n    if (wordSeparators.get(charBefore) !== 0 /* WordCharacterClass.Regular */) {\n        // The character before the match is a word separator\n        return true;\n    }\n    if (charBefore === 13 /* CharCode.CarriageReturn */ || charBefore === 10 /* CharCode.LineFeed */) {\n        // The character before the match is line break or carriage return.\n        return true;\n    }\n    if (matchLength > 0) {\n        const firstCharInMatch = text.charCodeAt(matchStartIndex);\n        if (wordSeparators.get(firstCharInMatch) !== 0 /* WordCharacterClass.Regular */) {\n            // The first character inside the match is a word separator\n            return true;\n        }\n    }\n    return false;\n}\nfunction rightIsWordBounday(wordSeparators, text, textLength, matchStartIndex, matchLength) {\n    if (matchStartIndex + matchLength === textLength) {\n        // Match ends at end of string\n        return true;\n    }\n    const charAfter = text.charCodeAt(matchStartIndex + matchLength);\n    if (wordSeparators.get(charAfter) !== 0 /* WordCharacterClass.Regular */) {\n        // The character after the match is a word separator\n        return true;\n    }\n    if (charAfter === 13 /* CharCode.CarriageReturn */ || charAfter === 10 /* CharCode.LineFeed */) {\n        // The character after the match is line break or carriage return.\n        return true;\n    }\n    if (matchLength > 0) {\n        const lastCharInMatch = text.charCodeAt(matchStartIndex + matchLength - 1);\n        if (wordSeparators.get(lastCharInMatch) !== 0 /* WordCharacterClass.Regular */) {\n            // The last character in the match is a word separator\n            return true;\n        }\n    }\n    return false;\n}\nfunction isValidMatch(wordSeparators, text, textLength, matchStartIndex, matchLength) {\n    return (leftIsWordBounday(wordSeparators, text, textLength, matchStartIndex, matchLength)\n        && rightIsWordBounday(wordSeparators, text, textLength, matchStartIndex, matchLength));\n}\nclass Searcher {\n    constructor(wordSeparators, searchRegex) {\n        this._wordSeparators = wordSeparators;\n        this._searchRegex = searchRegex;\n        this._prevMatchStartIndex = -1;\n        this._prevMatchLength = 0;\n    }\n    reset(lastIndex) {\n        this._searchRegex.lastIndex = lastIndex;\n        this._prevMatchStartIndex = -1;\n        this._prevMatchLength = 0;\n    }\n    next(text) {\n        const textLength = text.length;\n        let m;\n        do {\n            if (this._prevMatchStartIndex + this._prevMatchLength === textLength) {\n                // Reached the end of the line\n                return null;\n            }\n            m = this._searchRegex.exec(text);\n            if (!m) {\n                return null;\n            }\n            const matchStartIndex = m.index;\n            const matchLength = m[0].length;\n            if (matchStartIndex === this._prevMatchStartIndex && matchLength === this._prevMatchLength) {\n                if (matchLength === 0) {\n                    // the search result is an empty string and won't advance `regex.lastIndex`, so `regex.exec` will stuck here\n                    // we attempt to recover from that by advancing by two if surrogate pair found and by one otherwise\n                    if (getNextCodePoint(text, textLength, this._searchRegex.lastIndex) > 0xFFFF) {\n                        this._searchRegex.lastIndex += 2;\n                    }\n                    else {\n                        this._searchRegex.lastIndex += 1;\n                    }\n                    continue;\n                }\n                // Exit early if the regex matches the same range twice\n                return null;\n            }\n            this._prevMatchStartIndex = matchStartIndex;\n            this._prevMatchLength = matchLength;\n            if (!this._wordSeparators || isValidMatch(this._wordSeparators, text, textLength, matchStartIndex, matchLength)) {\n                return m;\n            }\n        } while (m);\n        return null;\n    }\n}\n\nexport { SearchParams, Searcher, TextModelSearch, createFindMatch, isMultilineRegexSource, isValidMatch };\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 469, "column": 0}, "map": {"version":3,"sources":["file:///D:/real-time-code-editor%20%282%29/node_modules/.pnpm/monaco-editor%400.55.1/node_modules/monaco-editor/esm/vs/editor/common/model/prefixSumComputer.js"],"sourcesContent":["import { arrayInsert } from '../../../base/common/arrays.js';\nimport { toUint32 } from '../../../base/common/uint.js';\n\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nclass PrefixSumComputer {\n    constructor(values) {\n        this.values = values;\n        this.prefixSum = new Uint32Array(values.length);\n        this.prefixSumValidIndex = new Int32Array(1);\n        this.prefixSumValidIndex[0] = -1;\n    }\n    insertValues(insertIndex, insertValues) {\n        insertIndex = toUint32(insertIndex);\n        const oldValues = this.values;\n        const oldPrefixSum = this.prefixSum;\n        const insertValuesLen = insertValues.length;\n        if (insertValuesLen === 0) {\n            return false;\n        }\n        this.values = new Uint32Array(oldValues.length + insertValuesLen);\n        this.values.set(oldValues.subarray(0, insertIndex), 0);\n        this.values.set(oldValues.subarray(insertIndex), insertIndex + insertValuesLen);\n        this.values.set(insertValues, insertIndex);\n        if (insertIndex - 1 < this.prefixSumValidIndex[0]) {\n            this.prefixSumValidIndex[0] = insertIndex - 1;\n        }\n        this.prefixSum = new Uint32Array(this.values.length);\n        if (this.prefixSumValidIndex[0] >= 0) {\n            this.prefixSum.set(oldPrefixSum.subarray(0, this.prefixSumValidIndex[0] + 1));\n        }\n        return true;\n    }\n    setValue(index, value) {\n        index = toUint32(index);\n        value = toUint32(value);\n        if (this.values[index] === value) {\n            return false;\n        }\n        this.values[index] = value;\n        if (index - 1 < this.prefixSumValidIndex[0]) {\n            this.prefixSumValidIndex[0] = index - 1;\n        }\n        return true;\n    }\n    removeValues(startIndex, count) {\n        startIndex = toUint32(startIndex);\n        count = toUint32(count);\n        const oldValues = this.values;\n        const oldPrefixSum = this.prefixSum;\n        if (startIndex >= oldValues.length) {\n            return false;\n        }\n        const maxCount = oldValues.length - startIndex;\n        if (count >= maxCount) {\n            count = maxCount;\n        }\n        if (count === 0) {\n            return false;\n        }\n        this.values = new Uint32Array(oldValues.length - count);\n        this.values.set(oldValues.subarray(0, startIndex), 0);\n        this.values.set(oldValues.subarray(startIndex + count), startIndex);\n        this.prefixSum = new Uint32Array(this.values.length);\n        if (startIndex - 1 < this.prefixSumValidIndex[0]) {\n            this.prefixSumValidIndex[0] = startIndex - 1;\n        }\n        if (this.prefixSumValidIndex[0] >= 0) {\n            this.prefixSum.set(oldPrefixSum.subarray(0, this.prefixSumValidIndex[0] + 1));\n        }\n        return true;\n    }\n    getTotalSum() {\n        if (this.values.length === 0) {\n            return 0;\n        }\n        return this._getPrefixSum(this.values.length - 1);\n    }\n    /**\n     * Returns the sum of the first `index + 1` many items.\n     * @returns `SUM(0 <= j <= index, values[j])`.\n     */\n    getPrefixSum(index) {\n        if (index < 0) {\n            return 0;\n        }\n        index = toUint32(index);\n        return this._getPrefixSum(index);\n    }\n    _getPrefixSum(index) {\n        if (index <= this.prefixSumValidIndex[0]) {\n            return this.prefixSum[index];\n        }\n        let startIndex = this.prefixSumValidIndex[0] + 1;\n        if (startIndex === 0) {\n            this.prefixSum[0] = this.values[0];\n            startIndex++;\n        }\n        if (index >= this.values.length) {\n            index = this.values.length - 1;\n        }\n        for (let i = startIndex; i <= index; i++) {\n            this.prefixSum[i] = this.prefixSum[i - 1] + this.values[i];\n        }\n        this.prefixSumValidIndex[0] = Math.max(this.prefixSumValidIndex[0], index);\n        return this.prefixSum[index];\n    }\n    getIndexOf(sum) {\n        sum = Math.floor(sum);\n        // Compute all sums (to get a fully valid prefixSum)\n        this.getTotalSum();\n        let low = 0;\n        let high = this.values.length - 1;\n        let mid = 0;\n        let midStop = 0;\n        let midStart = 0;\n        while (low <= high) {\n            mid = low + ((high - low) / 2) | 0;\n            midStop = this.prefixSum[mid];\n            midStart = midStop - this.values[mid];\n            if (sum < midStart) {\n                high = mid - 1;\n            }\n            else if (sum >= midStop) {\n                low = mid + 1;\n            }\n            else {\n                break;\n            }\n        }\n        return new PrefixSumIndexOfResult(mid, sum - midStart);\n    }\n}\n/**\n * {@link getIndexOf} has an amortized runtime complexity of O(1).\n *\n * ({@link PrefixSumComputer.getIndexOf} is just  O(log n))\n*/\nclass ConstantTimePrefixSumComputer {\n    constructor(values) {\n        this._values = values;\n        this._isValid = false;\n        this._validEndIndex = -1;\n        this._prefixSum = [];\n        this._indexBySum = [];\n    }\n    /**\n     * @returns SUM(0 <= j < values.length, values[j])\n     */\n    getTotalSum() {\n        this._ensureValid();\n        return this._indexBySum.length;\n    }\n    /**\n     * Returns the sum of the first `count` many items.\n     * @returns `SUM(0 <= j < count, values[j])`.\n     */\n    getPrefixSum(count) {\n        this._ensureValid();\n        if (count === 0) {\n            return 0;\n        }\n        return this._prefixSum[count - 1];\n    }\n    /**\n     * @returns `result`, such that `getPrefixSum(result.index) + result.remainder = sum`\n     */\n    getIndexOf(sum) {\n        this._ensureValid();\n        const idx = this._indexBySum[sum];\n        const viewLinesAbove = idx > 0 ? this._prefixSum[idx - 1] : 0;\n        return new PrefixSumIndexOfResult(idx, sum - viewLinesAbove);\n    }\n    removeValues(start, deleteCount) {\n        this._values.splice(start, deleteCount);\n        this._invalidate(start);\n    }\n    insertValues(insertIndex, insertArr) {\n        this._values = arrayInsert(this._values, insertIndex, insertArr);\n        this._invalidate(insertIndex);\n    }\n    _invalidate(index) {\n        this._isValid = false;\n        this._validEndIndex = Math.min(this._validEndIndex, index - 1);\n    }\n    _ensureValid() {\n        if (this._isValid) {\n            return;\n        }\n        for (let i = this._validEndIndex + 1, len = this._values.length; i < len; i++) {\n            const value = this._values[i];\n            const sumAbove = i > 0 ? this._prefixSum[i - 1] : 0;\n            this._prefixSum[i] = sumAbove + value;\n            for (let j = 0; j < value; j++) {\n                this._indexBySum[sumAbove + j] = i;\n            }\n        }\n        // trim things\n        this._prefixSum.length = this._values.length;\n        this._indexBySum.length = this._prefixSum[this._prefixSum.length - 1];\n        // mark as valid\n        this._isValid = true;\n        this._validEndIndex = this._values.length - 1;\n    }\n    setValue(index, value) {\n        if (this._values[index] === value) {\n            // no change\n            return;\n        }\n        this._values[index] = value;\n        this._invalidate(index);\n    }\n}\nclass PrefixSumIndexOfResult {\n    constructor(index, remainder) {\n        this.index = index;\n        this.remainder = remainder;\n        this._prefixSumIndexOfResultBrand = undefined;\n        this.index = index;\n        this.remainder = remainder;\n    }\n}\n\nexport { ConstantTimePrefixSumComputer, PrefixSumComputer, PrefixSumIndexOfResult };\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 699, "column": 0}, "map": {"version":3,"sources":["file:///D:/real-time-code-editor%20%282%29/node_modules/.pnpm/monaco-editor%400.55.1/node_modules/monaco-editor/esm/vs/editor/common/model/mirrorTextModel.js"],"sourcesContent":["import { splitLines } from '../../../base/common/strings.js';\nimport { Position } from '../core/position.js';\nimport { PrefixSumComputer } from './prefixSumComputer.js';\n\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nclass MirrorTextModel {\n    constructor(uri, lines, eol, versionId) {\n        this._uri = uri;\n        this._lines = lines;\n        this._eol = eol;\n        this._versionId = versionId;\n        this._lineStarts = null;\n        this._cachedTextValue = null;\n    }\n    dispose() {\n        this._lines.length = 0;\n    }\n    get version() {\n        return this._versionId;\n    }\n    getText() {\n        if (this._cachedTextValue === null) {\n            this._cachedTextValue = this._lines.join(this._eol);\n        }\n        return this._cachedTextValue;\n    }\n    onEvents(e) {\n        if (e.eol && e.eol !== this._eol) {\n            this._eol = e.eol;\n            this._lineStarts = null;\n        }\n        // Update my lines\n        const changes = e.changes;\n        for (const change of changes) {\n            this._acceptDeleteRange(change.range);\n            this._acceptInsertText(new Position(change.range.startLineNumber, change.range.startColumn), change.text);\n        }\n        this._versionId = e.versionId;\n        this._cachedTextValue = null;\n    }\n    _ensureLineStarts() {\n        if (!this._lineStarts) {\n            const eolLength = this._eol.length;\n            const linesLength = this._lines.length;\n            const lineStartValues = new Uint32Array(linesLength);\n            for (let i = 0; i < linesLength; i++) {\n                lineStartValues[i] = this._lines[i].length + eolLength;\n            }\n            this._lineStarts = new PrefixSumComputer(lineStartValues);\n        }\n    }\n    /**\n     * All changes to a line's text go through this method\n     */\n    _setLineText(lineIndex, newValue) {\n        this._lines[lineIndex] = newValue;\n        if (this._lineStarts) {\n            // update prefix sum\n            this._lineStarts.setValue(lineIndex, this._lines[lineIndex].length + this._eol.length);\n        }\n    }\n    _acceptDeleteRange(range) {\n        if (range.startLineNumber === range.endLineNumber) {\n            if (range.startColumn === range.endColumn) {\n                // Nothing to delete\n                return;\n            }\n            // Delete text on the affected line\n            this._setLineText(range.startLineNumber - 1, this._lines[range.startLineNumber - 1].substring(0, range.startColumn - 1)\n                + this._lines[range.startLineNumber - 1].substring(range.endColumn - 1));\n            return;\n        }\n        // Take remaining text on last line and append it to remaining text on first line\n        this._setLineText(range.startLineNumber - 1, this._lines[range.startLineNumber - 1].substring(0, range.startColumn - 1)\n            + this._lines[range.endLineNumber - 1].substring(range.endColumn - 1));\n        // Delete middle lines\n        this._lines.splice(range.startLineNumber, range.endLineNumber - range.startLineNumber);\n        if (this._lineStarts) {\n            // update prefix sum\n            this._lineStarts.removeValues(range.startLineNumber, range.endLineNumber - range.startLineNumber);\n        }\n    }\n    _acceptInsertText(position, insertText) {\n        if (insertText.length === 0) {\n            // Nothing to insert\n            return;\n        }\n        const insertLines = splitLines(insertText);\n        if (insertLines.length === 1) {\n            // Inserting text on one line\n            this._setLineText(position.lineNumber - 1, this._lines[position.lineNumber - 1].substring(0, position.column - 1)\n                + insertLines[0]\n                + this._lines[position.lineNumber - 1].substring(position.column - 1));\n            return;\n        }\n        // Append overflowing text from first line to the end of text to insert\n        insertLines[insertLines.length - 1] += this._lines[position.lineNumber - 1].substring(position.column - 1);\n        // Delete overflowing text from first line and insert text on first line\n        this._setLineText(position.lineNumber - 1, this._lines[position.lineNumber - 1].substring(0, position.column - 1)\n            + insertLines[0]);\n        // Insert new lines & store lengths\n        const newLengths = new Uint32Array(insertLines.length - 1);\n        for (let i = 1; i < insertLines.length; i++) {\n            this._lines.splice(position.lineNumber + i - 1, 0, insertLines[i]);\n            newLengths[i - 1] = insertLines[i].length + this._eol.length;\n        }\n        if (this._lineStarts) {\n            // update prefix sum\n            this._lineStarts.insertValues(position.lineNumber, newLengths);\n        }\n    }\n}\n\nexport { MirrorTextModel };\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 818, "column": 0}, "map": {"version":3,"sources":["file:///D:/real-time-code-editor%20%282%29/node_modules/.pnpm/monaco-editor%400.55.1/node_modules/monaco-editor/esm/vs/editor/common/model/textModelPart.js"],"sourcesContent":["import { Disposable } from '../../../base/common/lifecycle.js';\n\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nclass TextModelPart extends Disposable {\n    constructor() {\n        super(...arguments);\n        this._isDisposed = false;\n    }\n    dispose() {\n        super.dispose();\n        this._isDisposed = true;\n    }\n    assertNotDisposed() {\n        if (this._isDisposed) {\n            throw new Error('TextModelPart is disposed!');\n        }\n    }\n}\n\nexport { TextModelPart };\n"],"names":[],"mappings":";;;;AAAA;;AAEA;;;8FAG8F,GAC9F,MAAM,sBAAsB,2PAAU;IAClC,aAAc;QACV,KAAK,IAAI;QACT,IAAI,CAAC,WAAW,GAAG;IACvB;IACA,UAAU;QACN,KAAK,CAAC;QACN,IAAI,CAAC,WAAW,GAAG;IACvB;IACA,oBAAoB;QAChB,IAAI,IAAI,CAAC,WAAW,EAAE;YAClB,MAAM,IAAI,MAAM;QACpB;IACJ;AACJ","ignoreList":[0]}},
    {"offset": {"line": 847, "column": 0}, "map": {"version":3,"sources":["file:///D:/real-time-code-editor%20%282%29/node_modules/.pnpm/monaco-editor%400.55.1/node_modules/monaco-editor/esm/vs/editor/common/model/utils.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n/**\n * Returns:\n *  - -1 => the line consists of whitespace\n *  - otherwise => the indent level is returned value\n */\nfunction computeIndentLevel(line, tabSize) {\n    let indent = 0;\n    let i = 0;\n    const len = line.length;\n    while (i < len) {\n        const chCode = line.charCodeAt(i);\n        if (chCode === 32 /* CharCode.Space */) {\n            indent++;\n        }\n        else if (chCode === 9 /* CharCode.Tab */) {\n            indent = indent - indent % tabSize + tabSize;\n        }\n        else {\n            break;\n        }\n        i++;\n    }\n    if (i === len) {\n        return -1; // line only consists of whitespace\n    }\n    return indent;\n}\n\nexport { computeIndentLevel };\n"],"names":[],"mappings":"AAAA;;;8FAG8F,GAC9F;;;;CAIC;;;;AACD,SAAS,mBAAmB,IAAI,EAAE,OAAO;IACrC,IAAI,SAAS;IACb,IAAI,IAAI;IACR,MAAM,MAAM,KAAK,MAAM;IACvB,MAAO,IAAI,IAAK;QACZ,MAAM,SAAS,KAAK,UAAU,CAAC;QAC/B,IAAI,WAAW,GAAG,kBAAkB,KAAI;YACpC;QACJ,OACK,IAAI,WAAW,EAAE,gBAAgB,KAAI;YACtC,SAAS,SAAS,SAAS,UAAU;QACzC,OACK;YACD;QACJ;QACA;IACJ;IACA,IAAI,MAAM,KAAK;QACX,OAAO,CAAC,GAAG,mCAAmC;IAClD;IACA,OAAO;AACX","ignoreList":[0]}},
    {"offset": {"line": 883, "column": 0}, "map": {"version":3,"sources":["file:///D:/real-time-code-editor%20%282%29/node_modules/.pnpm/monaco-editor%400.55.1/node_modules/monaco-editor/esm/vs/editor/common/model/guidesTextModelPart.js"],"sourcesContent":["import { findLast } from '../../../base/common/arraysFind.js';\nimport { firstNonWhitespaceIndex } from '../../../base/common/strings.js';\nimport { CursorColumns } from '../core/cursorColumns.js';\nimport { Range } from '../core/range.js';\nimport { TextModelPart } from './textModelPart.js';\nimport { computeIndentLevel } from './utils.js';\nimport { HorizontalGuidesState, IndentGuide, IndentGuideHorizontalLine } from '../textModelGuides.js';\nimport { BugIndicatingError } from '../../../base/common/errors.js';\n\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nclass GuidesTextModelPart extends TextModelPart {\n    constructor(textModel, languageConfigurationService) {\n        super();\n        this.textModel = textModel;\n        this.languageConfigurationService = languageConfigurationService;\n    }\n    getLanguageConfiguration(languageId) {\n        return this.languageConfigurationService.getLanguageConfiguration(languageId);\n    }\n    _computeIndentLevel(lineIndex) {\n        return computeIndentLevel(this.textModel.getLineContent(lineIndex + 1), this.textModel.getOptions().tabSize);\n    }\n    getActiveIndentGuide(lineNumber, minLineNumber, maxLineNumber) {\n        this.assertNotDisposed();\n        const lineCount = this.textModel.getLineCount();\n        if (lineNumber < 1 || lineNumber > lineCount) {\n            throw new BugIndicatingError('Illegal value for lineNumber');\n        }\n        const foldingRules = this.getLanguageConfiguration(this.textModel.getLanguageId()).foldingRules;\n        const offSide = Boolean(foldingRules && foldingRules.offSide);\n        let up_aboveContentLineIndex = -2; /* -2 is a marker for not having computed it */\n        let up_aboveContentLineIndent = -1;\n        let up_belowContentLineIndex = -2; /* -2 is a marker for not having computed it */\n        let up_belowContentLineIndent = -1;\n        const up_resolveIndents = (lineNumber) => {\n            if (up_aboveContentLineIndex !== -1 &&\n                (up_aboveContentLineIndex === -2 ||\n                    up_aboveContentLineIndex > lineNumber - 1)) {\n                up_aboveContentLineIndex = -1;\n                up_aboveContentLineIndent = -1;\n                // must find previous line with content\n                for (let lineIndex = lineNumber - 2; lineIndex >= 0; lineIndex--) {\n                    const indent = this._computeIndentLevel(lineIndex);\n                    if (indent >= 0) {\n                        up_aboveContentLineIndex = lineIndex;\n                        up_aboveContentLineIndent = indent;\n                        break;\n                    }\n                }\n            }\n            if (up_belowContentLineIndex === -2) {\n                up_belowContentLineIndex = -1;\n                up_belowContentLineIndent = -1;\n                // must find next line with content\n                for (let lineIndex = lineNumber; lineIndex < lineCount; lineIndex++) {\n                    const indent = this._computeIndentLevel(lineIndex);\n                    if (indent >= 0) {\n                        up_belowContentLineIndex = lineIndex;\n                        up_belowContentLineIndent = indent;\n                        break;\n                    }\n                }\n            }\n        };\n        let down_aboveContentLineIndex = -2; /* -2 is a marker for not having computed it */\n        let down_aboveContentLineIndent = -1;\n        let down_belowContentLineIndex = -2; /* -2 is a marker for not having computed it */\n        let down_belowContentLineIndent = -1;\n        const down_resolveIndents = (lineNumber) => {\n            if (down_aboveContentLineIndex === -2) {\n                down_aboveContentLineIndex = -1;\n                down_aboveContentLineIndent = -1;\n                // must find previous line with content\n                for (let lineIndex = lineNumber - 2; lineIndex >= 0; lineIndex--) {\n                    const indent = this._computeIndentLevel(lineIndex);\n                    if (indent >= 0) {\n                        down_aboveContentLineIndex = lineIndex;\n                        down_aboveContentLineIndent = indent;\n                        break;\n                    }\n                }\n            }\n            if (down_belowContentLineIndex !== -1 &&\n                (down_belowContentLineIndex === -2 ||\n                    down_belowContentLineIndex < lineNumber - 1)) {\n                down_belowContentLineIndex = -1;\n                down_belowContentLineIndent = -1;\n                // must find next line with content\n                for (let lineIndex = lineNumber; lineIndex < lineCount; lineIndex++) {\n                    const indent = this._computeIndentLevel(lineIndex);\n                    if (indent >= 0) {\n                        down_belowContentLineIndex = lineIndex;\n                        down_belowContentLineIndent = indent;\n                        break;\n                    }\n                }\n            }\n        };\n        let startLineNumber = 0;\n        let goUp = true;\n        let endLineNumber = 0;\n        let goDown = true;\n        let indent = 0;\n        let initialIndent = 0;\n        for (let distance = 0; goUp || goDown; distance++) {\n            const upLineNumber = lineNumber - distance;\n            const downLineNumber = lineNumber + distance;\n            if (distance > 1 && (upLineNumber < 1 || upLineNumber < minLineNumber)) {\n                goUp = false;\n            }\n            if (distance > 1 &&\n                (downLineNumber > lineCount || downLineNumber > maxLineNumber)) {\n                goDown = false;\n            }\n            if (distance > 50000) {\n                // stop processing\n                goUp = false;\n                goDown = false;\n            }\n            let upLineIndentLevel = -1;\n            if (goUp && upLineNumber >= 1) {\n                // compute indent level going up\n                const currentIndent = this._computeIndentLevel(upLineNumber - 1);\n                if (currentIndent >= 0) {\n                    // This line has content (besides whitespace)\n                    // Use the line's indent\n                    up_belowContentLineIndex = upLineNumber - 1;\n                    up_belowContentLineIndent = currentIndent;\n                    upLineIndentLevel = Math.ceil(currentIndent / this.textModel.getOptions().indentSize);\n                }\n                else {\n                    up_resolveIndents(upLineNumber);\n                    upLineIndentLevel = this._getIndentLevelForWhitespaceLine(offSide, up_aboveContentLineIndent, up_belowContentLineIndent);\n                }\n            }\n            let downLineIndentLevel = -1;\n            if (goDown && downLineNumber <= lineCount) {\n                // compute indent level going down\n                const currentIndent = this._computeIndentLevel(downLineNumber - 1);\n                if (currentIndent >= 0) {\n                    // This line has content (besides whitespace)\n                    // Use the line's indent\n                    down_aboveContentLineIndex = downLineNumber - 1;\n                    down_aboveContentLineIndent = currentIndent;\n                    downLineIndentLevel = Math.ceil(currentIndent / this.textModel.getOptions().indentSize);\n                }\n                else {\n                    down_resolveIndents(downLineNumber);\n                    downLineIndentLevel = this._getIndentLevelForWhitespaceLine(offSide, down_aboveContentLineIndent, down_belowContentLineIndent);\n                }\n            }\n            if (distance === 0) {\n                initialIndent = upLineIndentLevel;\n                continue;\n            }\n            if (distance === 1) {\n                if (downLineNumber <= lineCount &&\n                    downLineIndentLevel >= 0 &&\n                    initialIndent + 1 === downLineIndentLevel) {\n                    // This is the beginning of a scope, we have special handling here, since we want the\n                    // child scope indent to be active, not the parent scope\n                    goUp = false;\n                    startLineNumber = downLineNumber;\n                    endLineNumber = downLineNumber;\n                    indent = downLineIndentLevel;\n                    continue;\n                }\n                if (upLineNumber >= 1 &&\n                    upLineIndentLevel >= 0 &&\n                    upLineIndentLevel - 1 === initialIndent) {\n                    // This is the end of a scope, just like above\n                    goDown = false;\n                    startLineNumber = upLineNumber;\n                    endLineNumber = upLineNumber;\n                    indent = upLineIndentLevel;\n                    continue;\n                }\n                startLineNumber = lineNumber;\n                endLineNumber = lineNumber;\n                indent = initialIndent;\n                if (indent === 0) {\n                    // No need to continue\n                    return { startLineNumber, endLineNumber, indent };\n                }\n            }\n            if (goUp) {\n                if (upLineIndentLevel >= indent) {\n                    startLineNumber = upLineNumber;\n                }\n                else {\n                    goUp = false;\n                }\n            }\n            if (goDown) {\n                if (downLineIndentLevel >= indent) {\n                    endLineNumber = downLineNumber;\n                }\n                else {\n                    goDown = false;\n                }\n            }\n        }\n        return { startLineNumber, endLineNumber, indent };\n    }\n    getLinesBracketGuides(startLineNumber, endLineNumber, activePosition, options) {\n        const result = [];\n        for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n            result.push([]);\n        }\n        // If requested, this could be made configurable.\n        const includeSingleLinePairs = true;\n        const bracketPairs = this.textModel.bracketPairs.getBracketPairsInRangeWithMinIndentation(new Range(startLineNumber, 1, endLineNumber, this.textModel.getLineMaxColumn(endLineNumber))).toArray();\n        let activeBracketPairRange = undefined;\n        if (activePosition && bracketPairs.length > 0) {\n            const bracketsContainingActivePosition = (startLineNumber <= activePosition.lineNumber &&\n                activePosition.lineNumber <= endLineNumber\n                // We don't need to query the brackets again if the cursor is in the viewport\n                ? bracketPairs\n                : this.textModel.bracketPairs.getBracketPairsInRange(Range.fromPositions(activePosition)).toArray()).filter((bp) => Range.strictContainsPosition(bp.range, activePosition));\n            activeBracketPairRange = findLast(bracketsContainingActivePosition, (i) => includeSingleLinePairs)?.range;\n        }\n        const independentColorPoolPerBracketType = this.textModel.getOptions().bracketPairColorizationOptions.independentColorPoolPerBracketType;\n        const colorProvider = new BracketPairGuidesClassNames();\n        for (const pair of bracketPairs) {\n            /*\n\n\n                    {\n                    |\n                    }\n\n                    {\n                    |\n                    ----}\n\n                ____{\n                |test\n                ----}\n\n                renderHorizontalEndLineAtTheBottom:\n                    {\n                    |\n                    |x}\n                    --\n                renderHorizontalEndLineAtTheBottom:\n                ____{\n                |test\n                | x }\n                ----\n            */\n            if (!pair.closingBracketRange) {\n                continue;\n            }\n            const isActive = activeBracketPairRange && pair.range.equalsRange(activeBracketPairRange);\n            if (!isActive && !options.includeInactive) {\n                continue;\n            }\n            const className = colorProvider.getInlineClassName(pair.nestingLevel, pair.nestingLevelOfEqualBracketType, independentColorPoolPerBracketType) +\n                (options.highlightActive && isActive\n                    ? ' ' + colorProvider.activeClassName\n                    : '');\n            const start = pair.openingBracketRange.getStartPosition();\n            const end = pair.closingBracketRange.getStartPosition();\n            const horizontalGuides = options.horizontalGuides === HorizontalGuidesState.Enabled || (options.horizontalGuides === HorizontalGuidesState.EnabledForActive && isActive);\n            if (pair.range.startLineNumber === pair.range.endLineNumber) {\n                if (horizontalGuides) {\n                    result[pair.range.startLineNumber - startLineNumber].push(new IndentGuide(-1, pair.openingBracketRange.getEndPosition().column, className, new IndentGuideHorizontalLine(false, end.column), -1, -1));\n                }\n                continue;\n            }\n            const endVisibleColumn = this.getVisibleColumnFromPosition(end);\n            const startVisibleColumn = this.getVisibleColumnFromPosition(pair.openingBracketRange.getStartPosition());\n            const guideVisibleColumn = Math.min(startVisibleColumn, endVisibleColumn, pair.minVisibleColumnIndentation + 1);\n            let renderHorizontalEndLineAtTheBottom = false;\n            const firstNonWsIndex = firstNonWhitespaceIndex(this.textModel.getLineContent(pair.closingBracketRange.startLineNumber));\n            const hasTextBeforeClosingBracket = firstNonWsIndex < pair.closingBracketRange.startColumn - 1;\n            if (hasTextBeforeClosingBracket) {\n                renderHorizontalEndLineAtTheBottom = true;\n            }\n            const visibleGuideStartLineNumber = Math.max(start.lineNumber, startLineNumber);\n            const visibleGuideEndLineNumber = Math.min(end.lineNumber, endLineNumber);\n            const offset = renderHorizontalEndLineAtTheBottom ? 1 : 0;\n            for (let l = visibleGuideStartLineNumber; l < visibleGuideEndLineNumber + offset; l++) {\n                result[l - startLineNumber].push(new IndentGuide(guideVisibleColumn, -1, className, null, l === start.lineNumber ? start.column : -1, l === end.lineNumber ? end.column : -1));\n            }\n            if (horizontalGuides) {\n                if (start.lineNumber >= startLineNumber && startVisibleColumn > guideVisibleColumn) {\n                    result[start.lineNumber - startLineNumber].push(new IndentGuide(guideVisibleColumn, -1, className, new IndentGuideHorizontalLine(false, start.column), -1, -1));\n                }\n                if (end.lineNumber <= endLineNumber && endVisibleColumn > guideVisibleColumn) {\n                    result[end.lineNumber - startLineNumber].push(new IndentGuide(guideVisibleColumn, -1, className, new IndentGuideHorizontalLine(!renderHorizontalEndLineAtTheBottom, end.column), -1, -1));\n                }\n            }\n        }\n        for (const guides of result) {\n            guides.sort((a, b) => a.visibleColumn - b.visibleColumn);\n        }\n        return result;\n    }\n    getVisibleColumnFromPosition(position) {\n        return (CursorColumns.visibleColumnFromColumn(this.textModel.getLineContent(position.lineNumber), position.column, this.textModel.getOptions().tabSize) + 1);\n    }\n    getLinesIndentGuides(startLineNumber, endLineNumber) {\n        this.assertNotDisposed();\n        const lineCount = this.textModel.getLineCount();\n        if (startLineNumber < 1 || startLineNumber > lineCount) {\n            throw new Error('Illegal value for startLineNumber');\n        }\n        if (endLineNumber < 1 || endLineNumber > lineCount) {\n            throw new Error('Illegal value for endLineNumber');\n        }\n        const options = this.textModel.getOptions();\n        const foldingRules = this.getLanguageConfiguration(this.textModel.getLanguageId()).foldingRules;\n        const offSide = Boolean(foldingRules && foldingRules.offSide);\n        const result = new Array(endLineNumber - startLineNumber + 1);\n        let aboveContentLineIndex = -2; /* -2 is a marker for not having computed it */\n        let aboveContentLineIndent = -1;\n        let belowContentLineIndex = -2; /* -2 is a marker for not having computed it */\n        let belowContentLineIndent = -1;\n        for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n            const resultIndex = lineNumber - startLineNumber;\n            const currentIndent = this._computeIndentLevel(lineNumber - 1);\n            if (currentIndent >= 0) {\n                // This line has content (besides whitespace)\n                // Use the line's indent\n                aboveContentLineIndex = lineNumber - 1;\n                aboveContentLineIndent = currentIndent;\n                result[resultIndex] = Math.ceil(currentIndent / options.indentSize);\n                continue;\n            }\n            if (aboveContentLineIndex === -2) {\n                aboveContentLineIndex = -1;\n                aboveContentLineIndent = -1;\n                // must find previous line with content\n                for (let lineIndex = lineNumber - 2; lineIndex >= 0; lineIndex--) {\n                    const indent = this._computeIndentLevel(lineIndex);\n                    if (indent >= 0) {\n                        aboveContentLineIndex = lineIndex;\n                        aboveContentLineIndent = indent;\n                        break;\n                    }\n                }\n            }\n            if (belowContentLineIndex !== -1 &&\n                (belowContentLineIndex === -2 || belowContentLineIndex < lineNumber - 1)) {\n                belowContentLineIndex = -1;\n                belowContentLineIndent = -1;\n                // must find next line with content\n                for (let lineIndex = lineNumber; lineIndex < lineCount; lineIndex++) {\n                    const indent = this._computeIndentLevel(lineIndex);\n                    if (indent >= 0) {\n                        belowContentLineIndex = lineIndex;\n                        belowContentLineIndent = indent;\n                        break;\n                    }\n                }\n            }\n            result[resultIndex] = this._getIndentLevelForWhitespaceLine(offSide, aboveContentLineIndent, belowContentLineIndent);\n        }\n        return result;\n    }\n    _getIndentLevelForWhitespaceLine(offSide, aboveContentLineIndent, belowContentLineIndent) {\n        const options = this.textModel.getOptions();\n        if (aboveContentLineIndent === -1 || belowContentLineIndent === -1) {\n            // At the top or bottom of the file\n            return 0;\n        }\n        else if (aboveContentLineIndent < belowContentLineIndent) {\n            // we are inside the region above\n            return 1 + Math.floor(aboveContentLineIndent / options.indentSize);\n        }\n        else if (aboveContentLineIndent === belowContentLineIndent) {\n            // we are in between two regions\n            return Math.ceil(belowContentLineIndent / options.indentSize);\n        }\n        else {\n            if (offSide) {\n                // same level as region below\n                return Math.ceil(belowContentLineIndent / options.indentSize);\n            }\n            else {\n                // we are inside the region that ends below\n                return 1 + Math.floor(belowContentLineIndent / options.indentSize);\n            }\n        }\n    }\n}\nclass BracketPairGuidesClassNames {\n    constructor() {\n        this.activeClassName = 'indent-active';\n    }\n    getInlineClassName(nestingLevel, nestingLevelOfEqualBracketType, independentColorPoolPerBracketType) {\n        return this.getInlineClassNameOfLevel(independentColorPoolPerBracketType ? nestingLevelOfEqualBracketType : nestingLevel);\n    }\n    getInlineClassNameOfLevel(level) {\n        // To support a dynamic amount of colors up to 6 colors,\n        // we use a number that is a lcm of all numbers from 1 to 6.\n        return `bracket-indent-guide lvl-${level % 30}`;\n    }\n}\n\nexport { BracketPairGuidesClassNames, GuidesTextModelPart };\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1285, "column": 0}, "map": {"version":3,"sources":["file:///D:/real-time-code-editor%20%282%29/node_modules/.pnpm/monaco-editor%400.55.1/node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/length.js"],"sourcesContent":["import { splitLines } from '../../../../../base/common/strings.js';\nimport { Range } from '../../../core/range.js';\nimport { TextLength } from '../../../core/text/textLength.js';\n\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n/**\n * The end must be greater than or equal to the start.\n*/\nfunction lengthDiff(startLineCount, startColumnCount, endLineCount, endColumnCount) {\n    return (startLineCount !== endLineCount)\n        ? toLength(endLineCount - startLineCount, endColumnCount)\n        : toLength(0, endColumnCount - startColumnCount);\n}\n// eslint-disable-next-line local/code-no-any-casts, @typescript-eslint/no-explicit-any\nconst lengthZero = 0;\nfunction lengthIsZero(length) {\n    // eslint-disable-next-line local/code-no-any-casts, @typescript-eslint/no-explicit-any\n    return length === 0;\n}\n/*\n * We have 52 bits available in a JS number.\n * We use the upper 26 bits to store the line and the lower 26 bits to store the column.\n */\n///*\nconst factor = 2 ** 26;\n/*/\nconst factor = 1000000;\n// */\nfunction toLength(lineCount, columnCount) {\n    // llllllllllllllllllllllllllcccccccccccccccccccccccccc (52 bits)\n    //       line count (26 bits)    column count (26 bits)\n    // If there is no overflow (all values/sums below 2^26 = 67108864),\n    // we have `toLength(lns1, cols1) + toLength(lns2, cols2) = toLength(lns1 + lns2, cols1 + cols2)`.\n    // eslint-disable-next-line local/code-no-any-casts, @typescript-eslint/no-explicit-any\n    return (lineCount * factor + columnCount);\n}\nfunction lengthToObj(length) {\n    // eslint-disable-next-line local/code-no-any-casts, @typescript-eslint/no-explicit-any\n    const l = length;\n    const lineCount = Math.floor(l / factor);\n    const columnCount = l - lineCount * factor;\n    return new TextLength(lineCount, columnCount);\n}\nfunction lengthGetLineCount(length) {\n    // eslint-disable-next-line local/code-no-any-casts, @typescript-eslint/no-explicit-any\n    return Math.floor(length / factor);\n}\n/**\n * Returns the amount of columns of the given length, assuming that it does not span any line.\n*/\nfunction lengthGetColumnCountIfZeroLineCount(length) {\n    // eslint-disable-next-line local/code-no-any-casts, @typescript-eslint/no-explicit-any\n    return length;\n}\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction lengthAdd(l1, l2) {\n    let r = l1 + l2;\n    if (l2 >= factor) {\n        r = r - (l1 % factor);\n    }\n    return r;\n}\nfunction sumLengths(items, lengthFn) {\n    return items.reduce((a, b) => lengthAdd(a, lengthFn(b)), lengthZero);\n}\nfunction lengthEquals(length1, length2) {\n    return length1 === length2;\n}\n/**\n * Returns a non negative length `result` such that `lengthAdd(length1, result) = length2`, or zero if such length does not exist.\n */\nfunction lengthDiffNonNegative(length1, length2) {\n    // eslint-disable-next-line local/code-no-any-casts, @typescript-eslint/no-explicit-any\n    const l1 = length1;\n    // eslint-disable-next-line local/code-no-any-casts, @typescript-eslint/no-explicit-any\n    const l2 = length2;\n    const diff = l2 - l1;\n    if (diff <= 0) {\n        // line-count of length1 is higher than line-count of length2\n        // or they are equal and column-count of length1 is higher than column-count of length2\n        return lengthZero;\n    }\n    const lineCount1 = Math.floor(l1 / factor);\n    const lineCount2 = Math.floor(l2 / factor);\n    const colCount2 = l2 - lineCount2 * factor;\n    if (lineCount1 === lineCount2) {\n        const colCount1 = l1 - lineCount1 * factor;\n        return toLength(0, colCount2 - colCount1);\n    }\n    else {\n        return toLength(lineCount2 - lineCount1, colCount2);\n    }\n}\nfunction lengthLessThan(length1, length2) {\n    // First, compare line counts, then column counts.\n    // eslint-disable-next-line local/code-no-any-casts, @typescript-eslint/no-explicit-any\n    return length1 < length2;\n}\nfunction lengthLessThanEqual(length1, length2) {\n    // eslint-disable-next-line local/code-no-any-casts, @typescript-eslint/no-explicit-any\n    return length1 <= length2;\n}\nfunction lengthGreaterThanEqual(length1, length2) {\n    // eslint-disable-next-line local/code-no-any-casts, @typescript-eslint/no-explicit-any\n    return length1 >= length2;\n}\nfunction positionToLength(position) {\n    return toLength(position.lineNumber - 1, position.column - 1);\n}\nfunction lengthsToRange(lengthStart, lengthEnd) {\n    // eslint-disable-next-line local/code-no-any-casts, @typescript-eslint/no-explicit-any\n    const l = lengthStart;\n    const lineCount = Math.floor(l / factor);\n    const colCount = l - lineCount * factor;\n    // eslint-disable-next-line local/code-no-any-casts, @typescript-eslint/no-explicit-any\n    const l2 = lengthEnd;\n    const lineCount2 = Math.floor(l2 / factor);\n    const colCount2 = l2 - lineCount2 * factor;\n    return new Range(lineCount + 1, colCount + 1, lineCount2 + 1, colCount2 + 1);\n}\nfunction lengthOfString(str) {\n    const lines = splitLines(str);\n    return toLength(lines.length - 1, lines[lines.length - 1].length);\n}\n\nexport { lengthAdd, lengthDiff, lengthDiffNonNegative, lengthEquals, lengthGetColumnCountIfZeroLineCount, lengthGetLineCount, lengthGreaterThanEqual, lengthIsZero, lengthLessThan, lengthLessThanEqual, lengthOfString, lengthToObj, lengthZero, lengthsToRange, positionToLength, sumLengths, toLength };\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1446, "column": 0}, "map": {"version":3,"sources":["file:///D:/real-time-code-editor%20%282%29/node_modules/.pnpm/monaco-editor%400.55.1/node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/beforeEditPositionMapper.js"],"sourcesContent":["import { Range } from '../../../core/range.js';\nimport { positionToLength, lengthOfString, lengthToObj, lengthDiffNonNegative, toLength, lengthLessThanEqual, lengthAdd } from './length.js';\n\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nclass TextEditInfo {\n    static fromModelContentChanges(changes) {\n        // Must be sorted in ascending order\n        const edits = changes.map(c => {\n            const range = Range.lift(c.range);\n            return new TextEditInfo(positionToLength(range.getStartPosition()), positionToLength(range.getEndPosition()), lengthOfString(c.text));\n        }).reverse();\n        return edits;\n    }\n    constructor(startOffset, endOffset, newLength) {\n        this.startOffset = startOffset;\n        this.endOffset = endOffset;\n        this.newLength = newLength;\n    }\n    toString() {\n        return `[${lengthToObj(this.startOffset)}...${lengthToObj(this.endOffset)}) -> ${lengthToObj(this.newLength)}`;\n    }\n}\nclass BeforeEditPositionMapper {\n    /**\n     * @param edits Must be sorted by offset in ascending order.\n    */\n    constructor(edits) {\n        this.nextEditIdx = 0;\n        this.deltaOldToNewLineCount = 0;\n        this.deltaOldToNewColumnCount = 0;\n        this.deltaLineIdxInOld = -1;\n        this.edits = edits.map(edit => TextEditInfoCache.from(edit));\n    }\n    /**\n     * @param offset Must be equal to or greater than the last offset this method has been called with.\n    */\n    getOffsetBeforeChange(offset) {\n        this.adjustNextEdit(offset);\n        return this.translateCurToOld(offset);\n    }\n    /**\n     * @param offset Must be equal to or greater than the last offset this method has been called with.\n     * Returns null if there is no edit anymore.\n    */\n    getDistanceToNextChange(offset) {\n        this.adjustNextEdit(offset);\n        const nextEdit = this.edits[this.nextEditIdx];\n        const nextChangeOffset = nextEdit ? this.translateOldToCur(nextEdit.offsetObj) : null;\n        if (nextChangeOffset === null) {\n            return null;\n        }\n        return lengthDiffNonNegative(offset, nextChangeOffset);\n    }\n    translateOldToCur(oldOffsetObj) {\n        if (oldOffsetObj.lineCount === this.deltaLineIdxInOld) {\n            return toLength(oldOffsetObj.lineCount + this.deltaOldToNewLineCount, oldOffsetObj.columnCount + this.deltaOldToNewColumnCount);\n        }\n        else {\n            return toLength(oldOffsetObj.lineCount + this.deltaOldToNewLineCount, oldOffsetObj.columnCount);\n        }\n    }\n    translateCurToOld(newOffset) {\n        const offsetObj = lengthToObj(newOffset);\n        if (offsetObj.lineCount - this.deltaOldToNewLineCount === this.deltaLineIdxInOld) {\n            return toLength(offsetObj.lineCount - this.deltaOldToNewLineCount, offsetObj.columnCount - this.deltaOldToNewColumnCount);\n        }\n        else {\n            return toLength(offsetObj.lineCount - this.deltaOldToNewLineCount, offsetObj.columnCount);\n        }\n    }\n    adjustNextEdit(offset) {\n        while (this.nextEditIdx < this.edits.length) {\n            const nextEdit = this.edits[this.nextEditIdx];\n            // After applying the edit, what is its end offset (considering all previous edits)?\n            const nextEditEndOffsetInCur = this.translateOldToCur(nextEdit.endOffsetAfterObj);\n            if (lengthLessThanEqual(nextEditEndOffsetInCur, offset)) {\n                // We are after the edit, skip it\n                this.nextEditIdx++;\n                const nextEditEndOffsetInCurObj = lengthToObj(nextEditEndOffsetInCur);\n                // Before applying the edit, what is its end offset (considering all previous edits)?\n                const nextEditEndOffsetBeforeInCurObj = lengthToObj(this.translateOldToCur(nextEdit.endOffsetBeforeObj));\n                const lineDelta = nextEditEndOffsetInCurObj.lineCount - nextEditEndOffsetBeforeInCurObj.lineCount;\n                this.deltaOldToNewLineCount += lineDelta;\n                const previousColumnDelta = this.deltaLineIdxInOld === nextEdit.endOffsetBeforeObj.lineCount ? this.deltaOldToNewColumnCount : 0;\n                const columnDelta = nextEditEndOffsetInCurObj.columnCount - nextEditEndOffsetBeforeInCurObj.columnCount;\n                this.deltaOldToNewColumnCount = previousColumnDelta + columnDelta;\n                this.deltaLineIdxInOld = nextEdit.endOffsetBeforeObj.lineCount;\n            }\n            else {\n                // We are in or before the edit.\n                break;\n            }\n        }\n    }\n}\nclass TextEditInfoCache {\n    static from(edit) {\n        return new TextEditInfoCache(edit.startOffset, edit.endOffset, edit.newLength);\n    }\n    constructor(startOffset, endOffset, textLength) {\n        this.endOffsetBeforeObj = lengthToObj(endOffset);\n        this.endOffsetAfterObj = lengthToObj(lengthAdd(startOffset, textLength));\n        this.offsetObj = lengthToObj(startOffset);\n    }\n}\n\nexport { BeforeEditPositionMapper, TextEditInfo };\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1558, "column": 0}, "map": {"version":3,"sources":["file:///D:/real-time-code-editor%20%282%29/node_modules/.pnpm/monaco-editor%400.55.1/node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/smallImmutableSet.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nconst emptyArr = [];\n/**\n * Represents an immutable set that works best for a small number of elements (less than 32).\n * It uses bits to encode element membership efficiently.\n*/\nclass SmallImmutableSet {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    static { this.cache = new Array(129); }\n    static create(items, additionalItems) {\n        if (items <= 128 && additionalItems.length === 0) {\n            // We create a cache of 128=2^7 elements to cover all sets with up to 7 (dense) elements.\n            let cached = SmallImmutableSet.cache[items];\n            if (!cached) {\n                cached = new SmallImmutableSet(items, additionalItems);\n                SmallImmutableSet.cache[items] = cached;\n            }\n            return cached;\n        }\n        return new SmallImmutableSet(items, additionalItems);\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    static { this.empty = SmallImmutableSet.create(0, emptyArr); }\n    static getEmpty() {\n        return this.empty;\n    }\n    constructor(items, additionalItems) {\n        this.items = items;\n        this.additionalItems = additionalItems;\n    }\n    add(value, keyProvider) {\n        const key = keyProvider.getKey(value);\n        let idx = key >> 5; // divided by 32\n        if (idx === 0) {\n            // fast path\n            const newItem = (1 << key) | this.items;\n            if (newItem === this.items) {\n                return this;\n            }\n            return SmallImmutableSet.create(newItem, this.additionalItems);\n        }\n        idx--;\n        const newItems = this.additionalItems.slice(0);\n        while (newItems.length < idx) {\n            newItems.push(0);\n        }\n        newItems[idx] |= 1 << (key & 31);\n        return SmallImmutableSet.create(this.items, newItems);\n    }\n    merge(other) {\n        const merged = this.items | other.items;\n        if (this.additionalItems === emptyArr && other.additionalItems === emptyArr) {\n            // fast path\n            if (merged === this.items) {\n                return this;\n            }\n            if (merged === other.items) {\n                return other;\n            }\n            return SmallImmutableSet.create(merged, emptyArr);\n        }\n        // This can be optimized, but it's not a common case\n        const newItems = [];\n        for (let i = 0; i < Math.max(this.additionalItems.length, other.additionalItems.length); i++) {\n            const item1 = this.additionalItems[i] || 0;\n            const item2 = other.additionalItems[i] || 0;\n            newItems.push(item1 | item2);\n        }\n        return SmallImmutableSet.create(merged, newItems);\n    }\n    intersects(other) {\n        if ((this.items & other.items) !== 0) {\n            return true;\n        }\n        for (let i = 0; i < Math.min(this.additionalItems.length, other.additionalItems.length); i++) {\n            if ((this.additionalItems[i] & other.additionalItems[i]) !== 0) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\nconst identityKeyProvider = {\n    getKey(value) {\n        return value;\n    }\n};\n/**\n * Assigns values a unique incrementing key.\n*/\nclass DenseKeyProvider {\n    constructor() {\n        this.items = new Map();\n    }\n    getKey(value) {\n        let existing = this.items.get(value);\n        if (existing === undefined) {\n            existing = this.items.size;\n            this.items.set(value, existing);\n        }\n        return existing;\n    }\n}\n\nexport { DenseKeyProvider, SmallImmutableSet, identityKeyProvider };\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1678, "column": 0}, "map": {"version":3,"sources":["file:///D:/real-time-code-editor%20%282%29/node_modules/.pnpm/monaco-editor%400.55.1/node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/ast.js"],"sourcesContent":["import { BugIndicatingError } from '../../../../../base/common/errors.js';\nimport { CursorColumns } from '../../../core/cursorColumns.js';\nimport { lengthToObj, lengthGetLineCount, lengthAdd, lengthZero } from './length.js';\nimport { SmallImmutableSet } from './smallImmutableSet.js';\n\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n/**\n * The base implementation for all AST nodes.\n*/\nclass BaseAstNode {\n    /**\n     * The length of the entire node, which should equal the sum of lengths of all children.\n    */\n    get length() {\n        return this._length;\n    }\n    constructor(length) {\n        this._length = length;\n    }\n}\n/**\n * Represents a bracket pair including its child (e.g. `{ ... }`).\n * Might be unclosed.\n * Immutable, if all children are immutable.\n*/\nclass PairAstNode extends BaseAstNode {\n    static create(openingBracket, child, closingBracket) {\n        let length = openingBracket.length;\n        if (child) {\n            length = lengthAdd(length, child.length);\n        }\n        if (closingBracket) {\n            length = lengthAdd(length, closingBracket.length);\n        }\n        return new PairAstNode(length, openingBracket, child, closingBracket, child ? child.missingOpeningBracketIds : SmallImmutableSet.getEmpty());\n    }\n    get kind() {\n        return 2 /* AstNodeKind.Pair */;\n    }\n    get listHeight() {\n        return 0;\n    }\n    get childrenLength() {\n        return 3;\n    }\n    getChild(idx) {\n        switch (idx) {\n            case 0: return this.openingBracket;\n            case 1: return this.child;\n            case 2: return this.closingBracket;\n        }\n        throw new Error('Invalid child index');\n    }\n    /**\n     * Avoid using this property, it allocates an array!\n    */\n    get children() {\n        const result = [];\n        result.push(this.openingBracket);\n        if (this.child) {\n            result.push(this.child);\n        }\n        if (this.closingBracket) {\n            result.push(this.closingBracket);\n        }\n        return result;\n    }\n    constructor(length, openingBracket, child, closingBracket, missingOpeningBracketIds) {\n        super(length);\n        this.openingBracket = openingBracket;\n        this.child = child;\n        this.closingBracket = closingBracket;\n        this.missingOpeningBracketIds = missingOpeningBracketIds;\n    }\n    canBeReused(openBracketIds) {\n        if (this.closingBracket === null) {\n            // Unclosed pair ast nodes only\n            // end at the end of the document\n            // or when a parent node is closed.\n            // This could be improved:\n            // Only return false if some next token is neither \"undefined\" nor a bracket that closes a parent.\n            return false;\n        }\n        if (openBracketIds.intersects(this.missingOpeningBracketIds)) {\n            return false;\n        }\n        return true;\n    }\n    deepClone() {\n        return new PairAstNode(this.length, this.openingBracket.deepClone(), this.child && this.child.deepClone(), this.closingBracket && this.closingBracket.deepClone(), this.missingOpeningBracketIds);\n    }\n    computeMinIndentation(offset, textModel) {\n        return this.child ? this.child.computeMinIndentation(lengthAdd(offset, this.openingBracket.length), textModel) : Number.MAX_SAFE_INTEGER;\n    }\n}\nclass ListAstNode extends BaseAstNode {\n    /**\n     * This method uses more memory-efficient list nodes that can only store 2 or 3 children.\n    */\n    static create23(item1, item2, item3, immutable = false) {\n        let length = item1.length;\n        let missingBracketIds = item1.missingOpeningBracketIds;\n        if (item1.listHeight !== item2.listHeight) {\n            throw new Error('Invalid list heights');\n        }\n        length = lengthAdd(length, item2.length);\n        missingBracketIds = missingBracketIds.merge(item2.missingOpeningBracketIds);\n        if (item3) {\n            if (item1.listHeight !== item3.listHeight) {\n                throw new Error('Invalid list heights');\n            }\n            length = lengthAdd(length, item3.length);\n            missingBracketIds = missingBracketIds.merge(item3.missingOpeningBracketIds);\n        }\n        return immutable\n            ? new Immutable23ListAstNode(length, item1.listHeight + 1, item1, item2, item3, missingBracketIds)\n            : new TwoThreeListAstNode(length, item1.listHeight + 1, item1, item2, item3, missingBracketIds);\n    }\n    static getEmpty() {\n        return new ImmutableArrayListAstNode(lengthZero, 0, [], SmallImmutableSet.getEmpty());\n    }\n    get kind() {\n        return 4 /* AstNodeKind.List */;\n    }\n    get missingOpeningBracketIds() {\n        return this._missingOpeningBracketIds;\n    }\n    /**\n     * Use ListAstNode.create.\n    */\n    constructor(length, listHeight, _missingOpeningBracketIds) {\n        super(length);\n        this.listHeight = listHeight;\n        this._missingOpeningBracketIds = _missingOpeningBracketIds;\n        this.cachedMinIndentation = -1;\n    }\n    throwIfImmutable() {\n        // NOOP\n    }\n    makeLastElementMutable() {\n        this.throwIfImmutable();\n        const childCount = this.childrenLength;\n        if (childCount === 0) {\n            return undefined;\n        }\n        const lastChild = this.getChild(childCount - 1);\n        const mutable = lastChild.kind === 4 /* AstNodeKind.List */ ? lastChild.toMutable() : lastChild;\n        if (lastChild !== mutable) {\n            this.setChild(childCount - 1, mutable);\n        }\n        return mutable;\n    }\n    makeFirstElementMutable() {\n        this.throwIfImmutable();\n        const childCount = this.childrenLength;\n        if (childCount === 0) {\n            return undefined;\n        }\n        const firstChild = this.getChild(0);\n        const mutable = firstChild.kind === 4 /* AstNodeKind.List */ ? firstChild.toMutable() : firstChild;\n        if (firstChild !== mutable) {\n            this.setChild(0, mutable);\n        }\n        return mutable;\n    }\n    canBeReused(openBracketIds) {\n        if (openBracketIds.intersects(this.missingOpeningBracketIds)) {\n            return false;\n        }\n        if (this.childrenLength === 0) {\n            // Don't reuse empty lists.\n            return false;\n        }\n        let lastChild = this;\n        while (lastChild.kind === 4 /* AstNodeKind.List */) {\n            const lastLength = lastChild.childrenLength;\n            if (lastLength === 0) {\n                // Empty lists should never be contained in other lists.\n                throw new BugIndicatingError();\n            }\n            lastChild = lastChild.getChild(lastLength - 1);\n        }\n        return lastChild.canBeReused(openBracketIds);\n    }\n    handleChildrenChanged() {\n        this.throwIfImmutable();\n        const count = this.childrenLength;\n        let length = this.getChild(0).length;\n        let unopenedBrackets = this.getChild(0).missingOpeningBracketIds;\n        for (let i = 1; i < count; i++) {\n            const child = this.getChild(i);\n            length = lengthAdd(length, child.length);\n            unopenedBrackets = unopenedBrackets.merge(child.missingOpeningBracketIds);\n        }\n        this._length = length;\n        this._missingOpeningBracketIds = unopenedBrackets;\n        this.cachedMinIndentation = -1;\n    }\n    computeMinIndentation(offset, textModel) {\n        if (this.cachedMinIndentation !== -1) {\n            return this.cachedMinIndentation;\n        }\n        let minIndentation = Number.MAX_SAFE_INTEGER;\n        let childOffset = offset;\n        for (let i = 0; i < this.childrenLength; i++) {\n            const child = this.getChild(i);\n            if (child) {\n                minIndentation = Math.min(minIndentation, child.computeMinIndentation(childOffset, textModel));\n                childOffset = lengthAdd(childOffset, child.length);\n            }\n        }\n        this.cachedMinIndentation = minIndentation;\n        return minIndentation;\n    }\n}\nclass TwoThreeListAstNode extends ListAstNode {\n    get childrenLength() {\n        return this._item3 !== null ? 3 : 2;\n    }\n    getChild(idx) {\n        switch (idx) {\n            case 0: return this._item1;\n            case 1: return this._item2;\n            case 2: return this._item3;\n        }\n        throw new Error('Invalid child index');\n    }\n    setChild(idx, node) {\n        switch (idx) {\n            case 0:\n                this._item1 = node;\n                return;\n            case 1:\n                this._item2 = node;\n                return;\n            case 2:\n                this._item3 = node;\n                return;\n        }\n        throw new Error('Invalid child index');\n    }\n    get children() {\n        return this._item3 ? [this._item1, this._item2, this._item3] : [this._item1, this._item2];\n    }\n    get item1() {\n        return this._item1;\n    }\n    get item2() {\n        return this._item2;\n    }\n    get item3() {\n        return this._item3;\n    }\n    constructor(length, listHeight, _item1, _item2, _item3, missingOpeningBracketIds) {\n        super(length, listHeight, missingOpeningBracketIds);\n        this._item1 = _item1;\n        this._item2 = _item2;\n        this._item3 = _item3;\n    }\n    deepClone() {\n        return new TwoThreeListAstNode(this.length, this.listHeight, this._item1.deepClone(), this._item2.deepClone(), this._item3 ? this._item3.deepClone() : null, this.missingOpeningBracketIds);\n    }\n    appendChildOfSameHeight(node) {\n        if (this._item3) {\n            throw new Error('Cannot append to a full (2,3) tree node');\n        }\n        this.throwIfImmutable();\n        this._item3 = node;\n        this.handleChildrenChanged();\n    }\n    unappendChild() {\n        if (!this._item3) {\n            throw new Error('Cannot remove from a non-full (2,3) tree node');\n        }\n        this.throwIfImmutable();\n        const result = this._item3;\n        this._item3 = null;\n        this.handleChildrenChanged();\n        return result;\n    }\n    prependChildOfSameHeight(node) {\n        if (this._item3) {\n            throw new Error('Cannot prepend to a full (2,3) tree node');\n        }\n        this.throwIfImmutable();\n        this._item3 = this._item2;\n        this._item2 = this._item1;\n        this._item1 = node;\n        this.handleChildrenChanged();\n    }\n    unprependChild() {\n        if (!this._item3) {\n            throw new Error('Cannot remove from a non-full (2,3) tree node');\n        }\n        this.throwIfImmutable();\n        const result = this._item1;\n        this._item1 = this._item2;\n        this._item2 = this._item3;\n        this._item3 = null;\n        this.handleChildrenChanged();\n        return result;\n    }\n    toMutable() {\n        return this;\n    }\n}\n/**\n * Immutable, if all children are immutable.\n*/\nclass Immutable23ListAstNode extends TwoThreeListAstNode {\n    toMutable() {\n        return new TwoThreeListAstNode(this.length, this.listHeight, this.item1, this.item2, this.item3, this.missingOpeningBracketIds);\n    }\n    throwIfImmutable() {\n        throw new Error('this instance is immutable');\n    }\n}\n/**\n * For debugging.\n*/\nclass ArrayListAstNode extends ListAstNode {\n    get childrenLength() {\n        return this._children.length;\n    }\n    getChild(idx) {\n        return this._children[idx];\n    }\n    setChild(idx, child) {\n        this._children[idx] = child;\n    }\n    get children() {\n        return this._children;\n    }\n    constructor(length, listHeight, _children, missingOpeningBracketIds) {\n        super(length, listHeight, missingOpeningBracketIds);\n        this._children = _children;\n    }\n    deepClone() {\n        const children = new Array(this._children.length);\n        for (let i = 0; i < this._children.length; i++) {\n            children[i] = this._children[i].deepClone();\n        }\n        return new ArrayListAstNode(this.length, this.listHeight, children, this.missingOpeningBracketIds);\n    }\n    appendChildOfSameHeight(node) {\n        this.throwIfImmutable();\n        this._children.push(node);\n        this.handleChildrenChanged();\n    }\n    unappendChild() {\n        this.throwIfImmutable();\n        const item = this._children.pop();\n        this.handleChildrenChanged();\n        return item;\n    }\n    prependChildOfSameHeight(node) {\n        this.throwIfImmutable();\n        this._children.unshift(node);\n        this.handleChildrenChanged();\n    }\n    unprependChild() {\n        this.throwIfImmutable();\n        const item = this._children.shift();\n        this.handleChildrenChanged();\n        return item;\n    }\n    toMutable() {\n        return this;\n    }\n}\n/**\n * Immutable, if all children are immutable.\n*/\nclass ImmutableArrayListAstNode extends ArrayListAstNode {\n    toMutable() {\n        return new ArrayListAstNode(this.length, this.listHeight, [...this.children], this.missingOpeningBracketIds);\n    }\n    throwIfImmutable() {\n        throw new Error('this instance is immutable');\n    }\n}\nconst emptyArray = [];\nclass ImmutableLeafAstNode extends BaseAstNode {\n    get listHeight() {\n        return 0;\n    }\n    get childrenLength() {\n        return 0;\n    }\n    getChild(idx) {\n        return null;\n    }\n    get children() {\n        return emptyArray;\n    }\n    deepClone() {\n        return this;\n    }\n}\nclass TextAstNode extends ImmutableLeafAstNode {\n    get kind() {\n        return 0 /* AstNodeKind.Text */;\n    }\n    get missingOpeningBracketIds() {\n        return SmallImmutableSet.getEmpty();\n    }\n    canBeReused(_openedBracketIds) {\n        return true;\n    }\n    computeMinIndentation(offset, textModel) {\n        const start = lengthToObj(offset);\n        // Text ast nodes don't have partial indentation (ensured by the tokenizer).\n        // Thus, if this text node does not start at column 0, the first line cannot have any indentation at all.\n        const startLineNumber = (start.columnCount === 0 ? start.lineCount : start.lineCount + 1) + 1;\n        const endLineNumber = lengthGetLineCount(lengthAdd(offset, this.length)) + 1;\n        let result = Number.MAX_SAFE_INTEGER;\n        for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n            const firstNonWsColumn = textModel.getLineFirstNonWhitespaceColumn(lineNumber);\n            const lineContent = textModel.getLineContent(lineNumber);\n            if (firstNonWsColumn === 0) {\n                continue;\n            }\n            const visibleColumn = CursorColumns.visibleColumnFromColumn(lineContent, firstNonWsColumn, textModel.getOptions().tabSize);\n            result = Math.min(result, visibleColumn);\n        }\n        return result;\n    }\n}\nclass BracketAstNode extends ImmutableLeafAstNode {\n    static create(length, bracketInfo, bracketIds) {\n        const node = new BracketAstNode(length, bracketInfo, bracketIds);\n        return node;\n    }\n    get kind() {\n        return 1 /* AstNodeKind.Bracket */;\n    }\n    get missingOpeningBracketIds() {\n        return SmallImmutableSet.getEmpty();\n    }\n    constructor(length, bracketInfo, \n    /**\n     * In case of a opening bracket, this is the id of the opening bracket.\n     * In case of a closing bracket, this contains the ids of all opening brackets it can close.\n    */\n    bracketIds) {\n        super(length);\n        this.bracketInfo = bracketInfo;\n        this.bracketIds = bracketIds;\n    }\n    get text() {\n        return this.bracketInfo.bracketText;\n    }\n    get languageId() {\n        return this.bracketInfo.languageId;\n    }\n    canBeReused(_openedBracketIds) {\n        // These nodes could be reused,\n        // but not in a general way.\n        // Their parent may be reused.\n        return false;\n    }\n    computeMinIndentation(offset, textModel) {\n        return Number.MAX_SAFE_INTEGER;\n    }\n}\nclass InvalidBracketAstNode extends ImmutableLeafAstNode {\n    get kind() {\n        return 3 /* AstNodeKind.UnexpectedClosingBracket */;\n    }\n    constructor(closingBrackets, length) {\n        super(length);\n        this.missingOpeningBracketIds = closingBrackets;\n    }\n    canBeReused(openedBracketIds) {\n        return !openedBracketIds.intersects(this.missingOpeningBracketIds);\n    }\n    computeMinIndentation(offset, textModel) {\n        return Number.MAX_SAFE_INTEGER;\n    }\n}\n\nexport { BracketAstNode, InvalidBracketAstNode, ListAstNode, PairAstNode, TextAstNode };\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 2182, "column": 0}, "map": {"version":3,"sources":["file:///D:/real-time-code-editor%20%282%29/node_modules/.pnpm/monaco-editor%400.55.1/node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/tokenizer.js"],"sourcesContent":["import { NotSupportedError } from '../../../../../base/common/errors.js';\nimport { TokenMetadata } from '../../../encodedTokenAttributes.js';\nimport { TextAstNode } from './ast.js';\nimport { lengthZero, toLength, lengthAdd, lengthToObj, lengthGetColumnCountIfZeroLineCount, lengthDiff } from './length.js';\nimport { SmallImmutableSet } from './smallImmutableSet.js';\n\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nclass Token {\n    constructor(length, kind, \n    /**\n     * If this token is an opening bracket, this is the id of the opening bracket.\n     * If this token is a closing bracket, this is the id of the first opening bracket that is closed by this bracket.\n     * Otherwise, it is -1.\n     */\n    bracketId, \n    /**\n     * If this token is an opening bracket, this just contains `bracketId`.\n     * If this token is a closing bracket, this lists all opening bracket ids, that it closes.\n     * Otherwise, it is empty.\n     */\n    bracketIds, astNode) {\n        this.length = length;\n        this.kind = kind;\n        this.bracketId = bracketId;\n        this.bracketIds = bracketIds;\n        this.astNode = astNode;\n    }\n}\nclass TextBufferTokenizer {\n    constructor(textModel, bracketTokens) {\n        this.textModel = textModel;\n        this.bracketTokens = bracketTokens;\n        this.reader = new NonPeekableTextBufferTokenizer(this.textModel, this.bracketTokens);\n        this._offset = lengthZero;\n        this.didPeek = false;\n        this.peeked = null;\n        this.textBufferLineCount = textModel.getLineCount();\n        this.textBufferLastLineLength = textModel.getLineLength(this.textBufferLineCount);\n    }\n    get offset() {\n        return this._offset;\n    }\n    get length() {\n        return toLength(this.textBufferLineCount - 1, this.textBufferLastLineLength);\n    }\n    skip(length) {\n        this.didPeek = false;\n        this._offset = lengthAdd(this._offset, length);\n        const obj = lengthToObj(this._offset);\n        this.reader.setPosition(obj.lineCount, obj.columnCount);\n    }\n    read() {\n        let token;\n        if (this.peeked) {\n            this.didPeek = false;\n            token = this.peeked;\n        }\n        else {\n            token = this.reader.read();\n        }\n        if (token) {\n            this._offset = lengthAdd(this._offset, token.length);\n        }\n        return token;\n    }\n    peek() {\n        if (!this.didPeek) {\n            this.peeked = this.reader.read();\n            this.didPeek = true;\n        }\n        return this.peeked;\n    }\n}\n/**\n * Does not support peek.\n*/\nclass NonPeekableTextBufferTokenizer {\n    constructor(textModel, bracketTokens) {\n        this.textModel = textModel;\n        this.bracketTokens = bracketTokens;\n        this.lineIdx = 0;\n        this.line = null;\n        this.lineCharOffset = 0;\n        this.lineTokens = null;\n        this.lineTokenOffset = 0;\n        /** Must be a zero line token. The end of the document cannot be peeked. */\n        this.peekedToken = null;\n        this.textBufferLineCount = textModel.getLineCount();\n        this.textBufferLastLineLength = textModel.getLineLength(this.textBufferLineCount);\n    }\n    setPosition(lineIdx, column) {\n        // We must not jump into a token!\n        if (lineIdx === this.lineIdx) {\n            this.lineCharOffset = column;\n            if (this.line !== null) {\n                this.lineTokenOffset = this.lineCharOffset === 0 ? 0 : this.lineTokens.findTokenIndexAtOffset(this.lineCharOffset);\n            }\n        }\n        else {\n            this.lineIdx = lineIdx;\n            this.lineCharOffset = column;\n            this.line = null;\n        }\n        this.peekedToken = null;\n    }\n    read() {\n        if (this.peekedToken) {\n            const token = this.peekedToken;\n            this.peekedToken = null;\n            this.lineCharOffset += lengthGetColumnCountIfZeroLineCount(token.length);\n            return token;\n        }\n        if (this.lineIdx > this.textBufferLineCount - 1 || (this.lineIdx === this.textBufferLineCount - 1 && this.lineCharOffset >= this.textBufferLastLineLength)) {\n            // We are after the end\n            return null;\n        }\n        if (this.line === null) {\n            this.lineTokens = this.textModel.tokenization.getLineTokens(this.lineIdx + 1);\n            this.line = this.lineTokens.getLineContent();\n            this.lineTokenOffset = this.lineCharOffset === 0 ? 0 : this.lineTokens.findTokenIndexAtOffset(this.lineCharOffset);\n        }\n        const startLineIdx = this.lineIdx;\n        const startLineCharOffset = this.lineCharOffset;\n        // limits the length of text tokens.\n        // If text tokens get too long, incremental updates will be slow\n        let lengthHeuristic = 0;\n        while (true) {\n            const lineTokens = this.lineTokens;\n            const tokenCount = lineTokens.getCount();\n            let peekedBracketToken = null;\n            if (this.lineTokenOffset < tokenCount) {\n                const tokenMetadata = lineTokens.getMetadata(this.lineTokenOffset);\n                while (this.lineTokenOffset + 1 < tokenCount && tokenMetadata === lineTokens.getMetadata(this.lineTokenOffset + 1)) {\n                    // Skip tokens that are identical.\n                    // Sometimes, (bracket) identifiers are split up into multiple tokens.\n                    this.lineTokenOffset++;\n                }\n                const isOther = TokenMetadata.getTokenType(tokenMetadata) === 0 /* StandardTokenType.Other */;\n                const containsBracketType = TokenMetadata.containsBalancedBrackets(tokenMetadata);\n                const endOffset = lineTokens.getEndOffset(this.lineTokenOffset);\n                // Is there a bracket token next? Only consume text.\n                if (containsBracketType && isOther && this.lineCharOffset < endOffset) {\n                    const languageId = lineTokens.getLanguageId(this.lineTokenOffset);\n                    const text = this.line.substring(this.lineCharOffset, endOffset);\n                    const brackets = this.bracketTokens.getSingleLanguageBracketTokens(languageId);\n                    const regexp = brackets.regExpGlobal;\n                    if (regexp) {\n                        regexp.lastIndex = 0;\n                        const match = regexp.exec(text);\n                        if (match) {\n                            peekedBracketToken = brackets.getToken(match[0]);\n                            if (peekedBracketToken) {\n                                // Consume leading text of the token\n                                this.lineCharOffset += match.index;\n                            }\n                        }\n                    }\n                }\n                lengthHeuristic += endOffset - this.lineCharOffset;\n                if (peekedBracketToken) {\n                    // Don't skip the entire token, as a single token could contain multiple brackets.\n                    if (startLineIdx !== this.lineIdx || startLineCharOffset !== this.lineCharOffset) {\n                        // There is text before the bracket\n                        this.peekedToken = peekedBracketToken;\n                        break;\n                    }\n                    else {\n                        // Consume the peeked token\n                        this.lineCharOffset += lengthGetColumnCountIfZeroLineCount(peekedBracketToken.length);\n                        return peekedBracketToken;\n                    }\n                }\n                else {\n                    // Skip the entire token, as the token contains no brackets at all.\n                    this.lineTokenOffset++;\n                    this.lineCharOffset = endOffset;\n                }\n            }\n            else {\n                if (this.lineIdx === this.textBufferLineCount - 1) {\n                    break;\n                }\n                this.lineIdx++;\n                this.lineTokens = this.textModel.tokenization.getLineTokens(this.lineIdx + 1);\n                this.lineTokenOffset = 0;\n                this.line = this.lineTokens.getLineContent();\n                this.lineCharOffset = 0;\n                lengthHeuristic += 33; // max 1000/33 = 30 lines\n                // This limits the amount of work to recompute min-indentation\n                if (lengthHeuristic > 1000) {\n                    // only break (automatically) at the end of line.\n                    break;\n                }\n            }\n            if (lengthHeuristic > 1500) {\n                // Eventually break regardless of the line length so that\n                // very long lines do not cause bad performance.\n                // This effective limits max indentation to 500, as\n                // indentation is not computed across multiple text nodes.\n                break;\n            }\n        }\n        // If a token contains some proper indentation, it also contains \\n{INDENTATION+}(?!{INDENTATION}),\n        // unless the line is too long.\n        // Thus, the min indentation of the document is the minimum min indentation of every text node.\n        const length = lengthDiff(startLineIdx, startLineCharOffset, this.lineIdx, this.lineCharOffset);\n        return new Token(length, 0 /* TokenKind.Text */, -1, SmallImmutableSet.getEmpty(), new TextAstNode(length));\n    }\n}\nclass FastTokenizer {\n    constructor(text, brackets) {\n        this.text = text;\n        this._offset = lengthZero;\n        this.idx = 0;\n        const regExpStr = brackets.getRegExpStr();\n        const regexp = regExpStr ? new RegExp(regExpStr + '|\\n', 'gi') : null;\n        const tokens = [];\n        let match;\n        let curLineCount = 0;\n        let lastLineBreakOffset = 0;\n        let lastTokenEndOffset = 0;\n        let lastTokenEndLine = 0;\n        const smallTextTokens0Line = [];\n        for (let i = 0; i < 60; i++) {\n            smallTextTokens0Line.push(new Token(toLength(0, i), 0 /* TokenKind.Text */, -1, SmallImmutableSet.getEmpty(), new TextAstNode(toLength(0, i))));\n        }\n        const smallTextTokens1Line = [];\n        for (let i = 0; i < 60; i++) {\n            smallTextTokens1Line.push(new Token(toLength(1, i), 0 /* TokenKind.Text */, -1, SmallImmutableSet.getEmpty(), new TextAstNode(toLength(1, i))));\n        }\n        if (regexp) {\n            regexp.lastIndex = 0;\n            // If a token contains indentation, it also contains \\n{INDENTATION+}(?!{INDENTATION})\n            while ((match = regexp.exec(text)) !== null) {\n                const curOffset = match.index;\n                const value = match[0];\n                if (value === '\\n') {\n                    curLineCount++;\n                    lastLineBreakOffset = curOffset + 1;\n                }\n                else {\n                    if (lastTokenEndOffset !== curOffset) {\n                        let token;\n                        if (lastTokenEndLine === curLineCount) {\n                            const colCount = curOffset - lastTokenEndOffset;\n                            if (colCount < smallTextTokens0Line.length) {\n                                token = smallTextTokens0Line[colCount];\n                            }\n                            else {\n                                const length = toLength(0, colCount);\n                                token = new Token(length, 0 /* TokenKind.Text */, -1, SmallImmutableSet.getEmpty(), new TextAstNode(length));\n                            }\n                        }\n                        else {\n                            const lineCount = curLineCount - lastTokenEndLine;\n                            const colCount = curOffset - lastLineBreakOffset;\n                            if (lineCount === 1 && colCount < smallTextTokens1Line.length) {\n                                token = smallTextTokens1Line[colCount];\n                            }\n                            else {\n                                const length = toLength(lineCount, colCount);\n                                token = new Token(length, 0 /* TokenKind.Text */, -1, SmallImmutableSet.getEmpty(), new TextAstNode(length));\n                            }\n                        }\n                        tokens.push(token);\n                    }\n                    // value is matched by regexp, so the token must exist\n                    tokens.push(brackets.getToken(value));\n                    lastTokenEndOffset = curOffset + value.length;\n                    lastTokenEndLine = curLineCount;\n                }\n            }\n        }\n        const offset = text.length;\n        if (lastTokenEndOffset !== offset) {\n            const length = (lastTokenEndLine === curLineCount)\n                ? toLength(0, offset - lastTokenEndOffset)\n                : toLength(curLineCount - lastTokenEndLine, offset - lastLineBreakOffset);\n            tokens.push(new Token(length, 0 /* TokenKind.Text */, -1, SmallImmutableSet.getEmpty(), new TextAstNode(length)));\n        }\n        this.length = toLength(curLineCount, offset - lastLineBreakOffset);\n        this.tokens = tokens;\n    }\n    get offset() {\n        return this._offset;\n    }\n    read() {\n        return this.tokens[this.idx++] || null;\n    }\n    peek() {\n        return this.tokens[this.idx] || null;\n    }\n    skip(length) {\n        throw new NotSupportedError();\n    }\n}\n\nexport { FastTokenizer, TextBufferTokenizer, Token };\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 2475, "column": 0}, "map": {"version":3,"sources":["file:///D:/real-time-code-editor%20%282%29/node_modules/.pnpm/monaco-editor%400.55.1/node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/brackets.js"],"sourcesContent":["import { escapeRegExpCharacters } from '../../../../../base/common/strings.js';\nimport { BracketAstNode } from './ast.js';\nimport { toLength } from './length.js';\nimport { SmallImmutableSet, identityKeyProvider } from './smallImmutableSet.js';\nimport { Token } from './tokenizer.js';\n\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nclass BracketTokens {\n    static createFromLanguage(configuration, denseKeyProvider) {\n        function getId(bracketInfo) {\n            return denseKeyProvider.getKey(`${bracketInfo.languageId}:::${bracketInfo.bracketText}`);\n        }\n        const map = new Map();\n        for (const openingBracket of configuration.bracketsNew.openingBrackets) {\n            const length = toLength(0, openingBracket.bracketText.length);\n            const openingTextId = getId(openingBracket);\n            const bracketIds = SmallImmutableSet.getEmpty().add(openingTextId, identityKeyProvider);\n            map.set(openingBracket.bracketText, new Token(length, 1 /* TokenKind.OpeningBracket */, openingTextId, bracketIds, BracketAstNode.create(length, openingBracket, bracketIds)));\n        }\n        for (const closingBracket of configuration.bracketsNew.closingBrackets) {\n            const length = toLength(0, closingBracket.bracketText.length);\n            let bracketIds = SmallImmutableSet.getEmpty();\n            const closingBrackets = closingBracket.getOpeningBrackets();\n            for (const bracket of closingBrackets) {\n                bracketIds = bracketIds.add(getId(bracket), identityKeyProvider);\n            }\n            map.set(closingBracket.bracketText, new Token(length, 2 /* TokenKind.ClosingBracket */, getId(closingBrackets[0]), bracketIds, BracketAstNode.create(length, closingBracket, bracketIds)));\n        }\n        return new BracketTokens(map);\n    }\n    constructor(map) {\n        this.map = map;\n        this.hasRegExp = false;\n        this._regExpGlobal = null;\n    }\n    getRegExpStr() {\n        if (this.isEmpty) {\n            return null;\n        }\n        else {\n            const keys = [...this.map.keys()];\n            keys.sort();\n            keys.reverse();\n            return keys.map(k => prepareBracketForRegExp(k)).join('|');\n        }\n    }\n    /**\n     * Returns null if there is no such regexp (because there are no brackets).\n    */\n    get regExpGlobal() {\n        if (!this.hasRegExp) {\n            const regExpStr = this.getRegExpStr();\n            this._regExpGlobal = regExpStr ? new RegExp(regExpStr, 'gi') : null;\n            this.hasRegExp = true;\n        }\n        return this._regExpGlobal;\n    }\n    getToken(value) {\n        return this.map.get(value.toLowerCase());\n    }\n    findClosingTokenText(openingBracketIds) {\n        for (const [closingText, info] of this.map) {\n            if (info.kind === 2 /* TokenKind.ClosingBracket */ && info.bracketIds.intersects(openingBracketIds)) {\n                return closingText;\n            }\n        }\n        return undefined;\n    }\n    get isEmpty() {\n        return this.map.size === 0;\n    }\n}\nfunction prepareBracketForRegExp(str) {\n    let escaped = escapeRegExpCharacters(str);\n    // These bracket pair delimiters start or end with letters\n    // see https://github.com/microsoft/vscode/issues/132162 https://github.com/microsoft/vscode/issues/150440\n    if (/^[\\w ]+/.test(str)) {\n        escaped = `\\\\b${escaped}`;\n    }\n    if (/[\\w ]+$/.test(str)) {\n        escaped = `${escaped}\\\\b`;\n    }\n    return escaped;\n}\nclass LanguageAgnosticBracketTokens {\n    constructor(denseKeyProvider, getLanguageConfiguration) {\n        this.denseKeyProvider = denseKeyProvider;\n        this.getLanguageConfiguration = getLanguageConfiguration;\n        this.languageIdToBracketTokens = new Map();\n    }\n    didLanguageChange(languageId) {\n        // Report a change whenever the language configuration updates.\n        return this.languageIdToBracketTokens.has(languageId);\n    }\n    getSingleLanguageBracketTokens(languageId) {\n        let singleLanguageBracketTokens = this.languageIdToBracketTokens.get(languageId);\n        if (!singleLanguageBracketTokens) {\n            singleLanguageBracketTokens = BracketTokens.createFromLanguage(this.getLanguageConfiguration(languageId), this.denseKeyProvider);\n            this.languageIdToBracketTokens.set(languageId, singleLanguageBracketTokens);\n        }\n        return singleLanguageBracketTokens;\n    }\n}\n\nexport { BracketTokens, LanguageAgnosticBracketTokens };\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 2595, "column": 0}, "map": {"version":3,"sources":["file:///D:/real-time-code-editor%20%282%29/node_modules/.pnpm/monaco-editor%400.55.1/node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/concat23Trees.js"],"sourcesContent":["import { ListAstNode } from './ast.js';\n\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n/**\n * Concatenates a list of (2,3) AstNode's into a single (2,3) AstNode.\n * This mutates the items of the input array!\n * If all items have the same height, this method has runtime O(items.length).\n * Otherwise, it has runtime O(items.length * max(log(items.length), items.max(i => i.height))).\n*/\nfunction concat23Trees(items) {\n    if (items.length === 0) {\n        return null;\n    }\n    if (items.length === 1) {\n        return items[0];\n    }\n    let i = 0;\n    /**\n     * Reads nodes of same height and concatenates them to a single node.\n    */\n    function readNode() {\n        if (i >= items.length) {\n            return null;\n        }\n        const start = i;\n        const height = items[start].listHeight;\n        i++;\n        while (i < items.length && items[i].listHeight === height) {\n            i++;\n        }\n        if (i - start >= 2) {\n            return concat23TreesOfSameHeight(start === 0 && i === items.length ? items : items.slice(start, i), false);\n        }\n        else {\n            return items[start];\n        }\n    }\n    // The items might not have the same height.\n    // We merge all items by using a binary concat operator.\n    let first = readNode(); // There must be a first item\n    let second = readNode();\n    if (!second) {\n        return first;\n    }\n    for (let item = readNode(); item; item = readNode()) {\n        // Prefer concatenating smaller trees, as the runtime of concat depends on the tree height.\n        if (heightDiff(first, second) <= heightDiff(second, item)) {\n            first = concat(first, second);\n            second = item;\n        }\n        else {\n            second = concat(second, item);\n        }\n    }\n    const result = concat(first, second);\n    return result;\n}\nfunction concat23TreesOfSameHeight(items, createImmutableLists = false) {\n    if (items.length === 0) {\n        return null;\n    }\n    if (items.length === 1) {\n        return items[0];\n    }\n    let length = items.length;\n    // All trees have same height, just create parent nodes.\n    while (length > 3) {\n        const newLength = length >> 1;\n        for (let i = 0; i < newLength; i++) {\n            const j = i << 1;\n            items[i] = ListAstNode.create23(items[j], items[j + 1], j + 3 === length ? items[j + 2] : null, createImmutableLists);\n        }\n        length = newLength;\n    }\n    return ListAstNode.create23(items[0], items[1], length >= 3 ? items[2] : null, createImmutableLists);\n}\nfunction heightDiff(node1, node2) {\n    return Math.abs(node1.listHeight - node2.listHeight);\n}\nfunction concat(node1, node2) {\n    if (node1.listHeight === node2.listHeight) {\n        return ListAstNode.create23(node1, node2, null, false);\n    }\n    else if (node1.listHeight > node2.listHeight) {\n        // node1 is the tree we want to insert into\n        return append(node1, node2);\n    }\n    else {\n        return prepend(node2, node1);\n    }\n}\n/**\n * Appends the given node to the end of this (2,3) tree.\n * Returns the new root.\n*/\nfunction append(list, nodeToAppend) {\n    list = list.toMutable();\n    let curNode = list;\n    const parents = [];\n    let nodeToAppendOfCorrectHeight;\n    while (true) {\n        // assert nodeToInsert.listHeight <= curNode.listHeight\n        if (nodeToAppend.listHeight === curNode.listHeight) {\n            nodeToAppendOfCorrectHeight = nodeToAppend;\n            break;\n        }\n        // assert 0 <= nodeToInsert.listHeight < curNode.listHeight\n        if (curNode.kind !== 4 /* AstNodeKind.List */) {\n            throw new Error('unexpected');\n        }\n        parents.push(curNode);\n        // assert 2 <= curNode.childrenLength <= 3\n        curNode = curNode.makeLastElementMutable();\n    }\n    // assert nodeToAppendOfCorrectHeight!.listHeight === curNode.listHeight\n    for (let i = parents.length - 1; i >= 0; i--) {\n        const parent = parents[i];\n        if (nodeToAppendOfCorrectHeight) {\n            // Can we take the element?\n            if (parent.childrenLength >= 3) {\n                // assert parent.childrenLength === 3 && parent.listHeight === nodeToAppendOfCorrectHeight.listHeight + 1\n                // we need to split to maintain (2,3)-tree property.\n                // Send the third element + the new element to the parent.\n                nodeToAppendOfCorrectHeight = ListAstNode.create23(parent.unappendChild(), nodeToAppendOfCorrectHeight, null, false);\n            }\n            else {\n                parent.appendChildOfSameHeight(nodeToAppendOfCorrectHeight);\n                nodeToAppendOfCorrectHeight = undefined;\n            }\n        }\n        else {\n            parent.handleChildrenChanged();\n        }\n    }\n    if (nodeToAppendOfCorrectHeight) {\n        return ListAstNode.create23(list, nodeToAppendOfCorrectHeight, null, false);\n    }\n    else {\n        return list;\n    }\n}\n/**\n * Prepends the given node to the end of this (2,3) tree.\n * Returns the new root.\n*/\nfunction prepend(list, nodeToAppend) {\n    list = list.toMutable();\n    let curNode = list;\n    const parents = [];\n    // assert nodeToInsert.listHeight <= curNode.listHeight\n    while (nodeToAppend.listHeight !== curNode.listHeight) {\n        // assert 0 <= nodeToInsert.listHeight < curNode.listHeight\n        if (curNode.kind !== 4 /* AstNodeKind.List */) {\n            throw new Error('unexpected');\n        }\n        parents.push(curNode);\n        // assert 2 <= curNode.childrenFast.length <= 3\n        curNode = curNode.makeFirstElementMutable();\n    }\n    let nodeToPrependOfCorrectHeight = nodeToAppend;\n    // assert nodeToAppendOfCorrectHeight!.listHeight === curNode.listHeight\n    for (let i = parents.length - 1; i >= 0; i--) {\n        const parent = parents[i];\n        if (nodeToPrependOfCorrectHeight) {\n            // Can we take the element?\n            if (parent.childrenLength >= 3) {\n                // assert parent.childrenLength === 3 && parent.listHeight === nodeToAppendOfCorrectHeight.listHeight + 1\n                // we need to split to maintain (2,3)-tree property.\n                // Send the third element + the new element to the parent.\n                nodeToPrependOfCorrectHeight = ListAstNode.create23(nodeToPrependOfCorrectHeight, parent.unprependChild(), null, false);\n            }\n            else {\n                parent.prependChildOfSameHeight(nodeToPrependOfCorrectHeight);\n                nodeToPrependOfCorrectHeight = undefined;\n            }\n        }\n        else {\n            parent.handleChildrenChanged();\n        }\n    }\n    if (nodeToPrependOfCorrectHeight) {\n        return ListAstNode.create23(nodeToPrependOfCorrectHeight, list, null, false);\n    }\n    else {\n        return list;\n    }\n}\n\nexport { concat23Trees, concat23TreesOfSameHeight };\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 2781, "column": 0}, "map": {"version":3,"sources":["file:///D:/real-time-code-editor%20%282%29/node_modules/.pnpm/monaco-editor%400.55.1/node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/nodeReader.js"],"sourcesContent":["import { lengthZero, lengthLessThan, lengthAdd } from './length.js';\n\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n/**\n * Allows to efficiently find a longest child at a given offset in a fixed node.\n * The requested offsets must increase monotonously.\n*/\nclass NodeReader {\n    constructor(node) {\n        this.lastOffset = lengthZero;\n        this.nextNodes = [node];\n        this.offsets = [lengthZero];\n        this.idxs = [];\n    }\n    /**\n     * Returns the longest node at `offset` that satisfies the predicate.\n     * @param offset must be greater than or equal to the last offset this method has been called with!\n    */\n    readLongestNodeAt(offset, predicate) {\n        if (lengthLessThan(offset, this.lastOffset)) {\n            throw new Error('Invalid offset');\n        }\n        this.lastOffset = offset;\n        // Find the longest node of all those that are closest to the current offset.\n        while (true) {\n            const curNode = lastOrUndefined(this.nextNodes);\n            if (!curNode) {\n                return undefined;\n            }\n            const curNodeOffset = lastOrUndefined(this.offsets);\n            if (lengthLessThan(offset, curNodeOffset)) {\n                // The next best node is not here yet.\n                // The reader must advance before a cached node is hit.\n                return undefined;\n            }\n            if (lengthLessThan(curNodeOffset, offset)) {\n                // The reader is ahead of the current node.\n                if (lengthAdd(curNodeOffset, curNode.length) <= offset) {\n                    // The reader is after the end of the current node.\n                    this.nextNodeAfterCurrent();\n                }\n                else {\n                    // The reader is somewhere in the current node.\n                    const nextChildIdx = getNextChildIdx(curNode);\n                    if (nextChildIdx !== -1) {\n                        // Go to the first child and repeat.\n                        this.nextNodes.push(curNode.getChild(nextChildIdx));\n                        this.offsets.push(curNodeOffset);\n                        this.idxs.push(nextChildIdx);\n                    }\n                    else {\n                        // We don't have children\n                        this.nextNodeAfterCurrent();\n                    }\n                }\n            }\n            else {\n                // readerOffsetBeforeChange === curNodeOffset\n                if (predicate(curNode)) {\n                    this.nextNodeAfterCurrent();\n                    return curNode;\n                }\n                else {\n                    const nextChildIdx = getNextChildIdx(curNode);\n                    // look for shorter node\n                    if (nextChildIdx === -1) {\n                        // There is no shorter node.\n                        this.nextNodeAfterCurrent();\n                        return undefined;\n                    }\n                    else {\n                        // Descend into first child & repeat.\n                        this.nextNodes.push(curNode.getChild(nextChildIdx));\n                        this.offsets.push(curNodeOffset);\n                        this.idxs.push(nextChildIdx);\n                    }\n                }\n            }\n        }\n    }\n    // Navigates to the longest node that continues after the current node.\n    nextNodeAfterCurrent() {\n        while (true) {\n            const currentOffset = lastOrUndefined(this.offsets);\n            const currentNode = lastOrUndefined(this.nextNodes);\n            this.nextNodes.pop();\n            this.offsets.pop();\n            if (this.idxs.length === 0) {\n                // We just popped the root node, there is no next node.\n                break;\n            }\n            // Parent is not undefined, because idxs is not empty\n            const parent = lastOrUndefined(this.nextNodes);\n            const nextChildIdx = getNextChildIdx(parent, this.idxs[this.idxs.length - 1]);\n            if (nextChildIdx !== -1) {\n                this.nextNodes.push(parent.getChild(nextChildIdx));\n                this.offsets.push(lengthAdd(currentOffset, currentNode.length));\n                this.idxs[this.idxs.length - 1] = nextChildIdx;\n                break;\n            }\n            else {\n                this.idxs.pop();\n            }\n            // We fully consumed the parent.\n            // Current node is now parent, so call nextNodeAfterCurrent again\n        }\n    }\n}\nfunction getNextChildIdx(node, curIdx = -1) {\n    while (true) {\n        curIdx++;\n        if (curIdx >= node.childrenLength) {\n            return -1;\n        }\n        if (node.getChild(curIdx)) {\n            return curIdx;\n        }\n    }\n}\nfunction lastOrUndefined(arr) {\n    return arr.length > 0 ? arr[arr.length - 1] : undefined;\n}\n\nexport { NodeReader };\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 2909, "column": 0}, "map": {"version":3,"sources":["file:///D:/real-time-code-editor%20%282%29/node_modules/.pnpm/monaco-editor%400.55.1/node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/parser.js"],"sourcesContent":["import { ListAstNode, TextAstNode, PairAstNode, InvalidBracketAstNode } from './ast.js';\nimport { BeforeEditPositionMapper } from './beforeEditPositionMapper.js';\nimport { SmallImmutableSet } from './smallImmutableSet.js';\nimport { lengthIsZero, lengthLessThan } from './length.js';\nimport { concat23Trees, concat23TreesOfSameHeight } from './concat23Trees.js';\nimport { NodeReader } from './nodeReader.js';\n\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n/**\n * Non incrementally built ASTs are immutable.\n*/\nfunction parseDocument(tokenizer, edits, oldNode, createImmutableLists) {\n    const parser = new Parser(tokenizer, edits, oldNode, createImmutableLists);\n    return parser.parseDocument();\n}\n/**\n * Non incrementally built ASTs are immutable.\n*/\nclass Parser {\n    constructor(tokenizer, edits, oldNode, createImmutableLists) {\n        this.tokenizer = tokenizer;\n        this.createImmutableLists = createImmutableLists;\n        this._itemsConstructed = 0;\n        this._itemsFromCache = 0;\n        if (oldNode && createImmutableLists) {\n            throw new Error('Not supported');\n        }\n        this.oldNodeReader = oldNode ? new NodeReader(oldNode) : undefined;\n        this.positionMapper = new BeforeEditPositionMapper(edits);\n    }\n    parseDocument() {\n        this._itemsConstructed = 0;\n        this._itemsFromCache = 0;\n        let result = this.parseList(SmallImmutableSet.getEmpty(), 0);\n        if (!result) {\n            result = ListAstNode.getEmpty();\n        }\n        return result;\n    }\n    parseList(openedBracketIds, level) {\n        const items = [];\n        while (true) {\n            let child = this.tryReadChildFromCache(openedBracketIds);\n            if (!child) {\n                const token = this.tokenizer.peek();\n                if (!token ||\n                    (token.kind === 2 /* TokenKind.ClosingBracket */ &&\n                        token.bracketIds.intersects(openedBracketIds))) {\n                    break;\n                }\n                child = this.parseChild(openedBracketIds, level + 1);\n            }\n            if (child.kind === 4 /* AstNodeKind.List */ && child.childrenLength === 0) {\n                continue;\n            }\n            items.push(child);\n        }\n        // When there is no oldNodeReader, all items are created from scratch and must have the same height.\n        const result = this.oldNodeReader ? concat23Trees(items) : concat23TreesOfSameHeight(items, this.createImmutableLists);\n        return result;\n    }\n    tryReadChildFromCache(openedBracketIds) {\n        if (this.oldNodeReader) {\n            const maxCacheableLength = this.positionMapper.getDistanceToNextChange(this.tokenizer.offset);\n            if (maxCacheableLength === null || !lengthIsZero(maxCacheableLength)) {\n                const cachedNode = this.oldNodeReader.readLongestNodeAt(this.positionMapper.getOffsetBeforeChange(this.tokenizer.offset), curNode => {\n                    // The edit could extend the ending token, thus we cannot re-use nodes that touch the edit.\n                    // If there is no edit anymore, we can re-use the node in any case.\n                    if (maxCacheableLength !== null && !lengthLessThan(curNode.length, maxCacheableLength)) {\n                        // Either the node contains edited text or touches edited text.\n                        // In the latter case, brackets might have been extended (`end` -> `ending`), so even touching nodes cannot be reused.\n                        return false;\n                    }\n                    const canBeReused = curNode.canBeReused(openedBracketIds);\n                    return canBeReused;\n                });\n                if (cachedNode) {\n                    this._itemsFromCache++;\n                    this.tokenizer.skip(cachedNode.length);\n                    return cachedNode;\n                }\n            }\n        }\n        return undefined;\n    }\n    parseChild(openedBracketIds, level) {\n        this._itemsConstructed++;\n        const token = this.tokenizer.read();\n        switch (token.kind) {\n            case 2 /* TokenKind.ClosingBracket */:\n                return new InvalidBracketAstNode(token.bracketIds, token.length);\n            case 0 /* TokenKind.Text */:\n                return token.astNode;\n            case 1 /* TokenKind.OpeningBracket */: {\n                if (level > 300) {\n                    // To prevent stack overflows\n                    return new TextAstNode(token.length);\n                }\n                const set = openedBracketIds.merge(token.bracketIds);\n                const child = this.parseList(set, level + 1);\n                const nextToken = this.tokenizer.peek();\n                if (nextToken &&\n                    nextToken.kind === 2 /* TokenKind.ClosingBracket */ &&\n                    (nextToken.bracketId === token.bracketId || nextToken.bracketIds.intersects(token.bracketIds))) {\n                    this.tokenizer.read();\n                    return PairAstNode.create(token.astNode, child, nextToken.astNode);\n                }\n                else {\n                    return PairAstNode.create(token.astNode, child, null);\n                }\n            }\n            default:\n                throw new Error('unexpected');\n        }\n    }\n}\n\nexport { parseDocument };\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 3035, "column": 0}, "map": {"version":3,"sources":["file:///D:/real-time-code-editor%20%282%29/node_modules/.pnpm/monaco-editor%400.55.1/node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/combineTextEditInfos.js"],"sourcesContent":["import { ArrayQueue } from '../../../../../base/common/arrays.js';\nimport { TextEditInfo } from './beforeEditPositionMapper.js';\nimport { sumLengths, lengthAdd, lengthDiffNonNegative, lengthIsZero, lengthEquals, lengthZero, lengthToObj } from './length.js';\n\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nfunction combineTextEditInfos(textEditInfoFirst, textEditInfoSecond) {\n    if (textEditInfoFirst.length === 0) {\n        return textEditInfoSecond;\n    }\n    if (textEditInfoSecond.length === 0) {\n        return textEditInfoFirst;\n    }\n    // s0: State before any edits\n    const s0ToS1Map = new ArrayQueue(toLengthMapping(textEditInfoFirst));\n    // s1: State after first edit, but before second edit\n    const s1ToS2Map = toLengthMapping(textEditInfoSecond);\n    s1ToS2Map.push({ modified: false, lengthBefore: undefined, lengthAfter: undefined }); // Copy everything from old to new\n    // s2: State after both edits\n    let curItem = s0ToS1Map.dequeue();\n    /**\n     * @param s1Length Use undefined for length \"infinity\"\n     */\n    function nextS0ToS1MapWithS1LengthOf(s1Length) {\n        if (s1Length === undefined) {\n            const arr = s0ToS1Map.takeWhile(v => true) || [];\n            if (curItem) {\n                arr.unshift(curItem);\n            }\n            return arr;\n        }\n        const result = [];\n        while (curItem && !lengthIsZero(s1Length)) {\n            const [item, remainingItem] = curItem.splitAt(s1Length);\n            result.push(item);\n            s1Length = lengthDiffNonNegative(item.lengthAfter, s1Length);\n            curItem = remainingItem ?? s0ToS1Map.dequeue();\n        }\n        if (!lengthIsZero(s1Length)) {\n            result.push(new LengthMapping(false, s1Length, s1Length));\n        }\n        return result;\n    }\n    const result = [];\n    function pushEdit(startOffset, endOffset, newLength) {\n        if (result.length > 0 && lengthEquals(result[result.length - 1].endOffset, startOffset)) {\n            const lastResult = result[result.length - 1];\n            result[result.length - 1] = new TextEditInfo(lastResult.startOffset, endOffset, lengthAdd(lastResult.newLength, newLength));\n        }\n        else {\n            result.push({ startOffset, endOffset, newLength });\n        }\n    }\n    let s0offset = lengthZero;\n    for (const s1ToS2 of s1ToS2Map) {\n        const s0ToS1Map = nextS0ToS1MapWithS1LengthOf(s1ToS2.lengthBefore);\n        if (s1ToS2.modified) {\n            const s0Length = sumLengths(s0ToS1Map, s => s.lengthBefore);\n            const s0EndOffset = lengthAdd(s0offset, s0Length);\n            pushEdit(s0offset, s0EndOffset, s1ToS2.lengthAfter);\n            s0offset = s0EndOffset;\n        }\n        else {\n            for (const s1 of s0ToS1Map) {\n                const s0startOffset = s0offset;\n                s0offset = lengthAdd(s0offset, s1.lengthBefore);\n                if (s1.modified) {\n                    pushEdit(s0startOffset, s0offset, s1.lengthAfter);\n                }\n            }\n        }\n    }\n    return result;\n}\nclass LengthMapping {\n    constructor(\n    /**\n     * If false, length before and length after equal.\n     */\n    modified, lengthBefore, lengthAfter) {\n        this.modified = modified;\n        this.lengthBefore = lengthBefore;\n        this.lengthAfter = lengthAfter;\n    }\n    splitAt(lengthAfter) {\n        const remainingLengthAfter = lengthDiffNonNegative(lengthAfter, this.lengthAfter);\n        if (lengthEquals(remainingLengthAfter, lengthZero)) {\n            return [this, undefined];\n        }\n        else if (this.modified) {\n            return [\n                new LengthMapping(this.modified, this.lengthBefore, lengthAfter),\n                new LengthMapping(this.modified, lengthZero, remainingLengthAfter)\n            ];\n        }\n        else {\n            return [\n                new LengthMapping(this.modified, lengthAfter, lengthAfter),\n                new LengthMapping(this.modified, remainingLengthAfter, remainingLengthAfter)\n            ];\n        }\n    }\n    toString() {\n        return `${this.modified ? 'M' : 'U'}:${lengthToObj(this.lengthBefore)} -> ${lengthToObj(this.lengthAfter)}`;\n    }\n}\nfunction toLengthMapping(textEditInfos) {\n    const result = [];\n    let lastOffset = lengthZero;\n    for (const textEditInfo of textEditInfos) {\n        const spaceLength = lengthDiffNonNegative(lastOffset, textEditInfo.startOffset);\n        if (!lengthIsZero(spaceLength)) {\n            result.push(new LengthMapping(false, spaceLength, spaceLength));\n        }\n        const lengthBefore = lengthDiffNonNegative(textEditInfo.startOffset, textEditInfo.endOffset);\n        result.push(new LengthMapping(true, lengthBefore, textEditInfo.newLength));\n        lastOffset = textEditInfo.endOffset;\n    }\n    return result;\n}\n\nexport { combineTextEditInfos };\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 3171, "column": 0}, "map": {"version":3,"sources":["file:///D:/real-time-code-editor%20%282%29/node_modules/.pnpm/monaco-editor%400.55.1/node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/bracketPairsTree.js"],"sourcesContent":["import { Emitter } from '../../../../../base/common/event.js';\nimport { Disposable } from '../../../../../base/common/lifecycle.js';\nimport { BracketInfo, BracketPairWithMinIndentationInfo } from '../../../textModelBracketPairs.js';\nimport { TextEditInfo } from './beforeEditPositionMapper.js';\nimport { LanguageAgnosticBracketTokens } from './brackets.js';\nimport { toLength, lengthZero, positionToLength, lengthsToRange, lengthAdd, lengthLessThanEqual, lengthGreaterThanEqual, lengthLessThan } from './length.js';\nimport { parseDocument } from './parser.js';\nimport { DenseKeyProvider } from './smallImmutableSet.js';\nimport { FastTokenizer, TextBufferTokenizer } from './tokenizer.js';\nimport { CallbackIterable } from '../../../../../base/common/arrays.js';\nimport { combineTextEditInfos } from './combineTextEditInfos.js';\n\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nclass BracketPairsTree extends Disposable {\n    didLanguageChange(languageId) {\n        return this.brackets.didLanguageChange(languageId);\n    }\n    constructor(textModel, getLanguageConfiguration) {\n        super();\n        this.textModel = textModel;\n        this.getLanguageConfiguration = getLanguageConfiguration;\n        this.didChangeEmitter = new Emitter();\n        this.denseKeyProvider = new DenseKeyProvider();\n        this.brackets = new LanguageAgnosticBracketTokens(this.denseKeyProvider, this.getLanguageConfiguration);\n        this.onDidChange = this.didChangeEmitter.event;\n        this.queuedTextEditsForInitialAstWithoutTokens = [];\n        this.queuedTextEdits = [];\n        if (!textModel.tokenization.hasTokens) {\n            const brackets = this.brackets.getSingleLanguageBracketTokens(this.textModel.getLanguageId());\n            const tokenizer = new FastTokenizer(this.textModel.getValue(), brackets);\n            this.initialAstWithoutTokens = parseDocument(tokenizer, [], undefined, true);\n            this.astWithTokens = this.initialAstWithoutTokens;\n        }\n        else if (textModel.tokenization.backgroundTokenizationState === 2 /* BackgroundTokenizationState.Completed */) {\n            // Skip the initial ast, as there is no flickering.\n            // Directly create the tree with token information.\n            this.initialAstWithoutTokens = undefined;\n            this.astWithTokens = this.parseDocumentFromTextBuffer([], undefined, false);\n        }\n        else {\n            // We missed some token changes already, so we cannot use the fast tokenizer + delta increments\n            this.initialAstWithoutTokens = this.parseDocumentFromTextBuffer([], undefined, true);\n            this.astWithTokens = this.initialAstWithoutTokens;\n        }\n    }\n    //#region TextModel events\n    handleDidChangeBackgroundTokenizationState() {\n        if (this.textModel.tokenization.backgroundTokenizationState === 2 /* BackgroundTokenizationState.Completed */) {\n            const wasUndefined = this.initialAstWithoutTokens === undefined;\n            // Clear the initial tree as we can use the tree with token information now.\n            this.initialAstWithoutTokens = undefined;\n            if (!wasUndefined) {\n                this.didChangeEmitter.fire();\n            }\n        }\n    }\n    handleDidChangeTokens({ ranges }) {\n        const edits = ranges.map(r => new TextEditInfo(toLength(r.fromLineNumber - 1, 0), toLength(r.toLineNumber, 0), toLength(r.toLineNumber - r.fromLineNumber + 1, 0)));\n        this.handleEdits(edits, true);\n        if (!this.initialAstWithoutTokens) {\n            this.didChangeEmitter.fire();\n        }\n    }\n    handleContentChanged(change) {\n        const edits = TextEditInfo.fromModelContentChanges(change.changes);\n        this.handleEdits(edits, false);\n    }\n    handleEdits(edits, tokenChange) {\n        // Lazily queue the edits and only apply them when the tree is accessed.\n        const result = combineTextEditInfos(this.queuedTextEdits, edits);\n        this.queuedTextEdits = result;\n        if (this.initialAstWithoutTokens && !tokenChange) {\n            this.queuedTextEditsForInitialAstWithoutTokens = combineTextEditInfos(this.queuedTextEditsForInitialAstWithoutTokens, edits);\n        }\n    }\n    //#endregion\n    flushQueue() {\n        if (this.queuedTextEdits.length > 0) {\n            this.astWithTokens = this.parseDocumentFromTextBuffer(this.queuedTextEdits, this.astWithTokens, false);\n            this.queuedTextEdits = [];\n        }\n        if (this.queuedTextEditsForInitialAstWithoutTokens.length > 0) {\n            if (this.initialAstWithoutTokens) {\n                this.initialAstWithoutTokens = this.parseDocumentFromTextBuffer(this.queuedTextEditsForInitialAstWithoutTokens, this.initialAstWithoutTokens, false);\n            }\n            this.queuedTextEditsForInitialAstWithoutTokens = [];\n        }\n    }\n    /**\n     * @pure (only if isPure = true)\n    */\n    parseDocumentFromTextBuffer(edits, previousAst, immutable) {\n        const previousAstClone = previousAst;\n        const tokenizer = new TextBufferTokenizer(this.textModel, this.brackets);\n        const result = parseDocument(tokenizer, edits, previousAstClone, immutable);\n        return result;\n    }\n    getBracketsInRange(range, onlyColorizedBrackets) {\n        this.flushQueue();\n        const startOffset = toLength(range.startLineNumber - 1, range.startColumn - 1);\n        const endOffset = toLength(range.endLineNumber - 1, range.endColumn - 1);\n        return new CallbackIterable(cb => {\n            const node = this.initialAstWithoutTokens || this.astWithTokens;\n            collectBrackets(node, lengthZero, node.length, startOffset, endOffset, cb, 0, 0, new Map(), onlyColorizedBrackets);\n        });\n    }\n    getBracketPairsInRange(range, includeMinIndentation) {\n        this.flushQueue();\n        const startLength = positionToLength(range.getStartPosition());\n        const endLength = positionToLength(range.getEndPosition());\n        return new CallbackIterable(cb => {\n            const node = this.initialAstWithoutTokens || this.astWithTokens;\n            const context = new CollectBracketPairsContext(cb, includeMinIndentation, this.textModel);\n            collectBracketPairs(node, lengthZero, node.length, startLength, endLength, context, 0, new Map());\n        });\n    }\n    getFirstBracketAfter(position) {\n        this.flushQueue();\n        const node = this.initialAstWithoutTokens || this.astWithTokens;\n        return getFirstBracketAfter(node, lengthZero, node.length, positionToLength(position));\n    }\n    getFirstBracketBefore(position) {\n        this.flushQueue();\n        const node = this.initialAstWithoutTokens || this.astWithTokens;\n        return getFirstBracketBefore(node, lengthZero, node.length, positionToLength(position));\n    }\n}\nfunction getFirstBracketBefore(node, nodeOffsetStart, nodeOffsetEnd, position) {\n    if (node.kind === 4 /* AstNodeKind.List */ || node.kind === 2 /* AstNodeKind.Pair */) {\n        const lengths = [];\n        for (const child of node.children) {\n            nodeOffsetEnd = lengthAdd(nodeOffsetStart, child.length);\n            lengths.push({ nodeOffsetStart, nodeOffsetEnd });\n            nodeOffsetStart = nodeOffsetEnd;\n        }\n        for (let i = lengths.length - 1; i >= 0; i--) {\n            const { nodeOffsetStart, nodeOffsetEnd } = lengths[i];\n            if (lengthLessThan(nodeOffsetStart, position)) {\n                const result = getFirstBracketBefore(node.children[i], nodeOffsetStart, nodeOffsetEnd, position);\n                if (result) {\n                    return result;\n                }\n            }\n        }\n        return null;\n    }\n    else if (node.kind === 3 /* AstNodeKind.UnexpectedClosingBracket */) {\n        return null;\n    }\n    else if (node.kind === 1 /* AstNodeKind.Bracket */) {\n        const range = lengthsToRange(nodeOffsetStart, nodeOffsetEnd);\n        return {\n            bracketInfo: node.bracketInfo,\n            range\n        };\n    }\n    return null;\n}\nfunction getFirstBracketAfter(node, nodeOffsetStart, nodeOffsetEnd, position) {\n    if (node.kind === 4 /* AstNodeKind.List */ || node.kind === 2 /* AstNodeKind.Pair */) {\n        for (const child of node.children) {\n            nodeOffsetEnd = lengthAdd(nodeOffsetStart, child.length);\n            if (lengthLessThan(position, nodeOffsetEnd)) {\n                const result = getFirstBracketAfter(child, nodeOffsetStart, nodeOffsetEnd, position);\n                if (result) {\n                    return result;\n                }\n            }\n            nodeOffsetStart = nodeOffsetEnd;\n        }\n        return null;\n    }\n    else if (node.kind === 3 /* AstNodeKind.UnexpectedClosingBracket */) {\n        return null;\n    }\n    else if (node.kind === 1 /* AstNodeKind.Bracket */) {\n        const range = lengthsToRange(nodeOffsetStart, nodeOffsetEnd);\n        return {\n            bracketInfo: node.bracketInfo,\n            range\n        };\n    }\n    return null;\n}\nfunction collectBrackets(node, nodeOffsetStart, nodeOffsetEnd, startOffset, endOffset, push, level, nestingLevelOfEqualBracketType, levelPerBracketType, onlyColorizedBrackets, parentPairIsIncomplete = false) {\n    if (level > 200) {\n        return true;\n    }\n    whileLoop: while (true) {\n        switch (node.kind) {\n            case 4 /* AstNodeKind.List */: {\n                const childCount = node.childrenLength;\n                for (let i = 0; i < childCount; i++) {\n                    const child = node.getChild(i);\n                    if (!child) {\n                        continue;\n                    }\n                    nodeOffsetEnd = lengthAdd(nodeOffsetStart, child.length);\n                    if (lengthLessThanEqual(nodeOffsetStart, endOffset) &&\n                        lengthGreaterThanEqual(nodeOffsetEnd, startOffset)) {\n                        const childEndsAfterEnd = lengthGreaterThanEqual(nodeOffsetEnd, endOffset);\n                        if (childEndsAfterEnd) {\n                            // No child after this child in the requested window, don't recurse\n                            node = child;\n                            continue whileLoop;\n                        }\n                        const shouldContinue = collectBrackets(child, nodeOffsetStart, nodeOffsetEnd, startOffset, endOffset, push, level, 0, levelPerBracketType, onlyColorizedBrackets);\n                        if (!shouldContinue) {\n                            return false;\n                        }\n                    }\n                    nodeOffsetStart = nodeOffsetEnd;\n                }\n                return true;\n            }\n            case 2 /* AstNodeKind.Pair */: {\n                const colorize = !onlyColorizedBrackets || !node.closingBracket || node.closingBracket.bracketInfo.closesColorized(node.openingBracket.bracketInfo);\n                let levelPerBracket = 0;\n                if (levelPerBracketType) {\n                    let existing = levelPerBracketType.get(node.openingBracket.text);\n                    if (existing === undefined) {\n                        existing = 0;\n                    }\n                    levelPerBracket = existing;\n                    if (colorize) {\n                        existing++;\n                        levelPerBracketType.set(node.openingBracket.text, existing);\n                    }\n                }\n                const childCount = node.childrenLength;\n                for (let i = 0; i < childCount; i++) {\n                    const child = node.getChild(i);\n                    if (!child) {\n                        continue;\n                    }\n                    nodeOffsetEnd = lengthAdd(nodeOffsetStart, child.length);\n                    if (lengthLessThanEqual(nodeOffsetStart, endOffset) &&\n                        lengthGreaterThanEqual(nodeOffsetEnd, startOffset)) {\n                        const childEndsAfterEnd = lengthGreaterThanEqual(nodeOffsetEnd, endOffset);\n                        if (childEndsAfterEnd && child.kind !== 1 /* AstNodeKind.Bracket */) {\n                            // No child after this child in the requested window, don't recurse\n                            // Don't do this for brackets because of unclosed/unopened brackets\n                            node = child;\n                            if (colorize) {\n                                level++;\n                                nestingLevelOfEqualBracketType = levelPerBracket + 1;\n                            }\n                            else {\n                                nestingLevelOfEqualBracketType = levelPerBracket;\n                            }\n                            continue whileLoop;\n                        }\n                        if (colorize || child.kind !== 1 /* AstNodeKind.Bracket */ || !node.closingBracket) {\n                            const shouldContinue = collectBrackets(child, nodeOffsetStart, nodeOffsetEnd, startOffset, endOffset, push, colorize ? level + 1 : level, colorize ? levelPerBracket + 1 : levelPerBracket, levelPerBracketType, onlyColorizedBrackets, !node.closingBracket);\n                            if (!shouldContinue) {\n                                return false;\n                            }\n                        }\n                    }\n                    nodeOffsetStart = nodeOffsetEnd;\n                }\n                levelPerBracketType?.set(node.openingBracket.text, levelPerBracket);\n                return true;\n            }\n            case 3 /* AstNodeKind.UnexpectedClosingBracket */: {\n                const range = lengthsToRange(nodeOffsetStart, nodeOffsetEnd);\n                return push(new BracketInfo(range, level - 1, 0, true));\n            }\n            case 1 /* AstNodeKind.Bracket */: {\n                const range = lengthsToRange(nodeOffsetStart, nodeOffsetEnd);\n                return push(new BracketInfo(range, level - 1, nestingLevelOfEqualBracketType - 1, parentPairIsIncomplete));\n            }\n            case 0 /* AstNodeKind.Text */:\n                return true;\n        }\n    }\n}\nclass CollectBracketPairsContext {\n    constructor(push, includeMinIndentation, textModel) {\n        this.push = push;\n        this.includeMinIndentation = includeMinIndentation;\n        this.textModel = textModel;\n    }\n}\nfunction collectBracketPairs(node, nodeOffsetStart, nodeOffsetEnd, startOffset, endOffset, context, level, levelPerBracketType) {\n    if (level > 200) {\n        return true;\n    }\n    let shouldContinue = true;\n    if (node.kind === 2 /* AstNodeKind.Pair */) {\n        let levelPerBracket = 0;\n        if (levelPerBracketType) {\n            let existing = levelPerBracketType.get(node.openingBracket.text);\n            if (existing === undefined) {\n                existing = 0;\n            }\n            levelPerBracket = existing;\n            existing++;\n            levelPerBracketType.set(node.openingBracket.text, existing);\n        }\n        const openingBracketEnd = lengthAdd(nodeOffsetStart, node.openingBracket.length);\n        let minIndentation = -1;\n        if (context.includeMinIndentation) {\n            minIndentation = node.computeMinIndentation(nodeOffsetStart, context.textModel);\n        }\n        shouldContinue = context.push(new BracketPairWithMinIndentationInfo(lengthsToRange(nodeOffsetStart, nodeOffsetEnd), lengthsToRange(nodeOffsetStart, openingBracketEnd), node.closingBracket\n            ? lengthsToRange(lengthAdd(openingBracketEnd, node.child?.length || lengthZero), nodeOffsetEnd)\n            : undefined, level, levelPerBracket, node, minIndentation));\n        nodeOffsetStart = openingBracketEnd;\n        if (shouldContinue && node.child) {\n            const child = node.child;\n            nodeOffsetEnd = lengthAdd(nodeOffsetStart, child.length);\n            if (lengthLessThanEqual(nodeOffsetStart, endOffset) &&\n                lengthGreaterThanEqual(nodeOffsetEnd, startOffset)) {\n                shouldContinue = collectBracketPairs(child, nodeOffsetStart, nodeOffsetEnd, startOffset, endOffset, context, level + 1, levelPerBracketType);\n                if (!shouldContinue) {\n                    return false;\n                }\n            }\n        }\n        levelPerBracketType?.set(node.openingBracket.text, levelPerBracket);\n    }\n    else {\n        let curOffset = nodeOffsetStart;\n        for (const child of node.children) {\n            const childOffset = curOffset;\n            curOffset = lengthAdd(curOffset, child.length);\n            if (lengthLessThanEqual(childOffset, endOffset) &&\n                lengthLessThanEqual(startOffset, curOffset)) {\n                shouldContinue = collectBracketPairs(child, childOffset, curOffset, startOffset, endOffset, context, level, levelPerBracketType);\n                if (!shouldContinue) {\n                    return false;\n                }\n            }\n        }\n    }\n    return shouldContinue;\n}\n\nexport { BracketPairsTree };\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 3522, "column": 0}, "map": {"version":3,"sources":["file:///D:/real-time-code-editor%20%282%29/node_modules/.pnpm/monaco-editor%400.55.1/node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsImpl.js"],"sourcesContent":["import { CallbackIterable, compareBy } from '../../../../base/common/arrays.js';\nimport { Emitter } from '../../../../base/common/event.js';\nimport { Disposable, MutableDisposable, DisposableStore } from '../../../../base/common/lifecycle.js';\nimport { Range } from '../../core/range.js';\nimport { ignoreBracketsInToken } from '../../languages/supports.js';\nimport { BracketsUtils } from '../../languages/supports/richEditBrackets.js';\nimport { BracketPairsTree } from './bracketPairsTree/bracketPairsTree.js';\n\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nclass BracketPairsTextModelPart extends Disposable {\n    get canBuildAST() {\n        const maxSupportedDocumentLength = /* max lines */ 50_000 * /* average column count */ 100;\n        return this.textModel.getValueLength() <= maxSupportedDocumentLength;\n    }\n    constructor(textModel, languageConfigurationService) {\n        super();\n        this.textModel = textModel;\n        this.languageConfigurationService = languageConfigurationService;\n        this.bracketPairsTree = this._register(new MutableDisposable());\n        this.onDidChangeEmitter = new Emitter();\n        this.onDidChange = this.onDidChangeEmitter.event;\n        this.bracketsRequested = false;\n    }\n    //#region TextModel events\n    handleLanguageConfigurationServiceChange(e) {\n        if (!e.languageId || this.bracketPairsTree.value?.object.didLanguageChange(e.languageId)) {\n            this.bracketPairsTree.clear();\n            this.updateBracketPairsTree();\n        }\n    }\n    handleDidChangeOptions(e) {\n        this.bracketPairsTree.clear();\n        this.updateBracketPairsTree();\n    }\n    handleDidChangeLanguage(e) {\n        this.bracketPairsTree.clear();\n        this.updateBracketPairsTree();\n    }\n    handleDidChangeContent(change) {\n        this.bracketPairsTree.value?.object.handleContentChanged(change);\n    }\n    handleDidChangeBackgroundTokenizationState() {\n        this.bracketPairsTree.value?.object.handleDidChangeBackgroundTokenizationState();\n    }\n    handleDidChangeTokens(e) {\n        this.bracketPairsTree.value?.object.handleDidChangeTokens(e);\n    }\n    //#endregion\n    updateBracketPairsTree() {\n        if (this.bracketsRequested && this.canBuildAST) {\n            if (!this.bracketPairsTree.value) {\n                const store = new DisposableStore();\n                this.bracketPairsTree.value = createDisposableRef(store.add(new BracketPairsTree(this.textModel, (languageId) => {\n                    return this.languageConfigurationService.getLanguageConfiguration(languageId);\n                })), store);\n                store.add(this.bracketPairsTree.value.object.onDidChange(e => this.onDidChangeEmitter.fire(e)));\n                this.onDidChangeEmitter.fire();\n            }\n        }\n        else {\n            if (this.bracketPairsTree.value) {\n                this.bracketPairsTree.clear();\n                // Important: Don't call fire if there was no change!\n                this.onDidChangeEmitter.fire();\n            }\n        }\n    }\n    /**\n     * Returns all bracket pairs that intersect the given range.\n     * The result is sorted by the start position.\n    */\n    getBracketPairsInRange(range) {\n        this.bracketsRequested = true;\n        this.updateBracketPairsTree();\n        return this.bracketPairsTree.value?.object.getBracketPairsInRange(range, false) || CallbackIterable.empty;\n    }\n    getBracketPairsInRangeWithMinIndentation(range) {\n        this.bracketsRequested = true;\n        this.updateBracketPairsTree();\n        return this.bracketPairsTree.value?.object.getBracketPairsInRange(range, true) || CallbackIterable.empty;\n    }\n    getBracketsInRange(range, onlyColorizedBrackets = false) {\n        this.bracketsRequested = true;\n        this.updateBracketPairsTree();\n        return this.bracketPairsTree.value?.object.getBracketsInRange(range, onlyColorizedBrackets) || CallbackIterable.empty;\n    }\n    findMatchingBracketUp(_bracket, _position, maxDuration) {\n        const position = this.textModel.validatePosition(_position);\n        const languageId = this.textModel.getLanguageIdAtPosition(position.lineNumber, position.column);\n        if (this.canBuildAST) {\n            const closingBracketInfo = this.languageConfigurationService\n                .getLanguageConfiguration(languageId)\n                .bracketsNew.getClosingBracketInfo(_bracket);\n            if (!closingBracketInfo) {\n                return null;\n            }\n            const bracketPair = this.getBracketPairsInRange(Range.fromPositions(_position, _position)).findLast((b) => closingBracketInfo.closes(b.openingBracketInfo));\n            if (bracketPair) {\n                return bracketPair.openingBracketRange;\n            }\n            return null;\n        }\n        else {\n            // Fallback to old bracket matching code:\n            const bracket = _bracket.toLowerCase();\n            const bracketsSupport = this.languageConfigurationService.getLanguageConfiguration(languageId).brackets;\n            if (!bracketsSupport) {\n                return null;\n            }\n            const data = bracketsSupport.textIsBracket[bracket];\n            if (!data) {\n                return null;\n            }\n            return stripBracketSearchCanceled(this._findMatchingBracketUp(data, position, createTimeBasedContinueBracketSearchPredicate(maxDuration)));\n        }\n    }\n    matchBracket(position, maxDuration) {\n        if (this.canBuildAST) {\n            const bracketPair = this.getBracketPairsInRange(Range.fromPositions(position, position)).filter((item) => item.closingBracketRange !== undefined &&\n                (item.openingBracketRange.containsPosition(position) ||\n                    item.closingBracketRange.containsPosition(position))).findLastMaxBy(compareBy((item) => item.openingBracketRange.containsPosition(position)\n                ? item.openingBracketRange\n                : item.closingBracketRange, Range.compareRangesUsingStarts));\n            if (bracketPair) {\n                return [bracketPair.openingBracketRange, bracketPair.closingBracketRange];\n            }\n            return null;\n        }\n        else {\n            // Fallback to old bracket matching code:\n            const continueSearchPredicate = createTimeBasedContinueBracketSearchPredicate(maxDuration);\n            return this._matchBracket(this.textModel.validatePosition(position), continueSearchPredicate);\n        }\n    }\n    _establishBracketSearchOffsets(position, lineTokens, modeBrackets, tokenIndex) {\n        const tokenCount = lineTokens.getCount();\n        const currentLanguageId = lineTokens.getLanguageId(tokenIndex);\n        // limit search to not go before `maxBracketLength`\n        let searchStartOffset = Math.max(0, position.column - 1 - modeBrackets.maxBracketLength);\n        for (let i = tokenIndex - 1; i >= 0; i--) {\n            const tokenEndOffset = lineTokens.getEndOffset(i);\n            if (tokenEndOffset <= searchStartOffset) {\n                break;\n            }\n            if (ignoreBracketsInToken(lineTokens.getStandardTokenType(i)) || lineTokens.getLanguageId(i) !== currentLanguageId) {\n                searchStartOffset = tokenEndOffset;\n                break;\n            }\n        }\n        // limit search to not go after `maxBracketLength`\n        let searchEndOffset = Math.min(lineTokens.getLineContent().length, position.column - 1 + modeBrackets.maxBracketLength);\n        for (let i = tokenIndex + 1; i < tokenCount; i++) {\n            const tokenStartOffset = lineTokens.getStartOffset(i);\n            if (tokenStartOffset >= searchEndOffset) {\n                break;\n            }\n            if (ignoreBracketsInToken(lineTokens.getStandardTokenType(i)) || lineTokens.getLanguageId(i) !== currentLanguageId) {\n                searchEndOffset = tokenStartOffset;\n                break;\n            }\n        }\n        return { searchStartOffset, searchEndOffset };\n    }\n    _matchBracket(position, continueSearchPredicate) {\n        const lineNumber = position.lineNumber;\n        const lineTokens = this.textModel.tokenization.getLineTokens(lineNumber);\n        const lineText = this.textModel.getLineContent(lineNumber);\n        const tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n        if (tokenIndex < 0) {\n            return null;\n        }\n        const currentModeBrackets = this.languageConfigurationService.getLanguageConfiguration(lineTokens.getLanguageId(tokenIndex)).brackets;\n        // check that the token is not to be ignored\n        if (currentModeBrackets && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex))) {\n            let { searchStartOffset, searchEndOffset } = this._establishBracketSearchOffsets(position, lineTokens, currentModeBrackets, tokenIndex);\n            // it might be the case that [currentTokenStart -> currentTokenEnd] contains multiple brackets\n            // `bestResult` will contain the most right-side result\n            let bestResult = null;\n            while (true) {\n                const foundBracket = BracketsUtils.findNextBracketInRange(currentModeBrackets.forwardRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                if (!foundBracket) {\n                    // there are no more brackets in this text\n                    break;\n                }\n                // check that we didn't hit a bracket too far away from position\n                if (foundBracket.startColumn <= position.column && position.column <= foundBracket.endColumn) {\n                    const foundBracketText = lineText.substring(foundBracket.startColumn - 1, foundBracket.endColumn - 1).toLowerCase();\n                    const r = this._matchFoundBracket(foundBracket, currentModeBrackets.textIsBracket[foundBracketText], currentModeBrackets.textIsOpenBracket[foundBracketText], continueSearchPredicate);\n                    if (r) {\n                        if (r instanceof BracketSearchCanceled) {\n                            return null;\n                        }\n                        bestResult = r;\n                    }\n                }\n                searchStartOffset = foundBracket.endColumn - 1;\n            }\n            if (bestResult) {\n                return bestResult;\n            }\n        }\n        // If position is in between two tokens, try also looking in the previous token\n        if (tokenIndex > 0 && lineTokens.getStartOffset(tokenIndex) === position.column - 1) {\n            const prevTokenIndex = tokenIndex - 1;\n            const prevModeBrackets = this.languageConfigurationService.getLanguageConfiguration(lineTokens.getLanguageId(prevTokenIndex)).brackets;\n            // check that previous token is not to be ignored\n            if (prevModeBrackets && !ignoreBracketsInToken(lineTokens.getStandardTokenType(prevTokenIndex))) {\n                const { searchStartOffset, searchEndOffset } = this._establishBracketSearchOffsets(position, lineTokens, prevModeBrackets, prevTokenIndex);\n                const foundBracket = BracketsUtils.findPrevBracketInRange(prevModeBrackets.reversedRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                // check that we didn't hit a bracket too far away from position\n                if (foundBracket && foundBracket.startColumn <= position.column && position.column <= foundBracket.endColumn) {\n                    const foundBracketText = lineText.substring(foundBracket.startColumn - 1, foundBracket.endColumn - 1).toLowerCase();\n                    const r = this._matchFoundBracket(foundBracket, prevModeBrackets.textIsBracket[foundBracketText], prevModeBrackets.textIsOpenBracket[foundBracketText], continueSearchPredicate);\n                    if (r) {\n                        if (r instanceof BracketSearchCanceled) {\n                            return null;\n                        }\n                        return r;\n                    }\n                }\n            }\n        }\n        return null;\n    }\n    _matchFoundBracket(foundBracket, data, isOpen, continueSearchPredicate) {\n        if (!data) {\n            return null;\n        }\n        const matched = (isOpen\n            ? this._findMatchingBracketDown(data, foundBracket.getEndPosition(), continueSearchPredicate)\n            : this._findMatchingBracketUp(data, foundBracket.getStartPosition(), continueSearchPredicate));\n        if (!matched) {\n            return null;\n        }\n        if (matched instanceof BracketSearchCanceled) {\n            return matched;\n        }\n        return [foundBracket, matched];\n    }\n    _findMatchingBracketUp(bracket, position, continueSearchPredicate) {\n        // console.log('_findMatchingBracketUp: ', 'bracket: ', JSON.stringify(bracket), 'startPosition: ', String(position));\n        const languageId = bracket.languageId;\n        const reversedBracketRegex = bracket.reversedRegex;\n        let count = -1;\n        let totalCallCount = 0;\n        const searchPrevMatchingBracketInRange = (lineNumber, lineText, searchStartOffset, searchEndOffset) => {\n            while (true) {\n                if (continueSearchPredicate && (++totalCallCount) % 100 === 0 && !continueSearchPredicate()) {\n                    return BracketSearchCanceled.INSTANCE;\n                }\n                const r = BracketsUtils.findPrevBracketInRange(reversedBracketRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                if (!r) {\n                    break;\n                }\n                const hitText = lineText.substring(r.startColumn - 1, r.endColumn - 1).toLowerCase();\n                if (bracket.isOpen(hitText)) {\n                    count++;\n                }\n                else if (bracket.isClose(hitText)) {\n                    count--;\n                }\n                if (count === 0) {\n                    return r;\n                }\n                searchEndOffset = r.startColumn - 1;\n            }\n            return null;\n        };\n        for (let lineNumber = position.lineNumber; lineNumber >= 1; lineNumber--) {\n            const lineTokens = this.textModel.tokenization.getLineTokens(lineNumber);\n            const tokenCount = lineTokens.getCount();\n            const lineText = this.textModel.getLineContent(lineNumber);\n            let tokenIndex = tokenCount - 1;\n            let searchStartOffset = lineText.length;\n            let searchEndOffset = lineText.length;\n            if (lineNumber === position.lineNumber) {\n                tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n                searchStartOffset = position.column - 1;\n                searchEndOffset = position.column - 1;\n            }\n            let prevSearchInToken = true;\n            for (; tokenIndex >= 0; tokenIndex--) {\n                const searchInToken = (lineTokens.getLanguageId(tokenIndex) === languageId && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex)));\n                if (searchInToken) {\n                    // this token should be searched\n                    if (prevSearchInToken) {\n                        // the previous token should be searched, simply extend searchStartOffset\n                        searchStartOffset = lineTokens.getStartOffset(tokenIndex);\n                    }\n                    else {\n                        // the previous token should not be searched\n                        searchStartOffset = lineTokens.getStartOffset(tokenIndex);\n                        searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n                    }\n                }\n                else {\n                    // this token should not be searched\n                    if (prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                        const r = searchPrevMatchingBracketInRange(lineNumber, lineText, searchStartOffset, searchEndOffset);\n                        if (r) {\n                            return r;\n                        }\n                    }\n                }\n                prevSearchInToken = searchInToken;\n            }\n            if (prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                const r = searchPrevMatchingBracketInRange(lineNumber, lineText, searchStartOffset, searchEndOffset);\n                if (r) {\n                    return r;\n                }\n            }\n        }\n        return null;\n    }\n    _findMatchingBracketDown(bracket, position, continueSearchPredicate) {\n        // console.log('_findMatchingBracketDown: ', 'bracket: ', JSON.stringify(bracket), 'startPosition: ', String(position));\n        const languageId = bracket.languageId;\n        const bracketRegex = bracket.forwardRegex;\n        let count = 1;\n        let totalCallCount = 0;\n        const searchNextMatchingBracketInRange = (lineNumber, lineText, searchStartOffset, searchEndOffset) => {\n            while (true) {\n                if (continueSearchPredicate && (++totalCallCount) % 100 === 0 && !continueSearchPredicate()) {\n                    return BracketSearchCanceled.INSTANCE;\n                }\n                const r = BracketsUtils.findNextBracketInRange(bracketRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                if (!r) {\n                    break;\n                }\n                const hitText = lineText.substring(r.startColumn - 1, r.endColumn - 1).toLowerCase();\n                if (bracket.isOpen(hitText)) {\n                    count++;\n                }\n                else if (bracket.isClose(hitText)) {\n                    count--;\n                }\n                if (count === 0) {\n                    return r;\n                }\n                searchStartOffset = r.endColumn - 1;\n            }\n            return null;\n        };\n        const lineCount = this.textModel.getLineCount();\n        for (let lineNumber = position.lineNumber; lineNumber <= lineCount; lineNumber++) {\n            const lineTokens = this.textModel.tokenization.getLineTokens(lineNumber);\n            const tokenCount = lineTokens.getCount();\n            const lineText = this.textModel.getLineContent(lineNumber);\n            let tokenIndex = 0;\n            let searchStartOffset = 0;\n            let searchEndOffset = 0;\n            if (lineNumber === position.lineNumber) {\n                tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n                searchStartOffset = position.column - 1;\n                searchEndOffset = position.column - 1;\n            }\n            let prevSearchInToken = true;\n            for (; tokenIndex < tokenCount; tokenIndex++) {\n                const searchInToken = (lineTokens.getLanguageId(tokenIndex) === languageId && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex)));\n                if (searchInToken) {\n                    // this token should be searched\n                    if (prevSearchInToken) {\n                        // the previous token should be searched, simply extend searchEndOffset\n                        searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n                    }\n                    else {\n                        // the previous token should not be searched\n                        searchStartOffset = lineTokens.getStartOffset(tokenIndex);\n                        searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n                    }\n                }\n                else {\n                    // this token should not be searched\n                    if (prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                        const r = searchNextMatchingBracketInRange(lineNumber, lineText, searchStartOffset, searchEndOffset);\n                        if (r) {\n                            return r;\n                        }\n                    }\n                }\n                prevSearchInToken = searchInToken;\n            }\n            if (prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                const r = searchNextMatchingBracketInRange(lineNumber, lineText, searchStartOffset, searchEndOffset);\n                if (r) {\n                    return r;\n                }\n            }\n        }\n        return null;\n    }\n    findPrevBracket(_position) {\n        const position = this.textModel.validatePosition(_position);\n        if (this.canBuildAST) {\n            this.bracketsRequested = true;\n            this.updateBracketPairsTree();\n            return this.bracketPairsTree.value?.object.getFirstBracketBefore(position) || null;\n        }\n        let languageId = null;\n        let modeBrackets = null;\n        let bracketConfig = null;\n        for (let lineNumber = position.lineNumber; lineNumber >= 1; lineNumber--) {\n            const lineTokens = this.textModel.tokenization.getLineTokens(lineNumber);\n            const tokenCount = lineTokens.getCount();\n            const lineText = this.textModel.getLineContent(lineNumber);\n            let tokenIndex = tokenCount - 1;\n            let searchStartOffset = lineText.length;\n            let searchEndOffset = lineText.length;\n            if (lineNumber === position.lineNumber) {\n                tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n                searchStartOffset = position.column - 1;\n                searchEndOffset = position.column - 1;\n                const tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\n                if (languageId !== tokenLanguageId) {\n                    languageId = tokenLanguageId;\n                    modeBrackets = this.languageConfigurationService.getLanguageConfiguration(languageId).brackets;\n                    bracketConfig = this.languageConfigurationService.getLanguageConfiguration(languageId).bracketsNew;\n                }\n            }\n            let prevSearchInToken = true;\n            for (; tokenIndex >= 0; tokenIndex--) {\n                const tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\n                if (languageId !== tokenLanguageId) {\n                    // language id change!\n                    if (modeBrackets && bracketConfig && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                        const r = BracketsUtils.findPrevBracketInRange(modeBrackets.reversedRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                        if (r) {\n                            return this._toFoundBracket(bracketConfig, r);\n                        }\n                        prevSearchInToken = false;\n                    }\n                    languageId = tokenLanguageId;\n                    modeBrackets = this.languageConfigurationService.getLanguageConfiguration(languageId).brackets;\n                    bracketConfig = this.languageConfigurationService.getLanguageConfiguration(languageId).bracketsNew;\n                }\n                const searchInToken = (!!modeBrackets && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex)));\n                if (searchInToken) {\n                    // this token should be searched\n                    if (prevSearchInToken) {\n                        // the previous token should be searched, simply extend searchStartOffset\n                        searchStartOffset = lineTokens.getStartOffset(tokenIndex);\n                    }\n                    else {\n                        // the previous token should not be searched\n                        searchStartOffset = lineTokens.getStartOffset(tokenIndex);\n                        searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n                    }\n                }\n                else {\n                    // this token should not be searched\n                    if (bracketConfig && modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                        const r = BracketsUtils.findPrevBracketInRange(modeBrackets.reversedRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                        if (r) {\n                            return this._toFoundBracket(bracketConfig, r);\n                        }\n                    }\n                }\n                prevSearchInToken = searchInToken;\n            }\n            if (bracketConfig && modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                const r = BracketsUtils.findPrevBracketInRange(modeBrackets.reversedRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                if (r) {\n                    return this._toFoundBracket(bracketConfig, r);\n                }\n            }\n        }\n        return null;\n    }\n    findNextBracket(_position) {\n        const position = this.textModel.validatePosition(_position);\n        if (this.canBuildAST) {\n            this.bracketsRequested = true;\n            this.updateBracketPairsTree();\n            return this.bracketPairsTree.value?.object.getFirstBracketAfter(position) || null;\n        }\n        const lineCount = this.textModel.getLineCount();\n        let languageId = null;\n        let modeBrackets = null;\n        let bracketConfig = null;\n        for (let lineNumber = position.lineNumber; lineNumber <= lineCount; lineNumber++) {\n            const lineTokens = this.textModel.tokenization.getLineTokens(lineNumber);\n            const tokenCount = lineTokens.getCount();\n            const lineText = this.textModel.getLineContent(lineNumber);\n            let tokenIndex = 0;\n            let searchStartOffset = 0;\n            let searchEndOffset = 0;\n            if (lineNumber === position.lineNumber) {\n                tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n                searchStartOffset = position.column - 1;\n                searchEndOffset = position.column - 1;\n                const tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\n                if (languageId !== tokenLanguageId) {\n                    languageId = tokenLanguageId;\n                    modeBrackets = this.languageConfigurationService.getLanguageConfiguration(languageId).brackets;\n                    bracketConfig = this.languageConfigurationService.getLanguageConfiguration(languageId).bracketsNew;\n                }\n            }\n            let prevSearchInToken = true;\n            for (; tokenIndex < tokenCount; tokenIndex++) {\n                const tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\n                if (languageId !== tokenLanguageId) {\n                    // language id change!\n                    if (bracketConfig && modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                        const r = BracketsUtils.findNextBracketInRange(modeBrackets.forwardRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                        if (r) {\n                            return this._toFoundBracket(bracketConfig, r);\n                        }\n                        prevSearchInToken = false;\n                    }\n                    languageId = tokenLanguageId;\n                    modeBrackets = this.languageConfigurationService.getLanguageConfiguration(languageId).brackets;\n                    bracketConfig = this.languageConfigurationService.getLanguageConfiguration(languageId).bracketsNew;\n                }\n                const searchInToken = (!!modeBrackets && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex)));\n                if (searchInToken) {\n                    // this token should be searched\n                    if (prevSearchInToken) {\n                        // the previous token should be searched, simply extend searchEndOffset\n                        searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n                    }\n                    else {\n                        // the previous token should not be searched\n                        searchStartOffset = lineTokens.getStartOffset(tokenIndex);\n                        searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n                    }\n                }\n                else {\n                    // this token should not be searched\n                    if (bracketConfig && modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                        const r = BracketsUtils.findNextBracketInRange(modeBrackets.forwardRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                        if (r) {\n                            return this._toFoundBracket(bracketConfig, r);\n                        }\n                    }\n                }\n                prevSearchInToken = searchInToken;\n            }\n            if (bracketConfig && modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                const r = BracketsUtils.findNextBracketInRange(modeBrackets.forwardRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                if (r) {\n                    return this._toFoundBracket(bracketConfig, r);\n                }\n            }\n        }\n        return null;\n    }\n    findEnclosingBrackets(_position, maxDuration) {\n        const position = this.textModel.validatePosition(_position);\n        if (this.canBuildAST) {\n            const range = Range.fromPositions(position);\n            const bracketPair = this.getBracketPairsInRange(Range.fromPositions(position, position)).findLast((item) => item.closingBracketRange !== undefined && item.range.strictContainsRange(range));\n            if (bracketPair) {\n                return [bracketPair.openingBracketRange, bracketPair.closingBracketRange];\n            }\n            return null;\n        }\n        const continueSearchPredicate = createTimeBasedContinueBracketSearchPredicate(maxDuration);\n        const lineCount = this.textModel.getLineCount();\n        const savedCounts = new Map();\n        let counts = [];\n        const resetCounts = (languageId, modeBrackets) => {\n            if (!savedCounts.has(languageId)) {\n                const tmp = [];\n                for (let i = 0, len = modeBrackets ? modeBrackets.brackets.length : 0; i < len; i++) {\n                    tmp[i] = 0;\n                }\n                savedCounts.set(languageId, tmp);\n            }\n            counts = savedCounts.get(languageId);\n        };\n        let totalCallCount = 0;\n        const searchInRange = (modeBrackets, lineNumber, lineText, searchStartOffset, searchEndOffset) => {\n            while (true) {\n                if (continueSearchPredicate && (++totalCallCount) % 100 === 0 && !continueSearchPredicate()) {\n                    return BracketSearchCanceled.INSTANCE;\n                }\n                const r = BracketsUtils.findNextBracketInRange(modeBrackets.forwardRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                if (!r) {\n                    break;\n                }\n                const hitText = lineText.substring(r.startColumn - 1, r.endColumn - 1).toLowerCase();\n                const bracket = modeBrackets.textIsBracket[hitText];\n                if (bracket) {\n                    if (bracket.isOpen(hitText)) {\n                        counts[bracket.index]++;\n                    }\n                    else if (bracket.isClose(hitText)) {\n                        counts[bracket.index]--;\n                    }\n                    if (counts[bracket.index] === -1) {\n                        return this._matchFoundBracket(r, bracket, false, continueSearchPredicate);\n                    }\n                }\n                searchStartOffset = r.endColumn - 1;\n            }\n            return null;\n        };\n        let languageId = null;\n        let modeBrackets = null;\n        for (let lineNumber = position.lineNumber; lineNumber <= lineCount; lineNumber++) {\n            const lineTokens = this.textModel.tokenization.getLineTokens(lineNumber);\n            const tokenCount = lineTokens.getCount();\n            const lineText = this.textModel.getLineContent(lineNumber);\n            let tokenIndex = 0;\n            let searchStartOffset = 0;\n            let searchEndOffset = 0;\n            if (lineNumber === position.lineNumber) {\n                tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n                searchStartOffset = position.column - 1;\n                searchEndOffset = position.column - 1;\n                const tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\n                if (languageId !== tokenLanguageId) {\n                    languageId = tokenLanguageId;\n                    modeBrackets = this.languageConfigurationService.getLanguageConfiguration(languageId).brackets;\n                    resetCounts(languageId, modeBrackets);\n                }\n            }\n            let prevSearchInToken = true;\n            for (; tokenIndex < tokenCount; tokenIndex++) {\n                const tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\n                if (languageId !== tokenLanguageId) {\n                    // language id change!\n                    if (modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                        const r = searchInRange(modeBrackets, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                        if (r) {\n                            return stripBracketSearchCanceled(r);\n                        }\n                        prevSearchInToken = false;\n                    }\n                    languageId = tokenLanguageId;\n                    modeBrackets = this.languageConfigurationService.getLanguageConfiguration(languageId).brackets;\n                    resetCounts(languageId, modeBrackets);\n                }\n                const searchInToken = (!!modeBrackets && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex)));\n                if (searchInToken) {\n                    // this token should be searched\n                    if (prevSearchInToken) {\n                        // the previous token should be searched, simply extend searchEndOffset\n                        searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n                    }\n                    else {\n                        // the previous token should not be searched\n                        searchStartOffset = lineTokens.getStartOffset(tokenIndex);\n                        searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n                    }\n                }\n                else {\n                    // this token should not be searched\n                    if (modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                        const r = searchInRange(modeBrackets, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                        if (r) {\n                            return stripBracketSearchCanceled(r);\n                        }\n                    }\n                }\n                prevSearchInToken = searchInToken;\n            }\n            if (modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                const r = searchInRange(modeBrackets, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                if (r) {\n                    return stripBracketSearchCanceled(r);\n                }\n            }\n        }\n        return null;\n    }\n    _toFoundBracket(bracketConfig, r) {\n        if (!r) {\n            return null;\n        }\n        let text = this.textModel.getValueInRange(r);\n        text = text.toLowerCase();\n        const bracketInfo = bracketConfig.getBracketInfo(text);\n        if (!bracketInfo) {\n            return null;\n        }\n        return {\n            range: r,\n            bracketInfo\n        };\n    }\n}\nfunction createDisposableRef(object, disposable) {\n    return {\n        object,\n        dispose: () => disposable?.dispose(),\n    };\n}\nfunction createTimeBasedContinueBracketSearchPredicate(maxDuration) {\n    if (typeof maxDuration === 'undefined') {\n        return () => true;\n    }\n    else {\n        const startTime = Date.now();\n        return () => {\n            return (Date.now() - startTime <= maxDuration);\n        };\n    }\n}\nclass BracketSearchCanceled {\n    static { this.INSTANCE = new BracketSearchCanceled(); }\n    constructor() {\n        this._searchCanceledBrand = undefined;\n    }\n}\nfunction stripBracketSearchCanceled(result) {\n    if (result instanceof BracketSearchCanceled) {\n        return null;\n    }\n    return result;\n}\n\nexport { BracketPairsTextModelPart };\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 4238, "column": 0}, "map": {"version":3,"sources":["file:///D:/real-time-code-editor%20%282%29/node_modules/.pnpm/monaco-editor%400.55.1/node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/colorizedBracketPairsDecorationProvider.js"],"sourcesContent":["import { Emitter } from '../../../../base/common/event.js';\nimport { Disposable } from '../../../../base/common/lifecycle.js';\nimport { Range } from '../../core/range.js';\nimport { editorBracketHighlightingUnexpectedBracketForeground, editorBracketHighlightingForeground1, editorBracketHighlightingForeground2, editorBracketHighlightingForeground3, editorBracketHighlightingForeground4, editorBracketHighlightingForeground5, editorBracketHighlightingForeground6 } from '../../core/editorColorRegistry.js';\nimport { registerThemingParticipant } from '../../../../platform/theme/common/themeService.js';\n\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nclass ColorizedBracketPairsDecorationProvider extends Disposable {\n    constructor(textModel) {\n        super();\n        this.textModel = textModel;\n        this.colorProvider = new ColorProvider();\n        this.onDidChangeEmitter = new Emitter();\n        this.onDidChange = this.onDidChangeEmitter.event;\n        this.colorizationOptions = textModel.getOptions().bracketPairColorizationOptions;\n        this._register(textModel.bracketPairs.onDidChange(e => {\n            this.onDidChangeEmitter.fire();\n        }));\n    }\n    //#region TextModel events\n    handleDidChangeOptions(e) {\n        this.colorizationOptions = this.textModel.getOptions().bracketPairColorizationOptions;\n    }\n    //#endregion\n    getDecorationsInRange(range, ownerId, filterOutValidation, onlyMinimapDecorations) {\n        if (onlyMinimapDecorations) {\n            // Bracket pair colorization decorations are not rendered in the minimap\n            return [];\n        }\n        if (ownerId === undefined) {\n            return [];\n        }\n        if (!this.colorizationOptions.enabled) {\n            return [];\n        }\n        const result = this.textModel.bracketPairs.getBracketsInRange(range, true).map(bracket => ({\n            id: `bracket${bracket.range.toString()}-${bracket.nestingLevel}`,\n            options: {\n                description: 'BracketPairColorization',\n                inlineClassName: this.colorProvider.getInlineClassName(bracket, this.colorizationOptions.independentColorPoolPerBracketType),\n            },\n            ownerId: 0,\n            range: bracket.range,\n        })).toArray();\n        return result;\n    }\n    getAllDecorations(ownerId, filterOutValidation) {\n        if (ownerId === undefined) {\n            return [];\n        }\n        if (!this.colorizationOptions.enabled) {\n            return [];\n        }\n        return this.getDecorationsInRange(new Range(1, 1, this.textModel.getLineCount(), 1), ownerId, filterOutValidation);\n    }\n}\nclass ColorProvider {\n    constructor() {\n        this.unexpectedClosingBracketClassName = 'unexpected-closing-bracket';\n    }\n    getInlineClassName(bracket, independentColorPoolPerBracketType) {\n        if (bracket.isInvalid) {\n            return this.unexpectedClosingBracketClassName;\n        }\n        return this.getInlineClassNameOfLevel(independentColorPoolPerBracketType ? bracket.nestingLevelOfEqualBracketType : bracket.nestingLevel);\n    }\n    getInlineClassNameOfLevel(level) {\n        // To support a dynamic amount of colors up to 6 colors,\n        // we use a number that is a lcm of all numbers from 1 to 6.\n        return `bracket-highlighting-${level % 30}`;\n    }\n}\nregisterThemingParticipant((theme, collector) => {\n    const colors = [\n        editorBracketHighlightingForeground1,\n        editorBracketHighlightingForeground2,\n        editorBracketHighlightingForeground3,\n        editorBracketHighlightingForeground4,\n        editorBracketHighlightingForeground5,\n        editorBracketHighlightingForeground6\n    ];\n    const colorProvider = new ColorProvider();\n    collector.addRule(`.monaco-editor .${colorProvider.unexpectedClosingBracketClassName} { color: ${theme.getColor(editorBracketHighlightingUnexpectedBracketForeground)}; }`);\n    const colorValues = colors\n        .map(c => theme.getColor(c))\n        .filter((c) => !!c)\n        .filter(c => !c.isTransparent());\n    for (let level = 0; level < 30; level++) {\n        const color = colorValues[level % colorValues.length];\n        collector.addRule(`.monaco-editor .${colorProvider.getInlineClassNameOfLevel(level)} { color: ${color}; }`);\n    }\n});\n\nexport { ColorizedBracketPairsDecorationProvider };\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 4342, "column": 0}, "map": {"version":3,"sources":["file:///D:/real-time-code-editor%20%282%29/node_modules/.pnpm/monaco-editor%400.55.1/node_modules/monaco-editor/esm/vs/editor/common/model/editStack.js"],"sourcesContent":["import { localize } from '../../../nls.js';\nimport { onUnexpectedError } from '../../../base/common/errors.js';\nimport { Selection } from '../core/selection.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { compressConsecutiveTextChanges, TextChange } from '../core/textChange.js';\nimport { writeUInt32BE, readUInt32BE, writeUInt8, readUInt8 } from '../../../base/common/buffer.js';\nimport { basename } from '../../../base/common/resources.js';\nimport { EditSources } from '../textModelEditSource.js';\n\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nfunction uriGetComparisonKey(resource) {\n    return resource.toString();\n}\nclass SingleModelEditStackData {\n    static create(model, beforeCursorState) {\n        const alternativeVersionId = model.getAlternativeVersionId();\n        const eol = getModelEOL(model);\n        return new SingleModelEditStackData(alternativeVersionId, alternativeVersionId, eol, eol, beforeCursorState, beforeCursorState, []);\n    }\n    constructor(beforeVersionId, afterVersionId, beforeEOL, afterEOL, beforeCursorState, afterCursorState, changes) {\n        this.beforeVersionId = beforeVersionId;\n        this.afterVersionId = afterVersionId;\n        this.beforeEOL = beforeEOL;\n        this.afterEOL = afterEOL;\n        this.beforeCursorState = beforeCursorState;\n        this.afterCursorState = afterCursorState;\n        this.changes = changes;\n    }\n    append(model, textChanges, afterEOL, afterVersionId, afterCursorState) {\n        if (textChanges.length > 0) {\n            this.changes = compressConsecutiveTextChanges(this.changes, textChanges);\n        }\n        this.afterEOL = afterEOL;\n        this.afterVersionId = afterVersionId;\n        this.afterCursorState = afterCursorState;\n    }\n    static _writeSelectionsSize(selections) {\n        return 4 + 4 * 4 * (selections ? selections.length : 0);\n    }\n    static _writeSelections(b, selections, offset) {\n        writeUInt32BE(b, (selections ? selections.length : 0), offset);\n        offset += 4;\n        if (selections) {\n            for (const selection of selections) {\n                writeUInt32BE(b, selection.selectionStartLineNumber, offset);\n                offset += 4;\n                writeUInt32BE(b, selection.selectionStartColumn, offset);\n                offset += 4;\n                writeUInt32BE(b, selection.positionLineNumber, offset);\n                offset += 4;\n                writeUInt32BE(b, selection.positionColumn, offset);\n                offset += 4;\n            }\n        }\n        return offset;\n    }\n    static _readSelections(b, offset, dest) {\n        const count = readUInt32BE(b, offset);\n        offset += 4;\n        for (let i = 0; i < count; i++) {\n            const selectionStartLineNumber = readUInt32BE(b, offset);\n            offset += 4;\n            const selectionStartColumn = readUInt32BE(b, offset);\n            offset += 4;\n            const positionLineNumber = readUInt32BE(b, offset);\n            offset += 4;\n            const positionColumn = readUInt32BE(b, offset);\n            offset += 4;\n            dest.push(new Selection(selectionStartLineNumber, selectionStartColumn, positionLineNumber, positionColumn));\n        }\n        return offset;\n    }\n    serialize() {\n        let necessarySize = (4 // beforeVersionId\n            + 4 // afterVersionId\n            + 1 // beforeEOL\n            + 1 // afterEOL\n            + SingleModelEditStackData._writeSelectionsSize(this.beforeCursorState)\n            + SingleModelEditStackData._writeSelectionsSize(this.afterCursorState)\n            + 4 // change count\n        );\n        for (const change of this.changes) {\n            necessarySize += change.writeSize();\n        }\n        const b = new Uint8Array(necessarySize);\n        let offset = 0;\n        writeUInt32BE(b, this.beforeVersionId, offset);\n        offset += 4;\n        writeUInt32BE(b, this.afterVersionId, offset);\n        offset += 4;\n        writeUInt8(b, this.beforeEOL, offset);\n        offset += 1;\n        writeUInt8(b, this.afterEOL, offset);\n        offset += 1;\n        offset = SingleModelEditStackData._writeSelections(b, this.beforeCursorState, offset);\n        offset = SingleModelEditStackData._writeSelections(b, this.afterCursorState, offset);\n        writeUInt32BE(b, this.changes.length, offset);\n        offset += 4;\n        for (const change of this.changes) {\n            offset = change.write(b, offset);\n        }\n        return b.buffer;\n    }\n    static deserialize(source) {\n        const b = new Uint8Array(source);\n        let offset = 0;\n        const beforeVersionId = readUInt32BE(b, offset);\n        offset += 4;\n        const afterVersionId = readUInt32BE(b, offset);\n        offset += 4;\n        const beforeEOL = readUInt8(b, offset);\n        offset += 1;\n        const afterEOL = readUInt8(b, offset);\n        offset += 1;\n        const beforeCursorState = [];\n        offset = SingleModelEditStackData._readSelections(b, offset, beforeCursorState);\n        const afterCursorState = [];\n        offset = SingleModelEditStackData._readSelections(b, offset, afterCursorState);\n        const changeCount = readUInt32BE(b, offset);\n        offset += 4;\n        const changes = [];\n        for (let i = 0; i < changeCount; i++) {\n            offset = TextChange.read(b, offset, changes);\n        }\n        return new SingleModelEditStackData(beforeVersionId, afterVersionId, beforeEOL, afterEOL, beforeCursorState, afterCursorState, changes);\n    }\n}\nclass SingleModelEditStackElement {\n    get type() {\n        return 0 /* UndoRedoElementType.Resource */;\n    }\n    get resource() {\n        if (URI.isUri(this.model)) {\n            return this.model;\n        }\n        return this.model.uri;\n    }\n    constructor(label, code, model, beforeCursorState) {\n        this.label = label;\n        this.code = code;\n        this.model = model;\n        this._data = SingleModelEditStackData.create(model, beforeCursorState);\n    }\n    toString() {\n        const data = (this._data instanceof SingleModelEditStackData ? this._data : SingleModelEditStackData.deserialize(this._data));\n        return data.changes.map(change => change.toString()).join(', ');\n    }\n    matchesResource(resource) {\n        const uri = (URI.isUri(this.model) ? this.model : this.model.uri);\n        return (uri.toString() === resource.toString());\n    }\n    setModel(model) {\n        this.model = model;\n    }\n    canAppend(model) {\n        return (this.model === model && this._data instanceof SingleModelEditStackData);\n    }\n    append(model, textChanges, afterEOL, afterVersionId, afterCursorState) {\n        if (this._data instanceof SingleModelEditStackData) {\n            this._data.append(model, textChanges, afterEOL, afterVersionId, afterCursorState);\n        }\n    }\n    close() {\n        if (this._data instanceof SingleModelEditStackData) {\n            this._data = this._data.serialize();\n        }\n    }\n    open() {\n        if (!(this._data instanceof SingleModelEditStackData)) {\n            this._data = SingleModelEditStackData.deserialize(this._data);\n        }\n    }\n    undo() {\n        if (URI.isUri(this.model)) {\n            // don't have a model\n            throw new Error(`Invalid SingleModelEditStackElement`);\n        }\n        if (this._data instanceof SingleModelEditStackData) {\n            this._data = this._data.serialize();\n        }\n        const data = SingleModelEditStackData.deserialize(this._data);\n        this.model._applyUndo(data.changes, data.beforeEOL, data.beforeVersionId, data.beforeCursorState);\n    }\n    redo() {\n        if (URI.isUri(this.model)) {\n            // don't have a model\n            throw new Error(`Invalid SingleModelEditStackElement`);\n        }\n        if (this._data instanceof SingleModelEditStackData) {\n            this._data = this._data.serialize();\n        }\n        const data = SingleModelEditStackData.deserialize(this._data);\n        this.model._applyRedo(data.changes, data.afterEOL, data.afterVersionId, data.afterCursorState);\n    }\n    heapSize() {\n        if (this._data instanceof SingleModelEditStackData) {\n            this._data = this._data.serialize();\n        }\n        return this._data.byteLength + 168 /*heap overhead*/;\n    }\n}\nclass MultiModelEditStackElement {\n    get resources() {\n        return this._editStackElementsArr.map(editStackElement => editStackElement.resource);\n    }\n    constructor(label, code, editStackElements) {\n        this.label = label;\n        this.code = code;\n        this.type = 1 /* UndoRedoElementType.Workspace */;\n        this._isOpen = true;\n        this._editStackElementsArr = editStackElements.slice(0);\n        this._editStackElementsMap = new Map();\n        for (const editStackElement of this._editStackElementsArr) {\n            const key = uriGetComparisonKey(editStackElement.resource);\n            this._editStackElementsMap.set(key, editStackElement);\n        }\n        this._delegate = null;\n    }\n    prepareUndoRedo() {\n        if (this._delegate) {\n            return this._delegate.prepareUndoRedo(this);\n        }\n    }\n    matchesResource(resource) {\n        const key = uriGetComparisonKey(resource);\n        return (this._editStackElementsMap.has(key));\n    }\n    setModel(model) {\n        const key = uriGetComparisonKey(URI.isUri(model) ? model : model.uri);\n        if (this._editStackElementsMap.has(key)) {\n            this._editStackElementsMap.get(key).setModel(model);\n        }\n    }\n    canAppend(model) {\n        if (!this._isOpen) {\n            return false;\n        }\n        const key = uriGetComparisonKey(model.uri);\n        if (this._editStackElementsMap.has(key)) {\n            const editStackElement = this._editStackElementsMap.get(key);\n            return editStackElement.canAppend(model);\n        }\n        return false;\n    }\n    append(model, textChanges, afterEOL, afterVersionId, afterCursorState) {\n        const key = uriGetComparisonKey(model.uri);\n        const editStackElement = this._editStackElementsMap.get(key);\n        editStackElement.append(model, textChanges, afterEOL, afterVersionId, afterCursorState);\n    }\n    close() {\n        this._isOpen = false;\n    }\n    open() {\n        // cannot reopen\n    }\n    undo() {\n        this._isOpen = false;\n        for (const editStackElement of this._editStackElementsArr) {\n            editStackElement.undo();\n        }\n    }\n    redo() {\n        for (const editStackElement of this._editStackElementsArr) {\n            editStackElement.redo();\n        }\n    }\n    heapSize(resource) {\n        const key = uriGetComparisonKey(resource);\n        if (this._editStackElementsMap.has(key)) {\n            const editStackElement = this._editStackElementsMap.get(key);\n            return editStackElement.heapSize();\n        }\n        return 0;\n    }\n    split() {\n        return this._editStackElementsArr;\n    }\n    toString() {\n        const result = [];\n        for (const editStackElement of this._editStackElementsArr) {\n            result.push(`${basename(editStackElement.resource)}: ${editStackElement}`);\n        }\n        return `{${result.join(', ')}}`;\n    }\n}\nfunction getModelEOL(model) {\n    const eol = model.getEOL();\n    if (eol === '\\n') {\n        return 0 /* EndOfLineSequence.LF */;\n    }\n    else {\n        return 1 /* EndOfLineSequence.CRLF */;\n    }\n}\nfunction isEditStackElement(element) {\n    if (!element) {\n        return false;\n    }\n    return ((element instanceof SingleModelEditStackElement) || (element instanceof MultiModelEditStackElement));\n}\nclass EditStack {\n    constructor(model, undoRedoService) {\n        this._model = model;\n        this._undoRedoService = undoRedoService;\n    }\n    pushStackElement() {\n        const lastElement = this._undoRedoService.getLastElement(this._model.uri);\n        if (isEditStackElement(lastElement)) {\n            lastElement.close();\n        }\n    }\n    popStackElement() {\n        const lastElement = this._undoRedoService.getLastElement(this._model.uri);\n        if (isEditStackElement(lastElement)) {\n            lastElement.open();\n        }\n    }\n    clear() {\n        this._undoRedoService.removeElements(this._model.uri);\n    }\n    _getOrCreateEditStackElement(beforeCursorState, group) {\n        const lastElement = this._undoRedoService.getLastElement(this._model.uri);\n        if (isEditStackElement(lastElement) && lastElement.canAppend(this._model)) {\n            return lastElement;\n        }\n        const newElement = new SingleModelEditStackElement(localize(785, \"Typing\"), 'undoredo.textBufferEdit', this._model, beforeCursorState);\n        this._undoRedoService.pushElement(newElement, group);\n        return newElement;\n    }\n    pushEOL(eol) {\n        const editStackElement = this._getOrCreateEditStackElement(null, undefined);\n        this._model.setEOL(eol);\n        editStackElement.append(this._model, [], getModelEOL(this._model), this._model.getAlternativeVersionId(), null);\n    }\n    pushEditOperation(beforeCursorState, editOperations, cursorStateComputer, group, reason = EditSources.unknown({ name: 'pushEditOperation' })) {\n        const editStackElement = this._getOrCreateEditStackElement(beforeCursorState, group);\n        const inverseEditOperations = this._model.applyEdits(editOperations, true, reason);\n        const afterCursorState = EditStack._computeCursorState(cursorStateComputer, inverseEditOperations);\n        const textChanges = inverseEditOperations.map((op, index) => ({ index: index, textChange: op.textChange }));\n        textChanges.sort((a, b) => {\n            if (a.textChange.oldPosition === b.textChange.oldPosition) {\n                return a.index - b.index;\n            }\n            return a.textChange.oldPosition - b.textChange.oldPosition;\n        });\n        editStackElement.append(this._model, textChanges.map(op => op.textChange), getModelEOL(this._model), this._model.getAlternativeVersionId(), afterCursorState);\n        return afterCursorState;\n    }\n    static _computeCursorState(cursorStateComputer, inverseEditOperations) {\n        try {\n            return cursorStateComputer ? cursorStateComputer(inverseEditOperations) : null;\n        }\n        catch (e) {\n            onUnexpectedError(e);\n            return null;\n        }\n    }\n}\n\nexport { EditStack, MultiModelEditStackElement, SingleModelEditStackData, SingleModelEditStackElement, isEditStackElement };\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 4727, "column": 0}, "map": {"version":3,"sources":["file:///D:/real-time-code-editor%20%282%29/node_modules/.pnpm/monaco-editor%400.55.1/node_modules/monaco-editor/esm/vs/editor/common/model/indentationGuesser.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nclass SpacesDiffResult {\n    constructor() {\n        this.spacesDiff = 0;\n        this.looksLikeAlignment = false;\n    }\n}\n/**\n * Compute the diff in spaces between two line's indentation.\n */\nfunction spacesDiff(a, aLength, b, bLength, result) {\n    result.spacesDiff = 0;\n    result.looksLikeAlignment = false;\n    // This can go both ways (e.g.):\n    //  - a: \"\\t\"\n    //  - b: \"\\t    \"\n    //  => This should count 1 tab and 4 spaces\n    let i;\n    for (i = 0; i < aLength && i < bLength; i++) {\n        const aCharCode = a.charCodeAt(i);\n        const bCharCode = b.charCodeAt(i);\n        if (aCharCode !== bCharCode) {\n            break;\n        }\n    }\n    let aSpacesCnt = 0, aTabsCount = 0;\n    for (let j = i; j < aLength; j++) {\n        const aCharCode = a.charCodeAt(j);\n        if (aCharCode === 32 /* CharCode.Space */) {\n            aSpacesCnt++;\n        }\n        else {\n            aTabsCount++;\n        }\n    }\n    let bSpacesCnt = 0, bTabsCount = 0;\n    for (let j = i; j < bLength; j++) {\n        const bCharCode = b.charCodeAt(j);\n        if (bCharCode === 32 /* CharCode.Space */) {\n            bSpacesCnt++;\n        }\n        else {\n            bTabsCount++;\n        }\n    }\n    if (aSpacesCnt > 0 && aTabsCount > 0) {\n        return;\n    }\n    if (bSpacesCnt > 0 && bTabsCount > 0) {\n        return;\n    }\n    const tabsDiff = Math.abs(aTabsCount - bTabsCount);\n    const spacesDiff = Math.abs(aSpacesCnt - bSpacesCnt);\n    if (tabsDiff === 0) {\n        // check if the indentation difference might be caused by alignment reasons\n        // sometime folks like to align their code, but this should not be used as a hint\n        result.spacesDiff = spacesDiff;\n        if (spacesDiff > 0 && 0 <= bSpacesCnt - 1 && bSpacesCnt - 1 < a.length && bSpacesCnt < b.length) {\n            if (b.charCodeAt(bSpacesCnt) !== 32 /* CharCode.Space */ && a.charCodeAt(bSpacesCnt - 1) === 32 /* CharCode.Space */) {\n                if (a.charCodeAt(a.length - 1) === 44 /* CharCode.Comma */) {\n                    // This looks like an alignment desire: e.g.\n                    // const a = b + c,\n                    //       d = b - c;\n                    result.looksLikeAlignment = true;\n                }\n            }\n        }\n        return;\n    }\n    if (spacesDiff % tabsDiff === 0) {\n        result.spacesDiff = spacesDiff / tabsDiff;\n        return;\n    }\n}\nfunction guessIndentation(source, defaultTabSize, defaultInsertSpaces) {\n    // Look at most at the first 10k lines\n    const linesCount = Math.min(source.getLineCount(), 10000);\n    let linesIndentedWithTabsCount = 0; // number of lines that contain at least one tab in indentation\n    let linesIndentedWithSpacesCount = 0; // number of lines that contain only spaces in indentation\n    let previousLineText = ''; // content of latest line that contained non-whitespace chars\n    let previousLineIndentation = 0; // index at which latest line contained the first non-whitespace char\n    const ALLOWED_TAB_SIZE_GUESSES = [2, 4, 6, 8, 3, 5, 7]; // prefer even guesses for `tabSize`, limit to [2, 8].\n    const MAX_ALLOWED_TAB_SIZE_GUESS = 8; // max(ALLOWED_TAB_SIZE_GUESSES) = 8\n    const spacesDiffCount = [0, 0, 0, 0, 0, 0, 0, 0, 0]; // `tabSize` scores\n    const tmp = new SpacesDiffResult();\n    for (let lineNumber = 1; lineNumber <= linesCount; lineNumber++) {\n        const currentLineLength = source.getLineLength(lineNumber);\n        const currentLineText = source.getLineContent(lineNumber);\n        // if the text buffer is chunk based, so long lines are cons-string, v8 will flattern the string when we check charCode.\n        // checking charCode on chunks directly is cheaper.\n        const useCurrentLineText = (currentLineLength <= 65536);\n        let currentLineHasContent = false; // does `currentLineText` contain non-whitespace chars\n        let currentLineIndentation = 0; // index at which `currentLineText` contains the first non-whitespace char\n        let currentLineSpacesCount = 0; // count of spaces found in `currentLineText` indentation\n        let currentLineTabsCount = 0; // count of tabs found in `currentLineText` indentation\n        for (let j = 0, lenJ = currentLineLength; j < lenJ; j++) {\n            const charCode = (useCurrentLineText ? currentLineText.charCodeAt(j) : source.getLineCharCode(lineNumber, j));\n            if (charCode === 9 /* CharCode.Tab */) {\n                currentLineTabsCount++;\n            }\n            else if (charCode === 32 /* CharCode.Space */) {\n                currentLineSpacesCount++;\n            }\n            else {\n                // Hit non whitespace character on this line\n                currentLineHasContent = true;\n                currentLineIndentation = j;\n                break;\n            }\n        }\n        // Ignore empty or only whitespace lines\n        if (!currentLineHasContent) {\n            continue;\n        }\n        if (currentLineTabsCount > 0) {\n            linesIndentedWithTabsCount++;\n        }\n        else if (currentLineSpacesCount > 1) {\n            linesIndentedWithSpacesCount++;\n        }\n        spacesDiff(previousLineText, previousLineIndentation, currentLineText, currentLineIndentation, tmp);\n        if (tmp.looksLikeAlignment) {\n            // if defaultInsertSpaces === true && the spaces count == tabSize, we may want to count it as valid indentation\n            //\n            // - item1\n            //   - item2\n            //\n            // otherwise skip this line entirely\n            //\n            // const a = 1,\n            //       b = 2;\n            if (!(defaultInsertSpaces && defaultTabSize === tmp.spacesDiff)) {\n                continue;\n            }\n        }\n        const currentSpacesDiff = tmp.spacesDiff;\n        if (currentSpacesDiff <= MAX_ALLOWED_TAB_SIZE_GUESS) {\n            spacesDiffCount[currentSpacesDiff]++;\n        }\n        previousLineText = currentLineText;\n        previousLineIndentation = currentLineIndentation;\n    }\n    let insertSpaces = defaultInsertSpaces;\n    if (linesIndentedWithTabsCount !== linesIndentedWithSpacesCount) {\n        insertSpaces = (linesIndentedWithTabsCount < linesIndentedWithSpacesCount);\n    }\n    let tabSize = defaultTabSize;\n    // Guess tabSize only if inserting spaces...\n    if (insertSpaces) {\n        let tabSizeScore = (insertSpaces ? 0 : 0.1 * linesCount);\n        // console.log(\"score threshold: \" + tabSizeScore);\n        ALLOWED_TAB_SIZE_GUESSES.forEach((possibleTabSize) => {\n            const possibleTabSizeScore = spacesDiffCount[possibleTabSize];\n            if (possibleTabSizeScore > tabSizeScore) {\n                tabSizeScore = possibleTabSizeScore;\n                tabSize = possibleTabSize;\n            }\n        });\n        // Let a tabSize of 2 win even if it is not the maximum\n        // (only in case 4 was guessed)\n        if (tabSize === 4 && spacesDiffCount[4] > 0 && spacesDiffCount[2] > 0 && spacesDiffCount[2] >= spacesDiffCount[4] / 2) {\n            tabSize = 2;\n        }\n    }\n    // console.log('--------------------------');\n    // console.log('linesIndentedWithTabsCount: ' + linesIndentedWithTabsCount + ', linesIndentedWithSpacesCount: ' + linesIndentedWithSpacesCount);\n    // console.log('spacesDiffCount: ' + spacesDiffCount);\n    // console.log('tabSize: ' + tabSize + ', tabSizeScore: ' + tabSizeScore);\n    return {\n        insertSpaces: insertSpaces,\n        tabSize: tabSize\n    };\n}\n\nexport { guessIndentation };\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 4923, "column": 0}, "map": {"version":3,"sources":["file:///D:/real-time-code-editor%20%282%29/node_modules/.pnpm/monaco-editor%400.55.1/node_modules/monaco-editor/esm/vs/editor/common/model/intervalTree.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nfunction getNodeColor(node) {\n    return ((node.metadata & 1 /* Constants.ColorMask */) >>> 0 /* Constants.ColorOffset */);\n}\nfunction setNodeColor(node, color) {\n    node.metadata = ((node.metadata & 254 /* Constants.ColorMaskInverse */) | (color << 0 /* Constants.ColorOffset */));\n}\nfunction getNodeIsVisited(node) {\n    return ((node.metadata & 2 /* Constants.IsVisitedMask */) >>> 1 /* Constants.IsVisitedOffset */) === 1;\n}\nfunction setNodeIsVisited(node, value) {\n    node.metadata = ((node.metadata & 253 /* Constants.IsVisitedMaskInverse */) | ((value ? 1 : 0) << 1 /* Constants.IsVisitedOffset */));\n}\nfunction getNodeIsForValidation(node) {\n    return ((node.metadata & 4 /* Constants.IsForValidationMask */) >>> 2 /* Constants.IsForValidationOffset */) === 1;\n}\nfunction setNodeIsForValidation(node, value) {\n    node.metadata = ((node.metadata & 251 /* Constants.IsForValidationMaskInverse */) | ((value ? 1 : 0) << 2 /* Constants.IsForValidationOffset */));\n}\nfunction getNodeIsInGlyphMargin(node) {\n    return ((node.metadata & 64 /* Constants.IsMarginMask */) >>> 6 /* Constants.IsMarginOffset */) === 1;\n}\nfunction setNodeIsInGlyphMargin(node, value) {\n    node.metadata = ((node.metadata & 191 /* Constants.IsMarginMaskInverse */) | ((value ? 1 : 0) << 6 /* Constants.IsMarginOffset */));\n}\nfunction getNodeAffectsFont(node) {\n    return ((node.metadata & 128 /* Constants.AffectsFontMask */) >>> 7 /* Constants.AffectsFontOffset */) === 1;\n}\nfunction setNodeAffectsFont(node, value) {\n    node.metadata = ((node.metadata & 127 /* Constants.AffectsFontMaskInverse */) | ((value ? 1 : 0) << 7 /* Constants.AffectsFontOffset */));\n}\nfunction getNodeStickiness(node) {\n    return ((node.metadata & 24 /* Constants.StickinessMask */) >>> 3 /* Constants.StickinessOffset */);\n}\nfunction _setNodeStickiness(node, stickiness) {\n    node.metadata = ((node.metadata & 231 /* Constants.StickinessMaskInverse */) | (stickiness << 3 /* Constants.StickinessOffset */));\n}\nfunction getCollapseOnReplaceEdit(node) {\n    return ((node.metadata & 32 /* Constants.CollapseOnReplaceEditMask */) >>> 5 /* Constants.CollapseOnReplaceEditOffset */) === 1;\n}\nfunction setCollapseOnReplaceEdit(node, value) {\n    node.metadata = ((node.metadata & 223 /* Constants.CollapseOnReplaceEditMaskInverse */) | ((value ? 1 : 0) << 5 /* Constants.CollapseOnReplaceEditOffset */));\n}\nclass IntervalNode {\n    constructor(id, start, end) {\n        this.metadata = 0;\n        this.parent = this;\n        this.left = this;\n        this.right = this;\n        setNodeColor(this, 1 /* NodeColor.Red */);\n        this.start = start;\n        this.end = end;\n        // FORCE_OVERFLOWING_TEST: this.delta = start;\n        this.delta = 0;\n        this.maxEnd = end;\n        this.id = id;\n        this.ownerId = 0;\n        this.options = null;\n        setNodeIsForValidation(this, false);\n        setNodeIsInGlyphMargin(this, false);\n        _setNodeStickiness(this, 1 /* TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */);\n        setCollapseOnReplaceEdit(this, false);\n        setNodeAffectsFont(this, false);\n        this.cachedVersionId = 0;\n        this.cachedAbsoluteStart = start;\n        this.cachedAbsoluteEnd = end;\n        this.range = null;\n        setNodeIsVisited(this, false);\n    }\n    reset(versionId, start, end, range) {\n        this.start = start;\n        this.end = end;\n        this.maxEnd = end;\n        this.cachedVersionId = versionId;\n        this.cachedAbsoluteStart = start;\n        this.cachedAbsoluteEnd = end;\n        this.range = range;\n    }\n    setOptions(options) {\n        this.options = options;\n        const className = this.options.className;\n        setNodeIsForValidation(this, (className === \"squiggly-error\" /* ClassName.EditorErrorDecoration */\n            || className === \"squiggly-warning\" /* ClassName.EditorWarningDecoration */\n            || className === \"squiggly-info\" /* ClassName.EditorInfoDecoration */));\n        setNodeIsInGlyphMargin(this, this.options.glyphMarginClassName !== null);\n        _setNodeStickiness(this, this.options.stickiness);\n        setCollapseOnReplaceEdit(this, this.options.collapseOnReplaceEdit);\n        setNodeAffectsFont(this, this.options.affectsFont ?? false);\n    }\n    setCachedOffsets(absoluteStart, absoluteEnd, cachedVersionId) {\n        if (this.cachedVersionId !== cachedVersionId) {\n            this.range = null;\n        }\n        this.cachedVersionId = cachedVersionId;\n        this.cachedAbsoluteStart = absoluteStart;\n        this.cachedAbsoluteEnd = absoluteEnd;\n    }\n    detach() {\n        this.parent = null;\n        this.left = null;\n        this.right = null;\n    }\n}\nconst SENTINEL = new IntervalNode(null, 0, 0);\nSENTINEL.parent = SENTINEL;\nSENTINEL.left = SENTINEL;\nSENTINEL.right = SENTINEL;\nsetNodeColor(SENTINEL, 0 /* NodeColor.Black */);\nclass IntervalTree {\n    constructor() {\n        this.root = SENTINEL;\n        this.requestNormalizeDelta = false;\n    }\n    intervalSearch(start, end, filterOwnerId, filterOutValidation, filterFontDecorations, cachedVersionId, onlyMarginDecorations) {\n        if (this.root === SENTINEL) {\n            return [];\n        }\n        return intervalSearch(this, start, end, filterOwnerId, filterOutValidation, filterFontDecorations, cachedVersionId, onlyMarginDecorations);\n    }\n    search(filterOwnerId, filterOutValidation, filterFontDecorations, cachedVersionId, onlyMarginDecorations) {\n        if (this.root === SENTINEL) {\n            return [];\n        }\n        return search(this, filterOwnerId, filterOutValidation, filterFontDecorations, cachedVersionId, onlyMarginDecorations);\n    }\n    /**\n     * Will not set `cachedAbsoluteStart` nor `cachedAbsoluteEnd` on the returned nodes!\n     */\n    collectNodesFromOwner(ownerId) {\n        return collectNodesFromOwner(this, ownerId);\n    }\n    /**\n     * Will not set `cachedAbsoluteStart` nor `cachedAbsoluteEnd` on the returned nodes!\n     */\n    collectNodesPostOrder() {\n        return collectNodesPostOrder(this);\n    }\n    insert(node) {\n        rbTreeInsert(this, node);\n        this._normalizeDeltaIfNecessary();\n    }\n    delete(node) {\n        rbTreeDelete(this, node);\n        this._normalizeDeltaIfNecessary();\n    }\n    resolveNode(node, cachedVersionId) {\n        const initialNode = node;\n        let delta = 0;\n        while (node !== this.root) {\n            if (node === node.parent.right) {\n                delta += node.parent.delta;\n            }\n            node = node.parent;\n        }\n        const nodeStart = initialNode.start + delta;\n        const nodeEnd = initialNode.end + delta;\n        initialNode.setCachedOffsets(nodeStart, nodeEnd, cachedVersionId);\n    }\n    acceptReplace(offset, length, textLength, forceMoveMarkers) {\n        // Our strategy is to remove all directly impacted nodes, and then add them back to the tree.\n        // (1) collect all nodes that are intersecting this edit as nodes of interest\n        const nodesOfInterest = searchForEditing(this, offset, offset + length);\n        // (2) remove all nodes that are intersecting this edit\n        for (let i = 0, len = nodesOfInterest.length; i < len; i++) {\n            const node = nodesOfInterest[i];\n            rbTreeDelete(this, node);\n        }\n        this._normalizeDeltaIfNecessary();\n        // (3) edit all tree nodes except the nodes of interest\n        noOverlapReplace(this, offset, offset + length, textLength);\n        this._normalizeDeltaIfNecessary();\n        // (4) edit the nodes of interest and insert them back in the tree\n        for (let i = 0, len = nodesOfInterest.length; i < len; i++) {\n            const node = nodesOfInterest[i];\n            node.start = node.cachedAbsoluteStart;\n            node.end = node.cachedAbsoluteEnd;\n            nodeAcceptEdit(node, offset, (offset + length), textLength, forceMoveMarkers);\n            node.maxEnd = node.end;\n            rbTreeInsert(this, node);\n        }\n        this._normalizeDeltaIfNecessary();\n    }\n    _normalizeDeltaIfNecessary() {\n        if (!this.requestNormalizeDelta) {\n            return;\n        }\n        this.requestNormalizeDelta = false;\n        normalizeDelta(this);\n    }\n}\n//#region Delta Normalization\nfunction normalizeDelta(T) {\n    let node = T.root;\n    let delta = 0;\n    while (node !== SENTINEL) {\n        if (node.left !== SENTINEL && !getNodeIsVisited(node.left)) {\n            // go left\n            node = node.left;\n            continue;\n        }\n        if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n            // go right\n            delta += node.delta;\n            node = node.right;\n            continue;\n        }\n        // handle current node\n        node.start = delta + node.start;\n        node.end = delta + node.end;\n        node.delta = 0;\n        recomputeMaxEnd(node);\n        setNodeIsVisited(node, true);\n        // going up from this node\n        setNodeIsVisited(node.left, false);\n        setNodeIsVisited(node.right, false);\n        if (node === node.parent.right) {\n            delta -= node.parent.delta;\n        }\n        node = node.parent;\n    }\n    setNodeIsVisited(T.root, false);\n}\nfunction adjustMarkerBeforeColumn(markerOffset, markerStickToPreviousCharacter, checkOffset, moveSemantics) {\n    if (markerOffset < checkOffset) {\n        return true;\n    }\n    if (markerOffset > checkOffset) {\n        return false;\n    }\n    if (moveSemantics === 1 /* MarkerMoveSemantics.ForceMove */) {\n        return false;\n    }\n    if (moveSemantics === 2 /* MarkerMoveSemantics.ForceStay */) {\n        return true;\n    }\n    return markerStickToPreviousCharacter;\n}\n/**\n * This is a lot more complicated than strictly necessary to maintain the same behaviour\n * as when decorations were implemented using two markers.\n */\nfunction nodeAcceptEdit(node, start, end, textLength, forceMoveMarkers) {\n    const nodeStickiness = getNodeStickiness(node);\n    const startStickToPreviousCharacter = (nodeStickiness === 0 /* TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges */\n        || nodeStickiness === 2 /* TrackedRangeStickiness.GrowsOnlyWhenTypingBefore */);\n    const endStickToPreviousCharacter = (nodeStickiness === 1 /* TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */\n        || nodeStickiness === 2 /* TrackedRangeStickiness.GrowsOnlyWhenTypingBefore */);\n    const deletingCnt = (end - start);\n    const insertingCnt = textLength;\n    const commonLength = Math.min(deletingCnt, insertingCnt);\n    const nodeStart = node.start;\n    let startDone = false;\n    const nodeEnd = node.end;\n    let endDone = false;\n    if (start <= nodeStart && nodeEnd <= end && getCollapseOnReplaceEdit(node)) {\n        // This edit encompasses the entire decoration range\n        // and the decoration has asked to become collapsed\n        node.start = start;\n        startDone = true;\n        node.end = start;\n        endDone = true;\n    }\n    {\n        const moveSemantics = forceMoveMarkers ? 1 /* MarkerMoveSemantics.ForceMove */ : (deletingCnt > 0 ? 2 /* MarkerMoveSemantics.ForceStay */ : 0 /* MarkerMoveSemantics.MarkerDefined */);\n        if (!startDone && adjustMarkerBeforeColumn(nodeStart, startStickToPreviousCharacter, start, moveSemantics)) {\n            startDone = true;\n        }\n        if (!endDone && adjustMarkerBeforeColumn(nodeEnd, endStickToPreviousCharacter, start, moveSemantics)) {\n            endDone = true;\n        }\n    }\n    if (commonLength > 0 && !forceMoveMarkers) {\n        const moveSemantics = (deletingCnt > insertingCnt ? 2 /* MarkerMoveSemantics.ForceStay */ : 0 /* MarkerMoveSemantics.MarkerDefined */);\n        if (!startDone && adjustMarkerBeforeColumn(nodeStart, startStickToPreviousCharacter, start + commonLength, moveSemantics)) {\n            startDone = true;\n        }\n        if (!endDone && adjustMarkerBeforeColumn(nodeEnd, endStickToPreviousCharacter, start + commonLength, moveSemantics)) {\n            endDone = true;\n        }\n    }\n    {\n        const moveSemantics = forceMoveMarkers ? 1 /* MarkerMoveSemantics.ForceMove */ : 0 /* MarkerMoveSemantics.MarkerDefined */;\n        if (!startDone && adjustMarkerBeforeColumn(nodeStart, startStickToPreviousCharacter, end, moveSemantics)) {\n            node.start = start + insertingCnt;\n            startDone = true;\n        }\n        if (!endDone && adjustMarkerBeforeColumn(nodeEnd, endStickToPreviousCharacter, end, moveSemantics)) {\n            node.end = start + insertingCnt;\n            endDone = true;\n        }\n    }\n    // Finish\n    const deltaColumn = (insertingCnt - deletingCnt);\n    if (!startDone) {\n        node.start = Math.max(0, nodeStart + deltaColumn);\n    }\n    if (!endDone) {\n        node.end = Math.max(0, nodeEnd + deltaColumn);\n    }\n    if (node.start > node.end) {\n        node.end = node.start;\n    }\n}\nfunction searchForEditing(T, start, end) {\n    // https://en.wikipedia.org/wiki/Interval_tree#Augmented_tree\n    // Now, it is known that two intervals A and B overlap only when both\n    // A.low <= B.high and A.high >= B.low. When searching the trees for\n    // nodes overlapping with a given interval, you can immediately skip:\n    //  a) all nodes to the right of nodes whose low value is past the end of the given interval.\n    //  b) all nodes that have their maximum 'high' value below the start of the given interval.\n    let node = T.root;\n    let delta = 0;\n    let nodeMaxEnd = 0;\n    let nodeStart = 0;\n    let nodeEnd = 0;\n    const result = [];\n    let resultLen = 0;\n    while (node !== SENTINEL) {\n        if (getNodeIsVisited(node)) {\n            // going up from this node\n            setNodeIsVisited(node.left, false);\n            setNodeIsVisited(node.right, false);\n            if (node === node.parent.right) {\n                delta -= node.parent.delta;\n            }\n            node = node.parent;\n            continue;\n        }\n        if (!getNodeIsVisited(node.left)) {\n            // first time seeing this node\n            nodeMaxEnd = delta + node.maxEnd;\n            if (nodeMaxEnd < start) {\n                // cover case b) from above\n                // there is no need to search this node or its children\n                setNodeIsVisited(node, true);\n                continue;\n            }\n            if (node.left !== SENTINEL) {\n                // go left\n                node = node.left;\n                continue;\n            }\n        }\n        // handle current node\n        nodeStart = delta + node.start;\n        if (nodeStart > end) {\n            // cover case a) from above\n            // there is no need to search this node or its right subtree\n            setNodeIsVisited(node, true);\n            continue;\n        }\n        nodeEnd = delta + node.end;\n        if (nodeEnd >= start) {\n            node.setCachedOffsets(nodeStart, nodeEnd, 0);\n            result[resultLen++] = node;\n        }\n        setNodeIsVisited(node, true);\n        if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n            // go right\n            delta += node.delta;\n            node = node.right;\n            continue;\n        }\n    }\n    setNodeIsVisited(T.root, false);\n    return result;\n}\nfunction noOverlapReplace(T, start, end, textLength) {\n    // https://en.wikipedia.org/wiki/Interval_tree#Augmented_tree\n    // Now, it is known that two intervals A and B overlap only when both\n    // A.low <= B.high and A.high >= B.low. When searching the trees for\n    // nodes overlapping with a given interval, you can immediately skip:\n    //  a) all nodes to the right of nodes whose low value is past the end of the given interval.\n    //  b) all nodes that have their maximum 'high' value below the start of the given interval.\n    let node = T.root;\n    let delta = 0;\n    let nodeMaxEnd = 0;\n    let nodeStart = 0;\n    const editDelta = (textLength - (end - start));\n    while (node !== SENTINEL) {\n        if (getNodeIsVisited(node)) {\n            // going up from this node\n            setNodeIsVisited(node.left, false);\n            setNodeIsVisited(node.right, false);\n            if (node === node.parent.right) {\n                delta -= node.parent.delta;\n            }\n            recomputeMaxEnd(node);\n            node = node.parent;\n            continue;\n        }\n        if (!getNodeIsVisited(node.left)) {\n            // first time seeing this node\n            nodeMaxEnd = delta + node.maxEnd;\n            if (nodeMaxEnd < start) {\n                // cover case b) from above\n                // there is no need to search this node or its children\n                setNodeIsVisited(node, true);\n                continue;\n            }\n            if (node.left !== SENTINEL) {\n                // go left\n                node = node.left;\n                continue;\n            }\n        }\n        // handle current node\n        nodeStart = delta + node.start;\n        if (nodeStart > end) {\n            node.start += editDelta;\n            node.end += editDelta;\n            node.delta += editDelta;\n            if (node.delta < -1073741824 /* Constants.MIN_SAFE_DELTA */ || node.delta > 1073741824 /* Constants.MAX_SAFE_DELTA */) {\n                T.requestNormalizeDelta = true;\n            }\n            // cover case a) from above\n            // there is no need to search this node or its right subtree\n            setNodeIsVisited(node, true);\n            continue;\n        }\n        setNodeIsVisited(node, true);\n        if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n            // go right\n            delta += node.delta;\n            node = node.right;\n            continue;\n        }\n    }\n    setNodeIsVisited(T.root, false);\n}\n//#endregion\n//#region Searching\nfunction collectNodesFromOwner(T, ownerId) {\n    let node = T.root;\n    const result = [];\n    let resultLen = 0;\n    while (node !== SENTINEL) {\n        if (getNodeIsVisited(node)) {\n            // going up from this node\n            setNodeIsVisited(node.left, false);\n            setNodeIsVisited(node.right, false);\n            node = node.parent;\n            continue;\n        }\n        if (node.left !== SENTINEL && !getNodeIsVisited(node.left)) {\n            // go left\n            node = node.left;\n            continue;\n        }\n        // handle current node\n        if (node.ownerId === ownerId) {\n            result[resultLen++] = node;\n        }\n        setNodeIsVisited(node, true);\n        if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n            // go right\n            node = node.right;\n            continue;\n        }\n    }\n    setNodeIsVisited(T.root, false);\n    return result;\n}\nfunction collectNodesPostOrder(T) {\n    let node = T.root;\n    const result = [];\n    let resultLen = 0;\n    while (node !== SENTINEL) {\n        if (getNodeIsVisited(node)) {\n            // going up from this node\n            setNodeIsVisited(node.left, false);\n            setNodeIsVisited(node.right, false);\n            node = node.parent;\n            continue;\n        }\n        if (node.left !== SENTINEL && !getNodeIsVisited(node.left)) {\n            // go left\n            node = node.left;\n            continue;\n        }\n        if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n            // go right\n            node = node.right;\n            continue;\n        }\n        // handle current node\n        result[resultLen++] = node;\n        setNodeIsVisited(node, true);\n    }\n    setNodeIsVisited(T.root, false);\n    return result;\n}\nfunction search(T, filterOwnerId, filterOutValidation, filterFontDecorations, cachedVersionId, onlyMarginDecorations) {\n    let node = T.root;\n    let delta = 0;\n    let nodeStart = 0;\n    let nodeEnd = 0;\n    const result = [];\n    let resultLen = 0;\n    while (node !== SENTINEL) {\n        if (getNodeIsVisited(node)) {\n            // going up from this node\n            setNodeIsVisited(node.left, false);\n            setNodeIsVisited(node.right, false);\n            if (node === node.parent.right) {\n                delta -= node.parent.delta;\n            }\n            node = node.parent;\n            continue;\n        }\n        if (node.left !== SENTINEL && !getNodeIsVisited(node.left)) {\n            // go left\n            node = node.left;\n            continue;\n        }\n        // handle current node\n        nodeStart = delta + node.start;\n        nodeEnd = delta + node.end;\n        node.setCachedOffsets(nodeStart, nodeEnd, cachedVersionId);\n        let include = true;\n        if (filterOwnerId && node.ownerId && node.ownerId !== filterOwnerId) {\n            include = false;\n        }\n        if (filterOutValidation && getNodeIsForValidation(node)) {\n            include = false;\n        }\n        if (filterFontDecorations && getNodeAffectsFont(node)) {\n            include = false;\n        }\n        if (onlyMarginDecorations && !getNodeIsInGlyphMargin(node)) {\n            include = false;\n        }\n        if (include) {\n            result[resultLen++] = node;\n        }\n        setNodeIsVisited(node, true);\n        if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n            // go right\n            delta += node.delta;\n            node = node.right;\n            continue;\n        }\n    }\n    setNodeIsVisited(T.root, false);\n    return result;\n}\nfunction intervalSearch(T, intervalStart, intervalEnd, filterOwnerId, filterOutValidation, filterFontDecorations, cachedVersionId, onlyMarginDecorations) {\n    // https://en.wikipedia.org/wiki/Interval_tree#Augmented_tree\n    // Now, it is known that two intervals A and B overlap only when both\n    // A.low <= B.high and A.high >= B.low. When searching the trees for\n    // nodes overlapping with a given interval, you can immediately skip:\n    //  a) all nodes to the right of nodes whose low value is past the end of the given interval.\n    //  b) all nodes that have their maximum 'high' value below the start of the given interval.\n    let node = T.root;\n    let delta = 0;\n    let nodeMaxEnd = 0;\n    let nodeStart = 0;\n    let nodeEnd = 0;\n    const result = [];\n    let resultLen = 0;\n    while (node !== SENTINEL) {\n        if (getNodeIsVisited(node)) {\n            // going up from this node\n            setNodeIsVisited(node.left, false);\n            setNodeIsVisited(node.right, false);\n            if (node === node.parent.right) {\n                delta -= node.parent.delta;\n            }\n            node = node.parent;\n            continue;\n        }\n        if (!getNodeIsVisited(node.left)) {\n            // first time seeing this node\n            nodeMaxEnd = delta + node.maxEnd;\n            if (nodeMaxEnd < intervalStart) {\n                // cover case b) from above\n                // there is no need to search this node or its children\n                setNodeIsVisited(node, true);\n                continue;\n            }\n            if (node.left !== SENTINEL) {\n                // go left\n                node = node.left;\n                continue;\n            }\n        }\n        // handle current node\n        nodeStart = delta + node.start;\n        if (nodeStart > intervalEnd) {\n            // cover case a) from above\n            // there is no need to search this node or its right subtree\n            setNodeIsVisited(node, true);\n            continue;\n        }\n        nodeEnd = delta + node.end;\n        if (nodeEnd >= intervalStart) {\n            // There is overlap\n            node.setCachedOffsets(nodeStart, nodeEnd, cachedVersionId);\n            let include = true;\n            if (filterOwnerId && node.ownerId && node.ownerId !== filterOwnerId) {\n                include = false;\n            }\n            if (filterOutValidation && getNodeIsForValidation(node)) {\n                include = false;\n            }\n            if (filterFontDecorations && getNodeAffectsFont(node)) {\n                include = false;\n            }\n            if (onlyMarginDecorations && !getNodeIsInGlyphMargin(node)) {\n                include = false;\n            }\n            if (include) {\n                result[resultLen++] = node;\n            }\n        }\n        setNodeIsVisited(node, true);\n        if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n            // go right\n            delta += node.delta;\n            node = node.right;\n            continue;\n        }\n    }\n    setNodeIsVisited(T.root, false);\n    return result;\n}\n//#endregion\n//#region Insertion\nfunction rbTreeInsert(T, newNode) {\n    if (T.root === SENTINEL) {\n        newNode.parent = SENTINEL;\n        newNode.left = SENTINEL;\n        newNode.right = SENTINEL;\n        setNodeColor(newNode, 0 /* NodeColor.Black */);\n        T.root = newNode;\n        return T.root;\n    }\n    treeInsert(T, newNode);\n    recomputeMaxEndWalkToRoot(newNode.parent);\n    // repair tree\n    let x = newNode;\n    while (x !== T.root && getNodeColor(x.parent) === 1 /* NodeColor.Red */) {\n        if (x.parent === x.parent.parent.left) {\n            const y = x.parent.parent.right;\n            if (getNodeColor(y) === 1 /* NodeColor.Red */) {\n                setNodeColor(x.parent, 0 /* NodeColor.Black */);\n                setNodeColor(y, 0 /* NodeColor.Black */);\n                setNodeColor(x.parent.parent, 1 /* NodeColor.Red */);\n                x = x.parent.parent;\n            }\n            else {\n                if (x === x.parent.right) {\n                    x = x.parent;\n                    leftRotate(T, x);\n                }\n                setNodeColor(x.parent, 0 /* NodeColor.Black */);\n                setNodeColor(x.parent.parent, 1 /* NodeColor.Red */);\n                rightRotate(T, x.parent.parent);\n            }\n        }\n        else {\n            const y = x.parent.parent.left;\n            if (getNodeColor(y) === 1 /* NodeColor.Red */) {\n                setNodeColor(x.parent, 0 /* NodeColor.Black */);\n                setNodeColor(y, 0 /* NodeColor.Black */);\n                setNodeColor(x.parent.parent, 1 /* NodeColor.Red */);\n                x = x.parent.parent;\n            }\n            else {\n                if (x === x.parent.left) {\n                    x = x.parent;\n                    rightRotate(T, x);\n                }\n                setNodeColor(x.parent, 0 /* NodeColor.Black */);\n                setNodeColor(x.parent.parent, 1 /* NodeColor.Red */);\n                leftRotate(T, x.parent.parent);\n            }\n        }\n    }\n    setNodeColor(T.root, 0 /* NodeColor.Black */);\n    return newNode;\n}\nfunction treeInsert(T, z) {\n    let delta = 0;\n    let x = T.root;\n    const zAbsoluteStart = z.start;\n    const zAbsoluteEnd = z.end;\n    while (true) {\n        const cmp = intervalCompare(zAbsoluteStart, zAbsoluteEnd, x.start + delta, x.end + delta);\n        if (cmp < 0) {\n            // this node should be inserted to the left\n            // => it is not affected by the node's delta\n            if (x.left === SENTINEL) {\n                z.start -= delta;\n                z.end -= delta;\n                z.maxEnd -= delta;\n                x.left = z;\n                break;\n            }\n            else {\n                x = x.left;\n            }\n        }\n        else {\n            // this node should be inserted to the right\n            // => it is not affected by the node's delta\n            if (x.right === SENTINEL) {\n                z.start -= (delta + x.delta);\n                z.end -= (delta + x.delta);\n                z.maxEnd -= (delta + x.delta);\n                x.right = z;\n                break;\n            }\n            else {\n                delta += x.delta;\n                x = x.right;\n            }\n        }\n    }\n    z.parent = x;\n    z.left = SENTINEL;\n    z.right = SENTINEL;\n    setNodeColor(z, 1 /* NodeColor.Red */);\n}\n//#endregion\n//#region Deletion\nfunction rbTreeDelete(T, z) {\n    let x;\n    let y;\n    // RB-DELETE except we don't swap z and y in case c)\n    // i.e. we always delete what's pointed at by z.\n    if (z.left === SENTINEL) {\n        x = z.right;\n        y = z;\n        // x's delta is no longer influenced by z's delta\n        x.delta += z.delta;\n        if (x.delta < -1073741824 /* Constants.MIN_SAFE_DELTA */ || x.delta > 1073741824 /* Constants.MAX_SAFE_DELTA */) {\n            T.requestNormalizeDelta = true;\n        }\n        x.start += z.delta;\n        x.end += z.delta;\n    }\n    else if (z.right === SENTINEL) {\n        x = z.left;\n        y = z;\n    }\n    else {\n        y = leftest(z.right);\n        x = y.right;\n        // y's delta is no longer influenced by z's delta,\n        // but we don't want to walk the entire right-hand-side subtree of x.\n        // we therefore maintain z's delta in y, and adjust only x\n        x.start += y.delta;\n        x.end += y.delta;\n        x.delta += y.delta;\n        if (x.delta < -1073741824 /* Constants.MIN_SAFE_DELTA */ || x.delta > 1073741824 /* Constants.MAX_SAFE_DELTA */) {\n            T.requestNormalizeDelta = true;\n        }\n        y.start += z.delta;\n        y.end += z.delta;\n        y.delta = z.delta;\n        if (y.delta < -1073741824 /* Constants.MIN_SAFE_DELTA */ || y.delta > 1073741824 /* Constants.MAX_SAFE_DELTA */) {\n            T.requestNormalizeDelta = true;\n        }\n    }\n    if (y === T.root) {\n        T.root = x;\n        setNodeColor(x, 0 /* NodeColor.Black */);\n        z.detach();\n        resetSentinel();\n        recomputeMaxEnd(x);\n        T.root.parent = SENTINEL;\n        return;\n    }\n    const yWasRed = (getNodeColor(y) === 1 /* NodeColor.Red */);\n    if (y === y.parent.left) {\n        y.parent.left = x;\n    }\n    else {\n        y.parent.right = x;\n    }\n    if (y === z) {\n        x.parent = y.parent;\n    }\n    else {\n        if (y.parent === z) {\n            x.parent = y;\n        }\n        else {\n            x.parent = y.parent;\n        }\n        y.left = z.left;\n        y.right = z.right;\n        y.parent = z.parent;\n        setNodeColor(y, getNodeColor(z));\n        if (z === T.root) {\n            T.root = y;\n        }\n        else {\n            if (z === z.parent.left) {\n                z.parent.left = y;\n            }\n            else {\n                z.parent.right = y;\n            }\n        }\n        if (y.left !== SENTINEL) {\n            y.left.parent = y;\n        }\n        if (y.right !== SENTINEL) {\n            y.right.parent = y;\n        }\n    }\n    z.detach();\n    if (yWasRed) {\n        recomputeMaxEndWalkToRoot(x.parent);\n        if (y !== z) {\n            recomputeMaxEndWalkToRoot(y);\n            recomputeMaxEndWalkToRoot(y.parent);\n        }\n        resetSentinel();\n        return;\n    }\n    recomputeMaxEndWalkToRoot(x);\n    recomputeMaxEndWalkToRoot(x.parent);\n    if (y !== z) {\n        recomputeMaxEndWalkToRoot(y);\n        recomputeMaxEndWalkToRoot(y.parent);\n    }\n    // RB-DELETE-FIXUP\n    let w;\n    while (x !== T.root && getNodeColor(x) === 0 /* NodeColor.Black */) {\n        if (x === x.parent.left) {\n            w = x.parent.right;\n            if (getNodeColor(w) === 1 /* NodeColor.Red */) {\n                setNodeColor(w, 0 /* NodeColor.Black */);\n                setNodeColor(x.parent, 1 /* NodeColor.Red */);\n                leftRotate(T, x.parent);\n                w = x.parent.right;\n            }\n            if (getNodeColor(w.left) === 0 /* NodeColor.Black */ && getNodeColor(w.right) === 0 /* NodeColor.Black */) {\n                setNodeColor(w, 1 /* NodeColor.Red */);\n                x = x.parent;\n            }\n            else {\n                if (getNodeColor(w.right) === 0 /* NodeColor.Black */) {\n                    setNodeColor(w.left, 0 /* NodeColor.Black */);\n                    setNodeColor(w, 1 /* NodeColor.Red */);\n                    rightRotate(T, w);\n                    w = x.parent.right;\n                }\n                setNodeColor(w, getNodeColor(x.parent));\n                setNodeColor(x.parent, 0 /* NodeColor.Black */);\n                setNodeColor(w.right, 0 /* NodeColor.Black */);\n                leftRotate(T, x.parent);\n                x = T.root;\n            }\n        }\n        else {\n            w = x.parent.left;\n            if (getNodeColor(w) === 1 /* NodeColor.Red */) {\n                setNodeColor(w, 0 /* NodeColor.Black */);\n                setNodeColor(x.parent, 1 /* NodeColor.Red */);\n                rightRotate(T, x.parent);\n                w = x.parent.left;\n            }\n            if (getNodeColor(w.left) === 0 /* NodeColor.Black */ && getNodeColor(w.right) === 0 /* NodeColor.Black */) {\n                setNodeColor(w, 1 /* NodeColor.Red */);\n                x = x.parent;\n            }\n            else {\n                if (getNodeColor(w.left) === 0 /* NodeColor.Black */) {\n                    setNodeColor(w.right, 0 /* NodeColor.Black */);\n                    setNodeColor(w, 1 /* NodeColor.Red */);\n                    leftRotate(T, w);\n                    w = x.parent.left;\n                }\n                setNodeColor(w, getNodeColor(x.parent));\n                setNodeColor(x.parent, 0 /* NodeColor.Black */);\n                setNodeColor(w.left, 0 /* NodeColor.Black */);\n                rightRotate(T, x.parent);\n                x = T.root;\n            }\n        }\n    }\n    setNodeColor(x, 0 /* NodeColor.Black */);\n    resetSentinel();\n}\nfunction leftest(node) {\n    while (node.left !== SENTINEL) {\n        node = node.left;\n    }\n    return node;\n}\nfunction resetSentinel() {\n    SENTINEL.parent = SENTINEL;\n    SENTINEL.delta = 0; // optional\n    SENTINEL.start = 0; // optional\n    SENTINEL.end = 0; // optional\n}\n//#endregion\n//#region Rotations\nfunction leftRotate(T, x) {\n    const y = x.right; // set y.\n    y.delta += x.delta; // y's delta is no longer influenced by x's delta\n    if (y.delta < -1073741824 /* Constants.MIN_SAFE_DELTA */ || y.delta > 1073741824 /* Constants.MAX_SAFE_DELTA */) {\n        T.requestNormalizeDelta = true;\n    }\n    y.start += x.delta;\n    y.end += x.delta;\n    x.right = y.left; // turn y's left subtree into x's right subtree.\n    if (y.left !== SENTINEL) {\n        y.left.parent = x;\n    }\n    y.parent = x.parent; // link x's parent to y.\n    if (x.parent === SENTINEL) {\n        T.root = y;\n    }\n    else if (x === x.parent.left) {\n        x.parent.left = y;\n    }\n    else {\n        x.parent.right = y;\n    }\n    y.left = x; // put x on y's left.\n    x.parent = y;\n    recomputeMaxEnd(x);\n    recomputeMaxEnd(y);\n}\nfunction rightRotate(T, y) {\n    const x = y.left;\n    y.delta -= x.delta;\n    if (y.delta < -1073741824 /* Constants.MIN_SAFE_DELTA */ || y.delta > 1073741824 /* Constants.MAX_SAFE_DELTA */) {\n        T.requestNormalizeDelta = true;\n    }\n    y.start -= x.delta;\n    y.end -= x.delta;\n    y.left = x.right;\n    if (x.right !== SENTINEL) {\n        x.right.parent = y;\n    }\n    x.parent = y.parent;\n    if (y.parent === SENTINEL) {\n        T.root = x;\n    }\n    else if (y === y.parent.right) {\n        y.parent.right = x;\n    }\n    else {\n        y.parent.left = x;\n    }\n    x.right = y;\n    y.parent = x;\n    recomputeMaxEnd(y);\n    recomputeMaxEnd(x);\n}\n//#endregion\n//#region max end computation\nfunction computeMaxEnd(node) {\n    let maxEnd = node.end;\n    if (node.left !== SENTINEL) {\n        const leftMaxEnd = node.left.maxEnd;\n        if (leftMaxEnd > maxEnd) {\n            maxEnd = leftMaxEnd;\n        }\n    }\n    if (node.right !== SENTINEL) {\n        const rightMaxEnd = node.right.maxEnd + node.delta;\n        if (rightMaxEnd > maxEnd) {\n            maxEnd = rightMaxEnd;\n        }\n    }\n    return maxEnd;\n}\nfunction recomputeMaxEnd(node) {\n    node.maxEnd = computeMaxEnd(node);\n}\nfunction recomputeMaxEndWalkToRoot(node) {\n    while (node !== SENTINEL) {\n        const maxEnd = computeMaxEnd(node);\n        if (node.maxEnd === maxEnd) {\n            // no need to go further\n            return;\n        }\n        node.maxEnd = maxEnd;\n        node = node.parent;\n    }\n}\n//#endregion\n//#region utils\nfunction intervalCompare(aStart, aEnd, bStart, bEnd) {\n    if (aStart === bStart) {\n        return aEnd - bEnd;\n    }\n    return aStart - bStart;\n}\n//#endregion\n\nexport { IntervalNode, IntervalTree, SENTINEL, getNodeColor, intervalCompare, nodeAcceptEdit, recomputeMaxEnd };\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 5915, "column": 0}, "map": {"version":3,"sources":["file:///D:/real-time-code-editor%20%282%29/node_modules/.pnpm/monaco-editor%400.55.1/node_modules/monaco-editor/esm/vs/editor/common/model/pieceTreeTextBuffer/rbTreeBase.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nclass TreeNode {\n    constructor(piece, color) {\n        this.piece = piece;\n        this.color = color;\n        this.size_left = 0;\n        this.lf_left = 0;\n        this.parent = this;\n        this.left = this;\n        this.right = this;\n    }\n    next() {\n        if (this.right !== SENTINEL) {\n            return leftest(this.right);\n        }\n        let node = this;\n        while (node.parent !== SENTINEL) {\n            if (node.parent.left === node) {\n                break;\n            }\n            node = node.parent;\n        }\n        if (node.parent === SENTINEL) {\n            return SENTINEL;\n        }\n        else {\n            return node.parent;\n        }\n    }\n    prev() {\n        if (this.left !== SENTINEL) {\n            return righttest(this.left);\n        }\n        let node = this;\n        while (node.parent !== SENTINEL) {\n            if (node.parent.right === node) {\n                break;\n            }\n            node = node.parent;\n        }\n        if (node.parent === SENTINEL) {\n            return SENTINEL;\n        }\n        else {\n            return node.parent;\n        }\n    }\n    detach() {\n        this.parent = null;\n        this.left = null;\n        this.right = null;\n    }\n}\nconst SENTINEL = new TreeNode(null, 0 /* NodeColor.Black */);\nSENTINEL.parent = SENTINEL;\nSENTINEL.left = SENTINEL;\nSENTINEL.right = SENTINEL;\nSENTINEL.color = 0 /* NodeColor.Black */;\nfunction leftest(node) {\n    while (node.left !== SENTINEL) {\n        node = node.left;\n    }\n    return node;\n}\nfunction righttest(node) {\n    while (node.right !== SENTINEL) {\n        node = node.right;\n    }\n    return node;\n}\nfunction calculateSize(node) {\n    if (node === SENTINEL) {\n        return 0;\n    }\n    return node.size_left + node.piece.length + calculateSize(node.right);\n}\nfunction calculateLF(node) {\n    if (node === SENTINEL) {\n        return 0;\n    }\n    return node.lf_left + node.piece.lineFeedCnt + calculateLF(node.right);\n}\nfunction resetSentinel() {\n    SENTINEL.parent = SENTINEL;\n}\nfunction leftRotate(tree, x) {\n    const y = x.right;\n    // fix size_left\n    y.size_left += x.size_left + (x.piece ? x.piece.length : 0);\n    y.lf_left += x.lf_left + (x.piece ? x.piece.lineFeedCnt : 0);\n    x.right = y.left;\n    if (y.left !== SENTINEL) {\n        y.left.parent = x;\n    }\n    y.parent = x.parent;\n    if (x.parent === SENTINEL) {\n        tree.root = y;\n    }\n    else if (x.parent.left === x) {\n        x.parent.left = y;\n    }\n    else {\n        x.parent.right = y;\n    }\n    y.left = x;\n    x.parent = y;\n}\nfunction rightRotate(tree, y) {\n    const x = y.left;\n    y.left = x.right;\n    if (x.right !== SENTINEL) {\n        x.right.parent = y;\n    }\n    x.parent = y.parent;\n    // fix size_left\n    y.size_left -= x.size_left + (x.piece ? x.piece.length : 0);\n    y.lf_left -= x.lf_left + (x.piece ? x.piece.lineFeedCnt : 0);\n    if (y.parent === SENTINEL) {\n        tree.root = x;\n    }\n    else if (y === y.parent.right) {\n        y.parent.right = x;\n    }\n    else {\n        y.parent.left = x;\n    }\n    x.right = y;\n    y.parent = x;\n}\nfunction rbDelete(tree, z) {\n    let x;\n    let y;\n    if (z.left === SENTINEL) {\n        y = z;\n        x = y.right;\n    }\n    else if (z.right === SENTINEL) {\n        y = z;\n        x = y.left;\n    }\n    else {\n        y = leftest(z.right);\n        x = y.right;\n    }\n    if (y === tree.root) {\n        tree.root = x;\n        // if x is null, we are removing the only node\n        x.color = 0 /* NodeColor.Black */;\n        z.detach();\n        resetSentinel();\n        tree.root.parent = SENTINEL;\n        return;\n    }\n    const yWasRed = (y.color === 1 /* NodeColor.Red */);\n    if (y === y.parent.left) {\n        y.parent.left = x;\n    }\n    else {\n        y.parent.right = x;\n    }\n    if (y === z) {\n        x.parent = y.parent;\n        recomputeTreeMetadata(tree, x);\n    }\n    else {\n        if (y.parent === z) {\n            x.parent = y;\n        }\n        else {\n            x.parent = y.parent;\n        }\n        // as we make changes to x's hierarchy, update size_left of subtree first\n        recomputeTreeMetadata(tree, x);\n        y.left = z.left;\n        y.right = z.right;\n        y.parent = z.parent;\n        y.color = z.color;\n        if (z === tree.root) {\n            tree.root = y;\n        }\n        else {\n            if (z === z.parent.left) {\n                z.parent.left = y;\n            }\n            else {\n                z.parent.right = y;\n            }\n        }\n        if (y.left !== SENTINEL) {\n            y.left.parent = y;\n        }\n        if (y.right !== SENTINEL) {\n            y.right.parent = y;\n        }\n        // update metadata\n        // we replace z with y, so in this sub tree, the length change is z.item.length\n        y.size_left = z.size_left;\n        y.lf_left = z.lf_left;\n        recomputeTreeMetadata(tree, y);\n    }\n    z.detach();\n    if (x.parent.left === x) {\n        const newSizeLeft = calculateSize(x);\n        const newLFLeft = calculateLF(x);\n        if (newSizeLeft !== x.parent.size_left || newLFLeft !== x.parent.lf_left) {\n            const delta = newSizeLeft - x.parent.size_left;\n            const lf_delta = newLFLeft - x.parent.lf_left;\n            x.parent.size_left = newSizeLeft;\n            x.parent.lf_left = newLFLeft;\n            updateTreeMetadata(tree, x.parent, delta, lf_delta);\n        }\n    }\n    recomputeTreeMetadata(tree, x.parent);\n    if (yWasRed) {\n        resetSentinel();\n        return;\n    }\n    // RB-DELETE-FIXUP\n    let w;\n    while (x !== tree.root && x.color === 0 /* NodeColor.Black */) {\n        if (x === x.parent.left) {\n            w = x.parent.right;\n            if (w.color === 1 /* NodeColor.Red */) {\n                w.color = 0 /* NodeColor.Black */;\n                x.parent.color = 1 /* NodeColor.Red */;\n                leftRotate(tree, x.parent);\n                w = x.parent.right;\n            }\n            if (w.left.color === 0 /* NodeColor.Black */ && w.right.color === 0 /* NodeColor.Black */) {\n                w.color = 1 /* NodeColor.Red */;\n                x = x.parent;\n            }\n            else {\n                if (w.right.color === 0 /* NodeColor.Black */) {\n                    w.left.color = 0 /* NodeColor.Black */;\n                    w.color = 1 /* NodeColor.Red */;\n                    rightRotate(tree, w);\n                    w = x.parent.right;\n                }\n                w.color = x.parent.color;\n                x.parent.color = 0 /* NodeColor.Black */;\n                w.right.color = 0 /* NodeColor.Black */;\n                leftRotate(tree, x.parent);\n                x = tree.root;\n            }\n        }\n        else {\n            w = x.parent.left;\n            if (w.color === 1 /* NodeColor.Red */) {\n                w.color = 0 /* NodeColor.Black */;\n                x.parent.color = 1 /* NodeColor.Red */;\n                rightRotate(tree, x.parent);\n                w = x.parent.left;\n            }\n            if (w.left.color === 0 /* NodeColor.Black */ && w.right.color === 0 /* NodeColor.Black */) {\n                w.color = 1 /* NodeColor.Red */;\n                x = x.parent;\n            }\n            else {\n                if (w.left.color === 0 /* NodeColor.Black */) {\n                    w.right.color = 0 /* NodeColor.Black */;\n                    w.color = 1 /* NodeColor.Red */;\n                    leftRotate(tree, w);\n                    w = x.parent.left;\n                }\n                w.color = x.parent.color;\n                x.parent.color = 0 /* NodeColor.Black */;\n                w.left.color = 0 /* NodeColor.Black */;\n                rightRotate(tree, x.parent);\n                x = tree.root;\n            }\n        }\n    }\n    x.color = 0 /* NodeColor.Black */;\n    resetSentinel();\n}\nfunction fixInsert(tree, x) {\n    recomputeTreeMetadata(tree, x);\n    while (x !== tree.root && x.parent.color === 1 /* NodeColor.Red */) {\n        if (x.parent === x.parent.parent.left) {\n            const y = x.parent.parent.right;\n            if (y.color === 1 /* NodeColor.Red */) {\n                x.parent.color = 0 /* NodeColor.Black */;\n                y.color = 0 /* NodeColor.Black */;\n                x.parent.parent.color = 1 /* NodeColor.Red */;\n                x = x.parent.parent;\n            }\n            else {\n                if (x === x.parent.right) {\n                    x = x.parent;\n                    leftRotate(tree, x);\n                }\n                x.parent.color = 0 /* NodeColor.Black */;\n                x.parent.parent.color = 1 /* NodeColor.Red */;\n                rightRotate(tree, x.parent.parent);\n            }\n        }\n        else {\n            const y = x.parent.parent.left;\n            if (y.color === 1 /* NodeColor.Red */) {\n                x.parent.color = 0 /* NodeColor.Black */;\n                y.color = 0 /* NodeColor.Black */;\n                x.parent.parent.color = 1 /* NodeColor.Red */;\n                x = x.parent.parent;\n            }\n            else {\n                if (x === x.parent.left) {\n                    x = x.parent;\n                    rightRotate(tree, x);\n                }\n                x.parent.color = 0 /* NodeColor.Black */;\n                x.parent.parent.color = 1 /* NodeColor.Red */;\n                leftRotate(tree, x.parent.parent);\n            }\n        }\n    }\n    tree.root.color = 0 /* NodeColor.Black */;\n}\nfunction updateTreeMetadata(tree, x, delta, lineFeedCntDelta) {\n    // node length change or line feed count change\n    while (x !== tree.root && x !== SENTINEL) {\n        if (x.parent.left === x) {\n            x.parent.size_left += delta;\n            x.parent.lf_left += lineFeedCntDelta;\n        }\n        x = x.parent;\n    }\n}\nfunction recomputeTreeMetadata(tree, x) {\n    let delta = 0;\n    let lf_delta = 0;\n    if (x === tree.root) {\n        return;\n    }\n    // go upwards till the node whose left subtree is changed.\n    while (x !== tree.root && x === x.parent.right) {\n        x = x.parent;\n    }\n    if (x === tree.root) {\n        // well, it means we add a node to the end (inorder)\n        return;\n    }\n    // x is the node whose right subtree is changed.\n    x = x.parent;\n    delta = calculateSize(x.left) - x.size_left;\n    lf_delta = calculateLF(x.left) - x.lf_left;\n    x.size_left += delta;\n    x.lf_left += lf_delta;\n    // go upwards till root. O(logN)\n    while (x !== tree.root && (delta !== 0 || lf_delta !== 0)) {\n        if (x.parent.left === x) {\n            x.parent.size_left += delta;\n            x.parent.lf_left += lf_delta;\n        }\n        x = x.parent;\n    }\n}\n\nexport { SENTINEL, TreeNode, fixInsert, leftRotate, leftest, rbDelete, recomputeTreeMetadata, rightRotate, righttest, updateTreeMetadata };\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 6282, "column": 0}, "map": {"version":3,"sources":["file:///D:/real-time-code-editor%20%282%29/node_modules/.pnpm/monaco-editor%400.55.1/node_modules/monaco-editor/esm/vs/editor/common/model/pieceTreeTextBuffer/pieceTreeBase.js"],"sourcesContent":["import { Position } from '../../core/position.js';\nimport { Range } from '../../core/range.js';\nimport { FindMatch } from '../../model.js';\nimport { SENTINEL, rbDelete, updateTreeMetadata, TreeNode, leftest, fixInsert, righttest } from './rbTreeBase.js';\nimport { createFindMatch, Searcher, isValidMatch } from '../textModelSearch.js';\n\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n// const lfRegex = new RegExp(/\\r\\n|\\r|\\n/g);\nconst AverageBufferSize = 65535;\nfunction createUintArray(arr) {\n    let r;\n    if (arr[arr.length - 1] < 65536) {\n        r = new Uint16Array(arr.length);\n    }\n    else {\n        r = new Uint32Array(arr.length);\n    }\n    r.set(arr, 0);\n    return r;\n}\nclass LineStarts {\n    constructor(lineStarts, cr, lf, crlf, isBasicASCII) {\n        this.lineStarts = lineStarts;\n        this.cr = cr;\n        this.lf = lf;\n        this.crlf = crlf;\n        this.isBasicASCII = isBasicASCII;\n    }\n}\nfunction createLineStartsFast(str, readonly = true) {\n    const r = [0];\n    let rLength = 1;\n    for (let i = 0, len = str.length; i < len; i++) {\n        const chr = str.charCodeAt(i);\n        if (chr === 13 /* CharCode.CarriageReturn */) {\n            if (i + 1 < len && str.charCodeAt(i + 1) === 10 /* CharCode.LineFeed */) {\n                // \\r\\n... case\n                r[rLength++] = i + 2;\n                i++; // skip \\n\n            }\n            else {\n                // \\r... case\n                r[rLength++] = i + 1;\n            }\n        }\n        else if (chr === 10 /* CharCode.LineFeed */) {\n            r[rLength++] = i + 1;\n        }\n    }\n    if (readonly) {\n        return createUintArray(r);\n    }\n    else {\n        return r;\n    }\n}\nfunction createLineStarts(r, str) {\n    r.length = 0;\n    r[0] = 0;\n    let rLength = 1;\n    let cr = 0, lf = 0, crlf = 0;\n    let isBasicASCII = true;\n    for (let i = 0, len = str.length; i < len; i++) {\n        const chr = str.charCodeAt(i);\n        if (chr === 13 /* CharCode.CarriageReturn */) {\n            if (i + 1 < len && str.charCodeAt(i + 1) === 10 /* CharCode.LineFeed */) {\n                // \\r\\n... case\n                crlf++;\n                r[rLength++] = i + 2;\n                i++; // skip \\n\n            }\n            else {\n                cr++;\n                // \\r... case\n                r[rLength++] = i + 1;\n            }\n        }\n        else if (chr === 10 /* CharCode.LineFeed */) {\n            lf++;\n            r[rLength++] = i + 1;\n        }\n        else {\n            if (isBasicASCII) {\n                if (chr !== 9 /* CharCode.Tab */ && (chr < 32 || chr > 126)) {\n                    isBasicASCII = false;\n                }\n            }\n        }\n    }\n    const result = new LineStarts(createUintArray(r), cr, lf, crlf, isBasicASCII);\n    r.length = 0;\n    return result;\n}\nclass Piece {\n    constructor(bufferIndex, start, end, lineFeedCnt, length) {\n        this.bufferIndex = bufferIndex;\n        this.start = start;\n        this.end = end;\n        this.lineFeedCnt = lineFeedCnt;\n        this.length = length;\n    }\n}\nclass StringBuffer {\n    constructor(buffer, lineStarts) {\n        this.buffer = buffer;\n        this.lineStarts = lineStarts;\n    }\n}\n/**\n * Readonly snapshot for piece tree.\n * In a real multiple thread environment, to make snapshot reading always work correctly, we need to\n * 1. Make TreeNode.piece immutable, then reading and writing can run in parallel.\n * 2. TreeNode/Buffers normalization should not happen during snapshot reading.\n */\nclass PieceTreeSnapshot {\n    constructor(tree, BOM) {\n        this._pieces = [];\n        this._tree = tree;\n        this._BOM = BOM;\n        this._index = 0;\n        if (tree.root !== SENTINEL) {\n            tree.iterate(tree.root, node => {\n                if (node !== SENTINEL) {\n                    this._pieces.push(node.piece);\n                }\n                return true;\n            });\n        }\n    }\n    read() {\n        if (this._pieces.length === 0) {\n            if (this._index === 0) {\n                this._index++;\n                return this._BOM;\n            }\n            else {\n                return null;\n            }\n        }\n        if (this._index > this._pieces.length - 1) {\n            return null;\n        }\n        if (this._index === 0) {\n            return this._BOM + this._tree.getPieceContent(this._pieces[this._index++]);\n        }\n        return this._tree.getPieceContent(this._pieces[this._index++]);\n    }\n}\nclass PieceTreeSearchCache {\n    constructor(limit) {\n        this._limit = limit;\n        this._cache = [];\n    }\n    get(offset) {\n        for (let i = this._cache.length - 1; i >= 0; i--) {\n            const nodePos = this._cache[i];\n            if (nodePos.nodeStartOffset <= offset && nodePos.nodeStartOffset + nodePos.node.piece.length >= offset) {\n                return nodePos;\n            }\n        }\n        return null;\n    }\n    get2(lineNumber) {\n        for (let i = this._cache.length - 1; i >= 0; i--) {\n            const nodePos = this._cache[i];\n            if (nodePos.nodeStartLineNumber && nodePos.nodeStartLineNumber < lineNumber && nodePos.nodeStartLineNumber + nodePos.node.piece.lineFeedCnt >= lineNumber) {\n                return nodePos;\n            }\n        }\n        return null;\n    }\n    set(nodePosition) {\n        if (this._cache.length >= this._limit) {\n            this._cache.shift();\n        }\n        this._cache.push(nodePosition);\n    }\n    validate(offset) {\n        let hasInvalidVal = false;\n        const tmp = this._cache;\n        for (let i = 0; i < tmp.length; i++) {\n            const nodePos = tmp[i];\n            if (nodePos.node.parent === null || nodePos.nodeStartOffset >= offset) {\n                tmp[i] = null;\n                hasInvalidVal = true;\n                continue;\n            }\n        }\n        if (hasInvalidVal) {\n            const newArr = [];\n            for (const entry of tmp) {\n                if (entry !== null) {\n                    newArr.push(entry);\n                }\n            }\n            this._cache = newArr;\n        }\n    }\n}\nclass PieceTreeBase {\n    constructor(chunks, eol, eolNormalized) {\n        this.create(chunks, eol, eolNormalized);\n    }\n    create(chunks, eol, eolNormalized) {\n        this._buffers = [\n            new StringBuffer('', [0])\n        ];\n        this._lastChangeBufferPos = { line: 0, column: 0 };\n        this.root = SENTINEL;\n        this._lineCnt = 1;\n        this._length = 0;\n        this._EOL = eol;\n        this._EOLLength = eol.length;\n        this._EOLNormalized = eolNormalized;\n        let lastNode = null;\n        for (let i = 0, len = chunks.length; i < len; i++) {\n            if (chunks[i].buffer.length > 0) {\n                if (!chunks[i].lineStarts) {\n                    chunks[i].lineStarts = createLineStartsFast(chunks[i].buffer);\n                }\n                const piece = new Piece(i + 1, { line: 0, column: 0 }, { line: chunks[i].lineStarts.length - 1, column: chunks[i].buffer.length - chunks[i].lineStarts[chunks[i].lineStarts.length - 1] }, chunks[i].lineStarts.length - 1, chunks[i].buffer.length);\n                this._buffers.push(chunks[i]);\n                lastNode = this.rbInsertRight(lastNode, piece);\n            }\n        }\n        this._searchCache = new PieceTreeSearchCache(1);\n        this._lastVisitedLine = { lineNumber: 0, value: '' };\n        this.computeBufferMetadata();\n    }\n    normalizeEOL(eol) {\n        const averageBufferSize = AverageBufferSize;\n        const min = averageBufferSize - Math.floor(averageBufferSize / 3);\n        const max = min * 2;\n        let tempChunk = '';\n        let tempChunkLen = 0;\n        const chunks = [];\n        this.iterate(this.root, node => {\n            const str = this.getNodeContent(node);\n            const len = str.length;\n            if (tempChunkLen <= min || tempChunkLen + len < max) {\n                tempChunk += str;\n                tempChunkLen += len;\n                return true;\n            }\n            // flush anyways\n            const text = tempChunk.replace(/\\r\\n|\\r|\\n/g, eol);\n            chunks.push(new StringBuffer(text, createLineStartsFast(text)));\n            tempChunk = str;\n            tempChunkLen = len;\n            return true;\n        });\n        if (tempChunkLen > 0) {\n            const text = tempChunk.replace(/\\r\\n|\\r|\\n/g, eol);\n            chunks.push(new StringBuffer(text, createLineStartsFast(text)));\n        }\n        this.create(chunks, eol, true);\n    }\n    // #region Buffer API\n    getEOL() {\n        return this._EOL;\n    }\n    setEOL(newEOL) {\n        this._EOL = newEOL;\n        this._EOLLength = this._EOL.length;\n        this.normalizeEOL(newEOL);\n    }\n    createSnapshot(BOM) {\n        return new PieceTreeSnapshot(this, BOM);\n    }\n    getOffsetAt(lineNumber, column) {\n        let leftLen = 0; // inorder\n        let x = this.root;\n        while (x !== SENTINEL) {\n            if (x.left !== SENTINEL && x.lf_left + 1 >= lineNumber) {\n                x = x.left;\n            }\n            else if (x.lf_left + x.piece.lineFeedCnt + 1 >= lineNumber) {\n                leftLen += x.size_left;\n                // lineNumber >= 2\n                const accumualtedValInCurrentIndex = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);\n                return leftLen += accumualtedValInCurrentIndex + column - 1;\n            }\n            else {\n                lineNumber -= x.lf_left + x.piece.lineFeedCnt;\n                leftLen += x.size_left + x.piece.length;\n                x = x.right;\n            }\n        }\n        return leftLen;\n    }\n    getPositionAt(offset) {\n        offset = Math.floor(offset);\n        offset = Math.max(0, offset);\n        let x = this.root;\n        let lfCnt = 0;\n        const originalOffset = offset;\n        while (x !== SENTINEL) {\n            if (x.size_left !== 0 && x.size_left >= offset) {\n                x = x.left;\n            }\n            else if (x.size_left + x.piece.length >= offset) {\n                const out = this.getIndexOf(x, offset - x.size_left);\n                lfCnt += x.lf_left + out.index;\n                if (out.index === 0) {\n                    const lineStartOffset = this.getOffsetAt(lfCnt + 1, 1);\n                    const column = originalOffset - lineStartOffset;\n                    return new Position(lfCnt + 1, column + 1);\n                }\n                return new Position(lfCnt + 1, out.remainder + 1);\n            }\n            else {\n                offset -= x.size_left + x.piece.length;\n                lfCnt += x.lf_left + x.piece.lineFeedCnt;\n                if (x.right === SENTINEL) {\n                    // last node\n                    const lineStartOffset = this.getOffsetAt(lfCnt + 1, 1);\n                    const column = originalOffset - offset - lineStartOffset;\n                    return new Position(lfCnt + 1, column + 1);\n                }\n                else {\n                    x = x.right;\n                }\n            }\n        }\n        return new Position(1, 1);\n    }\n    getValueInRange(range, eol) {\n        if (range.startLineNumber === range.endLineNumber && range.startColumn === range.endColumn) {\n            return '';\n        }\n        const startPosition = this.nodeAt2(range.startLineNumber, range.startColumn);\n        const endPosition = this.nodeAt2(range.endLineNumber, range.endColumn);\n        const value = this.getValueInRange2(startPosition, endPosition);\n        if (eol) {\n            if (eol !== this._EOL || !this._EOLNormalized) {\n                return value.replace(/\\r\\n|\\r|\\n/g, eol);\n            }\n            if (eol === this.getEOL() && this._EOLNormalized) {\n                return value;\n            }\n            return value.replace(/\\r\\n|\\r|\\n/g, eol);\n        }\n        return value;\n    }\n    getValueInRange2(startPosition, endPosition) {\n        if (startPosition.node === endPosition.node) {\n            const node = startPosition.node;\n            const buffer = this._buffers[node.piece.bufferIndex].buffer;\n            const startOffset = this.offsetInBuffer(node.piece.bufferIndex, node.piece.start);\n            return buffer.substring(startOffset + startPosition.remainder, startOffset + endPosition.remainder);\n        }\n        let x = startPosition.node;\n        const buffer = this._buffers[x.piece.bufferIndex].buffer;\n        const startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n        let ret = buffer.substring(startOffset + startPosition.remainder, startOffset + x.piece.length);\n        x = x.next();\n        while (x !== SENTINEL) {\n            const buffer = this._buffers[x.piece.bufferIndex].buffer;\n            const startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n            if (x === endPosition.node) {\n                ret += buffer.substring(startOffset, startOffset + endPosition.remainder);\n                break;\n            }\n            else {\n                ret += buffer.substr(startOffset, x.piece.length);\n            }\n            x = x.next();\n        }\n        return ret;\n    }\n    getLinesContent() {\n        const lines = [];\n        let linesLength = 0;\n        let currentLine = '';\n        let danglingCR = false;\n        this.iterate(this.root, node => {\n            if (node === SENTINEL) {\n                return true;\n            }\n            const piece = node.piece;\n            let pieceLength = piece.length;\n            if (pieceLength === 0) {\n                return true;\n            }\n            const buffer = this._buffers[piece.bufferIndex].buffer;\n            const lineStarts = this._buffers[piece.bufferIndex].lineStarts;\n            const pieceStartLine = piece.start.line;\n            const pieceEndLine = piece.end.line;\n            let pieceStartOffset = lineStarts[pieceStartLine] + piece.start.column;\n            if (danglingCR) {\n                if (buffer.charCodeAt(pieceStartOffset) === 10 /* CharCode.LineFeed */) {\n                    // pretend the \\n was in the previous piece..\n                    pieceStartOffset++;\n                    pieceLength--;\n                }\n                lines[linesLength++] = currentLine;\n                currentLine = '';\n                danglingCR = false;\n                if (pieceLength === 0) {\n                    return true;\n                }\n            }\n            if (pieceStartLine === pieceEndLine) {\n                // this piece has no new lines\n                if (!this._EOLNormalized && buffer.charCodeAt(pieceStartOffset + pieceLength - 1) === 13 /* CharCode.CarriageReturn */) {\n                    danglingCR = true;\n                    currentLine += buffer.substr(pieceStartOffset, pieceLength - 1);\n                }\n                else {\n                    currentLine += buffer.substr(pieceStartOffset, pieceLength);\n                }\n                return true;\n            }\n            // add the text before the first line start in this piece\n            currentLine += (this._EOLNormalized\n                ? buffer.substring(pieceStartOffset, Math.max(pieceStartOffset, lineStarts[pieceStartLine + 1] - this._EOLLength))\n                : buffer.substring(pieceStartOffset, lineStarts[pieceStartLine + 1]).replace(/(\\r\\n|\\r|\\n)$/, ''));\n            lines[linesLength++] = currentLine;\n            for (let line = pieceStartLine + 1; line < pieceEndLine; line++) {\n                currentLine = (this._EOLNormalized\n                    ? buffer.substring(lineStarts[line], lineStarts[line + 1] - this._EOLLength)\n                    : buffer.substring(lineStarts[line], lineStarts[line + 1]).replace(/(\\r\\n|\\r|\\n)$/, ''));\n                lines[linesLength++] = currentLine;\n            }\n            if (!this._EOLNormalized && buffer.charCodeAt(lineStarts[pieceEndLine] + piece.end.column - 1) === 13 /* CharCode.CarriageReturn */) {\n                danglingCR = true;\n                if (piece.end.column === 0) {\n                    // The last line ended with a \\r, let's undo the push, it will be pushed by next iteration\n                    linesLength--;\n                }\n                else {\n                    currentLine = buffer.substr(lineStarts[pieceEndLine], piece.end.column - 1);\n                }\n            }\n            else {\n                currentLine = buffer.substr(lineStarts[pieceEndLine], piece.end.column);\n            }\n            return true;\n        });\n        if (danglingCR) {\n            lines[linesLength++] = currentLine;\n            currentLine = '';\n        }\n        lines[linesLength++] = currentLine;\n        return lines;\n    }\n    getLength() {\n        return this._length;\n    }\n    getLineCount() {\n        return this._lineCnt;\n    }\n    getLineContent(lineNumber) {\n        if (this._lastVisitedLine.lineNumber === lineNumber) {\n            return this._lastVisitedLine.value;\n        }\n        this._lastVisitedLine.lineNumber = lineNumber;\n        if (lineNumber === this._lineCnt) {\n            this._lastVisitedLine.value = this.getLineRawContent(lineNumber);\n        }\n        else if (this._EOLNormalized) {\n            this._lastVisitedLine.value = this.getLineRawContent(lineNumber, this._EOLLength);\n        }\n        else {\n            this._lastVisitedLine.value = this.getLineRawContent(lineNumber).replace(/(\\r\\n|\\r|\\n)$/, '');\n        }\n        return this._lastVisitedLine.value;\n    }\n    _getCharCode(nodePos) {\n        if (nodePos.remainder === nodePos.node.piece.length) {\n            // the char we want to fetch is at the head of next node.\n            const matchingNode = nodePos.node.next();\n            if (!matchingNode) {\n                return 0;\n            }\n            const buffer = this._buffers[matchingNode.piece.bufferIndex];\n            const startOffset = this.offsetInBuffer(matchingNode.piece.bufferIndex, matchingNode.piece.start);\n            return buffer.buffer.charCodeAt(startOffset);\n        }\n        else {\n            const buffer = this._buffers[nodePos.node.piece.bufferIndex];\n            const startOffset = this.offsetInBuffer(nodePos.node.piece.bufferIndex, nodePos.node.piece.start);\n            const targetOffset = startOffset + nodePos.remainder;\n            return buffer.buffer.charCodeAt(targetOffset);\n        }\n    }\n    getLineCharCode(lineNumber, index) {\n        const nodePos = this.nodeAt2(lineNumber, index + 1);\n        return this._getCharCode(nodePos);\n    }\n    getLineLength(lineNumber) {\n        if (lineNumber === this.getLineCount()) {\n            const startOffset = this.getOffsetAt(lineNumber, 1);\n            return this.getLength() - startOffset;\n        }\n        return this.getOffsetAt(lineNumber + 1, 1) - this.getOffsetAt(lineNumber, 1) - this._EOLLength;\n    }\n    getNearestChunk(offset) {\n        const nodePos = this.nodeAt(offset);\n        if (nodePos.remainder === nodePos.node.piece.length) {\n            // the offset is at the head of next node.\n            const matchingNode = nodePos.node.next();\n            if (!matchingNode || matchingNode === SENTINEL) {\n                return '';\n            }\n            const buffer = this._buffers[matchingNode.piece.bufferIndex];\n            const startOffset = this.offsetInBuffer(matchingNode.piece.bufferIndex, matchingNode.piece.start);\n            return buffer.buffer.substring(startOffset, startOffset + matchingNode.piece.length);\n        }\n        else {\n            const buffer = this._buffers[nodePos.node.piece.bufferIndex];\n            const startOffset = this.offsetInBuffer(nodePos.node.piece.bufferIndex, nodePos.node.piece.start);\n            const targetOffset = startOffset + nodePos.remainder;\n            const targetEnd = startOffset + nodePos.node.piece.length;\n            return buffer.buffer.substring(targetOffset, targetEnd);\n        }\n    }\n    findMatchesInNode(node, searcher, startLineNumber, startColumn, startCursor, endCursor, searchData, captureMatches, limitResultCount, resultLen, result) {\n        const buffer = this._buffers[node.piece.bufferIndex];\n        const startOffsetInBuffer = this.offsetInBuffer(node.piece.bufferIndex, node.piece.start);\n        const start = this.offsetInBuffer(node.piece.bufferIndex, startCursor);\n        const end = this.offsetInBuffer(node.piece.bufferIndex, endCursor);\n        let m;\n        // Reset regex to search from the beginning\n        const ret = { line: 0, column: 0 };\n        let searchText;\n        let offsetInBuffer;\n        if (searcher._wordSeparators) {\n            searchText = buffer.buffer.substring(start, end);\n            offsetInBuffer = (offset) => offset + start;\n            searcher.reset(0);\n        }\n        else {\n            searchText = buffer.buffer;\n            offsetInBuffer = (offset) => offset;\n            searcher.reset(start);\n        }\n        do {\n            m = searcher.next(searchText);\n            if (m) {\n                if (offsetInBuffer(m.index) >= end) {\n                    return resultLen;\n                }\n                this.positionInBuffer(node, offsetInBuffer(m.index) - startOffsetInBuffer, ret);\n                const lineFeedCnt = this.getLineFeedCnt(node.piece.bufferIndex, startCursor, ret);\n                const retStartColumn = ret.line === startCursor.line ? ret.column - startCursor.column + startColumn : ret.column + 1;\n                const retEndColumn = retStartColumn + m[0].length;\n                result[resultLen++] = createFindMatch(new Range(startLineNumber + lineFeedCnt, retStartColumn, startLineNumber + lineFeedCnt, retEndColumn), m, captureMatches);\n                if (offsetInBuffer(m.index) + m[0].length >= end) {\n                    return resultLen;\n                }\n                if (resultLen >= limitResultCount) {\n                    return resultLen;\n                }\n            }\n        } while (m);\n        return resultLen;\n    }\n    findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount) {\n        const result = [];\n        let resultLen = 0;\n        const searcher = new Searcher(searchData.wordSeparators, searchData.regex);\n        let startPosition = this.nodeAt2(searchRange.startLineNumber, searchRange.startColumn);\n        if (startPosition === null) {\n            return [];\n        }\n        const endPosition = this.nodeAt2(searchRange.endLineNumber, searchRange.endColumn);\n        if (endPosition === null) {\n            return [];\n        }\n        let start = this.positionInBuffer(startPosition.node, startPosition.remainder);\n        const end = this.positionInBuffer(endPosition.node, endPosition.remainder);\n        if (startPosition.node === endPosition.node) {\n            this.findMatchesInNode(startPosition.node, searcher, searchRange.startLineNumber, searchRange.startColumn, start, end, searchData, captureMatches, limitResultCount, resultLen, result);\n            return result;\n        }\n        let startLineNumber = searchRange.startLineNumber;\n        let currentNode = startPosition.node;\n        while (currentNode !== endPosition.node) {\n            const lineBreakCnt = this.getLineFeedCnt(currentNode.piece.bufferIndex, start, currentNode.piece.end);\n            if (lineBreakCnt >= 1) {\n                // last line break position\n                const lineStarts = this._buffers[currentNode.piece.bufferIndex].lineStarts;\n                const startOffsetInBuffer = this.offsetInBuffer(currentNode.piece.bufferIndex, currentNode.piece.start);\n                const nextLineStartOffset = lineStarts[start.line + lineBreakCnt];\n                const startColumn = startLineNumber === searchRange.startLineNumber ? searchRange.startColumn : 1;\n                resultLen = this.findMatchesInNode(currentNode, searcher, startLineNumber, startColumn, start, this.positionInBuffer(currentNode, nextLineStartOffset - startOffsetInBuffer), searchData, captureMatches, limitResultCount, resultLen, result);\n                if (resultLen >= limitResultCount) {\n                    return result;\n                }\n                startLineNumber += lineBreakCnt;\n            }\n            const startColumn = startLineNumber === searchRange.startLineNumber ? searchRange.startColumn - 1 : 0;\n            // search for the remaining content\n            if (startLineNumber === searchRange.endLineNumber) {\n                const text = this.getLineContent(startLineNumber).substring(startColumn, searchRange.endColumn - 1);\n                resultLen = this._findMatchesInLine(searchData, searcher, text, searchRange.endLineNumber, startColumn, resultLen, result, captureMatches, limitResultCount);\n                return result;\n            }\n            resultLen = this._findMatchesInLine(searchData, searcher, this.getLineContent(startLineNumber).substr(startColumn), startLineNumber, startColumn, resultLen, result, captureMatches, limitResultCount);\n            if (resultLen >= limitResultCount) {\n                return result;\n            }\n            startLineNumber++;\n            startPosition = this.nodeAt2(startLineNumber, 1);\n            currentNode = startPosition.node;\n            start = this.positionInBuffer(startPosition.node, startPosition.remainder);\n        }\n        if (startLineNumber === searchRange.endLineNumber) {\n            const startColumn = startLineNumber === searchRange.startLineNumber ? searchRange.startColumn - 1 : 0;\n            const text = this.getLineContent(startLineNumber).substring(startColumn, searchRange.endColumn - 1);\n            resultLen = this._findMatchesInLine(searchData, searcher, text, searchRange.endLineNumber, startColumn, resultLen, result, captureMatches, limitResultCount);\n            return result;\n        }\n        const startColumn = startLineNumber === searchRange.startLineNumber ? searchRange.startColumn : 1;\n        resultLen = this.findMatchesInNode(endPosition.node, searcher, startLineNumber, startColumn, start, end, searchData, captureMatches, limitResultCount, resultLen, result);\n        return result;\n    }\n    _findMatchesInLine(searchData, searcher, text, lineNumber, deltaOffset, resultLen, result, captureMatches, limitResultCount) {\n        const wordSeparators = searchData.wordSeparators;\n        if (!captureMatches && searchData.simpleSearch) {\n            const searchString = searchData.simpleSearch;\n            const searchStringLen = searchString.length;\n            const textLength = text.length;\n            let lastMatchIndex = -searchStringLen;\n            while ((lastMatchIndex = text.indexOf(searchString, lastMatchIndex + searchStringLen)) !== -1) {\n                if (!wordSeparators || isValidMatch(wordSeparators, text, textLength, lastMatchIndex, searchStringLen)) {\n                    result[resultLen++] = new FindMatch(new Range(lineNumber, lastMatchIndex + 1 + deltaOffset, lineNumber, lastMatchIndex + 1 + searchStringLen + deltaOffset), null);\n                    if (resultLen >= limitResultCount) {\n                        return resultLen;\n                    }\n                }\n            }\n            return resultLen;\n        }\n        let m;\n        // Reset regex to search from the beginning\n        searcher.reset(0);\n        do {\n            m = searcher.next(text);\n            if (m) {\n                result[resultLen++] = createFindMatch(new Range(lineNumber, m.index + 1 + deltaOffset, lineNumber, m.index + 1 + m[0].length + deltaOffset), m, captureMatches);\n                if (resultLen >= limitResultCount) {\n                    return resultLen;\n                }\n            }\n        } while (m);\n        return resultLen;\n    }\n    // #endregion\n    // #region Piece Table\n    insert(offset, value, eolNormalized = false) {\n        this._EOLNormalized = this._EOLNormalized && eolNormalized;\n        this._lastVisitedLine.lineNumber = 0;\n        this._lastVisitedLine.value = '';\n        if (this.root !== SENTINEL) {\n            const { node, remainder, nodeStartOffset } = this.nodeAt(offset);\n            const piece = node.piece;\n            const bufferIndex = piece.bufferIndex;\n            const insertPosInBuffer = this.positionInBuffer(node, remainder);\n            if (node.piece.bufferIndex === 0 &&\n                piece.end.line === this._lastChangeBufferPos.line &&\n                piece.end.column === this._lastChangeBufferPos.column &&\n                (nodeStartOffset + piece.length === offset) &&\n                value.length < AverageBufferSize) {\n                // changed buffer\n                this.appendToNode(node, value);\n                this.computeBufferMetadata();\n                return;\n            }\n            if (nodeStartOffset === offset) {\n                this.insertContentToNodeLeft(value, node);\n                this._searchCache.validate(offset);\n            }\n            else if (nodeStartOffset + node.piece.length > offset) {\n                // we are inserting into the middle of a node.\n                const nodesToDel = [];\n                let newRightPiece = new Piece(piece.bufferIndex, insertPosInBuffer, piece.end, this.getLineFeedCnt(piece.bufferIndex, insertPosInBuffer, piece.end), this.offsetInBuffer(bufferIndex, piece.end) - this.offsetInBuffer(bufferIndex, insertPosInBuffer));\n                if (this.shouldCheckCRLF() && this.endWithCR(value)) {\n                    const headOfRight = this.nodeCharCodeAt(node, remainder);\n                    if (headOfRight === 10 /** \\n */) {\n                        const newStart = { line: newRightPiece.start.line + 1, column: 0 };\n                        newRightPiece = new Piece(newRightPiece.bufferIndex, newStart, newRightPiece.end, this.getLineFeedCnt(newRightPiece.bufferIndex, newStart, newRightPiece.end), newRightPiece.length - 1);\n                        value += '\\n';\n                    }\n                }\n                // reuse node for content before insertion point.\n                if (this.shouldCheckCRLF() && this.startWithLF(value)) {\n                    const tailOfLeft = this.nodeCharCodeAt(node, remainder - 1);\n                    if (tailOfLeft === 13 /** \\r */) {\n                        const previousPos = this.positionInBuffer(node, remainder - 1);\n                        this.deleteNodeTail(node, previousPos);\n                        value = '\\r' + value;\n                        if (node.piece.length === 0) {\n                            nodesToDel.push(node);\n                        }\n                    }\n                    else {\n                        this.deleteNodeTail(node, insertPosInBuffer);\n                    }\n                }\n                else {\n                    this.deleteNodeTail(node, insertPosInBuffer);\n                }\n                const newPieces = this.createNewPieces(value);\n                if (newRightPiece.length > 0) {\n                    this.rbInsertRight(node, newRightPiece);\n                }\n                let tmpNode = node;\n                for (let k = 0; k < newPieces.length; k++) {\n                    tmpNode = this.rbInsertRight(tmpNode, newPieces[k]);\n                }\n                this.deleteNodes(nodesToDel);\n            }\n            else {\n                this.insertContentToNodeRight(value, node);\n            }\n        }\n        else {\n            // insert new node\n            const pieces = this.createNewPieces(value);\n            let node = this.rbInsertLeft(null, pieces[0]);\n            for (let k = 1; k < pieces.length; k++) {\n                node = this.rbInsertRight(node, pieces[k]);\n            }\n        }\n        // todo, this is too brutal. Total line feed count should be updated the same way as lf_left.\n        this.computeBufferMetadata();\n    }\n    delete(offset, cnt) {\n        this._lastVisitedLine.lineNumber = 0;\n        this._lastVisitedLine.value = '';\n        if (cnt <= 0 || this.root === SENTINEL) {\n            return;\n        }\n        const startPosition = this.nodeAt(offset);\n        const endPosition = this.nodeAt(offset + cnt);\n        const startNode = startPosition.node;\n        const endNode = endPosition.node;\n        if (startNode === endNode) {\n            const startSplitPosInBuffer = this.positionInBuffer(startNode, startPosition.remainder);\n            const endSplitPosInBuffer = this.positionInBuffer(startNode, endPosition.remainder);\n            if (startPosition.nodeStartOffset === offset) {\n                if (cnt === startNode.piece.length) { // delete node\n                    const next = startNode.next();\n                    rbDelete(this, startNode);\n                    this.validateCRLFWithPrevNode(next);\n                    this.computeBufferMetadata();\n                    return;\n                }\n                this.deleteNodeHead(startNode, endSplitPosInBuffer);\n                this._searchCache.validate(offset);\n                this.validateCRLFWithPrevNode(startNode);\n                this.computeBufferMetadata();\n                return;\n            }\n            if (startPosition.nodeStartOffset + startNode.piece.length === offset + cnt) {\n                this.deleteNodeTail(startNode, startSplitPosInBuffer);\n                this.validateCRLFWithNextNode(startNode);\n                this.computeBufferMetadata();\n                return;\n            }\n            // delete content in the middle, this node will be splitted to nodes\n            this.shrinkNode(startNode, startSplitPosInBuffer, endSplitPosInBuffer);\n            this.computeBufferMetadata();\n            return;\n        }\n        const nodesToDel = [];\n        const startSplitPosInBuffer = this.positionInBuffer(startNode, startPosition.remainder);\n        this.deleteNodeTail(startNode, startSplitPosInBuffer);\n        this._searchCache.validate(offset);\n        if (startNode.piece.length === 0) {\n            nodesToDel.push(startNode);\n        }\n        // update last touched node\n        const endSplitPosInBuffer = this.positionInBuffer(endNode, endPosition.remainder);\n        this.deleteNodeHead(endNode, endSplitPosInBuffer);\n        if (endNode.piece.length === 0) {\n            nodesToDel.push(endNode);\n        }\n        // delete nodes in between\n        const secondNode = startNode.next();\n        for (let node = secondNode; node !== SENTINEL && node !== endNode; node = node.next()) {\n            nodesToDel.push(node);\n        }\n        const prev = startNode.piece.length === 0 ? startNode.prev() : startNode;\n        this.deleteNodes(nodesToDel);\n        this.validateCRLFWithNextNode(prev);\n        this.computeBufferMetadata();\n    }\n    insertContentToNodeLeft(value, node) {\n        // we are inserting content to the beginning of node\n        const nodesToDel = [];\n        if (this.shouldCheckCRLF() && this.endWithCR(value) && this.startWithLF(node)) {\n            // move `\\n` to new node.\n            const piece = node.piece;\n            const newStart = { line: piece.start.line + 1, column: 0 };\n            const nPiece = new Piece(piece.bufferIndex, newStart, piece.end, this.getLineFeedCnt(piece.bufferIndex, newStart, piece.end), piece.length - 1);\n            node.piece = nPiece;\n            value += '\\n';\n            updateTreeMetadata(this, node, -1, -1);\n            if (node.piece.length === 0) {\n                nodesToDel.push(node);\n            }\n        }\n        const newPieces = this.createNewPieces(value);\n        let newNode = this.rbInsertLeft(node, newPieces[newPieces.length - 1]);\n        for (let k = newPieces.length - 2; k >= 0; k--) {\n            newNode = this.rbInsertLeft(newNode, newPieces[k]);\n        }\n        this.validateCRLFWithPrevNode(newNode);\n        this.deleteNodes(nodesToDel);\n    }\n    insertContentToNodeRight(value, node) {\n        // we are inserting to the right of this node.\n        if (this.adjustCarriageReturnFromNext(value, node)) {\n            // move \\n to the new node.\n            value += '\\n';\n        }\n        const newPieces = this.createNewPieces(value);\n        const newNode = this.rbInsertRight(node, newPieces[0]);\n        let tmpNode = newNode;\n        for (let k = 1; k < newPieces.length; k++) {\n            tmpNode = this.rbInsertRight(tmpNode, newPieces[k]);\n        }\n        this.validateCRLFWithPrevNode(newNode);\n    }\n    positionInBuffer(node, remainder, ret) {\n        const piece = node.piece;\n        const bufferIndex = node.piece.bufferIndex;\n        const lineStarts = this._buffers[bufferIndex].lineStarts;\n        const startOffset = lineStarts[piece.start.line] + piece.start.column;\n        const offset = startOffset + remainder;\n        // binary search offset between startOffset and endOffset\n        let low = piece.start.line;\n        let high = piece.end.line;\n        let mid = 0;\n        let midStop = 0;\n        let midStart = 0;\n        while (low <= high) {\n            mid = low + ((high - low) / 2) | 0;\n            midStart = lineStarts[mid];\n            if (mid === high) {\n                break;\n            }\n            midStop = lineStarts[mid + 1];\n            if (offset < midStart) {\n                high = mid - 1;\n            }\n            else if (offset >= midStop) {\n                low = mid + 1;\n            }\n            else {\n                break;\n            }\n        }\n        if (ret) {\n            ret.line = mid;\n            ret.column = offset - midStart;\n            return null;\n        }\n        return {\n            line: mid,\n            column: offset - midStart\n        };\n    }\n    getLineFeedCnt(bufferIndex, start, end) {\n        // we don't need to worry about start: abc\\r|\\n, or abc|\\r, or abc|\\n, or abc|\\r\\n doesn't change the fact that, there is one line break after start.\n        // now let's take care of end: abc\\r|\\n, if end is in between \\r and \\n, we need to add line feed count by 1\n        if (end.column === 0) {\n            return end.line - start.line;\n        }\n        const lineStarts = this._buffers[bufferIndex].lineStarts;\n        if (end.line === lineStarts.length - 1) { // it means, there is no \\n after end, otherwise, there will be one more lineStart.\n            return end.line - start.line;\n        }\n        const nextLineStartOffset = lineStarts[end.line + 1];\n        const endOffset = lineStarts[end.line] + end.column;\n        if (nextLineStartOffset > endOffset + 1) { // there are more than 1 character after end, which means it can't be \\n\n            return end.line - start.line;\n        }\n        // endOffset + 1 === nextLineStartOffset\n        // character at endOffset is \\n, so we check the character before first\n        // if character at endOffset is \\r, end.column is 0 and we can't get here.\n        const previousCharOffset = endOffset - 1; // end.column > 0 so it's okay.\n        const buffer = this._buffers[bufferIndex].buffer;\n        if (buffer.charCodeAt(previousCharOffset) === 13) {\n            return end.line - start.line + 1;\n        }\n        else {\n            return end.line - start.line;\n        }\n    }\n    offsetInBuffer(bufferIndex, cursor) {\n        const lineStarts = this._buffers[bufferIndex].lineStarts;\n        return lineStarts[cursor.line] + cursor.column;\n    }\n    deleteNodes(nodes) {\n        for (let i = 0; i < nodes.length; i++) {\n            rbDelete(this, nodes[i]);\n        }\n    }\n    createNewPieces(text) {\n        if (text.length > AverageBufferSize) {\n            // the content is large, operations like substring, charCode becomes slow\n            // so here we split it into smaller chunks, just like what we did for CR/LF normalization\n            const newPieces = [];\n            while (text.length > AverageBufferSize) {\n                const lastChar = text.charCodeAt(AverageBufferSize - 1);\n                let splitText;\n                if (lastChar === 13 /* CharCode.CarriageReturn */ || (lastChar >= 0xD800 && lastChar <= 0xDBFF)) {\n                    // last character is \\r or a high surrogate => keep it back\n                    splitText = text.substring(0, AverageBufferSize - 1);\n                    text = text.substring(AverageBufferSize - 1);\n                }\n                else {\n                    splitText = text.substring(0, AverageBufferSize);\n                    text = text.substring(AverageBufferSize);\n                }\n                const lineStarts = createLineStartsFast(splitText);\n                newPieces.push(new Piece(this._buffers.length, /* buffer index */ { line: 0, column: 0 }, { line: lineStarts.length - 1, column: splitText.length - lineStarts[lineStarts.length - 1] }, lineStarts.length - 1, splitText.length));\n                this._buffers.push(new StringBuffer(splitText, lineStarts));\n            }\n            const lineStarts = createLineStartsFast(text);\n            newPieces.push(new Piece(this._buffers.length, /* buffer index */ { line: 0, column: 0 }, { line: lineStarts.length - 1, column: text.length - lineStarts[lineStarts.length - 1] }, lineStarts.length - 1, text.length));\n            this._buffers.push(new StringBuffer(text, lineStarts));\n            return newPieces;\n        }\n        let startOffset = this._buffers[0].buffer.length;\n        const lineStarts = createLineStartsFast(text, false);\n        let start = this._lastChangeBufferPos;\n        if (this._buffers[0].lineStarts[this._buffers[0].lineStarts.length - 1] === startOffset\n            && startOffset !== 0\n            && this.startWithLF(text)\n            && this.endWithCR(this._buffers[0].buffer) // todo, we can check this._lastChangeBufferPos's column as it's the last one\n        ) {\n            this._lastChangeBufferPos = { line: this._lastChangeBufferPos.line, column: this._lastChangeBufferPos.column + 1 };\n            start = this._lastChangeBufferPos;\n            for (let i = 0; i < lineStarts.length; i++) {\n                lineStarts[i] += startOffset + 1;\n            }\n            this._buffers[0].lineStarts = this._buffers[0].lineStarts.concat(lineStarts.slice(1));\n            this._buffers[0].buffer += '_' + text;\n            startOffset += 1;\n        }\n        else {\n            if (startOffset !== 0) {\n                for (let i = 0; i < lineStarts.length; i++) {\n                    lineStarts[i] += startOffset;\n                }\n            }\n            this._buffers[0].lineStarts = this._buffers[0].lineStarts.concat(lineStarts.slice(1));\n            this._buffers[0].buffer += text;\n        }\n        const endOffset = this._buffers[0].buffer.length;\n        const endIndex = this._buffers[0].lineStarts.length - 1;\n        const endColumn = endOffset - this._buffers[0].lineStarts[endIndex];\n        const endPos = { line: endIndex, column: endColumn };\n        const newPiece = new Piece(0, /** todo@peng */ start, endPos, this.getLineFeedCnt(0, start, endPos), endOffset - startOffset);\n        this._lastChangeBufferPos = endPos;\n        return [newPiece];\n    }\n    getLineRawContent(lineNumber, endOffset = 0) {\n        let x = this.root;\n        let ret = '';\n        const cache = this._searchCache.get2(lineNumber);\n        if (cache) {\n            x = cache.node;\n            const prevAccumulatedValue = this.getAccumulatedValue(x, lineNumber - cache.nodeStartLineNumber - 1);\n            const buffer = this._buffers[x.piece.bufferIndex].buffer;\n            const startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n            if (cache.nodeStartLineNumber + x.piece.lineFeedCnt === lineNumber) {\n                ret = buffer.substring(startOffset + prevAccumulatedValue, startOffset + x.piece.length);\n            }\n            else {\n                const accumulatedValue = this.getAccumulatedValue(x, lineNumber - cache.nodeStartLineNumber);\n                return buffer.substring(startOffset + prevAccumulatedValue, startOffset + accumulatedValue - endOffset);\n            }\n        }\n        else {\n            let nodeStartOffset = 0;\n            const originalLineNumber = lineNumber;\n            while (x !== SENTINEL) {\n                if (x.left !== SENTINEL && x.lf_left >= lineNumber - 1) {\n                    x = x.left;\n                }\n                else if (x.lf_left + x.piece.lineFeedCnt > lineNumber - 1) {\n                    const prevAccumulatedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);\n                    const accumulatedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 1);\n                    const buffer = this._buffers[x.piece.bufferIndex].buffer;\n                    const startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n                    nodeStartOffset += x.size_left;\n                    this._searchCache.set({\n                        node: x,\n                        nodeStartOffset,\n                        nodeStartLineNumber: originalLineNumber - (lineNumber - 1 - x.lf_left)\n                    });\n                    return buffer.substring(startOffset + prevAccumulatedValue, startOffset + accumulatedValue - endOffset);\n                }\n                else if (x.lf_left + x.piece.lineFeedCnt === lineNumber - 1) {\n                    const prevAccumulatedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);\n                    const buffer = this._buffers[x.piece.bufferIndex].buffer;\n                    const startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n                    ret = buffer.substring(startOffset + prevAccumulatedValue, startOffset + x.piece.length);\n                    break;\n                }\n                else {\n                    lineNumber -= x.lf_left + x.piece.lineFeedCnt;\n                    nodeStartOffset += x.size_left + x.piece.length;\n                    x = x.right;\n                }\n            }\n        }\n        // search in order, to find the node contains end column\n        x = x.next();\n        while (x !== SENTINEL) {\n            const buffer = this._buffers[x.piece.bufferIndex].buffer;\n            if (x.piece.lineFeedCnt > 0) {\n                const accumulatedValue = this.getAccumulatedValue(x, 0);\n                const startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n                ret += buffer.substring(startOffset, startOffset + accumulatedValue - endOffset);\n                return ret;\n            }\n            else {\n                const startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n                ret += buffer.substr(startOffset, x.piece.length);\n            }\n            x = x.next();\n        }\n        return ret;\n    }\n    computeBufferMetadata() {\n        let x = this.root;\n        let lfCnt = 1;\n        let len = 0;\n        while (x !== SENTINEL) {\n            lfCnt += x.lf_left + x.piece.lineFeedCnt;\n            len += x.size_left + x.piece.length;\n            x = x.right;\n        }\n        this._lineCnt = lfCnt;\n        this._length = len;\n        this._searchCache.validate(this._length);\n    }\n    // #region node operations\n    getIndexOf(node, accumulatedValue) {\n        const piece = node.piece;\n        const pos = this.positionInBuffer(node, accumulatedValue);\n        const lineCnt = pos.line - piece.start.line;\n        if (this.offsetInBuffer(piece.bufferIndex, piece.end) - this.offsetInBuffer(piece.bufferIndex, piece.start) === accumulatedValue) {\n            // we are checking the end of this node, so a CRLF check is necessary.\n            const realLineCnt = this.getLineFeedCnt(node.piece.bufferIndex, piece.start, pos);\n            if (realLineCnt !== lineCnt) {\n                // aha yes, CRLF\n                return { index: realLineCnt, remainder: 0 };\n            }\n        }\n        return { index: lineCnt, remainder: pos.column };\n    }\n    getAccumulatedValue(node, index) {\n        if (index < 0) {\n            return 0;\n        }\n        const piece = node.piece;\n        const lineStarts = this._buffers[piece.bufferIndex].lineStarts;\n        const expectedLineStartIndex = piece.start.line + index + 1;\n        if (expectedLineStartIndex > piece.end.line) {\n            return lineStarts[piece.end.line] + piece.end.column - lineStarts[piece.start.line] - piece.start.column;\n        }\n        else {\n            return lineStarts[expectedLineStartIndex] - lineStarts[piece.start.line] - piece.start.column;\n        }\n    }\n    deleteNodeTail(node, pos) {\n        const piece = node.piece;\n        const originalLFCnt = piece.lineFeedCnt;\n        const originalEndOffset = this.offsetInBuffer(piece.bufferIndex, piece.end);\n        const newEnd = pos;\n        const newEndOffset = this.offsetInBuffer(piece.bufferIndex, newEnd);\n        const newLineFeedCnt = this.getLineFeedCnt(piece.bufferIndex, piece.start, newEnd);\n        const lf_delta = newLineFeedCnt - originalLFCnt;\n        const size_delta = newEndOffset - originalEndOffset;\n        const newLength = piece.length + size_delta;\n        node.piece = new Piece(piece.bufferIndex, piece.start, newEnd, newLineFeedCnt, newLength);\n        updateTreeMetadata(this, node, size_delta, lf_delta);\n    }\n    deleteNodeHead(node, pos) {\n        const piece = node.piece;\n        const originalLFCnt = piece.lineFeedCnt;\n        const originalStartOffset = this.offsetInBuffer(piece.bufferIndex, piece.start);\n        const newStart = pos;\n        const newLineFeedCnt = this.getLineFeedCnt(piece.bufferIndex, newStart, piece.end);\n        const newStartOffset = this.offsetInBuffer(piece.bufferIndex, newStart);\n        const lf_delta = newLineFeedCnt - originalLFCnt;\n        const size_delta = originalStartOffset - newStartOffset;\n        const newLength = piece.length + size_delta;\n        node.piece = new Piece(piece.bufferIndex, newStart, piece.end, newLineFeedCnt, newLength);\n        updateTreeMetadata(this, node, size_delta, lf_delta);\n    }\n    shrinkNode(node, start, end) {\n        const piece = node.piece;\n        const originalStartPos = piece.start;\n        const originalEndPos = piece.end;\n        // old piece, originalStartPos, start\n        const oldLength = piece.length;\n        const oldLFCnt = piece.lineFeedCnt;\n        const newEnd = start;\n        const newLineFeedCnt = this.getLineFeedCnt(piece.bufferIndex, piece.start, newEnd);\n        const newLength = this.offsetInBuffer(piece.bufferIndex, start) - this.offsetInBuffer(piece.bufferIndex, originalStartPos);\n        node.piece = new Piece(piece.bufferIndex, piece.start, newEnd, newLineFeedCnt, newLength);\n        updateTreeMetadata(this, node, newLength - oldLength, newLineFeedCnt - oldLFCnt);\n        // new right piece, end, originalEndPos\n        const newPiece = new Piece(piece.bufferIndex, end, originalEndPos, this.getLineFeedCnt(piece.bufferIndex, end, originalEndPos), this.offsetInBuffer(piece.bufferIndex, originalEndPos) - this.offsetInBuffer(piece.bufferIndex, end));\n        const newNode = this.rbInsertRight(node, newPiece);\n        this.validateCRLFWithPrevNode(newNode);\n    }\n    appendToNode(node, value) {\n        if (this.adjustCarriageReturnFromNext(value, node)) {\n            value += '\\n';\n        }\n        const hitCRLF = this.shouldCheckCRLF() && this.startWithLF(value) && this.endWithCR(node);\n        const startOffset = this._buffers[0].buffer.length;\n        this._buffers[0].buffer += value;\n        const lineStarts = createLineStartsFast(value, false);\n        for (let i = 0; i < lineStarts.length; i++) {\n            lineStarts[i] += startOffset;\n        }\n        if (hitCRLF) {\n            const prevStartOffset = this._buffers[0].lineStarts[this._buffers[0].lineStarts.length - 2];\n            this._buffers[0].lineStarts.pop();\n            // _lastChangeBufferPos is already wrong\n            this._lastChangeBufferPos = { line: this._lastChangeBufferPos.line - 1, column: startOffset - prevStartOffset };\n        }\n        this._buffers[0].lineStarts = this._buffers[0].lineStarts.concat(lineStarts.slice(1));\n        const endIndex = this._buffers[0].lineStarts.length - 1;\n        const endColumn = this._buffers[0].buffer.length - this._buffers[0].lineStarts[endIndex];\n        const newEnd = { line: endIndex, column: endColumn };\n        const newLength = node.piece.length + value.length;\n        const oldLineFeedCnt = node.piece.lineFeedCnt;\n        const newLineFeedCnt = this.getLineFeedCnt(0, node.piece.start, newEnd);\n        const lf_delta = newLineFeedCnt - oldLineFeedCnt;\n        node.piece = new Piece(node.piece.bufferIndex, node.piece.start, newEnd, newLineFeedCnt, newLength);\n        this._lastChangeBufferPos = newEnd;\n        updateTreeMetadata(this, node, value.length, lf_delta);\n    }\n    nodeAt(offset) {\n        let x = this.root;\n        const cache = this._searchCache.get(offset);\n        if (cache) {\n            return {\n                node: cache.node,\n                nodeStartOffset: cache.nodeStartOffset,\n                remainder: offset - cache.nodeStartOffset\n            };\n        }\n        let nodeStartOffset = 0;\n        while (x !== SENTINEL) {\n            if (x.size_left > offset) {\n                x = x.left;\n            }\n            else if (x.size_left + x.piece.length >= offset) {\n                nodeStartOffset += x.size_left;\n                const ret = {\n                    node: x,\n                    remainder: offset - x.size_left,\n                    nodeStartOffset\n                };\n                this._searchCache.set(ret);\n                return ret;\n            }\n            else {\n                offset -= x.size_left + x.piece.length;\n                nodeStartOffset += x.size_left + x.piece.length;\n                x = x.right;\n            }\n        }\n        return null;\n    }\n    nodeAt2(lineNumber, column) {\n        let x = this.root;\n        let nodeStartOffset = 0;\n        while (x !== SENTINEL) {\n            if (x.left !== SENTINEL && x.lf_left >= lineNumber - 1) {\n                x = x.left;\n            }\n            else if (x.lf_left + x.piece.lineFeedCnt > lineNumber - 1) {\n                const prevAccumualtedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);\n                const accumulatedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 1);\n                nodeStartOffset += x.size_left;\n                return {\n                    node: x,\n                    remainder: Math.min(prevAccumualtedValue + column - 1, accumulatedValue),\n                    nodeStartOffset\n                };\n            }\n            else if (x.lf_left + x.piece.lineFeedCnt === lineNumber - 1) {\n                const prevAccumualtedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);\n                if (prevAccumualtedValue + column - 1 <= x.piece.length) {\n                    return {\n                        node: x,\n                        remainder: prevAccumualtedValue + column - 1,\n                        nodeStartOffset\n                    };\n                }\n                else {\n                    column -= x.piece.length - prevAccumualtedValue;\n                    break;\n                }\n            }\n            else {\n                lineNumber -= x.lf_left + x.piece.lineFeedCnt;\n                nodeStartOffset += x.size_left + x.piece.length;\n                x = x.right;\n            }\n        }\n        // search in order, to find the node contains position.column\n        x = x.next();\n        while (x !== SENTINEL) {\n            if (x.piece.lineFeedCnt > 0) {\n                const accumulatedValue = this.getAccumulatedValue(x, 0);\n                const nodeStartOffset = this.offsetOfNode(x);\n                return {\n                    node: x,\n                    remainder: Math.min(column - 1, accumulatedValue),\n                    nodeStartOffset\n                };\n            }\n            else {\n                if (x.piece.length >= column - 1) {\n                    const nodeStartOffset = this.offsetOfNode(x);\n                    return {\n                        node: x,\n                        remainder: column - 1,\n                        nodeStartOffset\n                    };\n                }\n                else {\n                    column -= x.piece.length;\n                }\n            }\n            x = x.next();\n        }\n        return null;\n    }\n    nodeCharCodeAt(node, offset) {\n        if (node.piece.lineFeedCnt < 1) {\n            return -1;\n        }\n        const buffer = this._buffers[node.piece.bufferIndex];\n        const newOffset = this.offsetInBuffer(node.piece.bufferIndex, node.piece.start) + offset;\n        return buffer.buffer.charCodeAt(newOffset);\n    }\n    offsetOfNode(node) {\n        if (!node) {\n            return 0;\n        }\n        let pos = node.size_left;\n        while (node !== this.root) {\n            if (node.parent.right === node) {\n                pos += node.parent.size_left + node.parent.piece.length;\n            }\n            node = node.parent;\n        }\n        return pos;\n    }\n    // #endregion\n    // #region CRLF\n    shouldCheckCRLF() {\n        return !(this._EOLNormalized && this._EOL === '\\n');\n    }\n    startWithLF(val) {\n        if (typeof val === 'string') {\n            return val.charCodeAt(0) === 10;\n        }\n        if (val === SENTINEL || val.piece.lineFeedCnt === 0) {\n            return false;\n        }\n        const piece = val.piece;\n        const lineStarts = this._buffers[piece.bufferIndex].lineStarts;\n        const line = piece.start.line;\n        const startOffset = lineStarts[line] + piece.start.column;\n        if (line === lineStarts.length - 1) {\n            // last line, so there is no line feed at the end of this line\n            return false;\n        }\n        const nextLineOffset = lineStarts[line + 1];\n        if (nextLineOffset > startOffset + 1) {\n            return false;\n        }\n        return this._buffers[piece.bufferIndex].buffer.charCodeAt(startOffset) === 10;\n    }\n    endWithCR(val) {\n        if (typeof val === 'string') {\n            return val.charCodeAt(val.length - 1) === 13;\n        }\n        if (val === SENTINEL || val.piece.lineFeedCnt === 0) {\n            return false;\n        }\n        return this.nodeCharCodeAt(val, val.piece.length - 1) === 13;\n    }\n    validateCRLFWithPrevNode(nextNode) {\n        if (this.shouldCheckCRLF() && this.startWithLF(nextNode)) {\n            const node = nextNode.prev();\n            if (this.endWithCR(node)) {\n                this.fixCRLF(node, nextNode);\n            }\n        }\n    }\n    validateCRLFWithNextNode(node) {\n        if (this.shouldCheckCRLF() && this.endWithCR(node)) {\n            const nextNode = node.next();\n            if (this.startWithLF(nextNode)) {\n                this.fixCRLF(node, nextNode);\n            }\n        }\n    }\n    fixCRLF(prev, next) {\n        const nodesToDel = [];\n        // update node\n        const lineStarts = this._buffers[prev.piece.bufferIndex].lineStarts;\n        let newEnd;\n        if (prev.piece.end.column === 0) {\n            // it means, last line ends with \\r, not \\r\\n\n            newEnd = { line: prev.piece.end.line - 1, column: lineStarts[prev.piece.end.line] - lineStarts[prev.piece.end.line - 1] - 1 };\n        }\n        else {\n            // \\r\\n\n            newEnd = { line: prev.piece.end.line, column: prev.piece.end.column - 1 };\n        }\n        const prevNewLength = prev.piece.length - 1;\n        const prevNewLFCnt = prev.piece.lineFeedCnt - 1;\n        prev.piece = new Piece(prev.piece.bufferIndex, prev.piece.start, newEnd, prevNewLFCnt, prevNewLength);\n        updateTreeMetadata(this, prev, -1, -1);\n        if (prev.piece.length === 0) {\n            nodesToDel.push(prev);\n        }\n        // update nextNode\n        const newStart = { line: next.piece.start.line + 1, column: 0 };\n        const newLength = next.piece.length - 1;\n        const newLineFeedCnt = this.getLineFeedCnt(next.piece.bufferIndex, newStart, next.piece.end);\n        next.piece = new Piece(next.piece.bufferIndex, newStart, next.piece.end, newLineFeedCnt, newLength);\n        updateTreeMetadata(this, next, -1, -1);\n        if (next.piece.length === 0) {\n            nodesToDel.push(next);\n        }\n        // create new piece which contains \\r\\n\n        const pieces = this.createNewPieces('\\r\\n');\n        this.rbInsertRight(prev, pieces[0]);\n        // delete empty nodes\n        for (let i = 0; i < nodesToDel.length; i++) {\n            rbDelete(this, nodesToDel[i]);\n        }\n    }\n    adjustCarriageReturnFromNext(value, node) {\n        if (this.shouldCheckCRLF() && this.endWithCR(value)) {\n            const nextNode = node.next();\n            if (this.startWithLF(nextNode)) {\n                // move `\\n` forward\n                value += '\\n';\n                if (nextNode.piece.length === 1) {\n                    rbDelete(this, nextNode);\n                }\n                else {\n                    const piece = nextNode.piece;\n                    const newStart = { line: piece.start.line + 1, column: 0 };\n                    const newLength = piece.length - 1;\n                    const newLineFeedCnt = this.getLineFeedCnt(piece.bufferIndex, newStart, piece.end);\n                    nextNode.piece = new Piece(piece.bufferIndex, newStart, piece.end, newLineFeedCnt, newLength);\n                    updateTreeMetadata(this, nextNode, -1, -1);\n                }\n                return true;\n            }\n        }\n        return false;\n    }\n    // #endregion\n    // #endregion\n    // #region Tree operations\n    iterate(node, callback) {\n        if (node === SENTINEL) {\n            return callback(SENTINEL);\n        }\n        const leftRet = this.iterate(node.left, callback);\n        if (!leftRet) {\n            return leftRet;\n        }\n        return callback(node) && this.iterate(node.right, callback);\n    }\n    getNodeContent(node) {\n        if (node === SENTINEL) {\n            return '';\n        }\n        const buffer = this._buffers[node.piece.bufferIndex];\n        const piece = node.piece;\n        const startOffset = this.offsetInBuffer(piece.bufferIndex, piece.start);\n        const endOffset = this.offsetInBuffer(piece.bufferIndex, piece.end);\n        const currentContent = buffer.buffer.substring(startOffset, endOffset);\n        return currentContent;\n    }\n    getPieceContent(piece) {\n        const buffer = this._buffers[piece.bufferIndex];\n        const startOffset = this.offsetInBuffer(piece.bufferIndex, piece.start);\n        const endOffset = this.offsetInBuffer(piece.bufferIndex, piece.end);\n        const currentContent = buffer.buffer.substring(startOffset, endOffset);\n        return currentContent;\n    }\n    /**\n     *      node              node\n     *     /  \\              /  \\\n     *    a   b    <----   a    b\n     *                         /\n     *                        z\n     */\n    rbInsertRight(node, p) {\n        const z = new TreeNode(p, 1 /* NodeColor.Red */);\n        z.left = SENTINEL;\n        z.right = SENTINEL;\n        z.parent = SENTINEL;\n        z.size_left = 0;\n        z.lf_left = 0;\n        const x = this.root;\n        if (x === SENTINEL) {\n            this.root = z;\n            z.color = 0 /* NodeColor.Black */;\n        }\n        else if (node.right === SENTINEL) {\n            node.right = z;\n            z.parent = node;\n        }\n        else {\n            const nextNode = leftest(node.right);\n            nextNode.left = z;\n            z.parent = nextNode;\n        }\n        fixInsert(this, z);\n        return z;\n    }\n    /**\n     *      node              node\n     *     /  \\              /  \\\n     *    a   b     ---->   a    b\n     *                       \\\n     *                        z\n     */\n    rbInsertLeft(node, p) {\n        const z = new TreeNode(p, 1 /* NodeColor.Red */);\n        z.left = SENTINEL;\n        z.right = SENTINEL;\n        z.parent = SENTINEL;\n        z.size_left = 0;\n        z.lf_left = 0;\n        if (this.root === SENTINEL) {\n            this.root = z;\n            z.color = 0 /* NodeColor.Black */;\n        }\n        else if (node.left === SENTINEL) {\n            node.left = z;\n            z.parent = node;\n        }\n        else {\n            const prevNode = righttest(node.left); // a\n            prevNode.right = z;\n            z.parent = prevNode;\n        }\n        fixInsert(this, z);\n        return z;\n    }\n}\n\nexport { Piece, PieceTreeBase, StringBuffer, createLineStarts, createLineStartsFast };\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 7775, "column": 0}, "map": {"version":3,"sources":["file:///D:/real-time-code-editor%20%282%29/node_modules/.pnpm/monaco-editor%400.55.1/node_modules/monaco-editor/esm/vs/editor/common/model/pieceTreeTextBuffer/pieceTreeTextBuffer.js"],"sourcesContent":["import { Emitter } from '../../../../base/common/event.js';\nimport { isHighSurrogate, firstNonWhitespaceIndex, lastNonWhitespaceIndex, isBasicASCII, containsRTL, containsUnusualLineTerminators } from '../../../../base/common/strings.js';\nimport { Range } from '../../core/range.js';\nimport { ApplyEditsResult } from '../../model.js';\nimport { PieceTreeBase } from './pieceTreeBase.js';\nimport { countEOL } from '../../core/misc/eolCounter.js';\nimport { TextChange } from '../../core/textChange.js';\nimport { Disposable } from '../../../../base/common/lifecycle.js';\n\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nclass PieceTreeTextBuffer extends Disposable {\n    constructor(chunks, BOM, eol, containsRTL, containsUnusualLineTerminators, isBasicASCII, eolNormalized) {\n        super();\n        this._onDidChangeContent = this._register(new Emitter());\n        this._BOM = BOM;\n        this._mightContainNonBasicASCII = !isBasicASCII;\n        this._mightContainRTL = containsRTL;\n        this._mightContainUnusualLineTerminators = containsUnusualLineTerminators;\n        this._pieceTree = new PieceTreeBase(chunks, eol, eolNormalized);\n    }\n    mightContainRTL() {\n        return this._mightContainRTL;\n    }\n    mightContainUnusualLineTerminators() {\n        return this._mightContainUnusualLineTerminators;\n    }\n    resetMightContainUnusualLineTerminators() {\n        this._mightContainUnusualLineTerminators = false;\n    }\n    mightContainNonBasicASCII() {\n        return this._mightContainNonBasicASCII;\n    }\n    getBOM() {\n        return this._BOM;\n    }\n    getEOL() {\n        return this._pieceTree.getEOL();\n    }\n    createSnapshot(preserveBOM) {\n        return this._pieceTree.createSnapshot(preserveBOM ? this._BOM : '');\n    }\n    getOffsetAt(lineNumber, column) {\n        return this._pieceTree.getOffsetAt(lineNumber, column);\n    }\n    getPositionAt(offset) {\n        return this._pieceTree.getPositionAt(offset);\n    }\n    getRangeAt(start, length) {\n        const end = start + length;\n        const startPosition = this.getPositionAt(start);\n        const endPosition = this.getPositionAt(end);\n        return new Range(startPosition.lineNumber, startPosition.column, endPosition.lineNumber, endPosition.column);\n    }\n    getValueInRange(range, eol = 0 /* EndOfLinePreference.TextDefined */) {\n        if (range.isEmpty()) {\n            return '';\n        }\n        const lineEnding = this._getEndOfLine(eol);\n        return this._pieceTree.getValueInRange(range, lineEnding);\n    }\n    getValueLengthInRange(range, eol = 0 /* EndOfLinePreference.TextDefined */) {\n        if (range.isEmpty()) {\n            return 0;\n        }\n        if (range.startLineNumber === range.endLineNumber) {\n            return (range.endColumn - range.startColumn);\n        }\n        const startOffset = this.getOffsetAt(range.startLineNumber, range.startColumn);\n        const endOffset = this.getOffsetAt(range.endLineNumber, range.endColumn);\n        // offsets use the text EOL, so we need to compensate for length differences\n        // if the requested EOL doesn't match the text EOL\n        let eolOffsetCompensation = 0;\n        const desiredEOL = this._getEndOfLine(eol);\n        const actualEOL = this.getEOL();\n        if (desiredEOL.length !== actualEOL.length) {\n            const delta = desiredEOL.length - actualEOL.length;\n            const eolCount = range.endLineNumber - range.startLineNumber;\n            eolOffsetCompensation = delta * eolCount;\n        }\n        return endOffset - startOffset + eolOffsetCompensation;\n    }\n    getCharacterCountInRange(range, eol = 0 /* EndOfLinePreference.TextDefined */) {\n        if (this._mightContainNonBasicASCII) {\n            // we must count by iterating\n            let result = 0;\n            const fromLineNumber = range.startLineNumber;\n            const toLineNumber = range.endLineNumber;\n            for (let lineNumber = fromLineNumber; lineNumber <= toLineNumber; lineNumber++) {\n                const lineContent = this.getLineContent(lineNumber);\n                const fromOffset = (lineNumber === fromLineNumber ? range.startColumn - 1 : 0);\n                const toOffset = (lineNumber === toLineNumber ? range.endColumn - 1 : lineContent.length);\n                for (let offset = fromOffset; offset < toOffset; offset++) {\n                    if (isHighSurrogate(lineContent.charCodeAt(offset))) {\n                        result = result + 1;\n                        offset = offset + 1;\n                    }\n                    else {\n                        result = result + 1;\n                    }\n                }\n            }\n            result += this._getEndOfLine(eol).length * (toLineNumber - fromLineNumber);\n            return result;\n        }\n        return this.getValueLengthInRange(range, eol);\n    }\n    getNearestChunk(offset) {\n        return this._pieceTree.getNearestChunk(offset);\n    }\n    getLength() {\n        return this._pieceTree.getLength();\n    }\n    getLineCount() {\n        return this._pieceTree.getLineCount();\n    }\n    getLinesContent() {\n        return this._pieceTree.getLinesContent();\n    }\n    getLineContent(lineNumber) {\n        return this._pieceTree.getLineContent(lineNumber);\n    }\n    getLineCharCode(lineNumber, index) {\n        return this._pieceTree.getLineCharCode(lineNumber, index);\n    }\n    getLineLength(lineNumber) {\n        return this._pieceTree.getLineLength(lineNumber);\n    }\n    getLineFirstNonWhitespaceColumn(lineNumber) {\n        const result = firstNonWhitespaceIndex(this.getLineContent(lineNumber));\n        if (result === -1) {\n            return 0;\n        }\n        return result + 1;\n    }\n    getLineLastNonWhitespaceColumn(lineNumber) {\n        const result = lastNonWhitespaceIndex(this.getLineContent(lineNumber));\n        if (result === -1) {\n            return 0;\n        }\n        return result + 2;\n    }\n    _getEndOfLine(eol) {\n        switch (eol) {\n            case 1 /* EndOfLinePreference.LF */:\n                return '\\n';\n            case 2 /* EndOfLinePreference.CRLF */:\n                return '\\r\\n';\n            case 0 /* EndOfLinePreference.TextDefined */:\n                return this.getEOL();\n            default:\n                throw new Error('Unknown EOL preference');\n        }\n    }\n    setEOL(newEOL) {\n        this._pieceTree.setEOL(newEOL);\n    }\n    applyEdits(rawOperations, recordTrimAutoWhitespace, computeUndoEdits) {\n        let mightContainRTL = this._mightContainRTL;\n        let mightContainUnusualLineTerminators = this._mightContainUnusualLineTerminators;\n        let mightContainNonBasicASCII = this._mightContainNonBasicASCII;\n        let canReduceOperations = true;\n        let operations = [];\n        for (let i = 0; i < rawOperations.length; i++) {\n            const op = rawOperations[i];\n            if (canReduceOperations && op._isTracked) {\n                canReduceOperations = false;\n            }\n            const validatedRange = op.range;\n            if (op.text) {\n                let textMightContainNonBasicASCII = true;\n                if (!mightContainNonBasicASCII) {\n                    textMightContainNonBasicASCII = !isBasicASCII(op.text);\n                    mightContainNonBasicASCII = textMightContainNonBasicASCII;\n                }\n                if (!mightContainRTL && textMightContainNonBasicASCII) {\n                    // check if the new inserted text contains RTL\n                    mightContainRTL = containsRTL(op.text);\n                }\n                if (!mightContainUnusualLineTerminators && textMightContainNonBasicASCII) {\n                    // check if the new inserted text contains unusual line terminators\n                    mightContainUnusualLineTerminators = containsUnusualLineTerminators(op.text);\n                }\n            }\n            let validText = '';\n            let eolCount = 0;\n            let firstLineLength = 0;\n            let lastLineLength = 0;\n            if (op.text) {\n                let strEOL;\n                [eolCount, firstLineLength, lastLineLength, strEOL] = countEOL(op.text);\n                const bufferEOL = this.getEOL();\n                const expectedStrEOL = (bufferEOL === '\\r\\n' ? 2 /* StringEOL.CRLF */ : 1 /* StringEOL.LF */);\n                if (strEOL === 0 /* StringEOL.Unknown */ || strEOL === expectedStrEOL) {\n                    validText = op.text;\n                }\n                else {\n                    validText = op.text.replace(/\\r\\n|\\r|\\n/g, bufferEOL);\n                }\n            }\n            operations[i] = {\n                sortIndex: i,\n                identifier: op.identifier || null,\n                range: validatedRange,\n                rangeOffset: this.getOffsetAt(validatedRange.startLineNumber, validatedRange.startColumn),\n                rangeLength: this.getValueLengthInRange(validatedRange),\n                text: validText,\n                eolCount: eolCount,\n                firstLineLength: firstLineLength,\n                lastLineLength: lastLineLength,\n                forceMoveMarkers: Boolean(op.forceMoveMarkers),\n                isAutoWhitespaceEdit: op.isAutoWhitespaceEdit || false\n            };\n        }\n        // Sort operations ascending\n        operations.sort(PieceTreeTextBuffer._sortOpsAscending);\n        let hasTouchingRanges = false;\n        for (let i = 0, count = operations.length - 1; i < count; i++) {\n            const rangeEnd = operations[i].range.getEndPosition();\n            const nextRangeStart = operations[i + 1].range.getStartPosition();\n            if (nextRangeStart.isBeforeOrEqual(rangeEnd)) {\n                if (nextRangeStart.isBefore(rangeEnd)) {\n                    // overlapping ranges\n                    throw new Error('Overlapping ranges are not allowed!');\n                }\n                hasTouchingRanges = true;\n            }\n        }\n        if (canReduceOperations) {\n            operations = this._reduceOperations(operations);\n        }\n        // Delta encode operations\n        const reverseRanges = (computeUndoEdits || recordTrimAutoWhitespace ? PieceTreeTextBuffer._getInverseEditRanges(operations) : []);\n        const newTrimAutoWhitespaceCandidates = [];\n        if (recordTrimAutoWhitespace) {\n            for (let i = 0; i < operations.length; i++) {\n                const op = operations[i];\n                const reverseRange = reverseRanges[i];\n                if (op.isAutoWhitespaceEdit && op.range.isEmpty()) {\n                    // Record already the future line numbers that might be auto whitespace removal candidates on next edit\n                    for (let lineNumber = reverseRange.startLineNumber; lineNumber <= reverseRange.endLineNumber; lineNumber++) {\n                        let currentLineContent = '';\n                        if (lineNumber === reverseRange.startLineNumber) {\n                            currentLineContent = this.getLineContent(op.range.startLineNumber);\n                            if (firstNonWhitespaceIndex(currentLineContent) !== -1) {\n                                continue;\n                            }\n                        }\n                        newTrimAutoWhitespaceCandidates.push({ lineNumber: lineNumber, oldContent: currentLineContent });\n                    }\n                }\n            }\n        }\n        let reverseOperations = null;\n        if (computeUndoEdits) {\n            let reverseRangeDeltaOffset = 0;\n            reverseOperations = [];\n            for (let i = 0; i < operations.length; i++) {\n                const op = operations[i];\n                const reverseRange = reverseRanges[i];\n                const bufferText = this.getValueInRange(op.range);\n                const reverseRangeOffset = op.rangeOffset + reverseRangeDeltaOffset;\n                reverseRangeDeltaOffset += (op.text.length - bufferText.length);\n                reverseOperations[i] = {\n                    sortIndex: op.sortIndex,\n                    identifier: op.identifier,\n                    range: reverseRange,\n                    text: bufferText,\n                    textChange: new TextChange(op.rangeOffset, bufferText, reverseRangeOffset, op.text)\n                };\n            }\n            // Can only sort reverse operations when the order is not significant\n            if (!hasTouchingRanges) {\n                reverseOperations.sort((a, b) => a.sortIndex - b.sortIndex);\n            }\n        }\n        this._mightContainRTL = mightContainRTL;\n        this._mightContainUnusualLineTerminators = mightContainUnusualLineTerminators;\n        this._mightContainNonBasicASCII = mightContainNonBasicASCII;\n        const contentChanges = this._doApplyEdits(operations);\n        let trimAutoWhitespaceLineNumbers = null;\n        if (recordTrimAutoWhitespace && newTrimAutoWhitespaceCandidates.length > 0) {\n            // sort line numbers auto whitespace removal candidates for next edit descending\n            newTrimAutoWhitespaceCandidates.sort((a, b) => b.lineNumber - a.lineNumber);\n            trimAutoWhitespaceLineNumbers = [];\n            for (let i = 0, len = newTrimAutoWhitespaceCandidates.length; i < len; i++) {\n                const lineNumber = newTrimAutoWhitespaceCandidates[i].lineNumber;\n                if (i > 0 && newTrimAutoWhitespaceCandidates[i - 1].lineNumber === lineNumber) {\n                    // Do not have the same line number twice\n                    continue;\n                }\n                const prevContent = newTrimAutoWhitespaceCandidates[i].oldContent;\n                const lineContent = this.getLineContent(lineNumber);\n                if (lineContent.length === 0 || lineContent === prevContent || firstNonWhitespaceIndex(lineContent) !== -1) {\n                    continue;\n                }\n                trimAutoWhitespaceLineNumbers.push(lineNumber);\n            }\n        }\n        this._onDidChangeContent.fire();\n        return new ApplyEditsResult(reverseOperations, contentChanges, trimAutoWhitespaceLineNumbers);\n    }\n    /**\n     * Transform operations such that they represent the same logic edit,\n     * but that they also do not cause OOM crashes.\n     */\n    _reduceOperations(operations) {\n        if (operations.length < 1000) {\n            // We know from empirical testing that a thousand edits work fine regardless of their shape.\n            return operations;\n        }\n        // At one point, due to how events are emitted and how each operation is handled,\n        // some operations can trigger a high amount of temporary string allocations,\n        // that will immediately get edited again.\n        // e.g. a formatter inserting ridiculous ammounts of \\n on a model with a single line\n        // Therefore, the strategy is to collapse all the operations into a huge single edit operation\n        return [this._toSingleEditOperation(operations)];\n    }\n    _toSingleEditOperation(operations) {\n        let forceMoveMarkers = false;\n        const firstEditRange = operations[0].range;\n        const lastEditRange = operations[operations.length - 1].range;\n        const entireEditRange = new Range(firstEditRange.startLineNumber, firstEditRange.startColumn, lastEditRange.endLineNumber, lastEditRange.endColumn);\n        let lastEndLineNumber = firstEditRange.startLineNumber;\n        let lastEndColumn = firstEditRange.startColumn;\n        const result = [];\n        for (let i = 0, len = operations.length; i < len; i++) {\n            const operation = operations[i];\n            const range = operation.range;\n            forceMoveMarkers = forceMoveMarkers || operation.forceMoveMarkers;\n            // (1) -- Push old text\n            result.push(this.getValueInRange(new Range(lastEndLineNumber, lastEndColumn, range.startLineNumber, range.startColumn)));\n            // (2) -- Push new text\n            if (operation.text.length > 0) {\n                result.push(operation.text);\n            }\n            lastEndLineNumber = range.endLineNumber;\n            lastEndColumn = range.endColumn;\n        }\n        const text = result.join('');\n        const [eolCount, firstLineLength, lastLineLength] = countEOL(text);\n        return {\n            sortIndex: 0,\n            identifier: operations[0].identifier,\n            range: entireEditRange,\n            rangeOffset: this.getOffsetAt(entireEditRange.startLineNumber, entireEditRange.startColumn),\n            rangeLength: this.getValueLengthInRange(entireEditRange, 0 /* EndOfLinePreference.TextDefined */),\n            text: text,\n            eolCount: eolCount,\n            firstLineLength: firstLineLength,\n            lastLineLength: lastLineLength,\n            forceMoveMarkers: forceMoveMarkers,\n            isAutoWhitespaceEdit: false\n        };\n    }\n    _doApplyEdits(operations) {\n        operations.sort(PieceTreeTextBuffer._sortOpsDescending);\n        const contentChanges = [];\n        // operations are from bottom to top\n        for (let i = 0; i < operations.length; i++) {\n            const op = operations[i];\n            const startLineNumber = op.range.startLineNumber;\n            const startColumn = op.range.startColumn;\n            const endLineNumber = op.range.endLineNumber;\n            const endColumn = op.range.endColumn;\n            if (startLineNumber === endLineNumber && startColumn === endColumn && op.text.length === 0) {\n                // no-op\n                continue;\n            }\n            if (op.text) {\n                // replacement\n                this._pieceTree.delete(op.rangeOffset, op.rangeLength);\n                this._pieceTree.insert(op.rangeOffset, op.text, true);\n            }\n            else {\n                // deletion\n                this._pieceTree.delete(op.rangeOffset, op.rangeLength);\n            }\n            const contentChangeRange = new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n            contentChanges.push({\n                range: contentChangeRange,\n                rangeLength: op.rangeLength,\n                text: op.text,\n                rangeOffset: op.rangeOffset,\n                forceMoveMarkers: op.forceMoveMarkers\n            });\n        }\n        return contentChanges;\n    }\n    findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount) {\n        return this._pieceTree.findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount);\n    }\n    /**\n     * Assumes `operations` are validated and sorted ascending\n     */\n    static _getInverseEditRanges(operations) {\n        const result = [];\n        let prevOpEndLineNumber = 0;\n        let prevOpEndColumn = 0;\n        let prevOp = null;\n        for (let i = 0, len = operations.length; i < len; i++) {\n            const op = operations[i];\n            let startLineNumber;\n            let startColumn;\n            if (prevOp) {\n                if (prevOp.range.endLineNumber === op.range.startLineNumber) {\n                    startLineNumber = prevOpEndLineNumber;\n                    startColumn = prevOpEndColumn + (op.range.startColumn - prevOp.range.endColumn);\n                }\n                else {\n                    startLineNumber = prevOpEndLineNumber + (op.range.startLineNumber - prevOp.range.endLineNumber);\n                    startColumn = op.range.startColumn;\n                }\n            }\n            else {\n                startLineNumber = op.range.startLineNumber;\n                startColumn = op.range.startColumn;\n            }\n            let resultRange;\n            if (op.text.length > 0) {\n                // the operation inserts something\n                const lineCount = op.eolCount + 1;\n                if (lineCount === 1) {\n                    // single line insert\n                    resultRange = new Range(startLineNumber, startColumn, startLineNumber, startColumn + op.firstLineLength);\n                }\n                else {\n                    // multi line insert\n                    resultRange = new Range(startLineNumber, startColumn, startLineNumber + lineCount - 1, op.lastLineLength + 1);\n                }\n            }\n            else {\n                // There is nothing to insert\n                resultRange = new Range(startLineNumber, startColumn, startLineNumber, startColumn);\n            }\n            prevOpEndLineNumber = resultRange.endLineNumber;\n            prevOpEndColumn = resultRange.endColumn;\n            result.push(resultRange);\n            prevOp = op;\n        }\n        return result;\n    }\n    static _sortOpsAscending(a, b) {\n        const r = Range.compareRangesUsingEnds(a.range, b.range);\n        if (r === 0) {\n            return a.sortIndex - b.sortIndex;\n        }\n        return r;\n    }\n    static _sortOpsDescending(a, b) {\n        const r = Range.compareRangesUsingEnds(a.range, b.range);\n        if (r === 0) {\n            return b.sortIndex - a.sortIndex;\n        }\n        return -r;\n    }\n}\n\nexport { PieceTreeTextBuffer };\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 8243, "column": 0}, "map": {"version":3,"sources":["file:///D:/real-time-code-editor%20%282%29/node_modules/.pnpm/monaco-editor%400.55.1/node_modules/monaco-editor/esm/vs/editor/common/model/pieceTreeTextBuffer/pieceTreeTextBufferBuilder.js"],"sourcesContent":["import { startsWithUTF8BOM, UTF8_BOM_CHARACTER, containsRTL, containsUnusualLineTerminators } from '../../../../base/common/strings.js';\nimport { createLineStarts, StringBuffer, createLineStartsFast } from './pieceTreeBase.js';\nimport { PieceTreeTextBuffer } from './pieceTreeTextBuffer.js';\n\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nclass PieceTreeTextBufferFactory {\n    constructor(_chunks, _bom, _cr, _lf, _crlf, _containsRTL, _containsUnusualLineTerminators, _isBasicASCII, _normalizeEOL) {\n        this._chunks = _chunks;\n        this._bom = _bom;\n        this._cr = _cr;\n        this._lf = _lf;\n        this._crlf = _crlf;\n        this._containsRTL = _containsRTL;\n        this._containsUnusualLineTerminators = _containsUnusualLineTerminators;\n        this._isBasicASCII = _isBasicASCII;\n        this._normalizeEOL = _normalizeEOL;\n    }\n    _getEOL(defaultEOL) {\n        const totalEOLCount = this._cr + this._lf + this._crlf;\n        const totalCRCount = this._cr + this._crlf;\n        if (totalEOLCount === 0) {\n            // This is an empty file or a file with precisely one line\n            return (defaultEOL === 1 /* DefaultEndOfLine.LF */ ? '\\n' : '\\r\\n');\n        }\n        if (totalCRCount > totalEOLCount / 2) {\n            // More than half of the file contains \\r\\n ending lines\n            return '\\r\\n';\n        }\n        // At least one line more ends in \\n\n        return '\\n';\n    }\n    create(defaultEOL) {\n        const eol = this._getEOL(defaultEOL);\n        const chunks = this._chunks;\n        if (this._normalizeEOL &&\n            ((eol === '\\r\\n' && (this._cr > 0 || this._lf > 0))\n                || (eol === '\\n' && (this._cr > 0 || this._crlf > 0)))) {\n            // Normalize pieces\n            for (let i = 0, len = chunks.length; i < len; i++) {\n                const str = chunks[i].buffer.replace(/\\r\\n|\\r|\\n/g, eol);\n                const newLineStart = createLineStartsFast(str);\n                chunks[i] = new StringBuffer(str, newLineStart);\n            }\n        }\n        const textBuffer = new PieceTreeTextBuffer(chunks, this._bom, eol, this._containsRTL, this._containsUnusualLineTerminators, this._isBasicASCII, this._normalizeEOL);\n        return { textBuffer: textBuffer, disposable: textBuffer };\n    }\n}\nclass PieceTreeTextBufferBuilder {\n    constructor() {\n        this.chunks = [];\n        this.BOM = '';\n        this._hasPreviousChar = false;\n        this._previousChar = 0;\n        this._tmpLineStarts = [];\n        this.cr = 0;\n        this.lf = 0;\n        this.crlf = 0;\n        this.containsRTL = false;\n        this.containsUnusualLineTerminators = false;\n        this.isBasicASCII = true;\n    }\n    acceptChunk(chunk) {\n        if (chunk.length === 0) {\n            return;\n        }\n        if (this.chunks.length === 0) {\n            if (startsWithUTF8BOM(chunk)) {\n                this.BOM = UTF8_BOM_CHARACTER;\n                chunk = chunk.substr(1);\n            }\n        }\n        const lastChar = chunk.charCodeAt(chunk.length - 1);\n        if (lastChar === 13 /* CharCode.CarriageReturn */ || (lastChar >= 0xD800 && lastChar <= 0xDBFF)) {\n            // last character is \\r or a high surrogate => keep it back\n            this._acceptChunk1(chunk.substr(0, chunk.length - 1), false);\n            this._hasPreviousChar = true;\n            this._previousChar = lastChar;\n        }\n        else {\n            this._acceptChunk1(chunk, false);\n            this._hasPreviousChar = false;\n            this._previousChar = lastChar;\n        }\n    }\n    _acceptChunk1(chunk, allowEmptyStrings) {\n        if (!allowEmptyStrings && chunk.length === 0) {\n            // Nothing to do\n            return;\n        }\n        if (this._hasPreviousChar) {\n            this._acceptChunk2(String.fromCharCode(this._previousChar) + chunk);\n        }\n        else {\n            this._acceptChunk2(chunk);\n        }\n    }\n    _acceptChunk2(chunk) {\n        const lineStarts = createLineStarts(this._tmpLineStarts, chunk);\n        this.chunks.push(new StringBuffer(chunk, lineStarts.lineStarts));\n        this.cr += lineStarts.cr;\n        this.lf += lineStarts.lf;\n        this.crlf += lineStarts.crlf;\n        if (!lineStarts.isBasicASCII) {\n            // this chunk contains non basic ASCII characters\n            this.isBasicASCII = false;\n            if (!this.containsRTL) {\n                this.containsRTL = containsRTL(chunk);\n            }\n            if (!this.containsUnusualLineTerminators) {\n                this.containsUnusualLineTerminators = containsUnusualLineTerminators(chunk);\n            }\n        }\n    }\n    finish(normalizeEOL = true) {\n        this._finish();\n        return new PieceTreeTextBufferFactory(this.chunks, this.BOM, this.cr, this.lf, this.crlf, this.containsRTL, this.containsUnusualLineTerminators, this.isBasicASCII, normalizeEOL);\n    }\n    _finish() {\n        if (this.chunks.length === 0) {\n            this._acceptChunk1('', true);\n        }\n        if (this._hasPreviousChar) {\n            this._hasPreviousChar = false;\n            // recreate last chunk\n            const lastChunk = this.chunks[this.chunks.length - 1];\n            lastChunk.buffer += String.fromCharCode(this._previousChar);\n            const newLineStarts = createLineStartsFast(lastChunk.buffer);\n            lastChunk.lineStarts = newLineStarts;\n            if (this._previousChar === 13 /* CharCode.CarriageReturn */) {\n                this.cr++;\n            }\n        }\n    }\n}\n\nexport { PieceTreeTextBufferBuilder };\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 8390, "column": 0}, "map": {"version":3,"sources":["file:///D:/real-time-code-editor%20%282%29/node_modules/.pnpm/monaco-editor%400.55.1/node_modules/monaco-editor/esm/vs/editor/common/model/tokens/abstractSyntaxTokenBackend.js"],"sourcesContent":["import { equals } from '../../../../base/common/arrays.js';\nimport { RunOnceScheduler } from '../../../../base/common/async.js';\nimport { Emitter } from '../../../../base/common/event.js';\nimport { Disposable } from '../../../../base/common/lifecycle.js';\nimport { LineRange } from '../../core/ranges/lineRange.js';\nimport '../../../../base/common/observableInternal/index.js';\nimport { itemsEquals, itemEquals, equalsIfDefined } from '../../../../base/common/equals.js';\nimport { observableSignal } from '../../../../base/common/observableInternal/observables/observableSignal.js';\nimport { observableValueOpts } from '../../../../base/common/observableInternal/observables/observableValueOpts.js';\nimport { derivedOpts } from '../../../../base/common/observableInternal/observables/derived.js';\n\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n/**\n * @internal\n */\nclass AttachedViews {\n    constructor() {\n        this._onDidChangeVisibleRanges = new Emitter();\n        this.onDidChangeVisibleRanges = this._onDidChangeVisibleRanges.event;\n        this._views = new Set();\n        this._viewsChanged = observableSignal(this);\n        this.visibleLineRanges = derivedOpts({\n            owner: this,\n            equalsFn: itemsEquals(itemEquals())\n        }, reader => {\n            this._viewsChanged.read(reader);\n            const ranges = LineRange.joinMany([...this._views].map(view => view.state.read(reader)?.visibleLineRanges ?? []));\n            return ranges;\n        });\n    }\n    attachView() {\n        const view = new AttachedViewImpl((state) => {\n            this._onDidChangeVisibleRanges.fire({ view, state });\n        });\n        this._views.add(view);\n        this._viewsChanged.trigger(undefined);\n        return view;\n    }\n    detachView(view) {\n        this._views.delete(view);\n        this._onDidChangeVisibleRanges.fire({ view, state: undefined });\n        this._viewsChanged.trigger(undefined);\n    }\n}\n/**\n * @internal\n */\nclass AttachedViewState {\n    constructor(visibleLineRanges, stabilized) {\n        this.visibleLineRanges = visibleLineRanges;\n        this.stabilized = stabilized;\n    }\n    equals(other) {\n        if (this === other) {\n            return true;\n        }\n        if (!equals(this.visibleLineRanges, other.visibleLineRanges, (a, b) => a.equals(b))) {\n            return false;\n        }\n        if (this.stabilized !== other.stabilized) {\n            return false;\n        }\n        return true;\n    }\n}\nclass AttachedViewImpl {\n    get state() { return this._state; }\n    constructor(handleStateChange) {\n        this.handleStateChange = handleStateChange;\n        this._state = observableValueOpts({ owner: this, equalsFn: equalsIfDefined((a, b) => a.equals(b)) }, undefined);\n    }\n    setVisibleLines(visibleLines, stabilized) {\n        const visibleLineRanges = visibleLines.map((line) => new LineRange(line.startLineNumber, line.endLineNumber + 1));\n        const state = new AttachedViewState(visibleLineRanges, stabilized);\n        this._state.set(state, undefined, undefined);\n        this.handleStateChange(state);\n    }\n}\nclass AttachedViewHandler extends Disposable {\n    get lineRanges() { return this._lineRanges; }\n    constructor(_refreshTokens) {\n        super();\n        this._refreshTokens = _refreshTokens;\n        this.runner = this._register(new RunOnceScheduler(() => this.update(), 50));\n        this._computedLineRanges = [];\n        this._lineRanges = [];\n    }\n    update() {\n        if (equals(this._computedLineRanges, this._lineRanges, (a, b) => a.equals(b))) {\n            return;\n        }\n        this._computedLineRanges = this._lineRanges;\n        this._refreshTokens();\n    }\n    handleStateChange(state) {\n        this._lineRanges = state.visibleLineRanges;\n        if (state.stabilized) {\n            this.runner.cancel();\n            this.update();\n        }\n        else {\n            this.runner.schedule();\n        }\n    }\n}\nclass AbstractSyntaxTokenBackend extends Disposable {\n    get backgroundTokenizationState() {\n        return this._backgroundTokenizationState;\n    }\n    constructor(_languageIdCodec, _textModel) {\n        super();\n        this._languageIdCodec = _languageIdCodec;\n        this._textModel = _textModel;\n        this._onDidChangeTokens = this._register(new Emitter());\n        /** @internal, should not be exposed by the text model! */\n        this.onDidChangeTokens = this._onDidChangeTokens.event;\n    }\n    tokenizeIfCheap(lineNumber) {\n        if (this.isCheapToTokenize(lineNumber)) {\n            this.forceTokenization(lineNumber);\n        }\n    }\n}\n\nexport { AbstractSyntaxTokenBackend, AttachedViewHandler, AttachedViewState, AttachedViews };\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 8550, "column": 0}, "map": {"version":3,"sources":["file:///D:/real-time-code-editor%20%282%29/node_modules/.pnpm/monaco-editor%400.55.1/node_modules/monaco-editor/esm/vs/editor/common/model/tokens/treeSitter/cursorUtils.js"],"sourcesContent":["function gotoNextSibling(newCursor, oldCursor) {\n    const n = newCursor.gotoNextSibling();\n    const o = oldCursor.gotoNextSibling();\n    if (n !== o) {\n        throw new Error('Trees are out of sync');\n    }\n    return n && o;\n}\nfunction gotoParent(newCursor, oldCursor) {\n    const n = newCursor.gotoParent();\n    const o = oldCursor.gotoParent();\n    if (n !== o) {\n        throw new Error('Trees are out of sync');\n    }\n    return n && o;\n}\nfunction gotoNthChild(newCursor, oldCursor, index) {\n    const n = newCursor.gotoFirstChild();\n    const o = oldCursor.gotoFirstChild();\n    if (n !== o) {\n        throw new Error('Trees are out of sync');\n    }\n    if (index === 0) {\n        return n && o;\n    }\n    for (let i = 1; i <= index; i++) {\n        const nn = newCursor.gotoNextSibling();\n        const oo = oldCursor.gotoNextSibling();\n        if (nn !== oo) {\n            throw new Error('Trees are out of sync');\n        }\n        if (!nn || !oo) {\n            return false;\n        }\n    }\n    return n && o;\n}\nfunction nextSiblingOrParentSibling(newCursor, oldCursor) {\n    do {\n        if (newCursor.currentNode.nextSibling) {\n            return gotoNextSibling(newCursor, oldCursor);\n        }\n        if (newCursor.currentNode.parent) {\n            gotoParent(newCursor, oldCursor);\n        }\n    } while (newCursor.currentNode.nextSibling || newCursor.currentNode.parent);\n    return false;\n}\nfunction getClosestPreviousNodes(cursor, tree) {\n    // Go up parents until the end of the parent is before the start of the current.\n    const findPrev = tree.walk();\n    findPrev.resetTo(cursor);\n    const startingNode = cursor.currentNode;\n    do {\n        if (findPrev.currentNode.previousSibling && ((findPrev.currentNode.endIndex - findPrev.currentNode.startIndex) !== 0)) {\n            findPrev.gotoPreviousSibling();\n        }\n        else {\n            while (!findPrev.currentNode.previousSibling && findPrev.currentNode.parent) {\n                findPrev.gotoParent();\n            }\n            findPrev.gotoPreviousSibling();\n        }\n    } while ((findPrev.currentNode.endIndex > startingNode.startIndex)\n        && (findPrev.currentNode.parent || findPrev.currentNode.previousSibling)\n        && (findPrev.currentNode.id !== startingNode.id));\n    if ((findPrev.currentNode.id !== startingNode.id) && findPrev.currentNode.endIndex <= startingNode.startIndex) {\n        return findPrev.currentNode;\n    }\n    else {\n        return undefined;\n    }\n}\n\nexport { getClosestPreviousNodes, gotoNextSibling, gotoNthChild, gotoParent, nextSiblingOrParentSibling };\n"],"names":[],"mappings":";;;;;;;;;;;;AAAA,SAAS,gBAAgB,SAAS,EAAE,SAAS;IACzC,MAAM,IAAI,UAAU,eAAe;IACnC,MAAM,IAAI,UAAU,eAAe;IACnC,IAAI,MAAM,GAAG;QACT,MAAM,IAAI,MAAM;IACpB;IACA,OAAO,KAAK;AAChB;AACA,SAAS,WAAW,SAAS,EAAE,SAAS;IACpC,MAAM,IAAI,UAAU,UAAU;IAC9B,MAAM,IAAI,UAAU,UAAU;IAC9B,IAAI,MAAM,GAAG;QACT,MAAM,IAAI,MAAM;IACpB;IACA,OAAO,KAAK;AAChB;AACA,SAAS,aAAa,SAAS,EAAE,SAAS,EAAE,KAAK;IAC7C,MAAM,IAAI,UAAU,cAAc;IAClC,MAAM,IAAI,UAAU,cAAc;IAClC,IAAI,MAAM,GAAG;QACT,MAAM,IAAI,MAAM;IACpB;IACA,IAAI,UAAU,GAAG;QACb,OAAO,KAAK;IAChB;IACA,IAAK,IAAI,IAAI,GAAG,KAAK,OAAO,IAAK;QAC7B,MAAM,KAAK,UAAU,eAAe;QACpC,MAAM,KAAK,UAAU,eAAe;QACpC,IAAI,OAAO,IAAI;YACX,MAAM,IAAI,MAAM;QACpB;QACA,IAAI,CAAC,MAAM,CAAC,IAAI;YACZ,OAAO;QACX;IACJ;IACA,OAAO,KAAK;AAChB;AACA,SAAS,2BAA2B,SAAS,EAAE,SAAS;IACpD,GAAG;QACC,IAAI,UAAU,WAAW,CAAC,WAAW,EAAE;YACnC,OAAO,gBAAgB,WAAW;QACtC;QACA,IAAI,UAAU,WAAW,CAAC,MAAM,EAAE;YAC9B,WAAW,WAAW;QAC1B;IACJ,QAAS,UAAU,WAAW,CAAC,WAAW,IAAI,UAAU,WAAW,CAAC,MAAM,CAAE;IAC5E,OAAO;AACX;AACA,SAAS,wBAAwB,MAAM,EAAE,IAAI;IACzC,gFAAgF;IAChF,MAAM,WAAW,KAAK,IAAI;IAC1B,SAAS,OAAO,CAAC;IACjB,MAAM,eAAe,OAAO,WAAW;IACvC,GAAG;QACC,IAAI,SAAS,WAAW,CAAC,eAAe,IAAK,AAAC,SAAS,WAAW,CAAC,QAAQ,GAAG,SAAS,WAAW,CAAC,UAAU,KAAM,GAAI;YACnH,SAAS,mBAAmB;QAChC,OACK;YACD,MAAO,CAAC,SAAS,WAAW,CAAC,eAAe,IAAI,SAAS,WAAW,CAAC,MAAM,CAAE;gBACzE,SAAS,UAAU;YACvB;YACA,SAAS,mBAAmB;QAChC;IACJ,QAAS,AAAC,SAAS,WAAW,CAAC,QAAQ,GAAG,aAAa,UAAU,IAC1D,CAAC,SAAS,WAAW,CAAC,MAAM,IAAI,SAAS,WAAW,CAAC,eAAe,KACnE,SAAS,WAAW,CAAC,EAAE,KAAK,aAAa,EAAE,CAAG;IACtD,IAAI,AAAC,SAAS,WAAW,CAAC,EAAE,KAAK,aAAa,EAAE,IAAK,SAAS,WAAW,CAAC,QAAQ,IAAI,aAAa,UAAU,EAAE;QAC3G,OAAO,SAAS,WAAW;IAC/B,OACK;QACD,OAAO;IACX;AACJ","ignoreList":[0]}},
    {"offset": {"line": 8636, "column": 0}, "map": {"version":3,"sources":["file:///D:/real-time-code-editor%20%282%29/node_modules/.pnpm/monaco-editor%400.55.1/node_modules/monaco-editor/esm/vs/editor/common/model/tokens/treeSitter/treeSitterTree.js"],"sourcesContent":["import { TaskQueue } from '../../../../../base/common/async.js';\nimport { Disposable, toDisposable } from '../../../../../base/common/lifecycle.js';\nimport '../../../../../base/common/observableInternal/index.js';\nimport { setTimeout0 } from '../../../../../base/common/platform.js';\nimport { ILogService } from '../../../../../platform/log/common/log.js';\nimport { ITelemetryService } from '../../../../../platform/telemetry/common/telemetry.js';\nimport { TextLength } from '../../../core/text/textLength.js';\nimport { gotoParent, getClosestPreviousNodes, nextSiblingOrParentSibling, gotoNthChild } from './cursorUtils.js';\nimport { Range } from '../../../core/range.js';\nimport { transaction } from '../../../../../base/common/observableInternal/transaction.js';\nimport { observableValue } from '../../../../../base/common/observableInternal/observables/observableValue.js';\n\nvar __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (undefined && undefined.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nlet TreeSitterTree = class TreeSitterTree extends Disposable {\n    constructor(languageId, _ranges, \n    // readonly treeSitterLanguage: Language,\n    /** Must have the language set! */\n    _parser, _parserClass, \n    // private readonly _injectionQuery: TreeSitter.Query,\n    textModel, _logService, _telemetryService) {\n        super();\n        this.languageId = languageId;\n        this._ranges = _ranges;\n        this._parser = _parser;\n        this._parserClass = _parserClass;\n        this.textModel = textModel;\n        this._logService = _logService;\n        this._telemetryService = _telemetryService;\n        this._tree = observableValue(this, undefined);\n        this.tree = this._tree;\n        this._treeLastParsedVersion = observableValue(this, -1);\n        this.treeLastParsedVersion = this._treeLastParsedVersion;\n        this._onDidChangeContentQueue = new TaskQueue();\n        this._tree = observableValue(this, undefined);\n        this.tree = this._tree;\n        this._register(toDisposable(() => {\n            this._tree.get()?.delete();\n            this._lastFullyParsed?.delete();\n            this._lastFullyParsedWithEdits?.delete();\n            this._parser.delete();\n        }));\n        this.handleContentChange(undefined, this._ranges);\n    }\n    handleContentChange(e, ranges) {\n        const version = this.textModel.getVersionId();\n        let newRanges = [];\n        if (ranges) {\n            newRanges = this._setRanges(ranges);\n        }\n        if (e) {\n            this._applyEdits(e.changes);\n        }\n        this._onDidChangeContentQueue.clearPending();\n        this._onDidChangeContentQueue.schedule(async () => {\n            if (this._store.isDisposed) {\n                // No need to continue the queue if we are disposed\n                return;\n            }\n            const oldTree = this._lastFullyParsed;\n            let changedNodes;\n            if (this._lastFullyParsedWithEdits && this._lastFullyParsed) {\n                changedNodes = this._findChangedNodes(this._lastFullyParsedWithEdits, this._lastFullyParsed);\n            }\n            const completed = await this._parseAndUpdateTree(version);\n            if (completed) {\n                let ranges;\n                if (!changedNodes) {\n                    if (this._ranges) {\n                        ranges = this._ranges.map(r => ({ newRange: new Range(r.startPosition.row + 1, r.startPosition.column + 1, r.endPosition.row + 1, r.endPosition.column + 1), oldRangeLength: r.endIndex - r.startIndex, newRangeStartOffset: r.startIndex, newRangeEndOffset: r.endIndex }));\n                    }\n                }\n                else if (oldTree && changedNodes) {\n                    ranges = this._findTreeChanges(completed, changedNodes, newRanges);\n                }\n                if (!ranges) {\n                    ranges = [{ newRange: this.textModel.getFullModelRange(), newRangeStartOffset: 0, newRangeEndOffset: this.textModel.getValueLength() }];\n                }\n                const previousTree = this._tree.get();\n                transaction(tx => {\n                    this._tree.set(completed, tx, { ranges, versionId: version });\n                    this._treeLastParsedVersion.set(version, tx);\n                });\n                previousTree?.delete();\n            }\n        });\n    }\n    _applyEdits(changes) {\n        for (const change of changes) {\n            const originalTextLength = TextLength.ofRange(Range.lift(change.range));\n            const newTextLength = TextLength.ofText(change.text);\n            const summedTextLengths = change.text.length === 0 ? newTextLength : originalTextLength.add(newTextLength);\n            const edit = {\n                startIndex: change.rangeOffset,\n                oldEndIndex: change.rangeOffset + change.rangeLength,\n                newEndIndex: change.rangeOffset + change.text.length,\n                startPosition: { row: change.range.startLineNumber - 1, column: change.range.startColumn - 1 },\n                oldEndPosition: { row: change.range.endLineNumber - 1, column: change.range.endColumn - 1 },\n                newEndPosition: { row: change.range.startLineNumber + summedTextLengths.lineCount - 1, column: summedTextLengths.lineCount ? summedTextLengths.columnCount : (change.range.endColumn + summedTextLengths.columnCount) }\n            };\n            this._tree.get()?.edit(edit);\n            this._lastFullyParsedWithEdits?.edit(edit);\n        }\n    }\n    _findChangedNodes(newTree, oldTree) {\n        if ((this._ranges && this._ranges.every(range => range.startPosition.row !== newTree.rootNode.startPosition.row)) || newTree.rootNode.startPosition.row !== 0) {\n            return [];\n        }\n        const newCursor = newTree.walk();\n        const oldCursor = oldTree.walk();\n        const nodes = [];\n        let next = true;\n        do {\n            if (newCursor.currentNode.hasChanges) {\n                // Check if only one of the children has changes.\n                // If it's only one, then we go to that child.\n                // If it's more then, we need to go to each child\n                // If it's none, then we've found one of our ranges\n                const newChildren = newCursor.currentNode.children;\n                const indexChangedChildren = [];\n                const changedChildren = newChildren.filter((c, index) => {\n                    if (c?.hasChanges || (oldCursor.currentNode.children.length <= index)) {\n                        indexChangedChildren.push(index);\n                        return true;\n                    }\n                    return false;\n                });\n                // If we have changes and we *had* an error, the whole node should be refreshed.\n                if ((changedChildren.length === 0) || (newCursor.currentNode.hasError !== oldCursor.currentNode.hasError)) {\n                    // walk up again until we get to the first one that's named as unnamed nodes can be too granular\n                    while (newCursor.currentNode.parent && next && !newCursor.currentNode.isNamed) {\n                        next = gotoParent(newCursor, oldCursor);\n                    }\n                    // Use the end position of the previous node and the start position of the current node\n                    const newNode = newCursor.currentNode;\n                    const closestPreviousNode = getClosestPreviousNodes(newCursor, newTree) ?? newNode;\n                    nodes.push({\n                        startIndex: closestPreviousNode.startIndex,\n                        endIndex: newNode.endIndex,\n                        startPosition: closestPreviousNode.startPosition,\n                        endPosition: newNode.endPosition\n                    });\n                    next = nextSiblingOrParentSibling(newCursor, oldCursor);\n                }\n                else if (changedChildren.length >= 1) {\n                    next = gotoNthChild(newCursor, oldCursor, indexChangedChildren[0]);\n                }\n            }\n            else {\n                next = nextSiblingOrParentSibling(newCursor, oldCursor);\n            }\n        } while (next);\n        newCursor.delete();\n        oldCursor.delete();\n        return nodes;\n    }\n    _findTreeChanges(newTree, changedNodes, newRanges) {\n        let newRangeIndex = 0;\n        const mergedChanges = [];\n        // Find the parent in the new tree of the changed node\n        for (let nodeIndex = 0; nodeIndex < changedNodes.length; nodeIndex++) {\n            const node = changedNodes[nodeIndex];\n            if (mergedChanges.length > 0) {\n                if ((node.startIndex >= mergedChanges[mergedChanges.length - 1].newRangeStartOffset) && (node.endIndex <= mergedChanges[mergedChanges.length - 1].newRangeEndOffset)) {\n                    // This node is within the previous range, skip it\n                    continue;\n                }\n            }\n            const cursor = newTree.walk();\n            const cursorContainersNode = () => cursor.startIndex < node.startIndex && cursor.endIndex > node.endIndex;\n            while (cursorContainersNode()) {\n                // See if we can go to a child\n                let child = cursor.gotoFirstChild();\n                let foundChild = false;\n                while (child) {\n                    if (cursorContainersNode() && cursor.currentNode.isNamed) {\n                        foundChild = true;\n                        break;\n                    }\n                    else {\n                        child = cursor.gotoNextSibling();\n                    }\n                }\n                if (!foundChild) {\n                    cursor.gotoParent();\n                    break;\n                }\n                if (cursor.currentNode.childCount === 0) {\n                    break;\n                }\n            }\n            const startPosition = cursor.currentNode.startPosition;\n            const endPosition = cursor.currentNode.endPosition;\n            const startIndex = cursor.currentNode.startIndex;\n            const endIndex = cursor.currentNode.endIndex;\n            const newChange = { newRange: new Range(startPosition.row + 1, startPosition.column + 1, endPosition.row + 1, endPosition.column + 1), newRangeStartOffset: startIndex, newRangeEndOffset: endIndex };\n            if ((newRangeIndex < newRanges.length) && rangesIntersect(newRanges[newRangeIndex], { startIndex, endIndex})) {\n                // combine the new change with the range\n                if (newRanges[newRangeIndex].startIndex < newChange.newRangeStartOffset) {\n                    newChange.newRange = newChange.newRange.setStartPosition(newRanges[newRangeIndex].startPosition.row + 1, newRanges[newRangeIndex].startPosition.column + 1);\n                    newChange.newRangeStartOffset = newRanges[newRangeIndex].startIndex;\n                }\n                if (newRanges[newRangeIndex].endIndex > newChange.newRangeEndOffset) {\n                    newChange.newRange = newChange.newRange.setEndPosition(newRanges[newRangeIndex].endPosition.row + 1, newRanges[newRangeIndex].endPosition.column + 1);\n                    newChange.newRangeEndOffset = newRanges[newRangeIndex].endIndex;\n                }\n                newRangeIndex++;\n            }\n            else if (newRangeIndex < newRanges.length && newRanges[newRangeIndex].endIndex < newChange.newRangeStartOffset) {\n                // add the full range to the merged changes\n                mergedChanges.push({\n                    newRange: new Range(newRanges[newRangeIndex].startPosition.row + 1, newRanges[newRangeIndex].startPosition.column + 1, newRanges[newRangeIndex].endPosition.row + 1, newRanges[newRangeIndex].endPosition.column + 1),\n                    newRangeStartOffset: newRanges[newRangeIndex].startIndex,\n                    newRangeEndOffset: newRanges[newRangeIndex].endIndex\n                });\n            }\n            if ((mergedChanges.length > 0) && (mergedChanges[mergedChanges.length - 1].newRangeEndOffset >= newChange.newRangeStartOffset)) {\n                // Merge the changes\n                mergedChanges[mergedChanges.length - 1].newRange = Range.fromPositions(mergedChanges[mergedChanges.length - 1].newRange.getStartPosition(), newChange.newRange.getEndPosition());\n                mergedChanges[mergedChanges.length - 1].newRangeEndOffset = newChange.newRangeEndOffset;\n            }\n            else {\n                mergedChanges.push(newChange);\n            }\n        }\n        return this._constrainRanges(mergedChanges);\n    }\n    _constrainRanges(changes) {\n        if (!this._ranges) {\n            return changes;\n        }\n        const constrainedChanges = [];\n        let changesIndex = 0;\n        let rangesIndex = 0;\n        while (changesIndex < changes.length && rangesIndex < this._ranges.length) {\n            const change = changes[changesIndex];\n            const range = this._ranges[rangesIndex];\n            if (change.newRangeEndOffset < range.startIndex) {\n                // Change is before the range, move to the next change\n                changesIndex++;\n            }\n            else if (change.newRangeStartOffset > range.endIndex) {\n                // Change is after the range, move to the next range\n                rangesIndex++;\n            }\n            else {\n                // Change is within the range, constrain it\n                const newRangeStartOffset = Math.max(change.newRangeStartOffset, range.startIndex);\n                const newRangeEndOffset = Math.min(change.newRangeEndOffset, range.endIndex);\n                const newRange = change.newRange.intersectRanges(new Range(range.startPosition.row + 1, range.startPosition.column + 1, range.endPosition.row + 1, range.endPosition.column + 1));\n                constrainedChanges.push({\n                    newRange,\n                    newRangeEndOffset,\n                    newRangeStartOffset\n                });\n                // Remove the intersected range from the current change\n                if (newRangeEndOffset < change.newRangeEndOffset) {\n                    change.newRange = Range.fromPositions(newRange.getEndPosition(), change.newRange.getEndPosition());\n                    change.newRangeStartOffset = newRangeEndOffset + 1;\n                }\n                else {\n                    // Move to the next change\n                    changesIndex++;\n                }\n            }\n        }\n        return constrainedChanges;\n    }\n    async _parseAndUpdateTree(version) {\n        const tree = await this._parse();\n        if (tree) {\n            this._lastFullyParsed?.delete();\n            this._lastFullyParsed = tree.copy();\n            this._lastFullyParsedWithEdits?.delete();\n            this._lastFullyParsedWithEdits = tree.copy();\n            return tree;\n        }\n        else if (!this._tree.get()) {\n            // No tree means this is the initial parse and there were edits\n            // parse function doesn't handle this well and we can end up with an incorrect tree, so we reset\n            this._parser.reset();\n        }\n        return undefined;\n    }\n    _parse() {\n        let parseType = \"fullParse\" /* TelemetryParseType.Full */;\n        if (this._tree.get()) {\n            parseType = \"incrementalParse\" /* TelemetryParseType.Incremental */;\n        }\n        return this._parseAndYield(parseType);\n    }\n    async _parseAndYield(parseType) {\n        let time = 0;\n        let passes = 0;\n        const inProgressVersion = this.textModel.getVersionId();\n        let newTree;\n        const progressCallback = newTimeOutProgressCallback();\n        do {\n            const timer = performance.now();\n            newTree = this._parser.parse((index, position) => this._parseCallback(index), this._tree.get(), { progressCallback, includedRanges: this._ranges });\n            time += performance.now() - timer;\n            passes++;\n            // So long as this isn't the initial parse, even if the model changes and edits are applied, the tree parsing will continue correctly after the await.\n            await new Promise(resolve => setTimeout0(resolve));\n        } while (!this._store.isDisposed && !newTree && inProgressVersion === this.textModel.getVersionId());\n        this._sendParseTimeTelemetry(parseType, time, passes);\n        return (newTree && (inProgressVersion === this.textModel.getVersionId())) ? newTree : undefined;\n    }\n    _parseCallback(index) {\n        try {\n            return this.textModel.getTextBuffer().getNearestChunk(index);\n        }\n        catch (e) {\n            this._logService.debug('Error getting chunk for tree-sitter parsing', e);\n        }\n        return undefined;\n    }\n    _setRanges(newRanges) {\n        const unKnownRanges = [];\n        // If we have existing ranges, find the parts of the new ranges that are not included in the existing ones\n        if (this._ranges) {\n            for (const newRange of newRanges) {\n                let isFullyIncluded = false;\n                for (let i = 0; i < this._ranges.length; i++) {\n                    const existingRange = this._ranges[i];\n                    if (rangesEqual(existingRange, newRange) || rangesIntersect(existingRange, newRange)) {\n                        isFullyIncluded = true;\n                        break;\n                    }\n                }\n                if (!isFullyIncluded) {\n                    unKnownRanges.push(newRange);\n                }\n            }\n        }\n        else {\n            // No existing ranges, all new ranges are unknown\n            unKnownRanges.push(...newRanges);\n        }\n        this._ranges = newRanges;\n        return unKnownRanges;\n    }\n    _sendParseTimeTelemetry(parseType, time, passes) {\n        this._logService.debug(`Tree parsing (${parseType}) took ${time} ms and ${passes} passes.`);\n        if (parseType === \"fullParse\" /* TelemetryParseType.Full */) {\n            this._telemetryService.publicLog2(`treeSitter.fullParse`, { languageId: this.languageId, time, passes });\n        }\n        else {\n            this._telemetryService.publicLog2(`treeSitter.incrementalParse`, { languageId: this.languageId, time, passes });\n        }\n    }\n    createParsedTreeSync(src) {\n        const parser = new this._parserClass();\n        parser.setLanguage(this._parser.language);\n        const tree = parser.parse(src);\n        parser.delete();\n        return tree ?? undefined;\n    }\n};\nTreeSitterTree = __decorate([\n    __param(5, ILogService),\n    __param(6, ITelemetryService)\n], TreeSitterTree);\nfunction newTimeOutProgressCallback() {\n    let lastYieldTime = performance.now();\n    return function parseProgressCallback(_state) {\n        const now = performance.now();\n        if (now - lastYieldTime > 50) {\n            lastYieldTime = now;\n            return true;\n        }\n        return false;\n    };\n}\nfunction rangesEqual(a, b) {\n    return (a.startPosition.row === b.startPosition.row)\n        && (a.startPosition.column === b.startPosition.column)\n        && (a.endPosition.row === b.endPosition.row)\n        && (a.endPosition.column === b.endPosition.column)\n        && (a.startIndex === b.startIndex)\n        && (a.endIndex === b.endIndex);\n}\nfunction rangesIntersect(a, b) {\n    return (a.startIndex <= b.startIndex && a.endIndex >= b.startIndex) ||\n        (b.startIndex <= a.startIndex && b.endIndex >= a.startIndex);\n}\n\nexport { TreeSitterTree, rangesEqual, rangesIntersect };\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 9072, "column": 0}, "map": {"version":3,"sources":["file:///D:/real-time-code-editor%20%282%29/node_modules/.pnpm/monaco-editor%400.55.1/node_modules/monaco-editor/esm/vs/editor/common/model/fixedArray.js"],"sourcesContent":["import { arrayInsert } from '../../../base/common/arrays.js';\n\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n/**\n * An array that avoids being sparse by always\n * filling up unused indices with a default value.\n */\nclass FixedArray {\n    constructor(_default) {\n        this._default = _default;\n        this._store = [];\n    }\n    get(index) {\n        if (index < this._store.length) {\n            return this._store[index];\n        }\n        return this._default;\n    }\n    set(index, value) {\n        while (index >= this._store.length) {\n            this._store[this._store.length] = this._default;\n        }\n        this._store[index] = value;\n    }\n    replace(index, oldLength, newLength) {\n        if (index >= this._store.length) {\n            return;\n        }\n        if (oldLength === 0) {\n            this.insert(index, newLength);\n            return;\n        }\n        else if (newLength === 0) {\n            this.delete(index, oldLength);\n            return;\n        }\n        const before = this._store.slice(0, index);\n        const after = this._store.slice(index + oldLength);\n        const insertArr = arrayFill(newLength, this._default);\n        this._store = before.concat(insertArr, after);\n    }\n    delete(deleteIndex, deleteCount) {\n        if (deleteCount === 0 || deleteIndex >= this._store.length) {\n            return;\n        }\n        this._store.splice(deleteIndex, deleteCount);\n    }\n    insert(insertIndex, insertCount) {\n        if (insertCount === 0 || insertIndex >= this._store.length) {\n            return;\n        }\n        const arr = [];\n        for (let i = 0; i < insertCount; i++) {\n            arr[i] = this._default;\n        }\n        this._store = arrayInsert(this._store, insertIndex, arr);\n    }\n}\nfunction arrayFill(length, value) {\n    const arr = [];\n    for (let i = 0; i < length; i++) {\n        arr[i] = value;\n    }\n    return arr;\n}\n\nexport { FixedArray };\n"],"names":[],"mappings":";;;;AAAA;;AAEA;;;8FAG8F,GAC9F;;;CAGC,GACD,MAAM;IACF,YAAY,QAAQ,CAAE;QAClB,IAAI,CAAC,QAAQ,GAAG;QAChB,IAAI,CAAC,MAAM,GAAG,EAAE;IACpB;IACA,IAAI,KAAK,EAAE;QACP,IAAI,QAAQ,IAAI,CAAC,MAAM,CAAC,MAAM,EAAE;YAC5B,OAAO,IAAI,CAAC,MAAM,CAAC,MAAM;QAC7B;QACA,OAAO,IAAI,CAAC,QAAQ;IACxB;IACA,IAAI,KAAK,EAAE,KAAK,EAAE;QACd,MAAO,SAAS,IAAI,CAAC,MAAM,CAAC,MAAM,CAAE;YAChC,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,GAAG,IAAI,CAAC,QAAQ;QACnD;QACA,IAAI,CAAC,MAAM,CAAC,MAAM,GAAG;IACzB;IACA,QAAQ,KAAK,EAAE,SAAS,EAAE,SAAS,EAAE;QACjC,IAAI,SAAS,IAAI,CAAC,MAAM,CAAC,MAAM,EAAE;YAC7B;QACJ;QACA,IAAI,cAAc,GAAG;YACjB,IAAI,CAAC,MAAM,CAAC,OAAO;YACnB;QACJ,OACK,IAAI,cAAc,GAAG;YACtB,IAAI,CAAC,MAAM,CAAC,OAAO;YACnB;QACJ;QACA,MAAM,SAAS,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,GAAG;QACpC,MAAM,QAAQ,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,QAAQ;QACxC,MAAM,YAAY,UAAU,WAAW,IAAI,CAAC,QAAQ;QACpD,IAAI,CAAC,MAAM,GAAG,OAAO,MAAM,CAAC,WAAW;IAC3C;IACA,OAAO,WAAW,EAAE,WAAW,EAAE;QAC7B,IAAI,gBAAgB,KAAK,eAAe,IAAI,CAAC,MAAM,CAAC,MAAM,EAAE;YACxD;QACJ;QACA,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,aAAa;IACpC;IACA,OAAO,WAAW,EAAE,WAAW,EAAE;QAC7B,IAAI,gBAAgB,KAAK,eAAe,IAAI,CAAC,MAAM,CAAC,MAAM,EAAE;YACxD;QACJ;QACA,MAAM,MAAM,EAAE;QACd,IAAK,IAAI,IAAI,GAAG,IAAI,aAAa,IAAK;YAClC,GAAG,CAAC,EAAE,GAAG,IAAI,CAAC,QAAQ;QAC1B;QACA,IAAI,CAAC,MAAM,GAAG,IAAA,yPAAW,EAAC,IAAI,CAAC,MAAM,EAAE,aAAa;IACxD;AACJ;AACA,SAAS,UAAU,MAAM,EAAE,KAAK;IAC5B,MAAM,MAAM,EAAE;IACd,IAAK,IAAI,IAAI,GAAG,IAAI,QAAQ,IAAK;QAC7B,GAAG,CAAC,EAAE,GAAG;IACb;IACA,OAAO;AACX","ignoreList":[0]}},
    {"offset": {"line": 9146, "column": 0}, "map": {"version":3,"sources":["file:///D:/real-time-code-editor%20%282%29/node_modules/.pnpm/monaco-editor%400.55.1/node_modules/monaco-editor/esm/vs/editor/common/model/textModelTokens.js"],"sourcesContent":["import { runWhenGlobalIdle } from '../../../base/common/async.js';\nimport { BugIndicatingError, onUnexpectedError } from '../../../base/common/errors.js';\nimport { setTimeout0 } from '../../../base/common/platform.js';\nimport { StopWatch } from '../../../base/common/stopwatch.js';\nimport { countEOL } from '../core/misc/eolCounter.js';\nimport { LineRange } from '../core/ranges/lineRange.js';\nimport { OffsetRange } from '../core/ranges/offsetRange.js';\nimport { nullTokenizeEncoded } from '../languages/nullTokenize.js';\nimport { FixedArray } from './fixedArray.js';\nimport { ContiguousMultilineTokensBuilder } from '../tokens/contiguousMultilineTokensBuilder.js';\nimport { LineTokens } from '../tokens/lineTokens.js';\n\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nclass TokenizerWithStateStore {\n    constructor(lineCount, tokenizationSupport) {\n        this.tokenizationSupport = tokenizationSupport;\n        this.initialState = this.tokenizationSupport.getInitialState();\n        this.store = new TrackingTokenizationStateStore(lineCount);\n    }\n    getStartState(lineNumber) {\n        return this.store.getStartState(lineNumber, this.initialState);\n    }\n    getFirstInvalidLine() {\n        return this.store.getFirstInvalidLine(this.initialState);\n    }\n}\nclass TokenizerWithStateStoreAndTextModel extends TokenizerWithStateStore {\n    constructor(lineCount, tokenizationSupport, _textModel, _languageIdCodec) {\n        super(lineCount, tokenizationSupport);\n        this._textModel = _textModel;\n        this._languageIdCodec = _languageIdCodec;\n    }\n    updateTokensUntilLine(builder, lineNumber) {\n        const languageId = this._textModel.getLanguageId();\n        while (true) {\n            const lineToTokenize = this.getFirstInvalidLine();\n            if (!lineToTokenize || lineToTokenize.lineNumber > lineNumber) {\n                break;\n            }\n            const text = this._textModel.getLineContent(lineToTokenize.lineNumber);\n            const r = safeTokenize(this._languageIdCodec, languageId, this.tokenizationSupport, text, true, lineToTokenize.startState);\n            builder.add(lineToTokenize.lineNumber, r.tokens);\n            this.store.setEndState(lineToTokenize.lineNumber, r.endState);\n        }\n    }\n    /** assumes state is up to date */\n    getTokenTypeIfInsertingCharacter(position, character) {\n        // TODO@hediet: use tokenizeLineWithEdit\n        const lineStartState = this.getStartState(position.lineNumber);\n        if (!lineStartState) {\n            return 0 /* StandardTokenType.Other */;\n        }\n        const languageId = this._textModel.getLanguageId();\n        const lineContent = this._textModel.getLineContent(position.lineNumber);\n        // Create the text as if `character` was inserted\n        const text = (lineContent.substring(0, position.column - 1)\n            + character\n            + lineContent.substring(position.column - 1));\n        const r = safeTokenize(this._languageIdCodec, languageId, this.tokenizationSupport, text, true, lineStartState);\n        const lineTokens = new LineTokens(r.tokens, text, this._languageIdCodec);\n        if (lineTokens.getCount() === 0) {\n            return 0 /* StandardTokenType.Other */;\n        }\n        const tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n        return lineTokens.getStandardTokenType(tokenIndex);\n    }\n    /** assumes state is up to date */\n    tokenizeLinesAt(lineNumber, lines) {\n        const lineStartState = this.getStartState(lineNumber);\n        if (!lineStartState) {\n            return null;\n        }\n        const languageId = this._textModel.getLanguageId();\n        const result = [];\n        let state = lineStartState;\n        for (const line of lines) {\n            const r = safeTokenize(this._languageIdCodec, languageId, this.tokenizationSupport, line, true, state);\n            result.push(new LineTokens(r.tokens, line, this._languageIdCodec));\n            state = r.endState;\n        }\n        return result;\n    }\n    hasAccurateTokensForLine(lineNumber) {\n        const firstInvalidLineNumber = this.store.getFirstInvalidEndStateLineNumberOrMax();\n        return (lineNumber < firstInvalidLineNumber);\n    }\n    isCheapToTokenize(lineNumber) {\n        const firstInvalidLineNumber = this.store.getFirstInvalidEndStateLineNumberOrMax();\n        if (lineNumber < firstInvalidLineNumber) {\n            return true;\n        }\n        if (lineNumber === firstInvalidLineNumber\n            && this._textModel.getLineLength(lineNumber) < 2048 /* Constants.CHEAP_TOKENIZATION_LENGTH_LIMIT */) {\n            return true;\n        }\n        return false;\n    }\n    /**\n     * The result is not cached.\n     */\n    tokenizeHeuristically(builder, startLineNumber, endLineNumber) {\n        if (endLineNumber <= this.store.getFirstInvalidEndStateLineNumberOrMax()) {\n            // nothing to do\n            return { heuristicTokens: false };\n        }\n        if (startLineNumber <= this.store.getFirstInvalidEndStateLineNumberOrMax()) {\n            // tokenization has reached the viewport start...\n            this.updateTokensUntilLine(builder, endLineNumber);\n            return { heuristicTokens: false };\n        }\n        let state = this.guessStartState(startLineNumber);\n        const languageId = this._textModel.getLanguageId();\n        for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n            const text = this._textModel.getLineContent(lineNumber);\n            const r = safeTokenize(this._languageIdCodec, languageId, this.tokenizationSupport, text, true, state);\n            builder.add(lineNumber, r.tokens);\n            state = r.endState;\n        }\n        return { heuristicTokens: true };\n    }\n    guessStartState(lineNumber) {\n        let { likelyRelevantLines, initialState } = findLikelyRelevantLines(this._textModel, lineNumber, this);\n        if (!initialState) {\n            initialState = this.tokenizationSupport.getInitialState();\n        }\n        const languageId = this._textModel.getLanguageId();\n        let state = initialState;\n        for (const line of likelyRelevantLines) {\n            const r = safeTokenize(this._languageIdCodec, languageId, this.tokenizationSupport, line, false, state);\n            state = r.endState;\n        }\n        return state;\n    }\n}\nfunction findLikelyRelevantLines(model, lineNumber, store) {\n    let nonWhitespaceColumn = model.getLineFirstNonWhitespaceColumn(lineNumber);\n    const likelyRelevantLines = [];\n    let initialState = null;\n    for (let i = lineNumber - 1; nonWhitespaceColumn > 1 && i >= 1; i--) {\n        const newNonWhitespaceIndex = model.getLineFirstNonWhitespaceColumn(i);\n        // Ignore lines full of whitespace\n        if (newNonWhitespaceIndex === 0) {\n            continue;\n        }\n        if (newNonWhitespaceIndex < nonWhitespaceColumn) {\n            likelyRelevantLines.push(model.getLineContent(i));\n            nonWhitespaceColumn = newNonWhitespaceIndex;\n            initialState = store?.getStartState(i);\n            if (initialState) {\n                break;\n            }\n        }\n    }\n    likelyRelevantLines.reverse();\n    return { likelyRelevantLines, initialState: initialState ?? undefined };\n}\n/**\n * **Invariant:**\n * If the text model is retokenized from line 1 to {@link getFirstInvalidEndStateLineNumber}() - 1,\n * then the recomputed end state for line l will be equal to {@link getEndState}(l).\n */\nclass TrackingTokenizationStateStore {\n    constructor(lineCount) {\n        this.lineCount = lineCount;\n        this._tokenizationStateStore = new TokenizationStateStore();\n        this._invalidEndStatesLineNumbers = new RangePriorityQueueImpl();\n        this._invalidEndStatesLineNumbers.addRange(new OffsetRange(1, lineCount + 1));\n    }\n    getEndState(lineNumber) {\n        return this._tokenizationStateStore.getEndState(lineNumber);\n    }\n    /**\n     * @returns if the end state has changed.\n     */\n    setEndState(lineNumber, state) {\n        if (!state) {\n            throw new BugIndicatingError('Cannot set null/undefined state');\n        }\n        this._invalidEndStatesLineNumbers.delete(lineNumber);\n        const r = this._tokenizationStateStore.setEndState(lineNumber, state);\n        if (r && lineNumber < this.lineCount) {\n            // because the state changed, we cannot trust the next state anymore and have to invalidate it.\n            this._invalidEndStatesLineNumbers.addRange(new OffsetRange(lineNumber + 1, lineNumber + 2));\n        }\n        return r;\n    }\n    acceptChange(range, newLineCount) {\n        this.lineCount += newLineCount - range.length;\n        this._tokenizationStateStore.acceptChange(range, newLineCount);\n        this._invalidEndStatesLineNumbers.addRangeAndResize(new OffsetRange(range.startLineNumber, range.endLineNumberExclusive), newLineCount);\n    }\n    acceptChanges(changes) {\n        for (const c of changes) {\n            const [eolCount] = countEOL(c.text);\n            this.acceptChange(new LineRange(c.range.startLineNumber, c.range.endLineNumber + 1), eolCount + 1);\n        }\n    }\n    invalidateEndStateRange(range) {\n        this._invalidEndStatesLineNumbers.addRange(new OffsetRange(range.startLineNumber, range.endLineNumberExclusive));\n    }\n    getFirstInvalidEndStateLineNumber() { return this._invalidEndStatesLineNumbers.min; }\n    getFirstInvalidEndStateLineNumberOrMax() {\n        return this.getFirstInvalidEndStateLineNumber() || Number.MAX_SAFE_INTEGER;\n    }\n    allStatesValid() { return this._invalidEndStatesLineNumbers.min === null; }\n    getStartState(lineNumber, initialState) {\n        if (lineNumber === 1) {\n            return initialState;\n        }\n        return this.getEndState(lineNumber - 1);\n    }\n    getFirstInvalidLine(initialState) {\n        const lineNumber = this.getFirstInvalidEndStateLineNumber();\n        if (lineNumber === null) {\n            return null;\n        }\n        const startState = this.getStartState(lineNumber, initialState);\n        if (!startState) {\n            throw new BugIndicatingError('Start state must be defined');\n        }\n        return { lineNumber, startState };\n    }\n}\nclass TokenizationStateStore {\n    constructor() {\n        this._lineEndStates = new FixedArray(null);\n    }\n    getEndState(lineNumber) {\n        return this._lineEndStates.get(lineNumber);\n    }\n    setEndState(lineNumber, state) {\n        const oldState = this._lineEndStates.get(lineNumber);\n        if (oldState && oldState.equals(state)) {\n            return false;\n        }\n        this._lineEndStates.set(lineNumber, state);\n        return true;\n    }\n    acceptChange(range, newLineCount) {\n        let length = range.length;\n        if (newLineCount > 0 && length > 0) {\n            // Keep the last state, even though it is unrelated.\n            // But if the new state happens to agree with this last state, then we know we can stop tokenizing.\n            length--;\n            newLineCount--;\n        }\n        this._lineEndStates.replace(range.startLineNumber, length, newLineCount);\n    }\n}\nclass RangePriorityQueueImpl {\n    constructor() {\n        this._ranges = [];\n    }\n    get min() {\n        if (this._ranges.length === 0) {\n            return null;\n        }\n        return this._ranges[0].start;\n    }\n    delete(value) {\n        const idx = this._ranges.findIndex(r => r.contains(value));\n        if (idx !== -1) {\n            const range = this._ranges[idx];\n            if (range.start === value) {\n                if (range.endExclusive === value + 1) {\n                    this._ranges.splice(idx, 1);\n                }\n                else {\n                    this._ranges[idx] = new OffsetRange(value + 1, range.endExclusive);\n                }\n            }\n            else {\n                if (range.endExclusive === value + 1) {\n                    this._ranges[idx] = new OffsetRange(range.start, value);\n                }\n                else {\n                    this._ranges.splice(idx, 1, new OffsetRange(range.start, value), new OffsetRange(value + 1, range.endExclusive));\n                }\n            }\n        }\n    }\n    addRange(range) {\n        OffsetRange.addRange(range, this._ranges);\n    }\n    addRangeAndResize(range, newLength) {\n        let idxFirstMightBeIntersecting = 0;\n        while (!(idxFirstMightBeIntersecting >= this._ranges.length || range.start <= this._ranges[idxFirstMightBeIntersecting].endExclusive)) {\n            idxFirstMightBeIntersecting++;\n        }\n        let idxFirstIsAfter = idxFirstMightBeIntersecting;\n        while (!(idxFirstIsAfter >= this._ranges.length || range.endExclusive < this._ranges[idxFirstIsAfter].start)) {\n            idxFirstIsAfter++;\n        }\n        const delta = newLength - range.length;\n        for (let i = idxFirstIsAfter; i < this._ranges.length; i++) {\n            this._ranges[i] = this._ranges[i].delta(delta);\n        }\n        if (idxFirstMightBeIntersecting === idxFirstIsAfter) {\n            const newRange = new OffsetRange(range.start, range.start + newLength);\n            if (!newRange.isEmpty) {\n                this._ranges.splice(idxFirstMightBeIntersecting, 0, newRange);\n            }\n        }\n        else {\n            const start = Math.min(range.start, this._ranges[idxFirstMightBeIntersecting].start);\n            const endEx = Math.max(range.endExclusive, this._ranges[idxFirstIsAfter - 1].endExclusive);\n            const newRange = new OffsetRange(start, endEx + delta);\n            if (!newRange.isEmpty) {\n                this._ranges.splice(idxFirstMightBeIntersecting, idxFirstIsAfter - idxFirstMightBeIntersecting, newRange);\n            }\n            else {\n                this._ranges.splice(idxFirstMightBeIntersecting, idxFirstIsAfter - idxFirstMightBeIntersecting);\n            }\n        }\n    }\n    toString() {\n        return this._ranges.map(r => r.toString()).join(' + ');\n    }\n}\nfunction safeTokenize(languageIdCodec, languageId, tokenizationSupport, text, hasEOL, state) {\n    let r = null;\n    if (tokenizationSupport) {\n        try {\n            r = tokenizationSupport.tokenizeEncoded(text, hasEOL, state.clone());\n        }\n        catch (e) {\n            onUnexpectedError(e);\n        }\n    }\n    if (!r) {\n        r = nullTokenizeEncoded(languageIdCodec.encodeLanguageId(languageId), state);\n    }\n    LineTokens.convertToEndOffset(r.tokens, text.length);\n    return r;\n}\nclass DefaultBackgroundTokenizer {\n    constructor(_tokenizerWithStateStore, _backgroundTokenStore) {\n        this._tokenizerWithStateStore = _tokenizerWithStateStore;\n        this._backgroundTokenStore = _backgroundTokenStore;\n        this._isDisposed = false;\n        this._isScheduled = false;\n    }\n    dispose() {\n        this._isDisposed = true;\n    }\n    handleChanges() {\n        this._beginBackgroundTokenization();\n    }\n    _beginBackgroundTokenization() {\n        if (this._isScheduled || !this._tokenizerWithStateStore._textModel.isAttachedToEditor() || !this._hasLinesToTokenize()) {\n            return;\n        }\n        this._isScheduled = true;\n        runWhenGlobalIdle((deadline) => {\n            this._isScheduled = false;\n            this._backgroundTokenizeWithDeadline(deadline);\n        });\n    }\n    /**\n     * Tokenize until the deadline occurs, but try to yield every 1-2ms.\n     */\n    _backgroundTokenizeWithDeadline(deadline) {\n        // Read the time remaining from the `deadline` immediately because it is unclear\n        // if the `deadline` object will be valid after execution leaves this function.\n        const endTime = Date.now() + deadline.timeRemaining();\n        const execute = () => {\n            if (this._isDisposed || !this._tokenizerWithStateStore._textModel.isAttachedToEditor() || !this._hasLinesToTokenize()) {\n                // disposed in the meantime or detached or finished\n                return;\n            }\n            this._backgroundTokenizeForAtLeast1ms();\n            if (Date.now() < endTime) {\n                // There is still time before reaching the deadline, so yield to the browser and then\n                // continue execution\n                setTimeout0(execute);\n            }\n            else {\n                // The deadline has been reached, so schedule a new idle callback if necessary\n                this._beginBackgroundTokenization();\n            }\n        };\n        execute();\n    }\n    /**\n     * Tokenize for at least 1ms.\n     */\n    _backgroundTokenizeForAtLeast1ms() {\n        const lineCount = this._tokenizerWithStateStore._textModel.getLineCount();\n        const builder = new ContiguousMultilineTokensBuilder();\n        const sw = StopWatch.create(false);\n        do {\n            if (sw.elapsed() > 1) {\n                // the comparison is intentionally > 1 and not >= 1 to ensure that\n                // a full millisecond has elapsed, given how microseconds are rounded\n                // to milliseconds\n                break;\n            }\n            const tokenizedLineNumber = this._tokenizeOneInvalidLine(builder);\n            if (tokenizedLineNumber >= lineCount) {\n                break;\n            }\n        } while (this._hasLinesToTokenize());\n        this._backgroundTokenStore.setTokens(builder.finalize());\n        this.checkFinished();\n    }\n    _hasLinesToTokenize() {\n        if (!this._tokenizerWithStateStore) {\n            return false;\n        }\n        return !this._tokenizerWithStateStore.store.allStatesValid();\n    }\n    _tokenizeOneInvalidLine(builder) {\n        const firstInvalidLine = this._tokenizerWithStateStore?.getFirstInvalidLine();\n        if (!firstInvalidLine) {\n            return this._tokenizerWithStateStore._textModel.getLineCount() + 1;\n        }\n        this._tokenizerWithStateStore.updateTokensUntilLine(builder, firstInvalidLine.lineNumber);\n        return firstInvalidLine.lineNumber;\n    }\n    checkFinished() {\n        if (this._isDisposed) {\n            return;\n        }\n        if (this._tokenizerWithStateStore.store.allStatesValid()) {\n            this._backgroundTokenStore.backgroundTokenizationFinished();\n        }\n    }\n    requestTokens(startLineNumber, endLineNumberExclusive) {\n        this._tokenizerWithStateStore.store.invalidateEndStateRange(new LineRange(startLineNumber, endLineNumberExclusive));\n    }\n}\n\nexport { DefaultBackgroundTokenizer, RangePriorityQueueImpl, TokenizationStateStore, TokenizerWithStateStore, TokenizerWithStateStoreAndTextModel, TrackingTokenizationStateStore, findLikelyRelevantLines };\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 9606, "column": 0}, "map": {"version":3,"sources":["file:///D:/real-time-code-editor%20%282%29/node_modules/.pnpm/monaco-editor%400.55.1/node_modules/monaco-editor/esm/vs/editor/common/model/tokens/treeSitter/tokenStore.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n// Exported for tests\nclass ListNode {\n    get children() { return this._children; }\n    get length() { return this._length; }\n    constructor(height) {\n        this.height = height;\n        this._children = [];\n        this._length = 0;\n    }\n    static create(node1, node2) {\n        const list = new ListNode(node1.height + 1);\n        list.appendChild(node1);\n        list.appendChild(node2);\n        return list;\n    }\n    canAppendChild() {\n        return this._children.length < 3;\n    }\n    appendChild(node) {\n        if (!this.canAppendChild()) {\n            throw new Error('Cannot insert more than 3 children in a ListNode');\n        }\n        this._children.push(node);\n        this._length += node.length;\n        this._updateParentLength(node.length);\n        if (!isLeaf(node)) {\n            node.parent = this;\n        }\n    }\n    _updateParentLength(delta) {\n        let updateParent = this.parent;\n        while (updateParent) {\n            updateParent._length += delta;\n            updateParent = updateParent.parent;\n        }\n    }\n    unappendChild() {\n        const child = this._children.pop();\n        this._length -= child.length;\n        this._updateParentLength(-child.length);\n        return child;\n    }\n    prependChild(node) {\n        if (this._children.length >= 3) {\n            throw new Error('Cannot prepend more than 3 children in a ListNode');\n        }\n        this._children.unshift(node);\n        this._length += node.length;\n        this._updateParentLength(node.length);\n        if (!isLeaf(node)) {\n            node.parent = this;\n        }\n    }\n    unprependChild() {\n        const child = this._children.shift();\n        this._length -= child.length;\n        this._updateParentLength(-child.length);\n        return child;\n    }\n    lastChild() {\n        return this._children[this._children.length - 1];\n    }\n    dispose() {\n        this._children.splice(0, this._children.length);\n    }\n}\nvar TokenQuality;\n(function (TokenQuality) {\n    TokenQuality[TokenQuality[\"None\"] = 0] = \"None\";\n    TokenQuality[TokenQuality[\"ViewportGuess\"] = 1] = \"ViewportGuess\";\n    TokenQuality[TokenQuality[\"EditGuess\"] = 2] = \"EditGuess\";\n    TokenQuality[TokenQuality[\"Accurate\"] = 3] = \"Accurate\";\n})(TokenQuality || (TokenQuality = {}));\nfunction isLeaf(node) {\n    return node.token !== undefined;\n}\n// Heavily inspired by https://github.com/microsoft/vscode/blob/4eb2658d592cb6114a7a393655574176cc790c5b/src/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/concat23Trees.ts#L108-L109\nfunction append(node, nodeToAppend) {\n    let curNode = node;\n    const parents = [];\n    let nodeToAppendOfCorrectHeight;\n    while (true) {\n        if (nodeToAppend.height === curNode.height) {\n            nodeToAppendOfCorrectHeight = nodeToAppend;\n            break;\n        }\n        if (isLeaf(curNode)) {\n            throw new Error('unexpected');\n        }\n        parents.push(curNode);\n        curNode = curNode.lastChild();\n    }\n    for (let i = parents.length - 1; i >= 0; i--) {\n        const parent = parents[i];\n        if (nodeToAppendOfCorrectHeight) {\n            // Can we take the element?\n            if (parent.children.length >= 3) {\n                // we need to split to maintain (2,3)-tree property.\n                // Send the third element + the new element to the parent.\n                const newList = ListNode.create(parent.unappendChild(), nodeToAppendOfCorrectHeight);\n                nodeToAppendOfCorrectHeight = newList;\n            }\n            else {\n                parent.appendChild(nodeToAppendOfCorrectHeight);\n                nodeToAppendOfCorrectHeight = undefined;\n            }\n        }\n    }\n    if (nodeToAppendOfCorrectHeight) {\n        const newList = new ListNode(nodeToAppendOfCorrectHeight.height + 1);\n        newList.appendChild(node);\n        newList.appendChild(nodeToAppendOfCorrectHeight);\n        return newList;\n    }\n    else {\n        return node;\n    }\n}\nfunction prepend(list, nodeToAppend) {\n    let curNode = list;\n    const parents = [];\n    while (nodeToAppend.height !== curNode.height) {\n        if (isLeaf(curNode)) {\n            throw new Error('unexpected');\n        }\n        parents.push(curNode);\n        // assert 2 <= curNode.childrenFast.length <= 3\n        curNode = curNode.children[0];\n    }\n    let nodeToPrependOfCorrectHeight = nodeToAppend;\n    // assert nodeToAppendOfCorrectHeight!.listHeight === curNode.listHeight\n    for (let i = parents.length - 1; i >= 0; i--) {\n        const parent = parents[i];\n        if (nodeToPrependOfCorrectHeight) {\n            // Can we take the element?\n            if (parent.children.length >= 3) {\n                // we need to split to maintain (2,3)-tree property.\n                // Send the third element + the new element to the parent.\n                nodeToPrependOfCorrectHeight = ListNode.create(nodeToPrependOfCorrectHeight, parent.unprependChild());\n            }\n            else {\n                parent.prependChild(nodeToPrependOfCorrectHeight);\n                nodeToPrependOfCorrectHeight = undefined;\n            }\n        }\n    }\n    if (nodeToPrependOfCorrectHeight) {\n        return ListNode.create(nodeToPrependOfCorrectHeight, list);\n    }\n    else {\n        return list;\n    }\n}\nfunction concat(node1, node2) {\n    if (node1.height === node2.height) {\n        return ListNode.create(node1, node2);\n    }\n    else if (node1.height > node2.height) {\n        // node1 is the tree we want to insert into\n        return append(node1, node2);\n    }\n    else {\n        return prepend(node2, node1);\n    }\n}\nclass TokenStore {\n    constructor(_textModel) {\n        this._textModel = _textModel;\n        this._root = this.createEmptyRoot();\n    }\n    createEmptyRoot() {\n        return {\n            length: this._textModel.getValueLength(),\n            token: 0,\n            height: 0,\n            tokenQuality: TokenQuality.None\n        };\n    }\n    /**\n     *\n     * @param update all the tokens for the document in sequence\n     */\n    buildStore(tokens, tokenQuality) {\n        this._root = this.createFromUpdates(tokens, tokenQuality);\n    }\n    createFromUpdates(tokens, tokenQuality) {\n        if (tokens.length === 0) {\n            return this.createEmptyRoot();\n        }\n        let newRoot = {\n            length: tokens[0].length,\n            token: tokens[0].token,\n            height: 0,\n            tokenQuality\n        };\n        for (let j = 1; j < tokens.length; j++) {\n            newRoot = append(newRoot, { length: tokens[j].length, token: tokens[j].token, height: 0, tokenQuality });\n        }\n        return newRoot;\n    }\n    /**\n     *\n     * @param tokens tokens are in sequence in the document.\n     */\n    update(length, tokens, tokenQuality) {\n        if (tokens.length === 0) {\n            return;\n        }\n        this.replace(length, tokens[0].startOffsetInclusive, tokens, tokenQuality);\n    }\n    delete(length, startOffset) {\n        this.replace(length, startOffset, [], TokenQuality.EditGuess);\n    }\n    /**\n     *\n     * @param tokens tokens are in sequence in the document.\n     */\n    replace(length, updateOffsetStart, tokens, tokenQuality) {\n        const firstUnchangedOffsetAfterUpdate = updateOffsetStart + length;\n        // Find the last unchanged node preceding the update\n        const precedingNodes = [];\n        // Find the first unchanged node after the update\n        const postcedingNodes = [];\n        const stack = [{ node: this._root, offset: 0 }];\n        while (stack.length > 0) {\n            const node = stack.pop();\n            const currentOffset = node.offset;\n            if (currentOffset < updateOffsetStart && currentOffset + node.node.length <= updateOffsetStart) {\n                if (!isLeaf(node.node)) {\n                    node.node.parent = undefined;\n                }\n                precedingNodes.push(node.node);\n                continue;\n            }\n            else if (isLeaf(node.node) && (currentOffset < updateOffsetStart)) {\n                // We have a partial preceding node\n                precedingNodes.push({ length: updateOffsetStart - currentOffset, token: node.node.token, height: 0, tokenQuality: node.node.tokenQuality });\n                // Node could also be postceeding, so don't continue\n            }\n            if ((updateOffsetStart <= currentOffset) && (currentOffset + node.node.length <= firstUnchangedOffsetAfterUpdate)) {\n                continue;\n            }\n            if (currentOffset >= firstUnchangedOffsetAfterUpdate) {\n                if (!isLeaf(node.node)) {\n                    node.node.parent = undefined;\n                }\n                postcedingNodes.push(node.node);\n                continue;\n            }\n            else if (isLeaf(node.node) && (currentOffset + node.node.length > firstUnchangedOffsetAfterUpdate)) {\n                // we have a partial postceeding node\n                postcedingNodes.push({ length: currentOffset + node.node.length - firstUnchangedOffsetAfterUpdate, token: node.node.token, height: 0, tokenQuality: node.node.tokenQuality });\n                continue;\n            }\n            if (!isLeaf(node.node)) {\n                // Push children in reverse order to process them left-to-right when popping\n                let childOffset = currentOffset + node.node.length;\n                for (let i = node.node.children.length - 1; i >= 0; i--) {\n                    childOffset -= node.node.children[i].length;\n                    stack.push({ node: node.node.children[i], offset: childOffset });\n                }\n            }\n        }\n        let allNodes;\n        if (tokens.length > 0) {\n            allNodes = precedingNodes.concat(this.createFromUpdates(tokens, tokenQuality), postcedingNodes);\n        }\n        else {\n            allNodes = precedingNodes.concat(postcedingNodes);\n        }\n        let newRoot = allNodes[0];\n        for (let i = 1; i < allNodes.length; i++) {\n            newRoot = concat(newRoot, allNodes[i]);\n        }\n        this._root = newRoot ?? this.createEmptyRoot();\n    }\n    /**\n     *\n     * @param startOffsetInclusive\n     * @param endOffsetExclusive\n     * @param visitor Return true from visitor to exit early\n     * @returns\n     */\n    traverseInOrderInRange(startOffsetInclusive, endOffsetExclusive, visitor) {\n        const stack = [{ node: this._root, offset: 0 }];\n        while (stack.length > 0) {\n            const { node, offset } = stack.pop();\n            const nodeEnd = offset + node.length;\n            // Skip nodes that are completely before or after the range\n            if (nodeEnd <= startOffsetInclusive || offset >= endOffsetExclusive) {\n                continue;\n            }\n            if (visitor(node, offset)) {\n                return;\n            }\n            if (!isLeaf(node)) {\n                // Push children in reverse order to process them left-to-right when popping\n                let childOffset = offset + node.length;\n                for (let i = node.children.length - 1; i >= 0; i--) {\n                    childOffset -= node.children[i].length;\n                    stack.push({ node: node.children[i], offset: childOffset });\n                }\n            }\n        }\n    }\n    getTokenAt(offset) {\n        let result;\n        this.traverseInOrderInRange(offset, this._root.length, (node, offset) => {\n            if (isLeaf(node)) {\n                result = { token: node.token, startOffsetInclusive: offset, length: node.length };\n                return true;\n            }\n            return false;\n        });\n        return result;\n    }\n    getTokensInRange(startOffsetInclusive, endOffsetExclusive) {\n        const result = [];\n        this.traverseInOrderInRange(startOffsetInclusive, endOffsetExclusive, (node, offset) => {\n            if (isLeaf(node)) {\n                let clippedLength = node.length;\n                let clippedOffset = offset;\n                if ((offset < startOffsetInclusive) && (offset + node.length > endOffsetExclusive)) {\n                    clippedOffset = startOffsetInclusive;\n                    clippedLength = endOffsetExclusive - startOffsetInclusive;\n                }\n                else if (offset < startOffsetInclusive) {\n                    clippedLength -= (startOffsetInclusive - offset);\n                    clippedOffset = startOffsetInclusive;\n                }\n                else if (offset + node.length > endOffsetExclusive) {\n                    clippedLength -= (offset + node.length - endOffsetExclusive);\n                }\n                result.push({ token: node.token, startOffsetInclusive: clippedOffset, length: clippedLength });\n            }\n            return false;\n        });\n        return result;\n    }\n    markForRefresh(startOffsetInclusive, endOffsetExclusive) {\n        this.traverseInOrderInRange(startOffsetInclusive, endOffsetExclusive, (node) => {\n            if (isLeaf(node)) {\n                node.tokenQuality = TokenQuality.None;\n            }\n            return false;\n        });\n    }\n    rangeHasTokens(startOffsetInclusive, endOffsetExclusive, minimumTokenQuality) {\n        let hasAny = true;\n        this.traverseInOrderInRange(startOffsetInclusive, endOffsetExclusive, (node) => {\n            if (isLeaf(node) && (node.tokenQuality < minimumTokenQuality)) {\n                hasAny = false;\n            }\n            return false;\n        });\n        return hasAny;\n    }\n    rangeNeedsRefresh(startOffsetInclusive, endOffsetExclusive) {\n        let needsRefresh = false;\n        this.traverseInOrderInRange(startOffsetInclusive, endOffsetExclusive, (node) => {\n            if (isLeaf(node) && (node.tokenQuality !== TokenQuality.Accurate)) {\n                needsRefresh = true;\n            }\n            return false;\n        });\n        return needsRefresh;\n    }\n    getNeedsRefresh() {\n        const result = [];\n        this.traverseInOrderInRange(0, this._textModel.getValueLength(), (node, offset) => {\n            if (isLeaf(node) && (node.tokenQuality !== TokenQuality.Accurate)) {\n                if ((result.length > 0) && (result[result.length - 1].endOffset === offset)) {\n                    result[result.length - 1].endOffset += node.length;\n                }\n                else {\n                    result.push({ startOffset: offset, endOffset: offset + node.length });\n                }\n            }\n            return false;\n        });\n        return result;\n    }\n    dispose() {\n        const stack = [[this._root, false]];\n        while (stack.length > 0) {\n            const [node, visited] = stack.pop();\n            if (isLeaf(node)) ;\n            else if (!visited) {\n                stack.push([node, true]);\n                for (let i = node.children.length - 1; i >= 0; i--) {\n                    stack.push([node.children[i], false]);\n                }\n            }\n            else {\n                node.dispose();\n                node.parent = undefined;\n            }\n        }\n        this._root = undefined;\n    }\n}\n\nexport { ListNode, TokenQuality, TokenStore };\n"],"names":[],"mappings":"AAAA;;;8FAG8F,GAC9F,qBAAqB;;;;;;;;;AACrB,MAAM;IACF,IAAI,WAAW;QAAE,OAAO,IAAI,CAAC,SAAS;IAAE;IACxC,IAAI,SAAS;QAAE,OAAO,IAAI,CAAC,OAAO;IAAE;IACpC,YAAY,MAAM,CAAE;QAChB,IAAI,CAAC,MAAM,GAAG;QACd,IAAI,CAAC,SAAS,GAAG,EAAE;QACnB,IAAI,CAAC,OAAO,GAAG;IACnB;IACA,OAAO,OAAO,KAAK,EAAE,KAAK,EAAE;QACxB,MAAM,OAAO,IAAI,SAAS,MAAM,MAAM,GAAG;QACzC,KAAK,WAAW,CAAC;QACjB,KAAK,WAAW,CAAC;QACjB,OAAO;IACX;IACA,iBAAiB;QACb,OAAO,IAAI,CAAC,SAAS,CAAC,MAAM,GAAG;IACnC;IACA,YAAY,IAAI,EAAE;QACd,IAAI,CAAC,IAAI,CAAC,cAAc,IAAI;YACxB,MAAM,IAAI,MAAM;QACpB;QACA,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC;QACpB,IAAI,CAAC,OAAO,IAAI,KAAK,MAAM;QAC3B,IAAI,CAAC,mBAAmB,CAAC,KAAK,MAAM;QACpC,IAAI,CAAC,OAAO,OAAO;YACf,KAAK,MAAM,GAAG,IAAI;QACtB;IACJ;IACA,oBAAoB,KAAK,EAAE;QACvB,IAAI,eAAe,IAAI,CAAC,MAAM;QAC9B,MAAO,aAAc;YACjB,aAAa,OAAO,IAAI;YACxB,eAAe,aAAa,MAAM;QACtC;IACJ;IACA,gBAAgB;QACZ,MAAM,QAAQ,IAAI,CAAC,SAAS,CAAC,GAAG;QAChC,IAAI,CAAC,OAAO,IAAI,MAAM,MAAM;QAC5B,IAAI,CAAC,mBAAmB,CAAC,CAAC,MAAM,MAAM;QACtC,OAAO;IACX;IACA,aAAa,IAAI,EAAE;QACf,IAAI,IAAI,CAAC,SAAS,CAAC,MAAM,IAAI,GAAG;YAC5B,MAAM,IAAI,MAAM;QACpB;QACA,IAAI,CAAC,SAAS,CAAC,OAAO,CAAC;QACvB,IAAI,CAAC,OAAO,IAAI,KAAK,MAAM;QAC3B,IAAI,CAAC,mBAAmB,CAAC,KAAK,MAAM;QACpC,IAAI,CAAC,OAAO,OAAO;YACf,KAAK,MAAM,GAAG,IAAI;QACtB;IACJ;IACA,iBAAiB;QACb,MAAM,QAAQ,IAAI,CAAC,SAAS,CAAC,KAAK;QAClC,IAAI,CAAC,OAAO,IAAI,MAAM,MAAM;QAC5B,IAAI,CAAC,mBAAmB,CAAC,CAAC,MAAM,MAAM;QACtC,OAAO;IACX;IACA,YAAY;QACR,OAAO,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,SAAS,CAAC,MAAM,GAAG,EAAE;IACpD;IACA,UAAU;QACN,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,GAAG,IAAI,CAAC,SAAS,CAAC,MAAM;IAClD;AACJ;AACA,IAAI;AACJ,CAAC,SAAU,YAAY;IACnB,YAAY,CAAC,YAAY,CAAC,OAAO,GAAG,EAAE,GAAG;IACzC,YAAY,CAAC,YAAY,CAAC,gBAAgB,GAAG,EAAE,GAAG;IAClD,YAAY,CAAC,YAAY,CAAC,YAAY,GAAG,EAAE,GAAG;IAC9C,YAAY,CAAC,YAAY,CAAC,WAAW,GAAG,EAAE,GAAG;AACjD,CAAC,EAAE,gBAAgB,CAAC,eAAe,CAAC,CAAC;AACrC,SAAS,OAAO,IAAI;IAChB,OAAO,KAAK,KAAK,KAAK;AAC1B;AACA,yMAAyM;AACzM,SAAS,OAAO,IAAI,EAAE,YAAY;IAC9B,IAAI,UAAU;IACd,MAAM,UAAU,EAAE;IAClB,IAAI;IACJ,MAAO,KAAM;QACT,IAAI,aAAa,MAAM,KAAK,QAAQ,MAAM,EAAE;YACxC,8BAA8B;YAC9B;QACJ;QACA,IAAI,OAAO,UAAU;YACjB,MAAM,IAAI,MAAM;QACpB;QACA,QAAQ,IAAI,CAAC;QACb,UAAU,QAAQ,SAAS;IAC/B;IACA,IAAK,IAAI,IAAI,QAAQ,MAAM,GAAG,GAAG,KAAK,GAAG,IAAK;QAC1C,MAAM,SAAS,OAAO,CAAC,EAAE;QACzB,IAAI,6BAA6B;YAC7B,2BAA2B;YAC3B,IAAI,OAAO,QAAQ,CAAC,MAAM,IAAI,GAAG;gBAC7B,oDAAoD;gBACpD,0DAA0D;gBAC1D,MAAM,UAAU,SAAS,MAAM,CAAC,OAAO,aAAa,IAAI;gBACxD,8BAA8B;YAClC,OACK;gBACD,OAAO,WAAW,CAAC;gBACnB,8BAA8B;YAClC;QACJ;IACJ;IACA,IAAI,6BAA6B;QAC7B,MAAM,UAAU,IAAI,SAAS,4BAA4B,MAAM,GAAG;QAClE,QAAQ,WAAW,CAAC;QACpB,QAAQ,WAAW,CAAC;QACpB,OAAO;IACX,OACK;QACD,OAAO;IACX;AACJ;AACA,SAAS,QAAQ,IAAI,EAAE,YAAY;IAC/B,IAAI,UAAU;IACd,MAAM,UAAU,EAAE;IAClB,MAAO,aAAa,MAAM,KAAK,QAAQ,MAAM,CAAE;QAC3C,IAAI,OAAO,UAAU;YACjB,MAAM,IAAI,MAAM;QACpB;QACA,QAAQ,IAAI,CAAC;QACb,+CAA+C;QAC/C,UAAU,QAAQ,QAAQ,CAAC,EAAE;IACjC;IACA,IAAI,+BAA+B;IACnC,wEAAwE;IACxE,IAAK,IAAI,IAAI,QAAQ,MAAM,GAAG,GAAG,KAAK,GAAG,IAAK;QAC1C,MAAM,SAAS,OAAO,CAAC,EAAE;QACzB,IAAI,8BAA8B;YAC9B,2BAA2B;YAC3B,IAAI,OAAO,QAAQ,CAAC,MAAM,IAAI,GAAG;gBAC7B,oDAAoD;gBACpD,0DAA0D;gBAC1D,+BAA+B,SAAS,MAAM,CAAC,8BAA8B,OAAO,cAAc;YACtG,OACK;gBACD,OAAO,YAAY,CAAC;gBACpB,+BAA+B;YACnC;QACJ;IACJ;IACA,IAAI,8BAA8B;QAC9B,OAAO,SAAS,MAAM,CAAC,8BAA8B;IACzD,OACK;QACD,OAAO;IACX;AACJ;AACA,SAAS,OAAO,KAAK,EAAE,KAAK;IACxB,IAAI,MAAM,MAAM,KAAK,MAAM,MAAM,EAAE;QAC/B,OAAO,SAAS,MAAM,CAAC,OAAO;IAClC,OACK,IAAI,MAAM,MAAM,GAAG,MAAM,MAAM,EAAE;QAClC,2CAA2C;QAC3C,OAAO,OAAO,OAAO;IACzB,OACK;QACD,OAAO,QAAQ,OAAO;IAC1B;AACJ;AACA,MAAM;IACF,YAAY,UAAU,CAAE;QACpB,IAAI,CAAC,UAAU,GAAG;QAClB,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC,eAAe;IACrC;IACA,kBAAkB;QACd,OAAO;YACH,QAAQ,IAAI,CAAC,UAAU,CAAC,cAAc;YACtC,OAAO;YACP,QAAQ;YACR,cAAc,aAAa,IAAI;QACnC;IACJ;IACA;;;KAGC,GACD,WAAW,MAAM,EAAE,YAAY,EAAE;QAC7B,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC,iBAAiB,CAAC,QAAQ;IAChD;IACA,kBAAkB,MAAM,EAAE,YAAY,EAAE;QACpC,IAAI,OAAO,MAAM,KAAK,GAAG;YACrB,OAAO,IAAI,CAAC,eAAe;QAC/B;QACA,IAAI,UAAU;YACV,QAAQ,MAAM,CAAC,EAAE,CAAC,MAAM;YACxB,OAAO,MAAM,CAAC,EAAE,CAAC,KAAK;YACtB,QAAQ;YACR;QACJ;QACA,IAAK,IAAI,IAAI,GAAG,IAAI,OAAO,MAAM,EAAE,IAAK;YACpC,UAAU,OAAO,SAAS;gBAAE,QAAQ,MAAM,CAAC,EAAE,CAAC,MAAM;gBAAE,OAAO,MAAM,CAAC,EAAE,CAAC,KAAK;gBAAE,QAAQ;gBAAG;YAAa;QAC1G;QACA,OAAO;IACX;IACA;;;KAGC,GACD,OAAO,MAAM,EAAE,MAAM,EAAE,YAAY,EAAE;QACjC,IAAI,OAAO,MAAM,KAAK,GAAG;YACrB;QACJ;QACA,IAAI,CAAC,OAAO,CAAC,QAAQ,MAAM,CAAC,EAAE,CAAC,oBAAoB,EAAE,QAAQ;IACjE;IACA,OAAO,MAAM,EAAE,WAAW,EAAE;QACxB,IAAI,CAAC,OAAO,CAAC,QAAQ,aAAa,EAAE,EAAE,aAAa,SAAS;IAChE;IACA;;;KAGC,GACD,QAAQ,MAAM,EAAE,iBAAiB,EAAE,MAAM,EAAE,YAAY,EAAE;QACrD,MAAM,kCAAkC,oBAAoB;QAC5D,oDAAoD;QACpD,MAAM,iBAAiB,EAAE;QACzB,iDAAiD;QACjD,MAAM,kBAAkB,EAAE;QAC1B,MAAM,QAAQ;YAAC;gBAAE,MAAM,IAAI,CAAC,KAAK;gBAAE,QAAQ;YAAE;SAAE;QAC/C,MAAO,MAAM,MAAM,GAAG,EAAG;YACrB,MAAM,OAAO,MAAM,GAAG;YACtB,MAAM,gBAAgB,KAAK,MAAM;YACjC,IAAI,gBAAgB,qBAAqB,gBAAgB,KAAK,IAAI,CAAC,MAAM,IAAI,mBAAmB;gBAC5F,IAAI,CAAC,OAAO,KAAK,IAAI,GAAG;oBACpB,KAAK,IAAI,CAAC,MAAM,GAAG;gBACvB;gBACA,eAAe,IAAI,CAAC,KAAK,IAAI;gBAC7B;YACJ,OACK,IAAI,OAAO,KAAK,IAAI,KAAM,gBAAgB,mBAAoB;gBAC/D,mCAAmC;gBACnC,eAAe,IAAI,CAAC;oBAAE,QAAQ,oBAAoB;oBAAe,OAAO,KAAK,IAAI,CAAC,KAAK;oBAAE,QAAQ;oBAAG,cAAc,KAAK,IAAI,CAAC,YAAY;gBAAC;YACzI,oDAAoD;YACxD;YACA,IAAI,AAAC,qBAAqB,iBAAmB,gBAAgB,KAAK,IAAI,CAAC,MAAM,IAAI,iCAAkC;gBAC/G;YACJ;YACA,IAAI,iBAAiB,iCAAiC;gBAClD,IAAI,CAAC,OAAO,KAAK,IAAI,GAAG;oBACpB,KAAK,IAAI,CAAC,MAAM,GAAG;gBACvB;gBACA,gBAAgB,IAAI,CAAC,KAAK,IAAI;gBAC9B;YACJ,OACK,IAAI,OAAO,KAAK,IAAI,KAAM,gBAAgB,KAAK,IAAI,CAAC,MAAM,GAAG,iCAAkC;gBAChG,qCAAqC;gBACrC,gBAAgB,IAAI,CAAC;oBAAE,QAAQ,gBAAgB,KAAK,IAAI,CAAC,MAAM,GAAG;oBAAiC,OAAO,KAAK,IAAI,CAAC,KAAK;oBAAE,QAAQ;oBAAG,cAAc,KAAK,IAAI,CAAC,YAAY;gBAAC;gBAC3K;YACJ;YACA,IAAI,CAAC,OAAO,KAAK,IAAI,GAAG;gBACpB,4EAA4E;gBAC5E,IAAI,cAAc,gBAAgB,KAAK,IAAI,CAAC,MAAM;gBAClD,IAAK,IAAI,IAAI,KAAK,IAAI,CAAC,QAAQ,CAAC,MAAM,GAAG,GAAG,KAAK,GAAG,IAAK;oBACrD,eAAe,KAAK,IAAI,CAAC,QAAQ,CAAC,EAAE,CAAC,MAAM;oBAC3C,MAAM,IAAI,CAAC;wBAAE,MAAM,KAAK,IAAI,CAAC,QAAQ,CAAC,EAAE;wBAAE,QAAQ;oBAAY;gBAClE;YACJ;QACJ;QACA,IAAI;QACJ,IAAI,OAAO,MAAM,GAAG,GAAG;YACnB,WAAW,eAAe,MAAM,CAAC,IAAI,CAAC,iBAAiB,CAAC,QAAQ,eAAe;QACnF,OACK;YACD,WAAW,eAAe,MAAM,CAAC;QACrC;QACA,IAAI,UAAU,QAAQ,CAAC,EAAE;QACzB,IAAK,IAAI,IAAI,GAAG,IAAI,SAAS,MAAM,EAAE,IAAK;YACtC,UAAU,OAAO,SAAS,QAAQ,CAAC,EAAE;QACzC;QACA,IAAI,CAAC,KAAK,GAAG,WAAW,IAAI,CAAC,eAAe;IAChD;IACA;;;;;;KAMC,GACD,uBAAuB,oBAAoB,EAAE,kBAAkB,EAAE,OAAO,EAAE;QACtE,MAAM,QAAQ;YAAC;gBAAE,MAAM,IAAI,CAAC,KAAK;gBAAE,QAAQ;YAAE;SAAE;QAC/C,MAAO,MAAM,MAAM,GAAG,EAAG;YACrB,MAAM,EAAE,IAAI,EAAE,MAAM,EAAE,GAAG,MAAM,GAAG;YAClC,MAAM,UAAU,SAAS,KAAK,MAAM;YACpC,2DAA2D;YAC3D,IAAI,WAAW,wBAAwB,UAAU,oBAAoB;gBACjE;YACJ;YACA,IAAI,QAAQ,MAAM,SAAS;gBACvB;YACJ;YACA,IAAI,CAAC,OAAO,OAAO;gBACf,4EAA4E;gBAC5E,IAAI,cAAc,SAAS,KAAK,MAAM;gBACtC,IAAK,IAAI,IAAI,KAAK,QAAQ,CAAC,MAAM,GAAG,GAAG,KAAK,GAAG,IAAK;oBAChD,eAAe,KAAK,QAAQ,CAAC,EAAE,CAAC,MAAM;oBACtC,MAAM,IAAI,CAAC;wBAAE,MAAM,KAAK,QAAQ,CAAC,EAAE;wBAAE,QAAQ;oBAAY;gBAC7D;YACJ;QACJ;IACJ;IACA,WAAW,MAAM,EAAE;QACf,IAAI;QACJ,IAAI,CAAC,sBAAsB,CAAC,QAAQ,IAAI,CAAC,KAAK,CAAC,MAAM,EAAE,CAAC,MAAM;YAC1D,IAAI,OAAO,OAAO;gBACd,SAAS;oBAAE,OAAO,KAAK,KAAK;oBAAE,sBAAsB;oBAAQ,QAAQ,KAAK,MAAM;gBAAC;gBAChF,OAAO;YACX;YACA,OAAO;QACX;QACA,OAAO;IACX;IACA,iBAAiB,oBAAoB,EAAE,kBAAkB,EAAE;QACvD,MAAM,SAAS,EAAE;QACjB,IAAI,CAAC,sBAAsB,CAAC,sBAAsB,oBAAoB,CAAC,MAAM;YACzE,IAAI,OAAO,OAAO;gBACd,IAAI,gBAAgB,KAAK,MAAM;gBAC/B,IAAI,gBAAgB;gBACpB,IAAI,AAAC,SAAS,wBAA0B,SAAS,KAAK,MAAM,GAAG,oBAAqB;oBAChF,gBAAgB;oBAChB,gBAAgB,qBAAqB;gBACzC,OACK,IAAI,SAAS,sBAAsB;oBACpC,iBAAkB,uBAAuB;oBACzC,gBAAgB;gBACpB,OACK,IAAI,SAAS,KAAK,MAAM,GAAG,oBAAoB;oBAChD,iBAAkB,SAAS,KAAK,MAAM,GAAG;gBAC7C;gBACA,OAAO,IAAI,CAAC;oBAAE,OAAO,KAAK,KAAK;oBAAE,sBAAsB;oBAAe,QAAQ;gBAAc;YAChG;YACA,OAAO;QACX;QACA,OAAO;IACX;IACA,eAAe,oBAAoB,EAAE,kBAAkB,EAAE;QACrD,IAAI,CAAC,sBAAsB,CAAC,sBAAsB,oBAAoB,CAAC;YACnE,IAAI,OAAO,OAAO;gBACd,KAAK,YAAY,GAAG,aAAa,IAAI;YACzC;YACA,OAAO;QACX;IACJ;IACA,eAAe,oBAAoB,EAAE,kBAAkB,EAAE,mBAAmB,EAAE;QAC1E,IAAI,SAAS;QACb,IAAI,CAAC,sBAAsB,CAAC,sBAAsB,oBAAoB,CAAC;YACnE,IAAI,OAAO,SAAU,KAAK,YAAY,GAAG,qBAAsB;gBAC3D,SAAS;YACb;YACA,OAAO;QACX;QACA,OAAO;IACX;IACA,kBAAkB,oBAAoB,EAAE,kBAAkB,EAAE;QACxD,IAAI,eAAe;QACnB,IAAI,CAAC,sBAAsB,CAAC,sBAAsB,oBAAoB,CAAC;YACnE,IAAI,OAAO,SAAU,KAAK,YAAY,KAAK,aAAa,QAAQ,EAAG;gBAC/D,eAAe;YACnB;YACA,OAAO;QACX;QACA,OAAO;IACX;IACA,kBAAkB;QACd,MAAM,SAAS,EAAE;QACjB,IAAI,CAAC,sBAAsB,CAAC,GAAG,IAAI,CAAC,UAAU,CAAC,cAAc,IAAI,CAAC,MAAM;YACpE,IAAI,OAAO,SAAU,KAAK,YAAY,KAAK,aAAa,QAAQ,EAAG;gBAC/D,IAAI,AAAC,OAAO,MAAM,GAAG,KAAO,MAAM,CAAC,OAAO,MAAM,GAAG,EAAE,CAAC,SAAS,KAAK,QAAS;oBACzE,MAAM,CAAC,OAAO,MAAM,GAAG,EAAE,CAAC,SAAS,IAAI,KAAK,MAAM;gBACtD,OACK;oBACD,OAAO,IAAI,CAAC;wBAAE,aAAa;wBAAQ,WAAW,SAAS,KAAK,MAAM;oBAAC;gBACvE;YACJ;YACA,OAAO;QACX;QACA,OAAO;IACX;IACA,UAAU;QACN,MAAM,QAAQ;YAAC;gBAAC,IAAI,CAAC,KAAK;gBAAE;aAAM;SAAC;QACnC,MAAO,MAAM,MAAM,GAAG,EAAG;YACrB,MAAM,CAAC,MAAM,QAAQ,GAAG,MAAM,GAAG;YACjC,IAAI,OAAO;iBACN,IAAI,CAAC,SAAS;gBACf,MAAM,IAAI,CAAC;oBAAC;oBAAM;iBAAK;gBACvB,IAAK,IAAI,IAAI,KAAK,QAAQ,CAAC,MAAM,GAAG,GAAG,KAAK,GAAG,IAAK;oBAChD,MAAM,IAAI,CAAC;wBAAC,KAAK,QAAQ,CAAC,EAAE;wBAAE;qBAAM;gBACxC;YACJ,OACK;gBACD,KAAK,OAAO;gBACZ,KAAK,MAAM,GAAG;YAClB;QACJ;QACA,IAAI,CAAC,KAAK,GAAG;IACjB;AACJ","ignoreList":[0]}},
    {"offset": {"line": 10063, "column": 0}, "map": {"version":3,"sources":["file:///D:/real-time-code-editor%20%282%29/node_modules/.pnpm/monaco-editor%400.55.1/node_modules/monaco-editor/esm/vs/editor/common/model/tokens/treeSitter/treeSitterTokenizationImpl.js"],"sourcesContent":["import { Emitter } from '../../../../../base/common/event.js';\nimport { Disposable } from '../../../../../base/common/lifecycle.js';\nimport { setTimeout0 } from '../../../../../base/common/platform.js';\nimport { StopWatch } from '../../../../../base/common/stopwatch.js';\nimport { findLikelyRelevantLines } from '../../textModelTokens.js';\nimport { TokenStore, TokenQuality } from './tokenStore.js';\nimport '../../../../../base/common/observableInternal/index.js';\nimport { LineTokens } from '../../../tokens/lineTokens.js';\nimport { Position } from '../../../core/position.js';\nimport { Range } from '../../../core/range.js';\nimport { isDefined } from '../../../../../base/common/types.js';\nimport { ITreeSitterThemeService } from '../../../services/treeSitter/treeSitterThemeService.js';\nimport { BugIndicatingError } from '../../../../../base/common/errors.js';\nimport { autorun, autorunHandleChanges } from '../../../../../base/common/observableInternal/reactions/autorun.js';\nimport { recordChanges } from '../../../../../base/common/observableInternal/changeTracker.js';\nimport { runOnChange } from '../../../../../base/common/observableInternal/utils/runOnChange.js';\n\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (undefined && undefined.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nlet TreeSitterTokenizationImpl = class TreeSitterTokenizationImpl extends Disposable {\n    get _textModel() {\n        return this._tree.textModel;\n    }\n    constructor(_tree, _highlightingQueries, _languageIdCodec, _visibleLineRanges, _treeSitterThemeService) {\n        super();\n        this._tree = _tree;\n        this._highlightingQueries = _highlightingQueries;\n        this._languageIdCodec = _languageIdCodec;\n        this._visibleLineRanges = _visibleLineRanges;\n        this._treeSitterThemeService = _treeSitterThemeService;\n        this._onDidChangeTokens = this._register(new Emitter());\n        this.onDidChangeTokens = this._onDidChangeTokens.event;\n        this._onDidCompleteBackgroundTokenization = this._register(new Emitter());\n        this.onDidChangeBackgroundTokenization = this._onDidCompleteBackgroundTokenization.event;\n        this._encodedLanguageId = this._languageIdCodec.encodeLanguageId(this._tree.languageId);\n        this._register(runOnChange(this._treeSitterThemeService.onChange, () => {\n            this._updateTheme();\n        }));\n        this._tokenStore = this._register(new TokenStore(this._textModel));\n        this._accurateVersion = this._textModel.getVersionId();\n        this._guessVersion = this._textModel.getVersionId();\n        this._tokenStore.buildStore(this._createEmptyTokens(), TokenQuality.None);\n        this._register(autorun(reader => {\n            const visibleLineRanges = this._visibleLineRanges.read(reader);\n            this._parseAndTokenizeViewPort(visibleLineRanges);\n        }));\n        this._register(autorunHandleChanges({\n            owner: this,\n            changeTracker: recordChanges({ tree: this._tree.tree }),\n        }, (reader, ctx) => {\n            const changeEvent = ctx.changes.at(0)?.change;\n            if (ctx.changes.length > 1) {\n                throw new BugIndicatingError('The tree changed twice in one transaction. This is currently not supported and should not happen.');\n            }\n            if (!changeEvent) {\n                if (ctx.tree) {\n                    this._firstTreeUpdate(this._tree.treeLastParsedVersion.read(reader));\n                }\n            }\n            else {\n                if (this.hasTokens()) {\n                    // Mark the range for refresh immediately\n                    for (const range of changeEvent.ranges) {\n                        this._markForRefresh(range.newRange);\n                    }\n                }\n                // First time we see a tree we need to build a token store.\n                if (!this.hasTokens()) {\n                    this._firstTreeUpdate(changeEvent.versionId);\n                }\n                else {\n                    this._handleTreeUpdate(changeEvent.ranges, changeEvent.versionId);\n                }\n            }\n        }));\n    }\n    handleContentChanged(e) {\n        this._guessVersion = e.versionId;\n        for (const change of e.changes) {\n            if (change.text.length > change.rangeLength) {\n                // If possible, use the token before the change as the starting point for the new token.\n                // This is more likely to let the new text be the correct color as typeing is usually at the end of the token.\n                const offset = change.rangeOffset > 0 ? change.rangeOffset - 1 : change.rangeOffset;\n                const oldToken = this._tokenStore.getTokenAt(offset);\n                let newToken;\n                if (oldToken) {\n                    // Insert. Just grow the token at this position to include the insert.\n                    newToken = { startOffsetInclusive: oldToken.startOffsetInclusive, length: oldToken.length + change.text.length - change.rangeLength, token: oldToken.token };\n                    // Also mark tokens that are in the range of the change as needing a refresh.\n                    this._tokenStore.markForRefresh(offset, change.rangeOffset + (change.text.length > change.rangeLength ? change.text.length : change.rangeLength));\n                }\n                else {\n                    // The document got larger and the change is at the end of the document.\n                    newToken = { startOffsetInclusive: offset, length: change.text.length, token: 0 };\n                }\n                this._tokenStore.update(oldToken?.length ?? 0, [newToken], TokenQuality.EditGuess);\n            }\n            else if (change.text.length < change.rangeLength) {\n                // Delete. Delete the tokens at the corresponding range.\n                const deletedCharCount = change.rangeLength - change.text.length;\n                this._tokenStore.delete(deletedCharCount, change.rangeOffset);\n            }\n        }\n    }\n    getLineTokens(lineNumber) {\n        const content = this._textModel.getLineContent(lineNumber);\n        const rawTokens = this.getTokens(lineNumber);\n        return new LineTokens(rawTokens, content, this._languageIdCodec);\n    }\n    _createEmptyTokens() {\n        const emptyToken = this._emptyToken();\n        const modelEndOffset = this._textModel.getValueLength();\n        const emptyTokens = [this._emptyTokensForOffsetAndLength(0, modelEndOffset, emptyToken)];\n        return emptyTokens;\n    }\n    _emptyToken() {\n        return this._treeSitterThemeService.findMetadata([], this._encodedLanguageId, false, undefined);\n    }\n    _emptyTokensForOffsetAndLength(offset, length, emptyToken) {\n        return { token: emptyToken, length: offset + length, startOffsetInclusive: 0 };\n    }\n    hasAccurateTokensForLine(lineNumber) {\n        return this.hasTokens(new Range(lineNumber, 1, lineNumber, this._textModel.getLineMaxColumn(lineNumber)));\n    }\n    tokenizeLinesAt(lineNumber, lines) {\n        const rawLineTokens = this._guessTokensForLinesContent(lineNumber, lines);\n        const lineTokens = [];\n        if (!rawLineTokens) {\n            return null;\n        }\n        for (let i = 0; i < rawLineTokens.length; i++) {\n            lineTokens.push(new LineTokens(rawLineTokens[i], lines[i], this._languageIdCodec));\n        }\n        return lineTokens;\n    }\n    _rangeHasTokens(range, minimumTokenQuality) {\n        return this._tokenStore.rangeHasTokens(this._textModel.getOffsetAt(range.getStartPosition()), this._textModel.getOffsetAt(range.getEndPosition()), minimumTokenQuality);\n    }\n    hasTokens(accurateForRange) {\n        if (!accurateForRange || (this._guessVersion === this._accurateVersion)) {\n            return true;\n        }\n        return !this._tokenStore.rangeNeedsRefresh(this._textModel.getOffsetAt(accurateForRange.getStartPosition()), this._textModel.getOffsetAt(accurateForRange.getEndPosition()));\n    }\n    getTokens(line) {\n        const lineStartOffset = this._textModel.getOffsetAt({ lineNumber: line, column: 1 });\n        const lineEndOffset = this._textModel.getOffsetAt({ lineNumber: line, column: this._textModel.getLineLength(line) + 1 });\n        const lineTokens = this._tokenStore.getTokensInRange(lineStartOffset, lineEndOffset);\n        const result = new Uint32Array(lineTokens.length * 2);\n        for (let i = 0; i < lineTokens.length; i++) {\n            result[i * 2] = lineTokens[i].startOffsetInclusive - lineStartOffset + lineTokens[i].length;\n            result[i * 2 + 1] = lineTokens[i].token;\n        }\n        return result;\n    }\n    getTokensInRange(range, rangeStartOffset, rangeEndOffset, captures) {\n        const tokens = captures ? this._tokenizeCapturesWithMetadata(captures, rangeStartOffset, rangeEndOffset) : this._tokenize(range, rangeStartOffset, rangeEndOffset);\n        if (tokens?.endOffsetsAndMetadata) {\n            return this._rangeTokensAsUpdates(rangeStartOffset, tokens.endOffsetsAndMetadata);\n        }\n        return undefined;\n    }\n    _updateTokensInStore(version, updates, tokenQuality) {\n        this._accurateVersion = version;\n        for (const update of updates) {\n            const lastToken = update.newTokens.length > 0 ? update.newTokens[update.newTokens.length - 1] : undefined;\n            let oldRangeLength;\n            if (lastToken && (this._guessVersion >= version)) {\n                oldRangeLength = lastToken.startOffsetInclusive + lastToken.length - update.newTokens[0].startOffsetInclusive;\n            }\n            else if (update.oldRangeLength) {\n                oldRangeLength = update.oldRangeLength;\n            }\n            else {\n                oldRangeLength = 0;\n            }\n            this._tokenStore.update(oldRangeLength, update.newTokens, tokenQuality);\n        }\n    }\n    _markForRefresh(range) {\n        this._tokenStore.markForRefresh(this._textModel.getOffsetAt(range.getStartPosition()), this._textModel.getOffsetAt(range.getEndPosition()));\n    }\n    _getNeedsRefresh() {\n        const needsRefreshOffsetRanges = this._tokenStore.getNeedsRefresh();\n        if (!needsRefreshOffsetRanges) {\n            return [];\n        }\n        return needsRefreshOffsetRanges.map(range => ({\n            range: Range.fromPositions(this._textModel.getPositionAt(range.startOffset), this._textModel.getPositionAt(range.endOffset)),\n            startOffset: range.startOffset,\n            endOffset: range.endOffset\n        }));\n    }\n    _parseAndTokenizeViewPort(lineRanges) {\n        const viewportRanges = lineRanges.map(r => r.toInclusiveRange()).filter(isDefined);\n        for (const range of viewportRanges) {\n            const startOffsetOfRangeInDocument = this._textModel.getOffsetAt(range.getStartPosition());\n            const endOffsetOfRangeInDocument = this._textModel.getOffsetAt(range.getEndPosition());\n            const version = this._textModel.getVersionId();\n            if (this._rangeHasTokens(range, TokenQuality.ViewportGuess)) {\n                continue;\n            }\n            const content = this._textModel.getValueInRange(range);\n            const tokenUpdates = this._forceParseAndTokenizeContent(range, startOffsetOfRangeInDocument, endOffsetOfRangeInDocument, content, true);\n            if (!tokenUpdates || this._rangeHasTokens(range, TokenQuality.ViewportGuess)) {\n                continue;\n            }\n            if (tokenUpdates.length === 0) {\n                continue;\n            }\n            const lastToken = tokenUpdates[tokenUpdates.length - 1];\n            const oldRangeLength = lastToken.startOffsetInclusive + lastToken.length - tokenUpdates[0].startOffsetInclusive;\n            this._updateTokensInStore(version, [{ newTokens: tokenUpdates, oldRangeLength }], TokenQuality.ViewportGuess);\n            this._onDidChangeTokens.fire({ changes: { semanticTokensApplied: false, ranges: [{ fromLineNumber: range.startLineNumber, toLineNumber: range.endLineNumber }] } });\n        }\n    }\n    _guessTokensForLinesContent(lineNumber, lines) {\n        if (lines.length === 0) {\n            return undefined;\n        }\n        const lineContent = lines.join(this._textModel.getEOL());\n        const range = new Range(1, 1, lineNumber + lines.length, lines[lines.length - 1].length + 1);\n        const startOffset = this._textModel.getOffsetAt({ lineNumber, column: 1 });\n        const tokens = this._forceParseAndTokenizeContent(range, startOffset, startOffset + lineContent.length, lineContent, false);\n        if (!tokens) {\n            return undefined;\n        }\n        const tokensByLine = new Array(lines.length);\n        let tokensIndex = 0;\n        let tokenStartOffset = 0;\n        let lineStartOffset = 0;\n        for (let i = 0; i < lines.length; i++) {\n            const tokensForLine = [];\n            let moveToNextLine = false;\n            for (let j = tokensIndex; (!moveToNextLine && (j < tokens.length)); j++) {\n                const token = tokens[j];\n                const lineAdjustedEndOffset = token.endOffset - lineStartOffset;\n                const lineAdjustedStartOffset = tokenStartOffset - lineStartOffset;\n                if (lineAdjustedEndOffset <= lines[i].length) {\n                    tokensForLine.push({ endOffset: lineAdjustedEndOffset, metadata: token.metadata });\n                    tokensIndex++;\n                }\n                else if (lineAdjustedStartOffset < lines[i].length) {\n                    const partialToken = { endOffset: lines[i].length, metadata: token.metadata };\n                    tokensForLine.push(partialToken);\n                    moveToNextLine = true;\n                }\n                else {\n                    moveToNextLine = true;\n                }\n                tokenStartOffset = token.endOffset;\n            }\n            tokensByLine[i] = this._endOffsetTokensToUint32Array(tokensForLine);\n            lineStartOffset += lines[i].length + this._textModel.getEOL().length;\n        }\n        return tokensByLine;\n    }\n    _forceParseAndTokenizeContent(range, startOffsetOfRangeInDocument, endOffsetOfRangeInDocument, content, asUpdate) {\n        const likelyRelevantLines = findLikelyRelevantLines(this._textModel, range.startLineNumber).likelyRelevantLines;\n        const likelyRelevantPrefix = likelyRelevantLines.join(this._textModel.getEOL());\n        const tree = this._tree.createParsedTreeSync(`${likelyRelevantPrefix}${content}`);\n        if (!tree) {\n            return;\n        }\n        const treeRange = new Range(1, 1, range.endLineNumber - range.startLineNumber + 1 + likelyRelevantLines.length, range.endColumn);\n        const captures = this.captureAtRange(treeRange);\n        const tokens = this._tokenizeCapturesWithMetadata(captures, likelyRelevantPrefix.length, endOffsetOfRangeInDocument - startOffsetOfRangeInDocument + likelyRelevantPrefix.length);\n        tree.delete();\n        if (!tokens) {\n            return;\n        }\n        if (asUpdate) {\n            return this._rangeTokensAsUpdates(startOffsetOfRangeInDocument, tokens.endOffsetsAndMetadata, likelyRelevantPrefix.length);\n        }\n        else {\n            return tokens.endOffsetsAndMetadata;\n        }\n    }\n    _firstTreeUpdate(versionId) {\n        return this._setViewPortTokens(versionId);\n    }\n    _setViewPortTokens(versionId) {\n        const rangeChanges = this._visibleLineRanges.get().map(lineRange => {\n            const range = lineRange.toInclusiveRange();\n            if (!range) {\n                return undefined;\n            }\n            const newRangeStartOffset = this._textModel.getOffsetAt(range.getStartPosition());\n            const newRangeEndOffset = this._textModel.getOffsetAt(range.getEndPosition());\n            return {\n                newRange: range,\n                newRangeEndOffset,\n                newRangeStartOffset,\n            };\n        }).filter(isDefined);\n        return this._handleTreeUpdate(rangeChanges, versionId);\n    }\n    /**\n     * Do not await in this method, it will cause a race\n     */\n    _handleTreeUpdate(ranges, versionId) {\n        const rangeChanges = [];\n        const chunkSize = 1000;\n        for (let i = 0; i < ranges.length; i++) {\n            const rangeLinesLength = ranges[i].newRange.endLineNumber - ranges[i].newRange.startLineNumber;\n            if (rangeLinesLength > chunkSize) {\n                // Split the range into chunks to avoid long operations\n                const fullRangeEndLineNumber = ranges[i].newRange.endLineNumber;\n                let chunkLineStart = ranges[i].newRange.startLineNumber;\n                let chunkColumnStart = ranges[i].newRange.startColumn;\n                let chunkLineEnd = chunkLineStart + chunkSize;\n                do {\n                    const chunkStartingPosition = new Position(chunkLineStart, chunkColumnStart);\n                    const chunkEndColumn = ((chunkLineEnd === ranges[i].newRange.endLineNumber) ? ranges[i].newRange.endColumn : this._textModel.getLineMaxColumn(chunkLineEnd));\n                    const chunkEndPosition = new Position(chunkLineEnd, chunkEndColumn);\n                    const chunkRange = Range.fromPositions(chunkStartingPosition, chunkEndPosition);\n                    rangeChanges.push({\n                        range: chunkRange,\n                        startOffset: this._textModel.getOffsetAt(chunkRange.getStartPosition()),\n                        endOffset: this._textModel.getOffsetAt(chunkRange.getEndPosition())\n                    });\n                    chunkLineStart = chunkLineEnd + 1;\n                    chunkColumnStart = 1;\n                    if (chunkLineEnd < fullRangeEndLineNumber && chunkLineEnd + chunkSize > fullRangeEndLineNumber) {\n                        chunkLineEnd = fullRangeEndLineNumber;\n                    }\n                    else {\n                        chunkLineEnd = chunkLineEnd + chunkSize;\n                    }\n                } while (chunkLineEnd <= fullRangeEndLineNumber);\n            }\n            else {\n                // Check that the previous range doesn't overlap\n                if ((i === 0) || (rangeChanges[i - 1].endOffset < ranges[i].newRangeStartOffset)) {\n                    rangeChanges.push({\n                        range: ranges[i].newRange,\n                        startOffset: ranges[i].newRangeStartOffset,\n                        endOffset: ranges[i].newRangeEndOffset\n                    });\n                }\n                else if (rangeChanges[i - 1].endOffset < ranges[i].newRangeEndOffset) {\n                    // clip the range to the previous range\n                    const startPosition = this._textModel.getPositionAt(rangeChanges[i - 1].endOffset + 1);\n                    const range = new Range(startPosition.lineNumber, startPosition.column, ranges[i].newRange.endLineNumber, ranges[i].newRange.endColumn);\n                    rangeChanges.push({\n                        range,\n                        startOffset: rangeChanges[i - 1].endOffset + 1,\n                        endOffset: ranges[i].newRangeEndOffset\n                    });\n                }\n            }\n        }\n        // Get the captures immediately while the text model is correct\n        const captures = rangeChanges.map(range => this._getCaptures(range.range));\n        // Don't block\n        return this._updateTreeForRanges(rangeChanges, versionId, captures).then(() => {\n            if (!this._textModel.isDisposed() && (this._tree.treeLastParsedVersion.get() === this._textModel.getVersionId())) {\n                this._refreshNeedsRefresh(versionId);\n            }\n        });\n    }\n    async _updateTreeForRanges(rangeChanges, versionId, captures) {\n        let tokenUpdate;\n        for (let i = 0; i < rangeChanges.length; i++) {\n            if (!this._textModel.isDisposed() && versionId !== this._textModel.getVersionId()) {\n                // Our captures have become invalid and we need to re-capture\n                break;\n            }\n            const capture = captures[i];\n            const range = rangeChanges[i];\n            const updates = this.getTokensInRange(range.range, range.startOffset, range.endOffset, capture);\n            if (updates) {\n                tokenUpdate = { newTokens: updates };\n            }\n            else {\n                tokenUpdate = { newTokens: [] };\n            }\n            this._updateTokensInStore(versionId, [tokenUpdate], TokenQuality.Accurate);\n            this._onDidChangeTokens.fire({\n                changes: {\n                    semanticTokensApplied: false,\n                    ranges: [{ fromLineNumber: range.range.getStartPosition().lineNumber, toLineNumber: range.range.getEndPosition().lineNumber }]\n                }\n            });\n            await new Promise(resolve => setTimeout0(resolve));\n        }\n        this._onDidCompleteBackgroundTokenization.fire();\n    }\n    _refreshNeedsRefresh(versionId) {\n        const rangesToRefresh = this._getNeedsRefresh();\n        if (rangesToRefresh.length === 0) {\n            return;\n        }\n        const rangeChanges = new Array(rangesToRefresh.length);\n        for (let i = 0; i < rangesToRefresh.length; i++) {\n            const range = rangesToRefresh[i];\n            rangeChanges[i] = {\n                newRange: range.range,\n                newRangeStartOffset: range.startOffset,\n                newRangeEndOffset: range.endOffset\n            };\n        }\n        this._handleTreeUpdate(rangeChanges, versionId);\n    }\n    _rangeTokensAsUpdates(rangeOffset, endOffsetToken, startingOffsetInArray) {\n        const updates = [];\n        let lastEnd = 0;\n        for (const token of endOffsetToken) {\n            if (token.endOffset <= lastEnd || (startingOffsetInArray && (token.endOffset < startingOffsetInArray))) {\n                continue;\n            }\n            let tokenUpdate;\n            if (startingOffsetInArray && (lastEnd < startingOffsetInArray)) {\n                tokenUpdate = { startOffsetInclusive: rangeOffset + startingOffsetInArray, length: token.endOffset - startingOffsetInArray, token: token.metadata };\n            }\n            else {\n                tokenUpdate = { startOffsetInclusive: rangeOffset + lastEnd, length: token.endOffset - lastEnd, token: token.metadata };\n            }\n            updates.push(tokenUpdate);\n            lastEnd = token.endOffset;\n        }\n        return updates;\n    }\n    _updateTheme() {\n        const modelRange = this._textModel.getFullModelRange();\n        this._markForRefresh(modelRange);\n        this._parseAndTokenizeViewPort(this._visibleLineRanges.get());\n    }\n    captureAtRange(range) {\n        const tree = this._tree.tree.get();\n        if (!tree) {\n            return [];\n        }\n        // Tree sitter row is 0 based, column is 0 based\n        return this._highlightingQueries.captures(tree.rootNode, { startPosition: { row: range.startLineNumber - 1, column: range.startColumn - 1 }, endPosition: { row: range.endLineNumber - 1, column: range.endColumn - 1 } }).map(capture => ({\n            name: capture.name,\n            text: capture.node.text,\n            node: {\n                startIndex: capture.node.startIndex,\n                endIndex: capture.node.endIndex,\n                startPosition: {\n                    lineNumber: capture.node.startPosition.row + 1,\n                    column: capture.node.startPosition.column + 1\n                },\n                endPosition: {\n                    lineNumber: capture.node.endPosition.row + 1,\n                    column: capture.node.endPosition.column + 1\n                }\n            },\n            encodedLanguageId: this._encodedLanguageId\n        }));\n    }\n    captureAtRangeWithInjections(range) {\n        const captures = this.captureAtRange(range);\n        for (let i = 0; i < captures.length; i++) {\n            const capture = captures[i];\n            const capStartLine = capture.node.startPosition.lineNumber;\n            const capEndLine = capture.node.endPosition.lineNumber;\n            const capStartColumn = capture.node.startPosition.column;\n            const capEndColumn = capture.node.endPosition.column;\n            const startLine = ((capStartLine > range.startLineNumber) && (capStartLine < range.endLineNumber)) ? capStartLine : range.startLineNumber;\n            const endLine = ((capEndLine > range.startLineNumber) && (capEndLine < range.endLineNumber)) ? capEndLine : range.endLineNumber;\n            const startColumn = (capStartLine === range.startLineNumber) ? (capStartColumn < range.startColumn ? range.startColumn : capStartColumn) : (capStartLine < range.startLineNumber ? range.startColumn : capStartColumn);\n            const endColumn = (capEndLine === range.endLineNumber) ? (capEndColumn > range.endColumn ? range.endColumn : capEndColumn) : (capEndLine > range.endLineNumber ? range.endColumn : capEndColumn);\n            const injectionRange = new Range(startLine, startColumn, endLine, endColumn);\n            const injection = this._getInjectionCaptures(capture, injectionRange);\n            if (injection && injection.length > 0) {\n                captures.splice(i + 1, 0, ...injection);\n                i += injection.length;\n            }\n        }\n        return captures;\n    }\n    /**\n     * Gets the tokens for a given line.\n     * Each token takes 2 elements in the array. The first element is the offset of the end of the token *in the line, not in the document*, and the second element is the metadata.\n     *\n     * @param lineNumber\n     * @returns\n     */\n    tokenizeEncoded(lineNumber) {\n        const tokens = this._tokenizeEncoded(lineNumber);\n        if (!tokens) {\n            return undefined;\n        }\n        const updates = this._rangeTokensAsUpdates(this._textModel.getOffsetAt({ lineNumber, column: 1 }), tokens.result);\n        if (tokens.versionId === this._textModel.getVersionId()) {\n            this._updateTokensInStore(tokens.versionId, [{ newTokens: updates, oldRangeLength: this._textModel.getLineLength(lineNumber) }], TokenQuality.Accurate);\n        }\n    }\n    _getCaptures(range) {\n        const captures = this.captureAtRangeWithInjections(range);\n        return captures;\n    }\n    _tokenize(range, rangeStartOffset, rangeEndOffset) {\n        const captures = this._getCaptures(range);\n        const result = this._tokenizeCapturesWithMetadata(captures, rangeStartOffset, rangeEndOffset);\n        if (!result) {\n            return undefined;\n        }\n        return { ...result, versionId: this._tree.treeLastParsedVersion.get() };\n    }\n    _createTokensFromCaptures(captures, rangeStartOffset, rangeEndOffset) {\n        const tree = this._tree.tree.get();\n        const stopwatch = StopWatch.create();\n        const rangeLength = rangeEndOffset - rangeStartOffset;\n        const encodedLanguageId = this._languageIdCodec.encodeLanguageId(this._tree.languageId);\n        const baseScope = TREESITTER_BASE_SCOPES[this._tree.languageId] || 'source';\n        if (captures.length === 0) {\n            if (tree) {\n                stopwatch.stop();\n                const endOffsetsAndMetadata = [{ endOffset: rangeLength, scopes: [], encodedLanguageId }];\n                return { endOffsets: endOffsetsAndMetadata, captureTime: stopwatch.elapsed() };\n            }\n            return undefined;\n        }\n        const endOffsetsAndScopes = Array(captures.length);\n        endOffsetsAndScopes.fill({ endOffset: 0, scopes: [baseScope], encodedLanguageId });\n        let tokenIndex = 0;\n        const increaseSizeOfTokensByOneToken = () => {\n            endOffsetsAndScopes.push({ endOffset: 0, scopes: [baseScope], encodedLanguageId });\n        };\n        const brackets = (capture, startOffset) => {\n            return (capture.name.includes('punctuation') && capture.text) ? Array.from(capture.text.matchAll(BRACKETS)).map(match => startOffset + match.index) : undefined;\n        };\n        const addCurrentTokenToArray = (capture, startOffset, endOffset, position) => {\n            if (position !== undefined) {\n                const oldScopes = endOffsetsAndScopes[position].scopes;\n                let oldBracket = endOffsetsAndScopes[position].bracket;\n                // Check that the previous token ends at the same point that the current token starts\n                const prevEndOffset = position > 0 ? endOffsetsAndScopes[position - 1].endOffset : 0;\n                if (prevEndOffset !== startOffset) {\n                    let preInsertBracket = undefined;\n                    if (oldBracket && oldBracket.length > 0) {\n                        preInsertBracket = [];\n                        const postInsertBracket = [];\n                        for (let i = 0; i < oldBracket.length; i++) {\n                            const bracket = oldBracket[i];\n                            if (bracket < startOffset) {\n                                preInsertBracket.push(bracket);\n                            }\n                            else if (bracket > endOffset) {\n                                postInsertBracket.push(bracket);\n                            }\n                        }\n                        if (preInsertBracket.length === 0) {\n                            preInsertBracket = undefined;\n                        }\n                        if (postInsertBracket.length === 0) {\n                            oldBracket = undefined;\n                        }\n                        else {\n                            oldBracket = postInsertBracket;\n                        }\n                    }\n                    // We need to add some of the position token to cover the space\n                    endOffsetsAndScopes.splice(position, 0, { endOffset: startOffset, scopes: [...oldScopes], bracket: preInsertBracket, encodedLanguageId: capture.encodedLanguageId });\n                    position++;\n                    increaseSizeOfTokensByOneToken();\n                    tokenIndex++;\n                }\n                endOffsetsAndScopes.splice(position, 0, { endOffset: endOffset, scopes: [...oldScopes, capture.name], bracket: brackets(capture, startOffset), encodedLanguageId: capture.encodedLanguageId });\n                endOffsetsAndScopes[tokenIndex].bracket = oldBracket;\n            }\n            else {\n                endOffsetsAndScopes[tokenIndex] = { endOffset: endOffset, scopes: [baseScope, capture.name], bracket: brackets(capture, startOffset), encodedLanguageId: capture.encodedLanguageId };\n            }\n            tokenIndex++;\n        };\n        for (let captureIndex = 0; captureIndex < captures.length; captureIndex++) {\n            const capture = captures[captureIndex];\n            const tokenEndIndex = capture.node.endIndex < rangeEndOffset ? ((capture.node.endIndex < rangeStartOffset) ? rangeStartOffset : capture.node.endIndex) : rangeEndOffset;\n            const tokenStartIndex = capture.node.startIndex < rangeStartOffset ? rangeStartOffset : capture.node.startIndex;\n            const endOffset = tokenEndIndex - rangeStartOffset;\n            // Not every character will get captured, so we need to make sure that our current capture doesn't bleed toward the start of the line and cover characters that it doesn't apply to.\n            // We do this by creating a new token in the array if the previous token ends before the current token starts.\n            let previousEndOffset;\n            const currentTokenLength = tokenEndIndex - tokenStartIndex;\n            if (captureIndex > 0) {\n                previousEndOffset = endOffsetsAndScopes[(tokenIndex - 1)].endOffset;\n            }\n            else {\n                previousEndOffset = tokenStartIndex - rangeStartOffset - 1;\n            }\n            const startOffset = endOffset - currentTokenLength;\n            if ((previousEndOffset >= 0) && (previousEndOffset < startOffset)) {\n                // Add en empty token to cover the space where there were no captures\n                endOffsetsAndScopes[tokenIndex] = { endOffset: startOffset, scopes: [baseScope], encodedLanguageId: this._encodedLanguageId };\n                tokenIndex++;\n                increaseSizeOfTokensByOneToken();\n            }\n            if (currentTokenLength < 0) {\n                // This happens when we have a token \"gap\" right at the end of the capture range. The last capture isn't used because it's start index isn't included in the range.\n                continue;\n            }\n            if (previousEndOffset >= endOffset) {\n                // walk back through the tokens until we find the one that contains the current token\n                let withinTokenIndex = tokenIndex - 1;\n                let previousTokenEndOffset = endOffsetsAndScopes[withinTokenIndex].endOffset;\n                let previousTokenStartOffset = ((withinTokenIndex >= 2) ? endOffsetsAndScopes[withinTokenIndex - 1].endOffset : 0);\n                do {\n                    // Check that the current token doesn't just replace the last token\n                    if ((previousTokenStartOffset + currentTokenLength) === previousTokenEndOffset) {\n                        if (previousTokenStartOffset === startOffset) {\n                            // Current token and previous token span the exact same characters, add the scopes to the previous token\n                            endOffsetsAndScopes[withinTokenIndex].scopes.push(capture.name);\n                            const oldBracket = endOffsetsAndScopes[withinTokenIndex].bracket;\n                            endOffsetsAndScopes[withinTokenIndex].bracket = ((oldBracket && (oldBracket.length > 0)) ? oldBracket : brackets(capture, startOffset));\n                        }\n                    }\n                    else if (previousTokenStartOffset <= startOffset) {\n                        addCurrentTokenToArray(capture, startOffset, endOffset, withinTokenIndex);\n                        break;\n                    }\n                    withinTokenIndex--;\n                    previousTokenStartOffset = ((withinTokenIndex >= 1) ? endOffsetsAndScopes[withinTokenIndex - 1].endOffset : 0);\n                    previousTokenEndOffset = ((withinTokenIndex >= 0) ? endOffsetsAndScopes[withinTokenIndex].endOffset : 0);\n                } while (previousTokenEndOffset > startOffset);\n            }\n            else {\n                // Just add the token to the array\n                addCurrentTokenToArray(capture, startOffset, endOffset);\n            }\n        }\n        // Account for uncaptured characters at the end of the line\n        if ((endOffsetsAndScopes[tokenIndex - 1].endOffset < rangeLength)) {\n            if (rangeLength - endOffsetsAndScopes[tokenIndex - 1].endOffset > 0) {\n                increaseSizeOfTokensByOneToken();\n                endOffsetsAndScopes[tokenIndex] = { endOffset: rangeLength, scopes: endOffsetsAndScopes[tokenIndex].scopes, encodedLanguageId: this._encodedLanguageId };\n                tokenIndex++;\n            }\n        }\n        for (let i = 0; i < endOffsetsAndScopes.length; i++) {\n            const token = endOffsetsAndScopes[i];\n            if (token.endOffset === 0 && i !== 0) {\n                endOffsetsAndScopes.splice(i, endOffsetsAndScopes.length - i);\n                break;\n            }\n        }\n        const captureTime = stopwatch.elapsed();\n        return { endOffsets: endOffsetsAndScopes, captureTime };\n    }\n    _getInjectionCaptures(parentCapture, range) {\n        /*\n                const injection = textModelTreeSitter.getInjection(parentCapture.node.startIndex, this._treeSitterModel.languageId);\n                if (!injection?.tree || injection.versionId !== textModelTreeSitter.parseResult?.versionId) {\n                    return undefined;\n                }\n\n                const feature = TreeSitterTokenizationRegistry.get(injection.languageId);\n                if (!feature) {\n                    return undefined;\n                }\n                return feature.tokSupport_captureAtRangeTree(range, injection.tree, textModelTreeSitter);*/\n        return [];\n    }\n    _tokenizeCapturesWithMetadata(captures, rangeStartOffset, rangeEndOffset) {\n        const stopwatch = StopWatch.create();\n        const emptyTokens = this._createTokensFromCaptures(captures, rangeStartOffset, rangeEndOffset);\n        if (!emptyTokens) {\n            return undefined;\n        }\n        const endOffsetsAndScopes = emptyTokens.endOffsets;\n        for (let i = 0; i < endOffsetsAndScopes.length; i++) {\n            const token = endOffsetsAndScopes[i];\n            token.metadata = this._treeSitterThemeService.findMetadata(token.scopes, token.encodedLanguageId, !!token.bracket && (token.bracket.length > 0), undefined);\n        }\n        const metadataTime = stopwatch.elapsed();\n        return { endOffsetsAndMetadata: endOffsetsAndScopes, captureTime: emptyTokens.captureTime, metadataTime };\n    }\n    _tokenizeEncoded(lineNumber) {\n        const lineOffset = this._textModel.getOffsetAt({ lineNumber: lineNumber, column: 1 });\n        const maxLine = this._textModel.getLineCount();\n        const lineEndOffset = (lineNumber + 1 <= maxLine) ? this._textModel.getOffsetAt({ lineNumber: lineNumber + 1, column: 1 }) : this._textModel.getValueLength();\n        const lineLength = lineEndOffset - lineOffset;\n        const result = this._tokenize(new Range(lineNumber, 1, lineNumber, lineLength + 1), lineOffset, lineEndOffset);\n        if (!result) {\n            return undefined;\n        }\n        return { result: result.endOffsetsAndMetadata, captureTime: result.captureTime, metadataTime: result.metadataTime, versionId: result.versionId };\n    }\n    _endOffsetTokensToUint32Array(endOffsetsAndMetadata) {\n        const uint32Array = new Uint32Array(endOffsetsAndMetadata.length * 2);\n        for (let i = 0; i < endOffsetsAndMetadata.length; i++) {\n            uint32Array[i * 2] = endOffsetsAndMetadata[i].endOffset;\n            uint32Array[i * 2 + 1] = endOffsetsAndMetadata[i].metadata;\n        }\n        return uint32Array;\n    }\n};\nTreeSitterTokenizationImpl = __decorate([\n    __param(4, ITreeSitterThemeService)\n], TreeSitterTokenizationImpl);\nconst TREESITTER_BASE_SCOPES = {\n    'css': 'source.css',\n    'typescript': 'source.ts',\n    'ini': 'source.ini',\n    'regex': 'source.regex',\n};\nconst BRACKETS = /[\\{\\}\\[\\]\\<\\>\\(\\)]/g;\n\nexport { TREESITTER_BASE_SCOPES, TreeSitterTokenizationImpl };\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 10935, "column": 0}, "map": {"version":3,"sources":["file:///D:/real-time-code-editor%20%282%29/node_modules/.pnpm/monaco-editor%400.55.1/node_modules/monaco-editor/esm/vs/editor/common/model/tokens/treeSitter/treeSitterSyntaxTokenBackend.js"],"sourcesContent":["import { Emitter } from '../../../../../base/common/event.js';\nimport { toDisposable } from '../../../../../base/common/lifecycle.js';\nimport { LineTokens } from '../../../tokens/lineTokens.js';\nimport { AbstractSyntaxTokenBackend } from '../abstractSyntaxTokenBackend.js';\nimport '../../../../../base/common/observableInternal/index.js';\nimport { TreeSitterTree } from './treeSitterTree.js';\nimport { IInstantiationService } from '../../../../../platform/instantiation/common/instantiation.js';\nimport { TreeSitterTokenizationImpl } from './treeSitterTokenizationImpl.js';\nimport { ITreeSitterLibraryService } from '../../../services/treeSitter/treeSitterLibraryService.js';\nimport { ObservablePromise } from '../../../../../base/common/observableInternal/utils/promise.js';\nimport { derived } from '../../../../../base/common/observableInternal/observables/derived.js';\nimport { autorun } from '../../../../../base/common/observableInternal/reactions/autorun.js';\n\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (undefined && undefined.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nlet TreeSitterSyntaxTokenBackend = class TreeSitterSyntaxTokenBackend extends AbstractSyntaxTokenBackend {\n    constructor(_languageIdObs, languageIdCodec, textModel, visibleLineRanges, _treeSitterLibraryService, _instantiationService) {\n        super(languageIdCodec, textModel);\n        this._languageIdObs = _languageIdObs;\n        this._treeSitterLibraryService = _treeSitterLibraryService;\n        this._instantiationService = _instantiationService;\n        this._backgroundTokenizationState = 1 /* BackgroundTokenizationState.InProgress */;\n        this._onDidChangeBackgroundTokenizationState = this._register(new Emitter());\n        this.onDidChangeBackgroundTokenizationState = this._onDidChangeBackgroundTokenizationState.event;\n        const parserClassPromise = new ObservablePromise(this._treeSitterLibraryService.getParserClass());\n        const parserClassObs = derived(this, reader => {\n            const parser = parserClassPromise.promiseResult?.read(reader)?.getDataOrThrow();\n            return parser;\n        });\n        this._tree = derived(this, reader => {\n            const parserClass = parserClassObs.read(reader);\n            if (!parserClass) {\n                return undefined;\n            }\n            const currentLanguage = this._languageIdObs.read(reader);\n            const treeSitterLang = this._treeSitterLibraryService.getLanguage(currentLanguage, false, reader);\n            if (!treeSitterLang) {\n                return undefined;\n            }\n            const parser = new parserClass();\n            reader.store.add(toDisposable(() => {\n                parser.delete();\n            }));\n            parser.setLanguage(treeSitterLang);\n            const queries = this._treeSitterLibraryService.getInjectionQueries(currentLanguage, reader);\n            if (queries === undefined) {\n                return undefined;\n            }\n            return reader.store.add(this._instantiationService.createInstance(TreeSitterTree, currentLanguage, undefined, parser, parserClass, /*queries, */ this._textModel));\n        });\n        this._tokenizationImpl = derived(this, reader => {\n            const treeModel = this._tree.read(reader);\n            if (!treeModel) {\n                return undefined;\n            }\n            const queries = this._treeSitterLibraryService.getHighlightingQueries(treeModel.languageId, reader);\n            if (!queries) {\n                return undefined;\n            }\n            return reader.store.add(this._instantiationService.createInstance(TreeSitterTokenizationImpl, treeModel, queries, this._languageIdCodec, visibleLineRanges));\n        });\n        this._register(autorun(reader => {\n            const tokModel = this._tokenizationImpl.read(reader);\n            if (!tokModel) {\n                return;\n            }\n            reader.store.add(tokModel.onDidChangeTokens((e) => {\n                this._onDidChangeTokens.fire(e.changes);\n            }));\n            reader.store.add(tokModel.onDidChangeBackgroundTokenization(e => {\n                this._backgroundTokenizationState = 2 /* BackgroundTokenizationState.Completed */;\n                this._onDidChangeBackgroundTokenizationState.fire();\n            }));\n        }));\n    }\n    getLineTokens(lineNumber) {\n        const model = this._tokenizationImpl.get();\n        if (!model) {\n            const content = this._textModel.getLineContent(lineNumber);\n            return LineTokens.createEmpty(content, this._languageIdCodec);\n        }\n        return model.getLineTokens(lineNumber);\n    }\n    todo_resetTokenization(fireTokenChangeEvent = true) {\n        if (fireTokenChangeEvent) {\n            this._onDidChangeTokens.fire({\n                semanticTokensApplied: false,\n                ranges: [\n                    {\n                        fromLineNumber: 1,\n                        toLineNumber: this._textModel.getLineCount(),\n                    },\n                ],\n            });\n        }\n    }\n    handleDidChangeAttached() {\n        // TODO @alexr00 implement for background tokenization\n    }\n    handleDidChangeContent(e) {\n        if (e.isFlush) {\n            // Don't fire the event, as the view might not have got the text change event yet\n            this.todo_resetTokenization(false);\n        }\n        else {\n            const model = this._tokenizationImpl.get();\n            model?.handleContentChanged(e);\n        }\n        const treeModel = this._tree.get();\n        treeModel?.handleContentChange(e);\n    }\n    forceTokenization(lineNumber) {\n        const model = this._tokenizationImpl.get();\n        if (!model) {\n            return;\n        }\n        if (!model.hasAccurateTokensForLine(lineNumber)) {\n            model.tokenizeEncoded(lineNumber);\n        }\n    }\n    hasAccurateTokensForLine(lineNumber) {\n        const model = this._tokenizationImpl.get();\n        if (!model) {\n            return false;\n        }\n        return model.hasAccurateTokensForLine(lineNumber);\n    }\n    isCheapToTokenize(lineNumber) {\n        // TODO @alexr00 determine what makes it cheap to tokenize?\n        return true;\n    }\n    getTokenTypeIfInsertingCharacter(lineNumber, column, character) {\n        // TODO @alexr00 implement once we have custom parsing and don't just feed in the whole text model value\n        return 0 /* StandardTokenType.Other */;\n    }\n    tokenizeLinesAt(lineNumber, lines) {\n        const model = this._tokenizationImpl.get();\n        if (!model) {\n            return null;\n        }\n        return model.tokenizeLinesAt(lineNumber, lines);\n    }\n    get hasTokens() {\n        const model = this._tokenizationImpl.get();\n        if (!model) {\n            return false;\n        }\n        return model.hasTokens();\n    }\n};\nTreeSitterSyntaxTokenBackend = __decorate([\n    __param(4, ITreeSitterLibraryService),\n    __param(5, IInstantiationService)\n], TreeSitterSyntaxTokenBackend);\n\nexport { TreeSitterSyntaxTokenBackend };\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 11120, "column": 0}, "map": {"version":3,"sources":["file:///D:/real-time-code-editor%20%282%29/node_modules/.pnpm/monaco-editor%400.55.1/node_modules/monaco-editor/esm/vs/editor/common/model/tokens/tokenizerSyntaxTokenBackend.js"],"sourcesContent":["import { onUnexpectedError } from '../../../../base/common/errors.js';\nimport { Emitter } from '../../../../base/common/event.js';\nimport { MutableDisposable, DisposableMap } from '../../../../base/common/lifecycle.js';\nimport { countEOL } from '../../core/misc/eolCounter.js';\nimport { Position } from '../../core/position.js';\nimport { LineRange } from '../../core/ranges/lineRange.js';\nimport { TokenizationRegistry } from '../../languages.js';\nimport { ContiguousMultilineTokensBuilder } from '../../tokens/contiguousMultilineTokensBuilder.js';\nimport { ContiguousTokensStore } from '../../tokens/contiguousTokensStore.js';\nimport { TrackingTokenizationStateStore, TokenizerWithStateStoreAndTextModel, DefaultBackgroundTokenizer } from '../textModelTokens.js';\nimport { AbstractSyntaxTokenBackend, AttachedViewHandler } from './abstractSyntaxTokenBackend.js';\n\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n/** For TextMate */\nclass TokenizerSyntaxTokenBackend extends AbstractSyntaxTokenBackend {\n    constructor(languageIdCodec, textModel, getLanguageId, attachedViews) {\n        super(languageIdCodec, textModel);\n        this.getLanguageId = getLanguageId;\n        this._tokenizer = null;\n        this._backgroundTokenizationState = 1 /* BackgroundTokenizationState.InProgress */;\n        this._onDidChangeBackgroundTokenizationState = this._register(new Emitter());\n        this.onDidChangeBackgroundTokenizationState = this._onDidChangeBackgroundTokenizationState.event;\n        this._defaultBackgroundTokenizer = null;\n        this._backgroundTokenizer = this._register(new MutableDisposable());\n        this._tokens = new ContiguousTokensStore(this._languageIdCodec);\n        this._debugBackgroundTokenizer = this._register(new MutableDisposable());\n        this._attachedViewStates = this._register(new DisposableMap());\n        this._register(TokenizationRegistry.onDidChange((e) => {\n            const languageId = this.getLanguageId();\n            if (e.changedLanguages.indexOf(languageId) === -1) {\n                return;\n            }\n            this.todo_resetTokenization();\n        }));\n        this.todo_resetTokenization();\n        this._register(attachedViews.onDidChangeVisibleRanges(({ view, state }) => {\n            if (state) {\n                let existing = this._attachedViewStates.get(view);\n                if (!existing) {\n                    existing = new AttachedViewHandler(() => this.refreshRanges(existing.lineRanges));\n                    this._attachedViewStates.set(view, existing);\n                }\n                existing.handleStateChange(state);\n            }\n            else {\n                this._attachedViewStates.deleteAndDispose(view);\n            }\n        }));\n    }\n    todo_resetTokenization(fireTokenChangeEvent = true) {\n        this._tokens.flush();\n        this._debugBackgroundTokens?.flush();\n        if (this._debugBackgroundStates) {\n            this._debugBackgroundStates = new TrackingTokenizationStateStore(this._textModel.getLineCount());\n        }\n        if (fireTokenChangeEvent) {\n            this._onDidChangeTokens.fire({\n                semanticTokensApplied: false,\n                ranges: [\n                    {\n                        fromLineNumber: 1,\n                        toLineNumber: this._textModel.getLineCount(),\n                    },\n                ],\n            });\n        }\n        const initializeTokenization = () => {\n            if (this._textModel.isTooLargeForTokenization()) {\n                return [null, null];\n            }\n            const tokenizationSupport = TokenizationRegistry.get(this.getLanguageId());\n            if (!tokenizationSupport) {\n                return [null, null];\n            }\n            let initialState;\n            try {\n                initialState = tokenizationSupport.getInitialState();\n            }\n            catch (e) {\n                onUnexpectedError(e);\n                return [null, null];\n            }\n            return [tokenizationSupport, initialState];\n        };\n        const [tokenizationSupport, initialState] = initializeTokenization();\n        if (tokenizationSupport && initialState) {\n            this._tokenizer = new TokenizerWithStateStoreAndTextModel(this._textModel.getLineCount(), tokenizationSupport, this._textModel, this._languageIdCodec);\n        }\n        else {\n            this._tokenizer = null;\n        }\n        this._backgroundTokenizer.clear();\n        this._defaultBackgroundTokenizer = null;\n        if (this._tokenizer) {\n            const b = {\n                setTokens: (tokens) => {\n                    this.setTokens(tokens);\n                },\n                backgroundTokenizationFinished: () => {\n                    if (this._backgroundTokenizationState === 2 /* BackgroundTokenizationState.Completed */) {\n                        // We already did a full tokenization and don't go back to progressing.\n                        return;\n                    }\n                    const newState = 2 /* BackgroundTokenizationState.Completed */;\n                    this._backgroundTokenizationState = newState;\n                    this._onDidChangeBackgroundTokenizationState.fire();\n                },\n                setEndState: (lineNumber, state) => {\n                    if (!this._tokenizer) {\n                        return;\n                    }\n                    const firstInvalidEndStateLineNumber = this._tokenizer.store.getFirstInvalidEndStateLineNumber();\n                    // Don't accept states for definitely valid states, the renderer is ahead of the worker!\n                    if (firstInvalidEndStateLineNumber !== null && lineNumber >= firstInvalidEndStateLineNumber) {\n                        this._tokenizer?.store.setEndState(lineNumber, state);\n                    }\n                },\n            };\n            if (tokenizationSupport && tokenizationSupport.createBackgroundTokenizer && !tokenizationSupport.backgroundTokenizerShouldOnlyVerifyTokens) {\n                this._backgroundTokenizer.value = tokenizationSupport.createBackgroundTokenizer(this._textModel, b);\n            }\n            if (!this._backgroundTokenizer.value && !this._textModel.isTooLargeForTokenization()) {\n                this._backgroundTokenizer.value = this._defaultBackgroundTokenizer =\n                    new DefaultBackgroundTokenizer(this._tokenizer, b);\n                this._defaultBackgroundTokenizer.handleChanges();\n            }\n            if (tokenizationSupport?.backgroundTokenizerShouldOnlyVerifyTokens && tokenizationSupport.createBackgroundTokenizer) {\n                this._debugBackgroundTokens = new ContiguousTokensStore(this._languageIdCodec);\n                this._debugBackgroundStates = new TrackingTokenizationStateStore(this._textModel.getLineCount());\n                this._debugBackgroundTokenizer.clear();\n                this._debugBackgroundTokenizer.value = tokenizationSupport.createBackgroundTokenizer(this._textModel, {\n                    setTokens: (tokens) => {\n                        this._debugBackgroundTokens?.setMultilineTokens(tokens, this._textModel);\n                    },\n                    backgroundTokenizationFinished() {\n                        // NO OP\n                    },\n                    setEndState: (lineNumber, state) => {\n                        this._debugBackgroundStates?.setEndState(lineNumber, state);\n                    },\n                });\n            }\n            else {\n                this._debugBackgroundTokens = undefined;\n                this._debugBackgroundStates = undefined;\n                this._debugBackgroundTokenizer.value = undefined;\n            }\n        }\n        this.refreshAllVisibleLineTokens();\n    }\n    handleDidChangeAttached() {\n        this._defaultBackgroundTokenizer?.handleChanges();\n    }\n    handleDidChangeContent(e) {\n        if (e.isFlush) {\n            // Don't fire the event, as the view might not have got the text change event yet\n            this.todo_resetTokenization(false);\n        }\n        else if (!e.isEolChange) { // We don't have to do anything on an EOL change\n            for (const c of e.changes) {\n                const [eolCount, firstLineLength] = countEOL(c.text);\n                this._tokens.acceptEdit(c.range, eolCount, firstLineLength);\n                this._debugBackgroundTokens?.acceptEdit(c.range, eolCount, firstLineLength);\n            }\n            this._debugBackgroundStates?.acceptChanges(e.changes);\n            if (this._tokenizer) {\n                this._tokenizer.store.acceptChanges(e.changes);\n            }\n            this._defaultBackgroundTokenizer?.handleChanges();\n        }\n    }\n    setTokens(tokens) {\n        const { changes } = this._tokens.setMultilineTokens(tokens, this._textModel);\n        if (changes.length > 0) {\n            this._onDidChangeTokens.fire({ semanticTokensApplied: false, ranges: changes, });\n        }\n        return { changes: changes };\n    }\n    refreshAllVisibleLineTokens() {\n        const ranges = LineRange.joinMany([...this._attachedViewStates].map(([_, s]) => s.lineRanges));\n        this.refreshRanges(ranges);\n    }\n    refreshRanges(ranges) {\n        for (const range of ranges) {\n            this.refreshRange(range.startLineNumber, range.endLineNumberExclusive - 1);\n        }\n    }\n    refreshRange(startLineNumber, endLineNumber) {\n        if (!this._tokenizer) {\n            return;\n        }\n        startLineNumber = Math.max(1, Math.min(this._textModel.getLineCount(), startLineNumber));\n        endLineNumber = Math.min(this._textModel.getLineCount(), endLineNumber);\n        const builder = new ContiguousMultilineTokensBuilder();\n        const { heuristicTokens } = this._tokenizer.tokenizeHeuristically(builder, startLineNumber, endLineNumber);\n        const changedTokens = this.setTokens(builder.finalize());\n        if (heuristicTokens) {\n            // We overrode tokens with heuristically computed ones.\n            // Because old states might get reused (thus stopping invalidation),\n            // we have to explicitly request the tokens for the changed ranges again.\n            for (const c of changedTokens.changes) {\n                this._backgroundTokenizer.value?.requestTokens(c.fromLineNumber, c.toLineNumber + 1);\n            }\n        }\n        this._defaultBackgroundTokenizer?.checkFinished();\n    }\n    forceTokenization(lineNumber) {\n        const builder = new ContiguousMultilineTokensBuilder();\n        this._tokenizer?.updateTokensUntilLine(builder, lineNumber);\n        this.setTokens(builder.finalize());\n        this._defaultBackgroundTokenizer?.checkFinished();\n    }\n    hasAccurateTokensForLine(lineNumber) {\n        if (!this._tokenizer) {\n            return true;\n        }\n        return this._tokenizer.hasAccurateTokensForLine(lineNumber);\n    }\n    isCheapToTokenize(lineNumber) {\n        if (!this._tokenizer) {\n            return true;\n        }\n        return this._tokenizer.isCheapToTokenize(lineNumber);\n    }\n    getLineTokens(lineNumber) {\n        const lineText = this._textModel.getLineContent(lineNumber);\n        const result = this._tokens.getTokens(this._textModel.getLanguageId(), lineNumber - 1, lineText);\n        if (this._debugBackgroundTokens && this._debugBackgroundStates && this._tokenizer) {\n            if (this._debugBackgroundStates.getFirstInvalidEndStateLineNumberOrMax() > lineNumber && this._tokenizer.store.getFirstInvalidEndStateLineNumberOrMax() > lineNumber) {\n                const backgroundResult = this._debugBackgroundTokens.getTokens(this._textModel.getLanguageId(), lineNumber - 1, lineText);\n                if (!result.equals(backgroundResult) && this._debugBackgroundTokenizer.value?.reportMismatchingTokens) {\n                    this._debugBackgroundTokenizer.value.reportMismatchingTokens(lineNumber);\n                }\n            }\n        }\n        return result;\n    }\n    getTokenTypeIfInsertingCharacter(lineNumber, column, character) {\n        if (!this._tokenizer) {\n            return 0 /* StandardTokenType.Other */;\n        }\n        const position = this._textModel.validatePosition(new Position(lineNumber, column));\n        this.forceTokenization(position.lineNumber);\n        return this._tokenizer.getTokenTypeIfInsertingCharacter(position, character);\n    }\n    tokenizeLinesAt(lineNumber, lines) {\n        if (!this._tokenizer) {\n            return null;\n        }\n        this.forceTokenization(lineNumber);\n        return this._tokenizer.tokenizeLinesAt(lineNumber, lines);\n    }\n    get hasTokens() {\n        return this._tokens.hasTokens;\n    }\n}\n\nexport { TokenizerSyntaxTokenBackend };\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 11409, "column": 0}, "map": {"version":3,"sources":["file:///D:/real-time-code-editor%20%282%29/node_modules/.pnpm/monaco-editor%400.55.1/node_modules/monaco-editor/esm/vs/editor/common/model/tokens/tokenizationTextModelPart.js"],"sourcesContent":["import { BugIndicatingError } from '../../../../base/common/errors.js';\nimport { Emitter } from '../../../../base/common/event.js';\nimport { countEOL } from '../../core/misc/eolCounter.js';\nimport { Position } from '../../core/position.js';\nimport { getWordAtText } from '../../core/wordHelper.js';\nimport { ILanguageService } from '../../languages/language.js';\nimport { ILanguageConfigurationService } from '../../languages/languageConfigurationRegistry.js';\nimport { TextModelPart } from '../textModelPart.js';\nimport { TreeSitterSyntaxTokenBackend } from './treeSitter/treeSitterSyntaxTokenBackend.js';\nimport { SparseTokensStore } from '../../tokens/sparseTokensStore.js';\nimport { IInstantiationService } from '../../../../platform/instantiation/common/instantiation.js';\nimport { TokenizerSyntaxTokenBackend } from './tokenizerSyntaxTokenBackend.js';\nimport { ITreeSitterLibraryService } from '../../services/treeSitter/treeSitterLibraryService.js';\nimport '../../../../base/common/observableInternal/index.js';\nimport { observableValue } from '../../../../base/common/observableInternal/observables/observableValue.js';\nimport { derived } from '../../../../base/common/observableInternal/observables/derived.js';\n\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (undefined && undefined.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nvar TokenizationTextModelPart_1;\nlet TokenizationTextModelPart = TokenizationTextModelPart_1 = class TokenizationTextModelPart extends TextModelPart {\n    constructor(_textModel, _bracketPairsTextModelPart, _languageId, _attachedViews, _languageService, _languageConfigurationService, _instantiationService, _treeSitterLibraryService) {\n        super();\n        this._textModel = _textModel;\n        this._bracketPairsTextModelPart = _bracketPairsTextModelPart;\n        this._languageId = _languageId;\n        this._attachedViews = _attachedViews;\n        this._languageService = _languageService;\n        this._languageConfigurationService = _languageConfigurationService;\n        this._instantiationService = _instantiationService;\n        this._treeSitterLibraryService = _treeSitterLibraryService;\n        this._languageIdObs = observableValue(this, this._languageId);\n        this._useTreeSitter = derived(this, reader => {\n            const languageId = this._languageIdObs.read(reader);\n            return this._treeSitterLibraryService.supportsLanguage(languageId, reader);\n        });\n        this.tokens = derived(this, reader => {\n            let tokens;\n            if (this._useTreeSitter.read(reader)) {\n                tokens = reader.store.add(this._instantiationService.createInstance(TreeSitterSyntaxTokenBackend, this._languageIdObs, this._languageService.languageIdCodec, this._textModel, this._attachedViews.visibleLineRanges));\n            }\n            else {\n                tokens = reader.store.add(new TokenizerSyntaxTokenBackend(this._languageService.languageIdCodec, this._textModel, () => this._languageId, this._attachedViews));\n            }\n            reader.store.add(tokens.onDidChangeTokens(e => {\n                this._emitModelTokensChangedEvent(e);\n            }));\n            reader.store.add(tokens.onDidChangeBackgroundTokenizationState(e => {\n                this._bracketPairsTextModelPart.handleDidChangeBackgroundTokenizationState();\n            }));\n            return tokens;\n        });\n        let hadTokens = false;\n        this.tokens.recomputeInitiallyAndOnChange(this._store, value => {\n            if (hadTokens) {\n                // We need to reset the tokenization, as the new token provider otherwise won't have a chance to provide tokens until some action happens in the editor.\n                // TODO@hediet: Look into why this is needed.\n                value.todo_resetTokenization();\n            }\n            hadTokens = true;\n        });\n        this._semanticTokens = new SparseTokensStore(this._languageService.languageIdCodec);\n        this._onDidChangeLanguage = this._register(new Emitter());\n        this.onDidChangeLanguage = this._onDidChangeLanguage.event;\n        this._onDidChangeLanguageConfiguration = this._register(new Emitter());\n        this.onDidChangeLanguageConfiguration = this._onDidChangeLanguageConfiguration.event;\n        this._onDidChangeTokens = this._register(new Emitter());\n        this.onDidChangeTokens = this._onDidChangeTokens.event;\n    }\n    handleLanguageConfigurationServiceChange(e) {\n        if (e.affects(this._languageId)) {\n            this._onDidChangeLanguageConfiguration.fire({});\n        }\n    }\n    handleDidChangeContent(e) {\n        if (e.isFlush) {\n            this._semanticTokens.flush();\n        }\n        else if (!e.isEolChange) { // We don't have to do anything on an EOL change\n            for (const c of e.changes) {\n                const [eolCount, firstLineLength, lastLineLength] = countEOL(c.text);\n                this._semanticTokens.acceptEdit(c.range, eolCount, firstLineLength, lastLineLength, c.text.length > 0 ? c.text.charCodeAt(0) : 0 /* CharCode.Null */);\n            }\n        }\n        this.tokens.get().handleDidChangeContent(e);\n    }\n    handleDidChangeAttached() {\n        this.tokens.get().handleDidChangeAttached();\n    }\n    /**\n     * Includes grammar and semantic tokens.\n     */\n    getLineTokens(lineNumber) {\n        this.validateLineNumber(lineNumber);\n        const syntacticTokens = this.tokens.get().getLineTokens(lineNumber);\n        return this._semanticTokens.addSparseTokens(lineNumber, syntacticTokens);\n    }\n    _emitModelTokensChangedEvent(e) {\n        if (!this._textModel._isDisposing()) {\n            this._bracketPairsTextModelPart.handleDidChangeTokens(e);\n            this._onDidChangeTokens.fire(e);\n        }\n    }\n    // #region Grammar Tokens\n    validateLineNumber(lineNumber) {\n        if (lineNumber < 1 || lineNumber > this._textModel.getLineCount()) {\n            throw new BugIndicatingError('Illegal value for lineNumber');\n        }\n    }\n    get hasTokens() {\n        return this.tokens.get().hasTokens;\n    }\n    resetTokenization() {\n        this.tokens.get().todo_resetTokenization();\n    }\n    get backgroundTokenizationState() {\n        return this.tokens.get().backgroundTokenizationState;\n    }\n    forceTokenization(lineNumber) {\n        this.validateLineNumber(lineNumber);\n        this.tokens.get().forceTokenization(lineNumber);\n    }\n    hasAccurateTokensForLine(lineNumber) {\n        this.validateLineNumber(lineNumber);\n        return this.tokens.get().hasAccurateTokensForLine(lineNumber);\n    }\n    isCheapToTokenize(lineNumber) {\n        this.validateLineNumber(lineNumber);\n        return this.tokens.get().isCheapToTokenize(lineNumber);\n    }\n    tokenizeIfCheap(lineNumber) {\n        this.validateLineNumber(lineNumber);\n        this.tokens.get().tokenizeIfCheap(lineNumber);\n    }\n    getTokenTypeIfInsertingCharacter(lineNumber, column, character) {\n        return this.tokens.get().getTokenTypeIfInsertingCharacter(lineNumber, column, character);\n    }\n    tokenizeLinesAt(lineNumber, lines) {\n        return this.tokens.get().tokenizeLinesAt(lineNumber, lines);\n    }\n    // #endregion\n    // #region Semantic Tokens\n    setSemanticTokens(tokens, isComplete) {\n        this._semanticTokens.set(tokens, isComplete, this._textModel);\n        this._emitModelTokensChangedEvent({\n            semanticTokensApplied: tokens !== null,\n            ranges: [{ fromLineNumber: 1, toLineNumber: this._textModel.getLineCount() }],\n        });\n    }\n    hasCompleteSemanticTokens() {\n        return this._semanticTokens.isComplete();\n    }\n    hasSomeSemanticTokens() {\n        return !this._semanticTokens.isEmpty();\n    }\n    setPartialSemanticTokens(range, tokens) {\n        if (this.hasCompleteSemanticTokens()) {\n            return;\n        }\n        const changedRange = this._textModel.validateRange(this._semanticTokens.setPartial(range, tokens));\n        this._emitModelTokensChangedEvent({\n            semanticTokensApplied: true,\n            ranges: [\n                {\n                    fromLineNumber: changedRange.startLineNumber,\n                    toLineNumber: changedRange.endLineNumber,\n                },\n            ],\n        });\n    }\n    // #endregion\n    // #region Utility Methods\n    getWordAtPosition(_position) {\n        this.assertNotDisposed();\n        const position = this._textModel.validatePosition(_position);\n        const lineContent = this._textModel.getLineContent(position.lineNumber);\n        const lineTokens = this.getLineTokens(position.lineNumber);\n        const tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n        // (1). First try checking right biased word\n        const [rbStartOffset, rbEndOffset] = TokenizationTextModelPart_1._findLanguageBoundaries(lineTokens, tokenIndex);\n        const rightBiasedWord = getWordAtText(position.column, this.getLanguageConfiguration(lineTokens.getLanguageId(tokenIndex)).getWordDefinition(), lineContent.substring(rbStartOffset, rbEndOffset), rbStartOffset);\n        // Make sure the result touches the original passed in position\n        if (rightBiasedWord &&\n            rightBiasedWord.startColumn <= _position.column &&\n            _position.column <= rightBiasedWord.endColumn) {\n            return rightBiasedWord;\n        }\n        // (2). Else, if we were at a language boundary, check the left biased word\n        if (tokenIndex > 0 && rbStartOffset === position.column - 1) {\n            // edge case, where `position` sits between two tokens belonging to two different languages\n            const [lbStartOffset, lbEndOffset] = TokenizationTextModelPart_1._findLanguageBoundaries(lineTokens, tokenIndex - 1);\n            const leftBiasedWord = getWordAtText(position.column, this.getLanguageConfiguration(lineTokens.getLanguageId(tokenIndex - 1)).getWordDefinition(), lineContent.substring(lbStartOffset, lbEndOffset), lbStartOffset);\n            // Make sure the result touches the original passed in position\n            if (leftBiasedWord &&\n                leftBiasedWord.startColumn <= _position.column &&\n                _position.column <= leftBiasedWord.endColumn) {\n                return leftBiasedWord;\n            }\n        }\n        return null;\n    }\n    getLanguageConfiguration(languageId) {\n        return this._languageConfigurationService.getLanguageConfiguration(languageId);\n    }\n    static _findLanguageBoundaries(lineTokens, tokenIndex) {\n        const languageId = lineTokens.getLanguageId(tokenIndex);\n        // go left until a different language is hit\n        let startOffset = 0;\n        for (let i = tokenIndex; i >= 0 && lineTokens.getLanguageId(i) === languageId; i--) {\n            startOffset = lineTokens.getStartOffset(i);\n        }\n        // go right until a different language is hit\n        let endOffset = lineTokens.getLineContent().length;\n        for (let i = tokenIndex, tokenCount = lineTokens.getCount(); i < tokenCount && lineTokens.getLanguageId(i) === languageId; i++) {\n            endOffset = lineTokens.getEndOffset(i);\n        }\n        return [startOffset, endOffset];\n    }\n    getWordUntilPosition(position) {\n        const wordAtPosition = this.getWordAtPosition(position);\n        if (!wordAtPosition) {\n            return { word: '', startColumn: position.column, endColumn: position.column, };\n        }\n        return {\n            word: wordAtPosition.word.substr(0, position.column - wordAtPosition.startColumn),\n            startColumn: wordAtPosition.startColumn,\n            endColumn: position.column,\n        };\n    }\n    // #endregion\n    // #region Language Id handling\n    getLanguageId() {\n        return this._languageId;\n    }\n    getLanguageIdAtPosition(lineNumber, column) {\n        const position = this._textModel.validatePosition(new Position(lineNumber, column));\n        const lineTokens = this.getLineTokens(position.lineNumber);\n        return lineTokens.getLanguageId(lineTokens.findTokenIndexAtOffset(position.column - 1));\n    }\n    setLanguageId(languageId, source = 'api') {\n        if (this._languageId === languageId) {\n            // There's nothing to do\n            return;\n        }\n        const e = {\n            oldLanguage: this._languageId,\n            newLanguage: languageId,\n            source\n        };\n        this._languageId = languageId;\n        this._languageIdObs.set(languageId, undefined);\n        this._bracketPairsTextModelPart.handleDidChangeLanguage(e);\n        this._onDidChangeLanguage.fire(e);\n        this._onDidChangeLanguageConfiguration.fire({});\n    }\n};\nTokenizationTextModelPart = TokenizationTextModelPart_1 = __decorate([\n    __param(4, ILanguageService),\n    __param(5, ILanguageConfigurationService),\n    __param(6, IInstantiationService),\n    __param(7, ITreeSitterLibraryService)\n], TokenizationTextModelPart);\n\nexport { TokenizationTextModelPart };\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 11712, "column": 0}, "map": {"version":3,"sources":["file:///D:/real-time-code-editor%20%282%29/node_modules/.pnpm/monaco-editor%400.55.1/node_modules/monaco-editor/esm/vs/editor/common/model/textModel.js"],"sourcesContent":["import { ArrayQueue, pushMany } from '../../../base/common/arrays.js';\nimport { Color } from '../../../base/common/color.js';\nimport { BugIndicatingError, illegalArgument, onUnexpectedError } from '../../../base/common/errors.js';\nimport { Emitter } from '../../../base/common/event.js';\nimport { Disposable, combinedDisposable, MutableDisposable } from '../../../base/common/lifecycle.js';\nimport { singleLetterHash, UNUSUAL_LINE_TERMINATORS, isHighSurrogate, htmlAttributeEncodeValue } from '../../../base/common/strings.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { countEOL } from '../core/misc/eolCounter.js';\nimport { normalizeIndentation } from '../core/misc/indentation.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport { Selection } from '../core/selection.js';\nimport { EDITOR_MODEL_DEFAULTS } from '../core/misc/textModelDefaults.js';\nimport { ILanguageService } from '../languages/language.js';\nimport { ILanguageConfigurationService } from '../languages/languageConfigurationRegistry.js';\nimport { TextModelResolvedOptions, ValidAnnotatedEditOperation, isITextSnapshot, OverviewRulerLane, GlyphMarginLane } from '../model.js';\nimport { BracketPairsTextModelPart } from './bracketPairsTextModelPart/bracketPairsImpl.js';\nimport { ColorizedBracketPairsDecorationProvider } from './bracketPairsTextModelPart/colorizedBracketPairsDecorationProvider.js';\nimport { EditStack } from './editStack.js';\nimport { GuidesTextModelPart } from './guidesTextModelPart.js';\nimport { guessIndentation } from './indentationGuesser.js';\nimport { recomputeMaxEnd, IntervalNode, IntervalTree } from './intervalTree.js';\nimport { PieceTreeTextBuffer } from './pieceTreeTextBuffer/pieceTreeTextBuffer.js';\nimport { PieceTreeTextBufferBuilder } from './pieceTreeTextBuffer/pieceTreeTextBufferBuilder.js';\nimport { SearchParams, TextModelSearch } from './textModelSearch.js';\nimport { TokenizationTextModelPart } from './tokens/tokenizationTextModelPart.js';\nimport { AttachedViews } from './tokens/abstractSyntaxTokenBackend.js';\nimport { InternalModelContentChangeEvent, ModelRawContentChangedEvent, ModelRawFlush, ModelRawEOLChanged, LineInjectedText, ModelRawLineChanged, ModelRawLinesDeleted, ModelRawLinesInserted, ModelInjectedTextChangedEvent, ModelLineHeightChanged, ModelLineHeightChangedEvent, ModelFontChanged, ModelFontChangedEvent } from '../textModelEvents.js';\nimport { IInstantiationService } from '../../../platform/instantiation/common/instantiation.js';\nimport { IUndoRedoService } from '../../../platform/undoRedo/common/undoRedo.js';\nimport { SetWithKey } from '../../../base/common/collections.js';\nimport { EditSources } from '../textModelEditSource.js';\nimport { isDark } from '../../../platform/theme/common/theme.js';\n\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (undefined && undefined.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nvar TextModel_1;\nfunction createTextBufferFactory(text) {\n    const builder = new PieceTreeTextBufferBuilder();\n    builder.acceptChunk(text);\n    return builder.finish();\n}\nfunction createTextBufferFactoryFromSnapshot(snapshot) {\n    const builder = new PieceTreeTextBufferBuilder();\n    let chunk;\n    while (typeof (chunk = snapshot.read()) === 'string') {\n        builder.acceptChunk(chunk);\n    }\n    return builder.finish();\n}\nfunction createTextBuffer(value, defaultEOL) {\n    let factory;\n    if (typeof value === 'string') {\n        factory = createTextBufferFactory(value);\n    }\n    else if (isITextSnapshot(value)) {\n        factory = createTextBufferFactoryFromSnapshot(value);\n    }\n    else {\n        factory = value;\n    }\n    return factory.create(defaultEOL);\n}\nlet MODEL_ID = 0;\nconst LIMIT_FIND_COUNT = 999;\nconst LONG_LINE_BOUNDARY = 10000;\nconst LINE_HEIGHT_CEILING = 300;\nclass TextModelSnapshot {\n    constructor(source) {\n        this._source = source;\n        this._eos = false;\n    }\n    read() {\n        if (this._eos) {\n            return null;\n        }\n        const result = [];\n        let resultCnt = 0;\n        let resultLength = 0;\n        do {\n            const tmp = this._source.read();\n            if (tmp === null) {\n                // end-of-stream\n                this._eos = true;\n                if (resultCnt === 0) {\n                    return null;\n                }\n                else {\n                    return result.join('');\n                }\n            }\n            if (tmp.length > 0) {\n                result[resultCnt++] = tmp;\n                resultLength += tmp.length;\n            }\n            if (resultLength >= 64 * 1024) {\n                return result.join('');\n            }\n        } while (true);\n    }\n}\nconst invalidFunc = () => { throw new Error(`Invalid change accessor`); };\nlet TextModel = class TextModel extends Disposable {\n    static { TextModel_1 = this; }\n    static { this._MODEL_SYNC_LIMIT = 50 * 1024 * 1024; } // 50 MB,  // used in tests\n    static { this.LARGE_FILE_SIZE_THRESHOLD = 20 * 1024 * 1024; } // 20 MB;\n    static { this.LARGE_FILE_LINE_COUNT_THRESHOLD = 300 * 1000; } // 300K lines\n    static { this.LARGE_FILE_HEAP_OPERATION_THRESHOLD = 256 * 1024 * 1024; } // 256M characters, usually ~> 512MB memory usage\n    static { this.DEFAULT_CREATION_OPTIONS = {\n        isForSimpleWidget: false,\n        tabSize: EDITOR_MODEL_DEFAULTS.tabSize,\n        indentSize: EDITOR_MODEL_DEFAULTS.indentSize,\n        insertSpaces: EDITOR_MODEL_DEFAULTS.insertSpaces,\n        detectIndentation: false,\n        defaultEOL: 1 /* model.DefaultEndOfLine.LF */,\n        trimAutoWhitespace: EDITOR_MODEL_DEFAULTS.trimAutoWhitespace,\n        largeFileOptimizations: EDITOR_MODEL_DEFAULTS.largeFileOptimizations,\n        bracketPairColorizationOptions: EDITOR_MODEL_DEFAULTS.bracketPairColorizationOptions,\n    }; }\n    static resolveOptions(textBuffer, options) {\n        if (options.detectIndentation) {\n            const guessedIndentation = guessIndentation(textBuffer, options.tabSize, options.insertSpaces);\n            return new TextModelResolvedOptions({\n                tabSize: guessedIndentation.tabSize,\n                indentSize: 'tabSize', // TODO@Alex: guess indentSize independent of tabSize\n                insertSpaces: guessedIndentation.insertSpaces,\n                trimAutoWhitespace: options.trimAutoWhitespace,\n                defaultEOL: options.defaultEOL,\n                bracketPairColorizationOptions: options.bracketPairColorizationOptions,\n            });\n        }\n        return new TextModelResolvedOptions(options);\n    }\n    get onDidChangeLanguage() { return this._tokenizationTextModelPart.onDidChangeLanguage; }\n    get onDidChangeLanguageConfiguration() { return this._tokenizationTextModelPart.onDidChangeLanguageConfiguration; }\n    get onDidChangeTokens() { return this._tokenizationTextModelPart.onDidChangeTokens; }\n    get onDidChangeOptions() { return this._onDidChangeOptions.event; }\n    get onDidChangeAttached() { return this._onDidChangeAttached.event; }\n    get onDidChangeLineHeight() { return this._onDidChangeLineHeight.event; }\n    get onDidChangeFont() { return this._onDidChangeFont.event; }\n    onDidChangeContent(listener) {\n        return this._eventEmitter.slowEvent((e) => listener(e.contentChangedEvent));\n    }\n    onDidChangeContentOrInjectedText(listener) {\n        return combinedDisposable(this._eventEmitter.fastEvent(e => listener(e)), this._onDidChangeInjectedText.event(e => listener(e)));\n    }\n    _isDisposing() { return this.__isDisposing; }\n    get tokenization() { return this._tokenizationTextModelPart; }\n    get bracketPairs() { return this._bracketPairs; }\n    get guides() { return this._guidesTextModelPart; }\n    constructor(source, languageIdOrSelection, creationOptions, associatedResource = null, _undoRedoService, _languageService, _languageConfigurationService, instantiationService) {\n        super();\n        this._undoRedoService = _undoRedoService;\n        this._languageService = _languageService;\n        this._languageConfigurationService = _languageConfigurationService;\n        this.instantiationService = instantiationService;\n        //#region Events\n        this._onWillDispose = this._register(new Emitter());\n        this.onWillDispose = this._onWillDispose.event;\n        this._onDidChangeDecorations = this._register(new DidChangeDecorationsEmitter((affectedInjectedTextLines, affectedLineHeights, affectedFontLines) => this.handleBeforeFireDecorationsChangedEvent(affectedInjectedTextLines, affectedLineHeights, affectedFontLines)));\n        this.onDidChangeDecorations = this._onDidChangeDecorations.event;\n        this._onDidChangeOptions = this._register(new Emitter());\n        this._onDidChangeAttached = this._register(new Emitter());\n        this._onDidChangeInjectedText = this._register(new Emitter());\n        this._onDidChangeLineHeight = this._register(new Emitter());\n        this._onDidChangeFont = this._register(new Emitter());\n        this._eventEmitter = this._register(new DidChangeContentEmitter());\n        this._languageSelectionListener = this._register(new MutableDisposable());\n        this._deltaDecorationCallCnt = 0;\n        this._attachedViews = new AttachedViews();\n        // Generate a new unique model id\n        MODEL_ID++;\n        this.id = '$model' + MODEL_ID;\n        this.isForSimpleWidget = creationOptions.isForSimpleWidget;\n        if (typeof associatedResource === 'undefined' || associatedResource === null) {\n            this._associatedResource = URI.parse('inmemory://model/' + MODEL_ID);\n        }\n        else {\n            this._associatedResource = associatedResource;\n        }\n        this._attachedEditorCount = 0;\n        const { textBuffer, disposable } = createTextBuffer(source, creationOptions.defaultEOL);\n        this._buffer = textBuffer;\n        this._bufferDisposable = disposable;\n        const bufferLineCount = this._buffer.getLineCount();\n        const bufferTextLength = this._buffer.getValueLengthInRange(new Range(1, 1, bufferLineCount, this._buffer.getLineLength(bufferLineCount) + 1), 0 /* model.EndOfLinePreference.TextDefined */);\n        // !!! Make a decision in the ctor and permanently respect this decision !!!\n        // If a model is too large at construction time, it will never get tokenized,\n        // under no circumstances.\n        if (creationOptions.largeFileOptimizations) {\n            this._isTooLargeForTokenization = ((bufferTextLength > TextModel_1.LARGE_FILE_SIZE_THRESHOLD)\n                || (bufferLineCount > TextModel_1.LARGE_FILE_LINE_COUNT_THRESHOLD));\n            this._isTooLargeForHeapOperation = bufferTextLength > TextModel_1.LARGE_FILE_HEAP_OPERATION_THRESHOLD;\n        }\n        else {\n            this._isTooLargeForTokenization = false;\n            this._isTooLargeForHeapOperation = false;\n        }\n        this._options = TextModel_1.resolveOptions(this._buffer, creationOptions);\n        const languageId = (typeof languageIdOrSelection === 'string' ? languageIdOrSelection : languageIdOrSelection.languageId);\n        if (typeof languageIdOrSelection !== 'string') {\n            this._languageSelectionListener.value = languageIdOrSelection.onDidChange(() => this._setLanguage(languageIdOrSelection.languageId));\n        }\n        this._bracketPairs = this._register(new BracketPairsTextModelPart(this, this._languageConfigurationService));\n        this._guidesTextModelPart = this._register(new GuidesTextModelPart(this, this._languageConfigurationService));\n        this._decorationProvider = this._register(new ColorizedBracketPairsDecorationProvider(this));\n        this._tokenizationTextModelPart = this.instantiationService.createInstance(TokenizationTextModelPart, this, this._bracketPairs, languageId, this._attachedViews);\n        this._isTooLargeForSyncing = (bufferTextLength > TextModel_1._MODEL_SYNC_LIMIT);\n        this._versionId = 1;\n        this._alternativeVersionId = 1;\n        this._initialUndoRedoSnapshot = null;\n        this._isDisposed = false;\n        this.__isDisposing = false;\n        this._instanceId = singleLetterHash(MODEL_ID);\n        this._lastDecorationId = 0;\n        this._decorations = Object.create(null);\n        this._decorationsTree = new DecorationsTrees();\n        this._commandManager = new EditStack(this, this._undoRedoService);\n        this._isUndoing = false;\n        this._isRedoing = false;\n        this._trimAutoWhitespaceLines = null;\n        this._register(this._decorationProvider.onDidChange(() => {\n            this._onDidChangeDecorations.beginDeferredEmit();\n            this._onDidChangeDecorations.fire();\n            this._onDidChangeDecorations.endDeferredEmit();\n        }));\n        this._languageService.requestRichLanguageFeatures(languageId);\n        this._register(this._languageConfigurationService.onDidChange(e => {\n            this._bracketPairs.handleLanguageConfigurationServiceChange(e);\n            this._tokenizationTextModelPart.handleLanguageConfigurationServiceChange(e);\n        }));\n    }\n    dispose() {\n        this.__isDisposing = true;\n        this._onWillDispose.fire();\n        this._tokenizationTextModelPart.dispose();\n        this._isDisposed = true;\n        super.dispose();\n        this._bufferDisposable.dispose();\n        this.__isDisposing = false;\n        // Manually release reference to previous text buffer to avoid large leaks\n        // in case someone leaks a TextModel reference\n        const emptyDisposedTextBuffer = new PieceTreeTextBuffer([], '', '\\n', false, false, true, true);\n        emptyDisposedTextBuffer.dispose();\n        this._buffer = emptyDisposedTextBuffer;\n        this._bufferDisposable = Disposable.None;\n    }\n    _assertNotDisposed() {\n        if (this._isDisposed) {\n            throw new BugIndicatingError('Model is disposed!');\n        }\n    }\n    getTextBuffer() {\n        this._assertNotDisposed();\n        return this._buffer;\n    }\n    _emitContentChangedEvent(rawChange, change) {\n        if (this.__isDisposing) {\n            // Do not confuse listeners by emitting any event after disposing\n            return;\n        }\n        this._tokenizationTextModelPart.handleDidChangeContent(change);\n        this._bracketPairs.handleDidChangeContent(change);\n        this._eventEmitter.fire(new InternalModelContentChangeEvent(rawChange, change));\n    }\n    setValue(value, reason = EditSources.setValue()) {\n        this._assertNotDisposed();\n        if (value === null || value === undefined) {\n            throw illegalArgument();\n        }\n        const { textBuffer, disposable } = createTextBuffer(value, this._options.defaultEOL);\n        this._setValueFromTextBuffer(textBuffer, disposable, reason);\n    }\n    _createContentChanged2(range, rangeOffset, rangeLength, rangeEndPosition, text, isUndoing, isRedoing, isFlush, isEolChange, reason) {\n        return {\n            changes: [{\n                    range: range,\n                    rangeOffset: rangeOffset,\n                    rangeLength: rangeLength,\n                    text: text,\n                }],\n            eol: this._buffer.getEOL(),\n            isEolChange: isEolChange,\n            versionId: this.getVersionId(),\n            isUndoing: isUndoing,\n            isRedoing: isRedoing,\n            isFlush: isFlush,\n            detailedReasons: [reason],\n            detailedReasonsChangeLengths: [1],\n        };\n    }\n    _setValueFromTextBuffer(textBuffer, textBufferDisposable, reason) {\n        this._assertNotDisposed();\n        const oldFullModelRange = this.getFullModelRange();\n        const oldModelValueLength = this.getValueLengthInRange(oldFullModelRange);\n        const endLineNumber = this.getLineCount();\n        const endColumn = this.getLineMaxColumn(endLineNumber);\n        this._buffer = textBuffer;\n        this._bufferDisposable.dispose();\n        this._bufferDisposable = textBufferDisposable;\n        this._increaseVersionId();\n        // Destroy all my decorations\n        this._decorations = Object.create(null);\n        this._decorationsTree = new DecorationsTrees();\n        // Destroy my edit history and settings\n        this._commandManager.clear();\n        this._trimAutoWhitespaceLines = null;\n        this._emitContentChangedEvent(new ModelRawContentChangedEvent([\n            new ModelRawFlush()\n        ], this._versionId, false, false), this._createContentChanged2(new Range(1, 1, endLineNumber, endColumn), 0, oldModelValueLength, new Position(endLineNumber, endColumn), this.getValue(), false, false, true, false, reason));\n    }\n    setEOL(eol) {\n        this._assertNotDisposed();\n        const newEOL = (eol === 1 /* model.EndOfLineSequence.CRLF */ ? '\\r\\n' : '\\n');\n        if (this._buffer.getEOL() === newEOL) {\n            // Nothing to do\n            return;\n        }\n        const oldFullModelRange = this.getFullModelRange();\n        const oldModelValueLength = this.getValueLengthInRange(oldFullModelRange);\n        const endLineNumber = this.getLineCount();\n        const endColumn = this.getLineMaxColumn(endLineNumber);\n        this._onBeforeEOLChange();\n        this._buffer.setEOL(newEOL);\n        this._increaseVersionId();\n        this._onAfterEOLChange();\n        this._emitContentChangedEvent(new ModelRawContentChangedEvent([\n            new ModelRawEOLChanged()\n        ], this._versionId, false, false), this._createContentChanged2(new Range(1, 1, endLineNumber, endColumn), 0, oldModelValueLength, new Position(endLineNumber, endColumn), this.getValue(), false, false, false, true, EditSources.eolChange()));\n    }\n    _onBeforeEOLChange() {\n        // Ensure all decorations get their `range` set.\n        this._decorationsTree.ensureAllNodesHaveRanges(this);\n    }\n    _onAfterEOLChange() {\n        // Transform back `range` to offsets\n        const versionId = this.getVersionId();\n        const allDecorations = this._decorationsTree.collectNodesPostOrder();\n        for (let i = 0, len = allDecorations.length; i < len; i++) {\n            const node = allDecorations[i];\n            const range = node.range; // the range is defined due to `_onBeforeEOLChange`\n            const delta = node.cachedAbsoluteStart - node.start;\n            const startOffset = this._buffer.getOffsetAt(range.startLineNumber, range.startColumn);\n            const endOffset = this._buffer.getOffsetAt(range.endLineNumber, range.endColumn);\n            node.cachedAbsoluteStart = startOffset;\n            node.cachedAbsoluteEnd = endOffset;\n            node.cachedVersionId = versionId;\n            node.start = startOffset - delta;\n            node.end = endOffset - delta;\n            recomputeMaxEnd(node);\n        }\n    }\n    onBeforeAttached() {\n        this._attachedEditorCount++;\n        if (this._attachedEditorCount === 1) {\n            this._tokenizationTextModelPart.handleDidChangeAttached();\n            this._onDidChangeAttached.fire(undefined);\n        }\n        return this._attachedViews.attachView();\n    }\n    onBeforeDetached(view) {\n        this._attachedEditorCount--;\n        if (this._attachedEditorCount === 0) {\n            this._tokenizationTextModelPart.handleDidChangeAttached();\n            this._onDidChangeAttached.fire(undefined);\n        }\n        this._attachedViews.detachView(view);\n    }\n    isAttachedToEditor() {\n        return this._attachedEditorCount > 0;\n    }\n    getAttachedEditorCount() {\n        return this._attachedEditorCount;\n    }\n    isTooLargeForSyncing() {\n        return this._isTooLargeForSyncing;\n    }\n    isTooLargeForTokenization() {\n        return this._isTooLargeForTokenization;\n    }\n    isTooLargeForHeapOperation() {\n        return this._isTooLargeForHeapOperation;\n    }\n    isDisposed() {\n        return this._isDisposed;\n    }\n    isDominatedByLongLines() {\n        this._assertNotDisposed();\n        if (this.isTooLargeForTokenization()) {\n            // Cannot word wrap huge files anyways, so it doesn't really matter\n            return false;\n        }\n        let smallLineCharCount = 0;\n        let longLineCharCount = 0;\n        const lineCount = this._buffer.getLineCount();\n        for (let lineNumber = 1; lineNumber <= lineCount; lineNumber++) {\n            const lineLength = this._buffer.getLineLength(lineNumber);\n            if (lineLength >= LONG_LINE_BOUNDARY) {\n                longLineCharCount += lineLength;\n            }\n            else {\n                smallLineCharCount += lineLength;\n            }\n        }\n        return (longLineCharCount > smallLineCharCount);\n    }\n    get uri() {\n        return this._associatedResource;\n    }\n    //#region Options\n    getOptions() {\n        this._assertNotDisposed();\n        return this._options;\n    }\n    getFormattingOptions() {\n        return {\n            tabSize: this._options.indentSize,\n            insertSpaces: this._options.insertSpaces\n        };\n    }\n    updateOptions(_newOpts) {\n        this._assertNotDisposed();\n        const tabSize = (typeof _newOpts.tabSize !== 'undefined') ? _newOpts.tabSize : this._options.tabSize;\n        const indentSize = (typeof _newOpts.indentSize !== 'undefined') ? _newOpts.indentSize : this._options.originalIndentSize;\n        const insertSpaces = (typeof _newOpts.insertSpaces !== 'undefined') ? _newOpts.insertSpaces : this._options.insertSpaces;\n        const trimAutoWhitespace = (typeof _newOpts.trimAutoWhitespace !== 'undefined') ? _newOpts.trimAutoWhitespace : this._options.trimAutoWhitespace;\n        const bracketPairColorizationOptions = (typeof _newOpts.bracketColorizationOptions !== 'undefined') ? _newOpts.bracketColorizationOptions : this._options.bracketPairColorizationOptions;\n        const newOpts = new TextModelResolvedOptions({\n            tabSize: tabSize,\n            indentSize: indentSize,\n            insertSpaces: insertSpaces,\n            defaultEOL: this._options.defaultEOL,\n            trimAutoWhitespace: trimAutoWhitespace,\n            bracketPairColorizationOptions,\n        });\n        if (this._options.equals(newOpts)) {\n            return;\n        }\n        const e = this._options.createChangeEvent(newOpts);\n        this._options = newOpts;\n        this._bracketPairs.handleDidChangeOptions(e);\n        this._decorationProvider.handleDidChangeOptions(e);\n        this._onDidChangeOptions.fire(e);\n    }\n    detectIndentation(defaultInsertSpaces, defaultTabSize) {\n        this._assertNotDisposed();\n        const guessedIndentation = guessIndentation(this._buffer, defaultTabSize, defaultInsertSpaces);\n        this.updateOptions({\n            insertSpaces: guessedIndentation.insertSpaces,\n            tabSize: guessedIndentation.tabSize,\n            indentSize: guessedIndentation.tabSize, // TODO@Alex: guess indentSize independent of tabSize\n        });\n    }\n    normalizeIndentation(str) {\n        this._assertNotDisposed();\n        return normalizeIndentation(str, this._options.indentSize, this._options.insertSpaces);\n    }\n    //#endregion\n    //#region Reading\n    getVersionId() {\n        this._assertNotDisposed();\n        return this._versionId;\n    }\n    mightContainRTL() {\n        return this._buffer.mightContainRTL();\n    }\n    mightContainUnusualLineTerminators() {\n        return this._buffer.mightContainUnusualLineTerminators();\n    }\n    removeUnusualLineTerminators(selections = null) {\n        const matches = this.findMatches(UNUSUAL_LINE_TERMINATORS.source, false, true, false, null, false, 1073741824 /* Constants.MAX_SAFE_SMALL_INTEGER */);\n        this._buffer.resetMightContainUnusualLineTerminators();\n        this.pushEditOperations(selections, matches.map(m => ({ range: m.range, text: null })), () => null);\n    }\n    mightContainNonBasicASCII() {\n        return this._buffer.mightContainNonBasicASCII();\n    }\n    getAlternativeVersionId() {\n        this._assertNotDisposed();\n        return this._alternativeVersionId;\n    }\n    getInitialUndoRedoSnapshot() {\n        this._assertNotDisposed();\n        return this._initialUndoRedoSnapshot;\n    }\n    getOffsetAt(rawPosition) {\n        this._assertNotDisposed();\n        const position = this._validatePosition(rawPosition.lineNumber, rawPosition.column, 0 /* StringOffsetValidationType.Relaxed */);\n        return this._buffer.getOffsetAt(position.lineNumber, position.column);\n    }\n    getPositionAt(rawOffset) {\n        this._assertNotDisposed();\n        const offset = (Math.min(this._buffer.getLength(), Math.max(0, rawOffset)));\n        return this._buffer.getPositionAt(offset);\n    }\n    _increaseVersionId() {\n        this._versionId = this._versionId + 1;\n        this._alternativeVersionId = this._versionId;\n    }\n    _overwriteVersionId(versionId) {\n        this._versionId = versionId;\n    }\n    _overwriteAlternativeVersionId(newAlternativeVersionId) {\n        this._alternativeVersionId = newAlternativeVersionId;\n    }\n    _overwriteInitialUndoRedoSnapshot(newInitialUndoRedoSnapshot) {\n        this._initialUndoRedoSnapshot = newInitialUndoRedoSnapshot;\n    }\n    getValue(eol, preserveBOM = false) {\n        this._assertNotDisposed();\n        if (this.isTooLargeForHeapOperation()) {\n            throw new BugIndicatingError('Operation would exceed heap memory limits');\n        }\n        const fullModelRange = this.getFullModelRange();\n        const fullModelValue = this.getValueInRange(fullModelRange, eol);\n        if (preserveBOM) {\n            return this._buffer.getBOM() + fullModelValue;\n        }\n        return fullModelValue;\n    }\n    createSnapshot(preserveBOM = false) {\n        return new TextModelSnapshot(this._buffer.createSnapshot(preserveBOM));\n    }\n    getValueLength(eol, preserveBOM = false) {\n        this._assertNotDisposed();\n        const fullModelRange = this.getFullModelRange();\n        const fullModelValue = this.getValueLengthInRange(fullModelRange, eol);\n        if (preserveBOM) {\n            return this._buffer.getBOM().length + fullModelValue;\n        }\n        return fullModelValue;\n    }\n    getValueInRange(rawRange, eol = 0 /* model.EndOfLinePreference.TextDefined */) {\n        this._assertNotDisposed();\n        return this._buffer.getValueInRange(this.validateRange(rawRange), eol);\n    }\n    getValueLengthInRange(rawRange, eol = 0 /* model.EndOfLinePreference.TextDefined */) {\n        this._assertNotDisposed();\n        return this._buffer.getValueLengthInRange(this.validateRange(rawRange), eol);\n    }\n    getCharacterCountInRange(rawRange, eol = 0 /* model.EndOfLinePreference.TextDefined */) {\n        this._assertNotDisposed();\n        return this._buffer.getCharacterCountInRange(this.validateRange(rawRange), eol);\n    }\n    getLineCount() {\n        this._assertNotDisposed();\n        return this._buffer.getLineCount();\n    }\n    getLineContent(lineNumber) {\n        this._assertNotDisposed();\n        if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n            throw new BugIndicatingError('Illegal value for lineNumber');\n        }\n        return this._buffer.getLineContent(lineNumber);\n    }\n    getLineLength(lineNumber) {\n        this._assertNotDisposed();\n        if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n            throw new BugIndicatingError('Illegal value for lineNumber');\n        }\n        return this._buffer.getLineLength(lineNumber);\n    }\n    getLinesContent() {\n        this._assertNotDisposed();\n        if (this.isTooLargeForHeapOperation()) {\n            throw new BugIndicatingError('Operation would exceed heap memory limits');\n        }\n        return this._buffer.getLinesContent();\n    }\n    getEOL() {\n        this._assertNotDisposed();\n        return this._buffer.getEOL();\n    }\n    getEndOfLineSequence() {\n        this._assertNotDisposed();\n        return (this._buffer.getEOL() === '\\n'\n            ? 0 /* model.EndOfLineSequence.LF */\n            : 1 /* model.EndOfLineSequence.CRLF */);\n    }\n    getLineMinColumn(lineNumber) {\n        this._assertNotDisposed();\n        return 1;\n    }\n    getLineMaxColumn(lineNumber) {\n        this._assertNotDisposed();\n        if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n            throw new BugIndicatingError('Illegal value for lineNumber');\n        }\n        return this._buffer.getLineLength(lineNumber) + 1;\n    }\n    getLineFirstNonWhitespaceColumn(lineNumber) {\n        this._assertNotDisposed();\n        if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n            throw new BugIndicatingError('Illegal value for lineNumber');\n        }\n        return this._buffer.getLineFirstNonWhitespaceColumn(lineNumber);\n    }\n    getLineLastNonWhitespaceColumn(lineNumber) {\n        this._assertNotDisposed();\n        if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n            throw new BugIndicatingError('Illegal value for lineNumber');\n        }\n        return this._buffer.getLineLastNonWhitespaceColumn(lineNumber);\n    }\n    /**\n     * Validates `range` is within buffer bounds, but allows it to sit in between surrogate pairs, etc.\n     * Will try to not allocate if possible.\n     */\n    _validateRangeRelaxedNoAllocations(range) {\n        const linesCount = this._buffer.getLineCount();\n        const initialStartLineNumber = range.startLineNumber;\n        const initialStartColumn = range.startColumn;\n        let startLineNumber = Math.floor((typeof initialStartLineNumber === 'number' && !isNaN(initialStartLineNumber)) ? initialStartLineNumber : 1);\n        let startColumn = Math.floor((typeof initialStartColumn === 'number' && !isNaN(initialStartColumn)) ? initialStartColumn : 1);\n        if (startLineNumber < 1) {\n            startLineNumber = 1;\n            startColumn = 1;\n        }\n        else if (startLineNumber > linesCount) {\n            startLineNumber = linesCount;\n            startColumn = this.getLineMaxColumn(startLineNumber);\n        }\n        else {\n            if (startColumn <= 1) {\n                startColumn = 1;\n            }\n            else {\n                const maxColumn = this.getLineMaxColumn(startLineNumber);\n                if (startColumn >= maxColumn) {\n                    startColumn = maxColumn;\n                }\n            }\n        }\n        const initialEndLineNumber = range.endLineNumber;\n        const initialEndColumn = range.endColumn;\n        let endLineNumber = Math.floor((typeof initialEndLineNumber === 'number' && !isNaN(initialEndLineNumber)) ? initialEndLineNumber : 1);\n        let endColumn = Math.floor((typeof initialEndColumn === 'number' && !isNaN(initialEndColumn)) ? initialEndColumn : 1);\n        if (endLineNumber < 1) {\n            endLineNumber = 1;\n            endColumn = 1;\n        }\n        else if (endLineNumber > linesCount) {\n            endLineNumber = linesCount;\n            endColumn = this.getLineMaxColumn(endLineNumber);\n        }\n        else {\n            if (endColumn <= 1) {\n                endColumn = 1;\n            }\n            else {\n                const maxColumn = this.getLineMaxColumn(endLineNumber);\n                if (endColumn >= maxColumn) {\n                    endColumn = maxColumn;\n                }\n            }\n        }\n        if (initialStartLineNumber === startLineNumber\n            && initialStartColumn === startColumn\n            && initialEndLineNumber === endLineNumber\n            && initialEndColumn === endColumn\n            && range instanceof Range\n            && !(range instanceof Selection)) {\n            return range;\n        }\n        return new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n    }\n    _isValidPosition(lineNumber, column, validationType) {\n        if (typeof lineNumber !== 'number' || typeof column !== 'number') {\n            return false;\n        }\n        if (isNaN(lineNumber) || isNaN(column)) {\n            return false;\n        }\n        if (lineNumber < 1 || column < 1) {\n            return false;\n        }\n        if ((lineNumber | 0) !== lineNumber || (column | 0) !== column) {\n            return false;\n        }\n        const lineCount = this._buffer.getLineCount();\n        if (lineNumber > lineCount) {\n            return false;\n        }\n        if (column === 1) {\n            return true;\n        }\n        const maxColumn = this.getLineMaxColumn(lineNumber);\n        if (column > maxColumn) {\n            return false;\n        }\n        if (validationType === 1 /* StringOffsetValidationType.SurrogatePairs */) {\n            // !!At this point, column > 1\n            const charCodeBefore = this._buffer.getLineCharCode(lineNumber, column - 2);\n            if (isHighSurrogate(charCodeBefore)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    _validatePosition(_lineNumber, _column, validationType) {\n        const lineNumber = Math.floor((typeof _lineNumber === 'number' && !isNaN(_lineNumber)) ? _lineNumber : 1);\n        const column = Math.floor((typeof _column === 'number' && !isNaN(_column)) ? _column : 1);\n        const lineCount = this._buffer.getLineCount();\n        if (lineNumber < 1) {\n            return new Position(1, 1);\n        }\n        if (lineNumber > lineCount) {\n            return new Position(lineCount, this.getLineMaxColumn(lineCount));\n        }\n        if (column <= 1) {\n            return new Position(lineNumber, 1);\n        }\n        const maxColumn = this.getLineMaxColumn(lineNumber);\n        if (column >= maxColumn) {\n            return new Position(lineNumber, maxColumn);\n        }\n        if (validationType === 1 /* StringOffsetValidationType.SurrogatePairs */) {\n            // If the position would end up in the middle of a high-low surrogate pair,\n            // we move it to before the pair\n            // !!At this point, column > 1\n            const charCodeBefore = this._buffer.getLineCharCode(lineNumber, column - 2);\n            if (isHighSurrogate(charCodeBefore)) {\n                return new Position(lineNumber, column - 1);\n            }\n        }\n        return new Position(lineNumber, column);\n    }\n    validatePosition(position) {\n        const validationType = 1 /* StringOffsetValidationType.SurrogatePairs */;\n        this._assertNotDisposed();\n        // Avoid object allocation and cover most likely case\n        if (position instanceof Position) {\n            if (this._isValidPosition(position.lineNumber, position.column, validationType)) {\n                return position;\n            }\n        }\n        return this._validatePosition(position.lineNumber, position.column, validationType);\n    }\n    isValidRange(range) {\n        return this._isValidRange(range, 1 /* StringOffsetValidationType.SurrogatePairs */);\n    }\n    _isValidRange(range, validationType) {\n        const startLineNumber = range.startLineNumber;\n        const startColumn = range.startColumn;\n        const endLineNumber = range.endLineNumber;\n        const endColumn = range.endColumn;\n        if (!this._isValidPosition(startLineNumber, startColumn, 0 /* StringOffsetValidationType.Relaxed */)) {\n            return false;\n        }\n        if (!this._isValidPosition(endLineNumber, endColumn, 0 /* StringOffsetValidationType.Relaxed */)) {\n            return false;\n        }\n        if (validationType === 1 /* StringOffsetValidationType.SurrogatePairs */) {\n            const charCodeBeforeStart = (startColumn > 1 ? this._buffer.getLineCharCode(startLineNumber, startColumn - 2) : 0);\n            const charCodeBeforeEnd = (endColumn > 1 && endColumn <= this._buffer.getLineLength(endLineNumber) ? this._buffer.getLineCharCode(endLineNumber, endColumn - 2) : 0);\n            const startInsideSurrogatePair = isHighSurrogate(charCodeBeforeStart);\n            const endInsideSurrogatePair = isHighSurrogate(charCodeBeforeEnd);\n            if (!startInsideSurrogatePair && !endInsideSurrogatePair) {\n                return true;\n            }\n            return false;\n        }\n        return true;\n    }\n    validateRange(_range) {\n        const validationType = 1 /* StringOffsetValidationType.SurrogatePairs */;\n        this._assertNotDisposed();\n        // Avoid object allocation and cover most likely case\n        if ((_range instanceof Range) && !(_range instanceof Selection)) {\n            if (this._isValidRange(_range, validationType)) {\n                return _range;\n            }\n        }\n        const start = this._validatePosition(_range.startLineNumber, _range.startColumn, 0 /* StringOffsetValidationType.Relaxed */);\n        const end = this._validatePosition(_range.endLineNumber, _range.endColumn, 0 /* StringOffsetValidationType.Relaxed */);\n        const startLineNumber = start.lineNumber;\n        const startColumn = start.column;\n        const endLineNumber = end.lineNumber;\n        const endColumn = end.column;\n        {\n            const charCodeBeforeStart = (startColumn > 1 ? this._buffer.getLineCharCode(startLineNumber, startColumn - 2) : 0);\n            const charCodeBeforeEnd = (endColumn > 1 && endColumn <= this._buffer.getLineLength(endLineNumber) ? this._buffer.getLineCharCode(endLineNumber, endColumn - 2) : 0);\n            const startInsideSurrogatePair = isHighSurrogate(charCodeBeforeStart);\n            const endInsideSurrogatePair = isHighSurrogate(charCodeBeforeEnd);\n            if (!startInsideSurrogatePair && !endInsideSurrogatePair) {\n                return new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n            }\n            if (startLineNumber === endLineNumber && startColumn === endColumn) {\n                // do not expand a collapsed range, simply move it to a valid location\n                return new Range(startLineNumber, startColumn - 1, endLineNumber, endColumn - 1);\n            }\n            if (startInsideSurrogatePair && endInsideSurrogatePair) {\n                // expand range at both ends\n                return new Range(startLineNumber, startColumn - 1, endLineNumber, endColumn + 1);\n            }\n            if (startInsideSurrogatePair) {\n                // only expand range at the start\n                return new Range(startLineNumber, startColumn - 1, endLineNumber, endColumn);\n            }\n            // only expand range at the end\n            return new Range(startLineNumber, startColumn, endLineNumber, endColumn + 1);\n        }\n    }\n    modifyPosition(rawPosition, offset) {\n        this._assertNotDisposed();\n        const candidate = this.getOffsetAt(rawPosition) + offset;\n        return this.getPositionAt(Math.min(this._buffer.getLength(), Math.max(0, candidate)));\n    }\n    getFullModelRange() {\n        this._assertNotDisposed();\n        const lineCount = this.getLineCount();\n        return new Range(1, 1, lineCount, this.getLineMaxColumn(lineCount));\n    }\n    findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount) {\n        return this._buffer.findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount);\n    }\n    findMatches(searchString, rawSearchScope, isRegex, matchCase, wordSeparators, captureMatches, limitResultCount = LIMIT_FIND_COUNT) {\n        this._assertNotDisposed();\n        let searchRanges = null;\n        if (rawSearchScope !== null && typeof rawSearchScope !== 'boolean') {\n            if (!Array.isArray(rawSearchScope)) {\n                rawSearchScope = [rawSearchScope];\n            }\n            if (rawSearchScope.every((searchScope) => Range.isIRange(searchScope))) {\n                searchRanges = rawSearchScope.map((searchScope) => this.validateRange(searchScope));\n            }\n        }\n        if (searchRanges === null) {\n            searchRanges = [this.getFullModelRange()];\n        }\n        searchRanges = searchRanges.sort((d1, d2) => d1.startLineNumber - d2.startLineNumber || d1.startColumn - d2.startColumn);\n        const uniqueSearchRanges = [];\n        uniqueSearchRanges.push(searchRanges.reduce((prev, curr) => {\n            if (Range.areIntersecting(prev, curr)) {\n                return prev.plusRange(curr);\n            }\n            uniqueSearchRanges.push(prev);\n            return curr;\n        }));\n        let matchMapper;\n        if (!isRegex && searchString.indexOf('\\n') < 0) {\n            // not regex, not multi line\n            const searchParams = new SearchParams(searchString, isRegex, matchCase, wordSeparators);\n            const searchData = searchParams.parseSearchRequest();\n            if (!searchData) {\n                return [];\n            }\n            matchMapper = (searchRange) => this.findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount);\n        }\n        else {\n            matchMapper = (searchRange) => TextModelSearch.findMatches(this, new SearchParams(searchString, isRegex, matchCase, wordSeparators), searchRange, captureMatches, limitResultCount);\n        }\n        return uniqueSearchRanges.map(matchMapper).reduce((arr, matches) => arr.concat(matches), []);\n    }\n    findNextMatch(searchString, rawSearchStart, isRegex, matchCase, wordSeparators, captureMatches) {\n        this._assertNotDisposed();\n        const searchStart = this.validatePosition(rawSearchStart);\n        if (!isRegex && searchString.indexOf('\\n') < 0) {\n            const searchParams = new SearchParams(searchString, isRegex, matchCase, wordSeparators);\n            const searchData = searchParams.parseSearchRequest();\n            if (!searchData) {\n                return null;\n            }\n            const lineCount = this.getLineCount();\n            let searchRange = new Range(searchStart.lineNumber, searchStart.column, lineCount, this.getLineMaxColumn(lineCount));\n            let ret = this.findMatchesLineByLine(searchRange, searchData, captureMatches, 1);\n            TextModelSearch.findNextMatch(this, new SearchParams(searchString, isRegex, matchCase, wordSeparators), searchStart, captureMatches);\n            if (ret.length > 0) {\n                return ret[0];\n            }\n            searchRange = new Range(1, 1, searchStart.lineNumber, this.getLineMaxColumn(searchStart.lineNumber));\n            ret = this.findMatchesLineByLine(searchRange, searchData, captureMatches, 1);\n            if (ret.length > 0) {\n                return ret[0];\n            }\n            return null;\n        }\n        return TextModelSearch.findNextMatch(this, new SearchParams(searchString, isRegex, matchCase, wordSeparators), searchStart, captureMatches);\n    }\n    findPreviousMatch(searchString, rawSearchStart, isRegex, matchCase, wordSeparators, captureMatches) {\n        this._assertNotDisposed();\n        const searchStart = this.validatePosition(rawSearchStart);\n        return TextModelSearch.findPreviousMatch(this, new SearchParams(searchString, isRegex, matchCase, wordSeparators), searchStart, captureMatches);\n    }\n    //#endregion\n    //#region Editing\n    pushStackElement() {\n        this._commandManager.pushStackElement();\n    }\n    popStackElement() {\n        this._commandManager.popStackElement();\n    }\n    pushEOL(eol) {\n        const currentEOL = (this.getEOL() === '\\n' ? 0 /* model.EndOfLineSequence.LF */ : 1 /* model.EndOfLineSequence.CRLF */);\n        if (currentEOL === eol) {\n            return;\n        }\n        try {\n            this._onDidChangeDecorations.beginDeferredEmit();\n            this._eventEmitter.beginDeferredEmit();\n            if (this._initialUndoRedoSnapshot === null) {\n                this._initialUndoRedoSnapshot = this._undoRedoService.createSnapshot(this.uri);\n            }\n            this._commandManager.pushEOL(eol);\n        }\n        finally {\n            this._eventEmitter.endDeferredEmit();\n            this._onDidChangeDecorations.endDeferredEmit();\n        }\n    }\n    _validateEditOperation(rawOperation) {\n        if (rawOperation instanceof ValidAnnotatedEditOperation) {\n            return rawOperation;\n        }\n        return new ValidAnnotatedEditOperation(rawOperation.identifier || null, this.validateRange(rawOperation.range), rawOperation.text, rawOperation.forceMoveMarkers || false, rawOperation.isAutoWhitespaceEdit || false, rawOperation._isTracked || false);\n    }\n    _validateEditOperations(rawOperations) {\n        const result = [];\n        for (let i = 0, len = rawOperations.length; i < len; i++) {\n            result[i] = this._validateEditOperation(rawOperations[i]);\n        }\n        return result;\n    }\n    pushEditOperations(beforeCursorState, editOperations, cursorStateComputer, group, reason) {\n        try {\n            this._onDidChangeDecorations.beginDeferredEmit();\n            this._eventEmitter.beginDeferredEmit();\n            return this._pushEditOperations(beforeCursorState, this._validateEditOperations(editOperations), cursorStateComputer, group, reason);\n        }\n        finally {\n            this._eventEmitter.endDeferredEmit();\n            this._onDidChangeDecorations.endDeferredEmit();\n        }\n    }\n    _pushEditOperations(beforeCursorState, editOperations, cursorStateComputer, group, reason) {\n        if (this._options.trimAutoWhitespace && this._trimAutoWhitespaceLines) {\n            // Go through each saved line number and insert a trim whitespace edit\n            // if it is safe to do so (no conflicts with other edits).\n            const incomingEdits = editOperations.map((op) => {\n                return {\n                    range: this.validateRange(op.range),\n                    text: op.text\n                };\n            });\n            // Sometimes, auto-formatters change ranges automatically which can cause undesired auto whitespace trimming near the cursor\n            // We'll use the following heuristic: if the edits occur near the cursor, then it's ok to trim auto whitespace\n            let editsAreNearCursors = true;\n            if (beforeCursorState) {\n                for (let i = 0, len = beforeCursorState.length; i < len; i++) {\n                    const sel = beforeCursorState[i];\n                    let foundEditNearSel = false;\n                    for (let j = 0, lenJ = incomingEdits.length; j < lenJ; j++) {\n                        const editRange = incomingEdits[j].range;\n                        const selIsAbove = editRange.startLineNumber > sel.endLineNumber;\n                        const selIsBelow = sel.startLineNumber > editRange.endLineNumber;\n                        if (!selIsAbove && !selIsBelow) {\n                            foundEditNearSel = true;\n                            break;\n                        }\n                    }\n                    if (!foundEditNearSel) {\n                        editsAreNearCursors = false;\n                        break;\n                    }\n                }\n            }\n            if (editsAreNearCursors) {\n                for (let i = 0, len = this._trimAutoWhitespaceLines.length; i < len; i++) {\n                    const trimLineNumber = this._trimAutoWhitespaceLines[i];\n                    const maxLineColumn = this.getLineMaxColumn(trimLineNumber);\n                    let allowTrimLine = true;\n                    for (let j = 0, lenJ = incomingEdits.length; j < lenJ; j++) {\n                        const editRange = incomingEdits[j].range;\n                        const editText = incomingEdits[j].text;\n                        if (trimLineNumber < editRange.startLineNumber || trimLineNumber > editRange.endLineNumber) {\n                            // `trimLine` is completely outside this edit\n                            continue;\n                        }\n                        // At this point:\n                        //   editRange.startLineNumber <= trimLine <= editRange.endLineNumber\n                        if (trimLineNumber === editRange.startLineNumber && editRange.startColumn === maxLineColumn\n                            && editRange.isEmpty() && editText && editText.length > 0 && editText.charAt(0) === '\\n') {\n                            // This edit inserts a new line (and maybe other text) after `trimLine`\n                            continue;\n                        }\n                        if (trimLineNumber === editRange.startLineNumber && editRange.startColumn === 1\n                            && editRange.isEmpty() && editText && editText.length > 0 && editText.charAt(editText.length - 1) === '\\n') {\n                            // This edit inserts a new line (and maybe other text) before `trimLine`\n                            continue;\n                        }\n                        // Looks like we can't trim this line as it would interfere with an incoming edit\n                        allowTrimLine = false;\n                        break;\n                    }\n                    if (allowTrimLine) {\n                        const trimRange = new Range(trimLineNumber, 1, trimLineNumber, maxLineColumn);\n                        editOperations.push(new ValidAnnotatedEditOperation(null, trimRange, null, false, false, false));\n                    }\n                }\n            }\n            this._trimAutoWhitespaceLines = null;\n        }\n        if (this._initialUndoRedoSnapshot === null) {\n            this._initialUndoRedoSnapshot = this._undoRedoService.createSnapshot(this.uri);\n        }\n        return this._commandManager.pushEditOperation(beforeCursorState, editOperations, cursorStateComputer, group, reason);\n    }\n    _applyUndo(changes, eol, resultingAlternativeVersionId, resultingSelection) {\n        const edits = changes.map((change) => {\n            const rangeStart = this.getPositionAt(change.newPosition);\n            const rangeEnd = this.getPositionAt(change.newEnd);\n            return {\n                range: new Range(rangeStart.lineNumber, rangeStart.column, rangeEnd.lineNumber, rangeEnd.column),\n                text: change.oldText\n            };\n        });\n        this._applyUndoRedoEdits(edits, eol, true, false, resultingAlternativeVersionId, resultingSelection);\n    }\n    _applyRedo(changes, eol, resultingAlternativeVersionId, resultingSelection) {\n        const edits = changes.map((change) => {\n            const rangeStart = this.getPositionAt(change.oldPosition);\n            const rangeEnd = this.getPositionAt(change.oldEnd);\n            return {\n                range: new Range(rangeStart.lineNumber, rangeStart.column, rangeEnd.lineNumber, rangeEnd.column),\n                text: change.newText\n            };\n        });\n        this._applyUndoRedoEdits(edits, eol, false, true, resultingAlternativeVersionId, resultingSelection);\n    }\n    _applyUndoRedoEdits(edits, eol, isUndoing, isRedoing, resultingAlternativeVersionId, resultingSelection) {\n        try {\n            this._onDidChangeDecorations.beginDeferredEmit();\n            this._eventEmitter.beginDeferredEmit();\n            this._isUndoing = isUndoing;\n            this._isRedoing = isRedoing;\n            this.applyEdits(edits, false);\n            this.setEOL(eol);\n            this._overwriteAlternativeVersionId(resultingAlternativeVersionId);\n        }\n        finally {\n            this._isUndoing = false;\n            this._isRedoing = false;\n            this._eventEmitter.endDeferredEmit(resultingSelection);\n            this._onDidChangeDecorations.endDeferredEmit();\n        }\n    }\n    applyEdits(rawOperations, computeUndoEdits, reason) {\n        try {\n            this._onDidChangeDecorations.beginDeferredEmit();\n            this._eventEmitter.beginDeferredEmit();\n            const operations = this._validateEditOperations(rawOperations);\n            return this._doApplyEdits(operations, computeUndoEdits ?? false, reason ?? EditSources.applyEdits());\n        }\n        finally {\n            this._eventEmitter.endDeferredEmit();\n            this._onDidChangeDecorations.endDeferredEmit();\n        }\n    }\n    _doApplyEdits(rawOperations, computeUndoEdits, reason) {\n        const oldLineCount = this._buffer.getLineCount();\n        const result = this._buffer.applyEdits(rawOperations, this._options.trimAutoWhitespace, computeUndoEdits);\n        const newLineCount = this._buffer.getLineCount();\n        const contentChanges = result.changes;\n        this._trimAutoWhitespaceLines = result.trimAutoWhitespaceLineNumbers;\n        if (contentChanges.length !== 0) {\n            // We do a first pass to update decorations\n            // because we want to read decorations in the second pass\n            // where we will emit content change events\n            // and we want to read the final decorations\n            for (let i = 0, len = contentChanges.length; i < len; i++) {\n                const change = contentChanges[i];\n                this._decorationsTree.acceptReplace(change.rangeOffset, change.rangeLength, change.text.length, change.forceMoveMarkers);\n            }\n            const rawContentChanges = [];\n            this._increaseVersionId();\n            let lineCount = oldLineCount;\n            for (let i = 0, len = contentChanges.length; i < len; i++) {\n                const change = contentChanges[i];\n                const [eolCount] = countEOL(change.text);\n                this._onDidChangeDecorations.fire();\n                const startLineNumber = change.range.startLineNumber;\n                const endLineNumber = change.range.endLineNumber;\n                const deletingLinesCnt = endLineNumber - startLineNumber;\n                const insertingLinesCnt = eolCount;\n                const editingLinesCnt = Math.min(deletingLinesCnt, insertingLinesCnt);\n                const changeLineCountDelta = (insertingLinesCnt - deletingLinesCnt);\n                const currentEditStartLineNumber = newLineCount - lineCount - changeLineCountDelta + startLineNumber;\n                const firstEditLineNumber = currentEditStartLineNumber;\n                const lastInsertedLineNumber = currentEditStartLineNumber + insertingLinesCnt;\n                const decorationsWithInjectedTextInEditedRange = this._decorationsTree.getInjectedTextInInterval(this, this.getOffsetAt(new Position(firstEditLineNumber, 1)), this.getOffsetAt(new Position(lastInsertedLineNumber, this.getLineMaxColumn(lastInsertedLineNumber))), 0);\n                const injectedTextInEditedRange = LineInjectedText.fromDecorations(decorationsWithInjectedTextInEditedRange);\n                const injectedTextInEditedRangeQueue = new ArrayQueue(injectedTextInEditedRange);\n                for (let j = editingLinesCnt; j >= 0; j--) {\n                    const editLineNumber = startLineNumber + j;\n                    const currentEditLineNumber = currentEditStartLineNumber + j;\n                    injectedTextInEditedRangeQueue.takeFromEndWhile(r => r.lineNumber > currentEditLineNumber);\n                    const decorationsInCurrentLine = injectedTextInEditedRangeQueue.takeFromEndWhile(r => r.lineNumber === currentEditLineNumber);\n                    rawContentChanges.push(new ModelRawLineChanged(editLineNumber, this.getLineContent(currentEditLineNumber), decorationsInCurrentLine));\n                }\n                if (editingLinesCnt < deletingLinesCnt) {\n                    // Must delete some lines\n                    const spliceStartLineNumber = startLineNumber + editingLinesCnt;\n                    rawContentChanges.push(new ModelRawLinesDeleted(spliceStartLineNumber + 1, endLineNumber));\n                }\n                if (editingLinesCnt < insertingLinesCnt) {\n                    const injectedTextInEditedRangeQueue = new ArrayQueue(injectedTextInEditedRange);\n                    // Must insert some lines\n                    const spliceLineNumber = startLineNumber + editingLinesCnt;\n                    const cnt = insertingLinesCnt - editingLinesCnt;\n                    const fromLineNumber = newLineCount - lineCount - cnt + spliceLineNumber + 1;\n                    const injectedTexts = [];\n                    const newLines = [];\n                    for (let i = 0; i < cnt; i++) {\n                        const lineNumber = fromLineNumber + i;\n                        newLines[i] = this.getLineContent(lineNumber);\n                        injectedTextInEditedRangeQueue.takeWhile(r => r.lineNumber < lineNumber);\n                        injectedTexts[i] = injectedTextInEditedRangeQueue.takeWhile(r => r.lineNumber === lineNumber);\n                    }\n                    rawContentChanges.push(new ModelRawLinesInserted(spliceLineNumber + 1, startLineNumber + insertingLinesCnt, newLines, injectedTexts));\n                }\n                lineCount += changeLineCountDelta;\n            }\n            this._emitContentChangedEvent(new ModelRawContentChangedEvent(rawContentChanges, this.getVersionId(), this._isUndoing, this._isRedoing), {\n                changes: contentChanges,\n                eol: this._buffer.getEOL(),\n                isEolChange: false,\n                versionId: this.getVersionId(),\n                isUndoing: this._isUndoing,\n                isRedoing: this._isRedoing,\n                isFlush: false,\n                detailedReasons: [reason],\n                detailedReasonsChangeLengths: [contentChanges.length],\n            });\n        }\n        return (result.reverseEdits === null ? undefined : result.reverseEdits);\n    }\n    undo() {\n        return this._undoRedoService.undo(this.uri);\n    }\n    canUndo() {\n        return this._undoRedoService.canUndo(this.uri);\n    }\n    redo() {\n        return this._undoRedoService.redo(this.uri);\n    }\n    canRedo() {\n        return this._undoRedoService.canRedo(this.uri);\n    }\n    //#endregion\n    //#region Decorations\n    handleBeforeFireDecorationsChangedEvent(affectedInjectedTextLines, affectedLineHeights, affectedFontLines) {\n        // This is called before the decoration changed event is fired.\n        if (affectedInjectedTextLines && affectedInjectedTextLines.size > 0) {\n            const affectedLines = Array.from(affectedInjectedTextLines);\n            const lineChangeEvents = affectedLines.map(lineNumber => new ModelRawLineChanged(lineNumber, this.getLineContent(lineNumber), this._getInjectedTextInLine(lineNumber)));\n            this._onDidChangeInjectedText.fire(new ModelInjectedTextChangedEvent(lineChangeEvents));\n        }\n        if (affectedLineHeights && affectedLineHeights.size > 0) {\n            const affectedLines = Array.from(affectedLineHeights);\n            const lineHeightChangeEvent = affectedLines.map(specialLineHeightChange => new ModelLineHeightChanged(specialLineHeightChange.ownerId, specialLineHeightChange.decorationId, specialLineHeightChange.lineNumber, specialLineHeightChange.lineHeight));\n            this._onDidChangeLineHeight.fire(new ModelLineHeightChangedEvent(lineHeightChangeEvent));\n        }\n        if (affectedFontLines && affectedFontLines.size > 0) {\n            const affectedLines = Array.from(affectedFontLines);\n            const fontChangeEvent = affectedLines.map(fontChange => new ModelFontChanged(fontChange.ownerId, fontChange.lineNumber));\n            this._onDidChangeFont.fire(new ModelFontChangedEvent(fontChangeEvent));\n        }\n    }\n    changeDecorations(callback, ownerId = 0) {\n        this._assertNotDisposed();\n        try {\n            this._onDidChangeDecorations.beginDeferredEmit();\n            return this._changeDecorations(ownerId, callback);\n        }\n        finally {\n            this._onDidChangeDecorations.endDeferredEmit();\n        }\n    }\n    _changeDecorations(ownerId, callback) {\n        const changeAccessor = {\n            addDecoration: (range, options) => {\n                return this._deltaDecorationsImpl(ownerId, [], [{ range: range, options: options }])[0];\n            },\n            changeDecoration: (id, newRange) => {\n                this._changeDecorationImpl(ownerId, id, newRange);\n            },\n            changeDecorationOptions: (id, options) => {\n                this._changeDecorationOptionsImpl(ownerId, id, _normalizeOptions(options));\n            },\n            removeDecoration: (id) => {\n                this._deltaDecorationsImpl(ownerId, [id], []);\n            },\n            deltaDecorations: (oldDecorations, newDecorations) => {\n                if (oldDecorations.length === 0 && newDecorations.length === 0) {\n                    // nothing to do\n                    return [];\n                }\n                return this._deltaDecorationsImpl(ownerId, oldDecorations, newDecorations);\n            }\n        };\n        let result = null;\n        try {\n            result = callback(changeAccessor);\n        }\n        catch (e) {\n            onUnexpectedError(e);\n        }\n        // Invalidate change accessor\n        changeAccessor.addDecoration = invalidFunc;\n        changeAccessor.changeDecoration = invalidFunc;\n        changeAccessor.changeDecorationOptions = invalidFunc;\n        changeAccessor.removeDecoration = invalidFunc;\n        changeAccessor.deltaDecorations = invalidFunc;\n        return result;\n    }\n    deltaDecorations(oldDecorations, newDecorations, ownerId = 0) {\n        this._assertNotDisposed();\n        if (!oldDecorations) {\n            oldDecorations = [];\n        }\n        if (oldDecorations.length === 0 && newDecorations.length === 0) {\n            // nothing to do\n            return [];\n        }\n        try {\n            this._deltaDecorationCallCnt++;\n            if (this._deltaDecorationCallCnt > 1) {\n                console.warn(`Invoking deltaDecorations recursively could lead to leaking decorations.`);\n                onUnexpectedError(new Error(`Invoking deltaDecorations recursively could lead to leaking decorations.`));\n            }\n            this._onDidChangeDecorations.beginDeferredEmit();\n            return this._deltaDecorationsImpl(ownerId, oldDecorations, newDecorations);\n        }\n        finally {\n            this._onDidChangeDecorations.endDeferredEmit();\n            this._deltaDecorationCallCnt--;\n        }\n    }\n    _getTrackedRange(id) {\n        return this.getDecorationRange(id);\n    }\n    _setTrackedRange(id, newRange, newStickiness) {\n        const node = (id ? this._decorations[id] : null);\n        if (!node) {\n            if (!newRange) {\n                // node doesn't exist, the request is to delete => nothing to do\n                return null;\n            }\n            // node doesn't exist, the request is to set => add the tracked range\n            return this._deltaDecorationsImpl(0, [], [{ range: newRange, options: TRACKED_RANGE_OPTIONS[newStickiness] }], true)[0];\n        }\n        if (!newRange) {\n            // node exists, the request is to delete => delete node\n            this._decorationsTree.delete(node);\n            delete this._decorations[node.id];\n            return null;\n        }\n        // node exists, the request is to set => change the tracked range and its options\n        const range = this._validateRangeRelaxedNoAllocations(newRange);\n        const startOffset = this._buffer.getOffsetAt(range.startLineNumber, range.startColumn);\n        const endOffset = this._buffer.getOffsetAt(range.endLineNumber, range.endColumn);\n        this._decorationsTree.delete(node);\n        node.reset(this.getVersionId(), startOffset, endOffset, range);\n        node.setOptions(TRACKED_RANGE_OPTIONS[newStickiness]);\n        this._decorationsTree.insert(node);\n        return node.id;\n    }\n    removeAllDecorationsWithOwnerId(ownerId) {\n        if (this._isDisposed) {\n            return;\n        }\n        const nodes = this._decorationsTree.collectNodesFromOwner(ownerId);\n        for (let i = 0, len = nodes.length; i < len; i++) {\n            const node = nodes[i];\n            this._decorationsTree.delete(node);\n            delete this._decorations[node.id];\n        }\n    }\n    getDecorationOptions(decorationId) {\n        const node = this._decorations[decorationId];\n        if (!node) {\n            return null;\n        }\n        return node.options;\n    }\n    getDecorationRange(decorationId) {\n        const node = this._decorations[decorationId];\n        if (!node) {\n            return null;\n        }\n        return this._decorationsTree.getNodeRange(this, node);\n    }\n    getLineDecorations(lineNumber, ownerId = 0, filterOutValidation = false, filterFontDecorations = false) {\n        if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n            return [];\n        }\n        return this.getLinesDecorations(lineNumber, lineNumber, ownerId, filterOutValidation, filterFontDecorations);\n    }\n    getLinesDecorations(_startLineNumber, _endLineNumber, ownerId = 0, filterOutValidation = false, filterFontDecorations = false, onlyMarginDecorations = false) {\n        const lineCount = this.getLineCount();\n        const startLineNumber = Math.min(lineCount, Math.max(1, _startLineNumber));\n        const endLineNumber = Math.min(lineCount, Math.max(1, _endLineNumber));\n        const endColumn = this.getLineMaxColumn(endLineNumber);\n        const range = new Range(startLineNumber, 1, endLineNumber, endColumn);\n        const decorations = this._getDecorationsInRange(range, ownerId, filterOutValidation, filterFontDecorations, onlyMarginDecorations);\n        pushMany(decorations, this._decorationProvider.getDecorationsInRange(range, ownerId, filterOutValidation));\n        return decorations;\n    }\n    getDecorationsInRange(range, ownerId = 0, filterOutValidation = false, filterFontDecorations = false, onlyMinimapDecorations = false, onlyMarginDecorations = false) {\n        const validatedRange = this.validateRange(range);\n        const decorations = this._getDecorationsInRange(validatedRange, ownerId, filterOutValidation, filterFontDecorations, onlyMarginDecorations);\n        pushMany(decorations, this._decorationProvider.getDecorationsInRange(validatedRange, ownerId, filterOutValidation, onlyMinimapDecorations));\n        return decorations;\n    }\n    getOverviewRulerDecorations(ownerId = 0, filterOutValidation = false, filterFontDecorations = false) {\n        return this._decorationsTree.getAll(this, ownerId, filterOutValidation, filterFontDecorations, true, false);\n    }\n    getInjectedTextDecorations(ownerId = 0) {\n        return this._decorationsTree.getAllInjectedText(this, ownerId);\n    }\n    getCustomLineHeightsDecorations(ownerId = 0) {\n        return this._decorationsTree.getAllCustomLineHeights(this, ownerId);\n    }\n    _getInjectedTextInLine(lineNumber) {\n        const startOffset = this._buffer.getOffsetAt(lineNumber, 1);\n        const endOffset = startOffset + this._buffer.getLineLength(lineNumber);\n        const result = this._decorationsTree.getInjectedTextInInterval(this, startOffset, endOffset, 0);\n        return LineInjectedText.fromDecorations(result).filter(t => t.lineNumber === lineNumber);\n    }\n    getFontDecorationsInRange(range, ownerId = 0) {\n        const startOffset = this._buffer.getOffsetAt(range.startLineNumber, range.startColumn);\n        const endOffset = this._buffer.getOffsetAt(range.endLineNumber, range.endColumn);\n        return this._decorationsTree.getFontDecorationsInInterval(this, startOffset, endOffset, ownerId);\n    }\n    getAllDecorations(ownerId = 0, filterOutValidation = false, filterFontDecorations = false) {\n        let result = this._decorationsTree.getAll(this, ownerId, filterOutValidation, filterFontDecorations, false, false);\n        result = result.concat(this._decorationProvider.getAllDecorations(ownerId, filterOutValidation));\n        return result;\n    }\n    getAllMarginDecorations(ownerId = 0) {\n        return this._decorationsTree.getAll(this, ownerId, false, false, false, true);\n    }\n    _getDecorationsInRange(filterRange, filterOwnerId, filterOutValidation, filterFontDecorations, onlyMarginDecorations) {\n        const startOffset = this._buffer.getOffsetAt(filterRange.startLineNumber, filterRange.startColumn);\n        const endOffset = this._buffer.getOffsetAt(filterRange.endLineNumber, filterRange.endColumn);\n        return this._decorationsTree.getAllInInterval(this, startOffset, endOffset, filterOwnerId, filterOutValidation, filterFontDecorations, onlyMarginDecorations);\n    }\n    getRangeAt(start, end) {\n        return this._buffer.getRangeAt(start, end - start);\n    }\n    _changeDecorationImpl(ownerId, decorationId, _range) {\n        const node = this._decorations[decorationId];\n        if (!node) {\n            return;\n        }\n        if (node.options.after) {\n            const oldRange = this.getDecorationRange(decorationId);\n            this._onDidChangeDecorations.recordLineAffectedByInjectedText(oldRange.endLineNumber);\n        }\n        if (node.options.before) {\n            const oldRange = this.getDecorationRange(decorationId);\n            this._onDidChangeDecorations.recordLineAffectedByInjectedText(oldRange.startLineNumber);\n        }\n        if (node.options.lineHeight !== null) {\n            const oldRange = this.getDecorationRange(decorationId);\n            this._onDidChangeDecorations.recordLineAffectedByLineHeightChange(ownerId, decorationId, oldRange.startLineNumber, null);\n        }\n        if (node.options.affectsFont) {\n            const oldRange = this.getDecorationRange(decorationId);\n            this._onDidChangeDecorations.recordLineAffectedByFontChange(ownerId, node.id, oldRange.startLineNumber);\n        }\n        const range = this._validateRangeRelaxedNoAllocations(_range);\n        const startOffset = this._buffer.getOffsetAt(range.startLineNumber, range.startColumn);\n        const endOffset = this._buffer.getOffsetAt(range.endLineNumber, range.endColumn);\n        this._decorationsTree.delete(node);\n        node.reset(this.getVersionId(), startOffset, endOffset, range);\n        this._decorationsTree.insert(node);\n        this._onDidChangeDecorations.checkAffectedAndFire(node.options);\n        if (node.options.after) {\n            this._onDidChangeDecorations.recordLineAffectedByInjectedText(range.endLineNumber);\n        }\n        if (node.options.before) {\n            this._onDidChangeDecorations.recordLineAffectedByInjectedText(range.startLineNumber);\n        }\n        if (node.options.lineHeight !== null) {\n            this._onDidChangeDecorations.recordLineAffectedByLineHeightChange(ownerId, decorationId, range.startLineNumber, node.options.lineHeight);\n        }\n        if (node.options.affectsFont) {\n            this._onDidChangeDecorations.recordLineAffectedByFontChange(ownerId, node.id, range.startLineNumber);\n        }\n    }\n    _changeDecorationOptionsImpl(ownerId, decorationId, options) {\n        const node = this._decorations[decorationId];\n        if (!node) {\n            return;\n        }\n        const nodeWasInOverviewRuler = (node.options.overviewRuler && node.options.overviewRuler.color ? true : false);\n        const nodeIsInOverviewRuler = (options.overviewRuler && options.overviewRuler.color ? true : false);\n        this._onDidChangeDecorations.checkAffectedAndFire(node.options);\n        this._onDidChangeDecorations.checkAffectedAndFire(options);\n        if (node.options.after || options.after) {\n            const nodeRange = this._decorationsTree.getNodeRange(this, node);\n            this._onDidChangeDecorations.recordLineAffectedByInjectedText(nodeRange.endLineNumber);\n        }\n        if (node.options.before || options.before) {\n            const nodeRange = this._decorationsTree.getNodeRange(this, node);\n            this._onDidChangeDecorations.recordLineAffectedByInjectedText(nodeRange.startLineNumber);\n        }\n        if (node.options.lineHeight !== null || options.lineHeight !== null) {\n            const nodeRange = this._decorationsTree.getNodeRange(this, node);\n            this._onDidChangeDecorations.recordLineAffectedByLineHeightChange(ownerId, decorationId, nodeRange.startLineNumber, options.lineHeight);\n        }\n        if (node.options.affectsFont || options.affectsFont) {\n            const nodeRange = this._decorationsTree.getNodeRange(this, node);\n            this._onDidChangeDecorations.recordLineAffectedByFontChange(ownerId, decorationId, nodeRange.startLineNumber);\n        }\n        const movedInOverviewRuler = nodeWasInOverviewRuler !== nodeIsInOverviewRuler;\n        const changedWhetherInjectedText = isOptionsInjectedText(options) !== isNodeInjectedText(node);\n        if (movedInOverviewRuler || changedWhetherInjectedText) {\n            this._decorationsTree.delete(node);\n            node.setOptions(options);\n            this._decorationsTree.insert(node);\n        }\n        else {\n            node.setOptions(options);\n        }\n    }\n    _deltaDecorationsImpl(ownerId, oldDecorationsIds, newDecorations, suppressEvents = false) {\n        const versionId = this.getVersionId();\n        const oldDecorationsLen = oldDecorationsIds.length;\n        let oldDecorationIndex = 0;\n        const newDecorationsLen = newDecorations.length;\n        let newDecorationIndex = 0;\n        this._onDidChangeDecorations.beginDeferredEmit();\n        try {\n            const result = new Array(newDecorationsLen);\n            while (oldDecorationIndex < oldDecorationsLen || newDecorationIndex < newDecorationsLen) {\n                let node = null;\n                if (oldDecorationIndex < oldDecorationsLen) {\n                    // (1) get ourselves an old node\n                    let decorationId;\n                    do {\n                        decorationId = oldDecorationsIds[oldDecorationIndex++];\n                        node = this._decorations[decorationId];\n                    } while (!node && oldDecorationIndex < oldDecorationsLen);\n                    // (2) remove the node from the tree (if it exists)\n                    if (node) {\n                        if (node.options.after) {\n                            const nodeRange = this._decorationsTree.getNodeRange(this, node);\n                            this._onDidChangeDecorations.recordLineAffectedByInjectedText(nodeRange.endLineNumber);\n                        }\n                        if (node.options.before) {\n                            const nodeRange = this._decorationsTree.getNodeRange(this, node);\n                            this._onDidChangeDecorations.recordLineAffectedByInjectedText(nodeRange.startLineNumber);\n                        }\n                        if (node.options.lineHeight !== null) {\n                            const nodeRange = this._decorationsTree.getNodeRange(this, node);\n                            this._onDidChangeDecorations.recordLineAffectedByLineHeightChange(ownerId, decorationId, nodeRange.startLineNumber, null);\n                        }\n                        if (node.options.affectsFont) {\n                            const nodeRange = this._decorationsTree.getNodeRange(this, node);\n                            this._onDidChangeDecorations.recordLineAffectedByFontChange(ownerId, decorationId, nodeRange.startLineNumber);\n                        }\n                        this._decorationsTree.delete(node);\n                        if (!suppressEvents) {\n                            this._onDidChangeDecorations.checkAffectedAndFire(node.options);\n                        }\n                    }\n                }\n                if (newDecorationIndex < newDecorationsLen) {\n                    // (3) create a new node if necessary\n                    if (!node) {\n                        const internalDecorationId = (++this._lastDecorationId);\n                        const decorationId = `${this._instanceId};${internalDecorationId}`;\n                        node = new IntervalNode(decorationId, 0, 0);\n                        this._decorations[decorationId] = node;\n                    }\n                    // (4) initialize node\n                    const newDecoration = newDecorations[newDecorationIndex];\n                    const range = this._validateRangeRelaxedNoAllocations(newDecoration.range);\n                    const options = _normalizeOptions(newDecoration.options);\n                    const startOffset = this._buffer.getOffsetAt(range.startLineNumber, range.startColumn);\n                    const endOffset = this._buffer.getOffsetAt(range.endLineNumber, range.endColumn);\n                    node.ownerId = ownerId;\n                    node.reset(versionId, startOffset, endOffset, range);\n                    node.setOptions(options);\n                    if (node.options.after) {\n                        this._onDidChangeDecorations.recordLineAffectedByInjectedText(range.endLineNumber);\n                    }\n                    if (node.options.before) {\n                        this._onDidChangeDecorations.recordLineAffectedByInjectedText(range.startLineNumber);\n                    }\n                    if (node.options.lineHeight !== null) {\n                        this._onDidChangeDecorations.recordLineAffectedByLineHeightChange(ownerId, node.id, range.startLineNumber, node.options.lineHeight);\n                    }\n                    if (node.options.affectsFont) {\n                        this._onDidChangeDecorations.recordLineAffectedByFontChange(ownerId, node.id, range.startLineNumber);\n                    }\n                    if (!suppressEvents) {\n                        this._onDidChangeDecorations.checkAffectedAndFire(options);\n                    }\n                    this._decorationsTree.insert(node);\n                    result[newDecorationIndex] = node.id;\n                    newDecorationIndex++;\n                }\n                else {\n                    if (node) {\n                        delete this._decorations[node.id];\n                    }\n                }\n            }\n            return result;\n        }\n        finally {\n            this._onDidChangeDecorations.endDeferredEmit();\n        }\n    }\n    //#endregion\n    //#region Tokenization\n    // TODO move them to the tokenization part.\n    getLanguageId() {\n        return this.tokenization.getLanguageId();\n    }\n    setLanguage(languageIdOrSelection, source) {\n        if (typeof languageIdOrSelection === 'string') {\n            this._languageSelectionListener.clear();\n            this._setLanguage(languageIdOrSelection, source);\n        }\n        else {\n            this._languageSelectionListener.value = languageIdOrSelection.onDidChange(() => this._setLanguage(languageIdOrSelection.languageId, source));\n            this._setLanguage(languageIdOrSelection.languageId, source);\n        }\n    }\n    _setLanguage(languageId, source) {\n        this.tokenization.setLanguageId(languageId, source);\n        this._languageService.requestRichLanguageFeatures(languageId);\n    }\n    getLanguageIdAtPosition(lineNumber, column) {\n        return this.tokenization.getLanguageIdAtPosition(lineNumber, column);\n    }\n    getWordAtPosition(position) {\n        return this._tokenizationTextModelPart.getWordAtPosition(position);\n    }\n    getWordUntilPosition(position) {\n        return this._tokenizationTextModelPart.getWordUntilPosition(position);\n    }\n    //#endregion\n    normalizePosition(position, affinity) {\n        return position;\n    }\n    /**\n     * Gets the column at which indentation stops at a given line.\n     * @internal\n    */\n    getLineIndentColumn(lineNumber) {\n        // Columns start with 1.\n        return indentOfLine(this.getLineContent(lineNumber)) + 1;\n    }\n    toString() {\n        return `TextModel(${this.uri.toString()})`;\n    }\n};\nTextModel = TextModel_1 = __decorate([\n    __param(4, IUndoRedoService),\n    __param(5, ILanguageService),\n    __param(6, ILanguageConfigurationService),\n    __param(7, IInstantiationService)\n], TextModel);\nfunction indentOfLine(line) {\n    let indent = 0;\n    for (const c of line) {\n        if (c === ' ' || c === '\\t') {\n            indent++;\n        }\n        else {\n            break;\n        }\n    }\n    return indent;\n}\n//#region Decorations\nfunction isNodeInOverviewRuler(node) {\n    return (node.options.overviewRuler && node.options.overviewRuler.color ? true : false);\n}\nfunction isOptionsInjectedText(options) {\n    return !!options.after || !!options.before;\n}\nfunction isNodeInjectedText(node) {\n    return !!node.options.after || !!node.options.before;\n}\nclass DecorationsTrees {\n    constructor() {\n        this._decorationsTree0 = new IntervalTree();\n        this._decorationsTree1 = new IntervalTree();\n        this._injectedTextDecorationsTree = new IntervalTree();\n    }\n    ensureAllNodesHaveRanges(host) {\n        this.getAll(host, 0, false, false, false, false);\n    }\n    _ensureNodesHaveRanges(host, nodes) {\n        for (const node of nodes) {\n            if (node.range === null) {\n                node.range = host.getRangeAt(node.cachedAbsoluteStart, node.cachedAbsoluteEnd);\n            }\n        }\n        return nodes;\n    }\n    getAllInInterval(host, start, end, filterOwnerId, filterOutValidation, filterFontDecorations, onlyMarginDecorations) {\n        const versionId = host.getVersionId();\n        const result = this._intervalSearch(start, end, filterOwnerId, filterOutValidation, filterFontDecorations, versionId, onlyMarginDecorations);\n        return this._ensureNodesHaveRanges(host, result);\n    }\n    _intervalSearch(start, end, filterOwnerId, filterOutValidation, filterFontDecorations, cachedVersionId, onlyMarginDecorations) {\n        const r0 = this._decorationsTree0.intervalSearch(start, end, filterOwnerId, filterOutValidation, filterFontDecorations, cachedVersionId, onlyMarginDecorations);\n        const r1 = this._decorationsTree1.intervalSearch(start, end, filterOwnerId, filterOutValidation, filterFontDecorations, cachedVersionId, onlyMarginDecorations);\n        const r2 = this._injectedTextDecorationsTree.intervalSearch(start, end, filterOwnerId, filterOutValidation, filterFontDecorations, cachedVersionId, onlyMarginDecorations);\n        return r0.concat(r1).concat(r2);\n    }\n    getInjectedTextInInterval(host, start, end, filterOwnerId) {\n        const versionId = host.getVersionId();\n        const result = this._injectedTextDecorationsTree.intervalSearch(start, end, filterOwnerId, false, false, versionId, false);\n        return this._ensureNodesHaveRanges(host, result).filter((i) => i.options.showIfCollapsed || !i.range.isEmpty());\n    }\n    getFontDecorationsInInterval(host, start, end, filterOwnerId) {\n        const versionId = host.getVersionId();\n        const decorations = this._decorationsTree0.intervalSearch(start, end, filterOwnerId, false, false, versionId, false);\n        return this._ensureNodesHaveRanges(host, decorations).filter((i) => i.options.affectsFont);\n    }\n    getAllInjectedText(host, filterOwnerId) {\n        const versionId = host.getVersionId();\n        const result = this._injectedTextDecorationsTree.search(filterOwnerId, false, false, versionId, false);\n        return this._ensureNodesHaveRanges(host, result).filter((i) => i.options.showIfCollapsed || !i.range.isEmpty());\n    }\n    getAllCustomLineHeights(host, filterOwnerId) {\n        const versionId = host.getVersionId();\n        const result = this._search(filterOwnerId, false, false, false, versionId, false);\n        return this._ensureNodesHaveRanges(host, result).filter((i) => typeof i.options.lineHeight === 'number');\n    }\n    getAll(host, filterOwnerId, filterOutValidation, filterFontDecorations, overviewRulerOnly, onlyMarginDecorations) {\n        const versionId = host.getVersionId();\n        const result = this._search(filterOwnerId, filterOutValidation, filterFontDecorations, overviewRulerOnly, versionId, onlyMarginDecorations);\n        return this._ensureNodesHaveRanges(host, result);\n    }\n    _search(filterOwnerId, filterOutValidation, filterFontDecorations, overviewRulerOnly, cachedVersionId, onlyMarginDecorations) {\n        if (overviewRulerOnly) {\n            return this._decorationsTree1.search(filterOwnerId, filterOutValidation, filterFontDecorations, cachedVersionId, onlyMarginDecorations);\n        }\n        else {\n            const r0 = this._decorationsTree0.search(filterOwnerId, filterOutValidation, filterFontDecorations, cachedVersionId, onlyMarginDecorations);\n            const r1 = this._decorationsTree1.search(filterOwnerId, filterOutValidation, filterFontDecorations, cachedVersionId, onlyMarginDecorations);\n            const r2 = this._injectedTextDecorationsTree.search(filterOwnerId, filterOutValidation, filterFontDecorations, cachedVersionId, onlyMarginDecorations);\n            return r0.concat(r1).concat(r2);\n        }\n    }\n    collectNodesFromOwner(ownerId) {\n        const r0 = this._decorationsTree0.collectNodesFromOwner(ownerId);\n        const r1 = this._decorationsTree1.collectNodesFromOwner(ownerId);\n        const r2 = this._injectedTextDecorationsTree.collectNodesFromOwner(ownerId);\n        return r0.concat(r1).concat(r2);\n    }\n    collectNodesPostOrder() {\n        const r0 = this._decorationsTree0.collectNodesPostOrder();\n        const r1 = this._decorationsTree1.collectNodesPostOrder();\n        const r2 = this._injectedTextDecorationsTree.collectNodesPostOrder();\n        return r0.concat(r1).concat(r2);\n    }\n    insert(node) {\n        if (isNodeInjectedText(node)) {\n            this._injectedTextDecorationsTree.insert(node);\n        }\n        else if (isNodeInOverviewRuler(node)) {\n            this._decorationsTree1.insert(node);\n        }\n        else {\n            this._decorationsTree0.insert(node);\n        }\n    }\n    delete(node) {\n        if (isNodeInjectedText(node)) {\n            this._injectedTextDecorationsTree.delete(node);\n        }\n        else if (isNodeInOverviewRuler(node)) {\n            this._decorationsTree1.delete(node);\n        }\n        else {\n            this._decorationsTree0.delete(node);\n        }\n    }\n    getNodeRange(host, node) {\n        const versionId = host.getVersionId();\n        if (node.cachedVersionId !== versionId) {\n            this._resolveNode(node, versionId);\n        }\n        if (node.range === null) {\n            node.range = host.getRangeAt(node.cachedAbsoluteStart, node.cachedAbsoluteEnd);\n        }\n        return node.range;\n    }\n    _resolveNode(node, cachedVersionId) {\n        if (isNodeInjectedText(node)) {\n            this._injectedTextDecorationsTree.resolveNode(node, cachedVersionId);\n        }\n        else if (isNodeInOverviewRuler(node)) {\n            this._decorationsTree1.resolveNode(node, cachedVersionId);\n        }\n        else {\n            this._decorationsTree0.resolveNode(node, cachedVersionId);\n        }\n    }\n    acceptReplace(offset, length, textLength, forceMoveMarkers) {\n        this._decorationsTree0.acceptReplace(offset, length, textLength, forceMoveMarkers);\n        this._decorationsTree1.acceptReplace(offset, length, textLength, forceMoveMarkers);\n        this._injectedTextDecorationsTree.acceptReplace(offset, length, textLength, forceMoveMarkers);\n    }\n}\nfunction cleanClassName(className) {\n    return className.replace(/[^a-z0-9\\-_]/gi, ' ');\n}\nclass DecorationOptions {\n    constructor(options) {\n        this.color = options.color || '';\n        this.darkColor = options.darkColor || '';\n    }\n}\nclass ModelDecorationOverviewRulerOptions extends DecorationOptions {\n    constructor(options) {\n        super(options);\n        this._resolvedColor = null;\n        this.position = (typeof options.position === 'number' ? options.position : OverviewRulerLane.Center);\n    }\n    getColor(theme) {\n        if (!this._resolvedColor) {\n            if (isDark(theme.type) && this.darkColor) {\n                this._resolvedColor = this._resolveColor(this.darkColor, theme);\n            }\n            else {\n                this._resolvedColor = this._resolveColor(this.color, theme);\n            }\n        }\n        return this._resolvedColor;\n    }\n    invalidateCachedColor() {\n        this._resolvedColor = null;\n    }\n    _resolveColor(color, theme) {\n        if (typeof color === 'string') {\n            return color;\n        }\n        const c = color ? theme.getColor(color.id) : null;\n        if (!c) {\n            return '';\n        }\n        return c.toString();\n    }\n}\nclass ModelDecorationGlyphMarginOptions {\n    constructor(options) {\n        this.position = options?.position ?? GlyphMarginLane.Center;\n        this.persistLane = options?.persistLane;\n    }\n}\nclass ModelDecorationMinimapOptions extends DecorationOptions {\n    constructor(options) {\n        super(options);\n        this.position = options.position;\n        this.sectionHeaderStyle = options.sectionHeaderStyle ?? null;\n        this.sectionHeaderText = options.sectionHeaderText ?? null;\n    }\n    getColor(theme) {\n        if (!this._resolvedColor) {\n            if (isDark(theme.type) && this.darkColor) {\n                this._resolvedColor = this._resolveColor(this.darkColor, theme);\n            }\n            else {\n                this._resolvedColor = this._resolveColor(this.color, theme);\n            }\n        }\n        return this._resolvedColor;\n    }\n    invalidateCachedColor() {\n        this._resolvedColor = undefined;\n    }\n    _resolveColor(color, theme) {\n        if (typeof color === 'string') {\n            return Color.fromHex(color);\n        }\n        return theme.getColor(color.id);\n    }\n}\nclass ModelDecorationInjectedTextOptions {\n    static from(options) {\n        if (options instanceof ModelDecorationInjectedTextOptions) {\n            return options;\n        }\n        return new ModelDecorationInjectedTextOptions(options);\n    }\n    constructor(options) {\n        this.content = options.content || '';\n        this.tokens = options.tokens ?? null;\n        this.inlineClassName = options.inlineClassName || null;\n        this.inlineClassNameAffectsLetterSpacing = options.inlineClassNameAffectsLetterSpacing || false;\n        this.attachedData = options.attachedData || null;\n        this.cursorStops = options.cursorStops || null;\n    }\n}\nclass ModelDecorationOptions {\n    static register(options) {\n        return new ModelDecorationOptions(options);\n    }\n    static createDynamic(options) {\n        return new ModelDecorationOptions(options);\n    }\n    constructor(options) {\n        this.description = options.description;\n        this.blockClassName = options.blockClassName ? cleanClassName(options.blockClassName) : null;\n        this.blockDoesNotCollapse = options.blockDoesNotCollapse ?? null;\n        this.blockIsAfterEnd = options.blockIsAfterEnd ?? null;\n        this.blockPadding = options.blockPadding ?? null;\n        this.stickiness = options.stickiness || 0 /* model.TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges */;\n        this.zIndex = options.zIndex || 0;\n        this.className = options.className ? cleanClassName(options.className) : null;\n        this.shouldFillLineOnLineBreak = options.shouldFillLineOnLineBreak ?? null;\n        this.hoverMessage = options.hoverMessage || null;\n        this.glyphMarginHoverMessage = options.glyphMarginHoverMessage || null;\n        this.lineNumberHoverMessage = options.lineNumberHoverMessage || null;\n        this.isWholeLine = options.isWholeLine || false;\n        this.lineHeight = options.lineHeight ? Math.min(options.lineHeight, LINE_HEIGHT_CEILING) : null;\n        this.fontSize = options.fontSize || null;\n        this.affectsFont = !!options.fontSize || !!options.fontFamily || !!options.fontWeight || !!options.fontStyle;\n        this.showIfCollapsed = options.showIfCollapsed || false;\n        this.collapseOnReplaceEdit = options.collapseOnReplaceEdit || false;\n        this.overviewRuler = options.overviewRuler ? new ModelDecorationOverviewRulerOptions(options.overviewRuler) : null;\n        this.minimap = options.minimap ? new ModelDecorationMinimapOptions(options.minimap) : null;\n        this.glyphMargin = options.glyphMarginClassName ? new ModelDecorationGlyphMarginOptions(options.glyphMargin) : null;\n        this.glyphMarginClassName = options.glyphMarginClassName ? cleanClassName(options.glyphMarginClassName) : null;\n        this.linesDecorationsClassName = options.linesDecorationsClassName ? cleanClassName(options.linesDecorationsClassName) : null;\n        this.lineNumberClassName = options.lineNumberClassName ? cleanClassName(options.lineNumberClassName) : null;\n        this.linesDecorationsTooltip = options.linesDecorationsTooltip ? htmlAttributeEncodeValue(options.linesDecorationsTooltip) : null;\n        this.firstLineDecorationClassName = options.firstLineDecorationClassName ? cleanClassName(options.firstLineDecorationClassName) : null;\n        this.marginClassName = options.marginClassName ? cleanClassName(options.marginClassName) : null;\n        this.inlineClassName = options.inlineClassName ? cleanClassName(options.inlineClassName) : null;\n        this.inlineClassNameAffectsLetterSpacing = options.inlineClassNameAffectsLetterSpacing || false;\n        this.beforeContentClassName = options.beforeContentClassName ? cleanClassName(options.beforeContentClassName) : null;\n        this.afterContentClassName = options.afterContentClassName ? cleanClassName(options.afterContentClassName) : null;\n        this.after = options.after ? ModelDecorationInjectedTextOptions.from(options.after) : null;\n        this.before = options.before ? ModelDecorationInjectedTextOptions.from(options.before) : null;\n        this.hideInCommentTokens = options.hideInCommentTokens ?? false;\n        this.hideInStringTokens = options.hideInStringTokens ?? false;\n        this.textDirection = options.textDirection ?? null;\n    }\n}\nModelDecorationOptions.EMPTY = ModelDecorationOptions.register({ description: 'empty' });\n/**\n * The order carefully matches the values of the enum.\n */\nconst TRACKED_RANGE_OPTIONS = [\n    ModelDecorationOptions.register({ description: 'tracked-range-always-grows-when-typing-at-edges', stickiness: 0 /* model.TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges */ }),\n    ModelDecorationOptions.register({ description: 'tracked-range-never-grows-when-typing-at-edges', stickiness: 1 /* model.TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */ }),\n    ModelDecorationOptions.register({ description: 'tracked-range-grows-only-when-typing-before', stickiness: 2 /* model.TrackedRangeStickiness.GrowsOnlyWhenTypingBefore */ }),\n    ModelDecorationOptions.register({ description: 'tracked-range-grows-only-when-typing-after', stickiness: 3 /* model.TrackedRangeStickiness.GrowsOnlyWhenTypingAfter */ }),\n];\nfunction _normalizeOptions(options) {\n    if (options instanceof ModelDecorationOptions) {\n        return options;\n    }\n    return ModelDecorationOptions.createDynamic(options);\n}\nclass LineHeightChangingDecoration {\n    static toKey(obj) {\n        return `${obj.ownerId};${obj.decorationId};${obj.lineNumber}`;\n    }\n    constructor(ownerId, decorationId, lineNumber, lineHeight) {\n        this.ownerId = ownerId;\n        this.decorationId = decorationId;\n        this.lineNumber = lineNumber;\n        this.lineHeight = lineHeight;\n    }\n}\nclass LineFontChangingDecoration {\n    static toKey(obj) {\n        return `${obj.ownerId};${obj.decorationId};${obj.lineNumber}`;\n    }\n    constructor(ownerId, decorationId, lineNumber) {\n        this.ownerId = ownerId;\n        this.decorationId = decorationId;\n        this.lineNumber = lineNumber;\n    }\n}\nclass DidChangeDecorationsEmitter extends Disposable {\n    constructor(handleBeforeFire) {\n        super();\n        this.handleBeforeFire = handleBeforeFire;\n        this._actual = this._register(new Emitter());\n        this.event = this._actual.event;\n        this._affectedInjectedTextLines = null;\n        this._affectedLineHeights = null;\n        this._affectedFontLines = null;\n        this._deferredCnt = 0;\n        this._shouldFireDeferred = false;\n        this._affectsMinimap = false;\n        this._affectsOverviewRuler = false;\n        this._affectsGlyphMargin = false;\n        this._affectsLineNumber = false;\n    }\n    beginDeferredEmit() {\n        this._deferredCnt++;\n    }\n    endDeferredEmit() {\n        this._deferredCnt--;\n        if (this._deferredCnt === 0) {\n            if (this._shouldFireDeferred) {\n                this.doFire();\n            }\n            this._affectedInjectedTextLines?.clear();\n            this._affectedInjectedTextLines = null;\n            this._affectedLineHeights?.clear();\n            this._affectedLineHeights = null;\n            this._affectedFontLines?.clear();\n            this._affectedFontLines = null;\n        }\n    }\n    recordLineAffectedByInjectedText(lineNumber) {\n        if (!this._affectedInjectedTextLines) {\n            this._affectedInjectedTextLines = new Set();\n        }\n        this._affectedInjectedTextLines.add(lineNumber);\n    }\n    recordLineAffectedByLineHeightChange(ownerId, decorationId, lineNumber, lineHeight) {\n        if (!this._affectedLineHeights) {\n            this._affectedLineHeights = new SetWithKey([], LineHeightChangingDecoration.toKey);\n        }\n        this._affectedLineHeights.add(new LineHeightChangingDecoration(ownerId, decorationId, lineNumber, lineHeight));\n    }\n    recordLineAffectedByFontChange(ownerId, decorationId, lineNumber) {\n        if (!this._affectedFontLines) {\n            this._affectedFontLines = new SetWithKey([], LineFontChangingDecoration.toKey);\n        }\n        this._affectedFontLines.add(new LineFontChangingDecoration(ownerId, decorationId, lineNumber));\n    }\n    checkAffectedAndFire(options) {\n        this._affectsMinimap ||= !!options.minimap?.position;\n        this._affectsOverviewRuler ||= !!options.overviewRuler?.color;\n        this._affectsGlyphMargin ||= !!options.glyphMarginClassName;\n        this._affectsLineNumber ||= !!options.lineNumberClassName;\n        this.tryFire();\n    }\n    fire() {\n        this._affectsMinimap = true;\n        this._affectsOverviewRuler = true;\n        this._affectsGlyphMargin = true;\n        this.tryFire();\n    }\n    tryFire() {\n        if (this._deferredCnt === 0) {\n            this.doFire();\n        }\n        else {\n            this._shouldFireDeferred = true;\n        }\n    }\n    doFire() {\n        this.handleBeforeFire(this._affectedInjectedTextLines, this._affectedLineHeights, this._affectedFontLines);\n        const event = {\n            affectsMinimap: this._affectsMinimap,\n            affectsOverviewRuler: this._affectsOverviewRuler,\n            affectsGlyphMargin: this._affectsGlyphMargin,\n            affectsLineNumber: this._affectsLineNumber,\n        };\n        this._shouldFireDeferred = false;\n        this._affectsMinimap = false;\n        this._affectsOverviewRuler = false;\n        this._affectsGlyphMargin = false;\n        this._actual.fire(event);\n    }\n}\n//#endregion\nclass DidChangeContentEmitter extends Disposable {\n    constructor() {\n        super();\n        /**\n         * Both `fastEvent` and `slowEvent` work the same way and contain the same events, but first we invoke `fastEvent` and then `slowEvent`.\n         */\n        this._fastEmitter = this._register(new Emitter());\n        this.fastEvent = this._fastEmitter.event;\n        this._slowEmitter = this._register(new Emitter());\n        this.slowEvent = this._slowEmitter.event;\n        this._deferredCnt = 0;\n        this._deferredEvent = null;\n    }\n    beginDeferredEmit() {\n        this._deferredCnt++;\n    }\n    endDeferredEmit(resultingSelection = null) {\n        this._deferredCnt--;\n        if (this._deferredCnt === 0) {\n            if (this._deferredEvent !== null) {\n                this._deferredEvent.rawContentChangedEvent.resultingSelection = resultingSelection;\n                const e = this._deferredEvent;\n                this._deferredEvent = null;\n                this._fastEmitter.fire(e);\n                this._slowEmitter.fire(e);\n            }\n        }\n    }\n    fire(e) {\n        if (this._deferredCnt > 0) {\n            if (this._deferredEvent) {\n                this._deferredEvent = this._deferredEvent.merge(e);\n            }\n            else {\n                this._deferredEvent = e;\n            }\n            return;\n        }\n        this._fastEmitter.fire(e);\n        this._slowEmitter.fire(e);\n    }\n}\n\nexport { ModelDecorationGlyphMarginOptions, ModelDecorationInjectedTextOptions, ModelDecorationMinimapOptions, ModelDecorationOptions, ModelDecorationOverviewRulerOptions, TextModel, createTextBuffer, createTextBufferFactory, createTextBufferFactoryFromSnapshot, indentOfLine };\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 13827, "column": 0}, "map": {"version":3,"sources":["file:///D:/real-time-code-editor%20%282%29/node_modules/.pnpm/monaco-editor%400.55.1/node_modules/monaco-editor/esm/vs/editor/common/model/textModelText.js"],"sourcesContent":["import { AbstractText } from '../core/text/abstractText.js';\nimport { TextLength } from '../core/text/textLength.js';\n\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nclass TextModelText extends AbstractText {\n    constructor(_textModel) {\n        super();\n        this._textModel = _textModel;\n    }\n    getValueOfRange(range) {\n        return this._textModel.getValueInRange(range);\n    }\n    getLineLength(lineNumber) {\n        return this._textModel.getLineLength(lineNumber);\n    }\n    get length() {\n        const lastLineNumber = this._textModel.getLineCount();\n        const lastLineLen = this._textModel.getLineLength(lastLineNumber);\n        return new TextLength(lastLineNumber - 1, lastLineLen);\n    }\n}\n\nexport { TextModelText };\n"],"names":[],"mappings":";;;;AAAA;AACA;;;AAEA;;;8FAG8F,GAC9F,MAAM,sBAAsB,kRAAY;IACpC,YAAY,UAAU,CAAE;QACpB,KAAK;QACL,IAAI,CAAC,UAAU,GAAG;IACtB;IACA,gBAAgB,KAAK,EAAE;QACnB,OAAO,IAAI,CAAC,UAAU,CAAC,eAAe,CAAC;IAC3C;IACA,cAAc,UAAU,EAAE;QACtB,OAAO,IAAI,CAAC,UAAU,CAAC,aAAa,CAAC;IACzC;IACA,IAAI,SAAS;QACT,MAAM,iBAAiB,IAAI,CAAC,UAAU,CAAC,YAAY;QACnD,MAAM,cAAc,IAAI,CAAC,UAAU,CAAC,aAAa,CAAC;QAClD,OAAO,IAAI,8QAAU,CAAC,iBAAiB,GAAG;IAC9C;AACJ","ignoreList":[0]}}]
}